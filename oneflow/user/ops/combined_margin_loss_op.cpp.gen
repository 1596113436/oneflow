#include "oneflow/core/framework/op_generated.h"

namespace oneflow {

/* static */ Maybe<void> CombinedMarginLossOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      const user_op::TensorDesc& x = ctx->InputTensorDesc("x", 0);
      const user_op::TensorDesc& label = ctx->InputTensorDesc("label", 0);
      user_op::TensorDesc* theta = ctx->OutputTensorDesc("theta", 0);
      CHECK_EQ_OR_RETURN(label.shape().At(0), x.shape().At(0));
      CHECK_GE_OR_RETURN(x.shape().NumAxes(), 2);
      *ctx->OutputShape("y", 0) = ctx->InputShape("x", 0);
      *ctx->IsDynamic4ArgNameAndIndex("y", 0) = ctx->InputIsDynamic("x", 0);
      *theta->mut_is_dynamic() = x.is_dynamic();
      *theta->mut_shape() = label.shape();
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> CombinedMarginLossOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> CombinedMarginLossOp::GetSbp(user_op::SbpContext *ctx) {
      ctx->NewBuilder()
          .Split(user_op::OpArg("x", 0), 0)
          .Split(user_op::OpArg("label", 0), 0)
          .Split(user_op::OpArg("y", 0), 0)
          .Split(user_op::OpArg("theta", 0), 0)
          .Build();
      ctx->NewBuilder()
          .Split(user_op::OpArg("x", 0), 1)
          .Broadcast(user_op::OpArg("label", 0))
          .Split(user_op::OpArg("y", 0), 1)
          .PartialSum(user_op::OpArg("theta", 0))
          .Build();
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> CombinedMarginLossOp::ModifyInputArg(GetInputArgModifier GetInputArgModifierFn, const user_op::UserOpConfWrapper &conf) {
      user_op::InputArgModifier* label_arg_modifier = GetInputArgModifierFn("label", 0);
      label_arg_modifier->set_requires_grad(false);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> CombinedMarginLossOp::InferDataType(user_op::InferContext *ctx) {
      *ctx->OutputDType("y", 0) = ctx->InputDType("x", 0);
      *ctx->OutputDType("theta", 0) = ctx->InputDType("x", 0);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> CombinedMarginLossGradOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      const user_op::TensorDesc& dy = ctx->InputTensorDesc("dy", 0);
      const user_op::TensorDesc& label = ctx->InputTensorDesc("label", 0);
      const user_op::TensorDesc& theta = ctx->InputTensorDesc("theta", 0);
      CHECK_EQ_OR_RETURN(label.shape().At(0), dy.shape().At(0));
      CHECK_EQ_OR_RETURN(label.shape().At(0), theta.shape().At(0));
      CHECK_GE_OR_RETURN(dy.shape().NumAxes(), 2);
      *ctx->OutputShape("dx", 0) = ctx->InputShape("dy", 0);
      *ctx->IsDynamic4ArgNameAndIndex("dx", 0) = ctx->InputIsDynamic("dy", 0);
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> CombinedMarginLossGradOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> CombinedMarginLossGradOp::GetSbp(user_op::SbpContext *ctx) {
      ctx->NewBuilder()
          .Split(user_op::OpArg("dy", 0), 0)
          .Split(user_op::OpArg("label", 0), 0)
          .Split(user_op::OpArg("theta", 0), 0)
          .Split(user_op::OpArg("dx", 0), 0)
          .Build();
      ctx->NewBuilder()
          .Split(user_op::OpArg("dy", 0), 1)
          .Broadcast(user_op::OpArg("label", 0))
          .Broadcast(user_op::OpArg("theta", 0))
          .Split(user_op::OpArg("dx", 0), 1)
          .Build();
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> CombinedMarginLossGradOp::InferDataType(user_op::InferContext *ctx) {
      *ctx->OutputDType("dx", 0) = ctx->InputDType("dy", 0);
      return Maybe<void>::Ok();
    }

