#include "oneflow/core/framework/op_generated.h"

namespace oneflow {

/* static */ Maybe<void> UnpackOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      const user_op::TensorDesc& in_desc = ctx->InputTensorDesc("in", 0);
      const Shape& in_shape = in_desc.shape();
      CHECK_GT_OR_RETURN(in_shape.NumAxes(), 0);
      const auto unpack_num = ctx->Attr<int32_t>("unpack_num");
      CHECK_EQ_OR_RETURN(in_shape.At(0) % unpack_num, 0);
      user_op::TensorDesc* out_desc = ctx->OutputTensorDesc("out", 0);
      *out_desc->mut_shape() = in_desc.shape();
      out_desc->mut_shape()->Set(0, in_shape.At(0) / unpack_num);
      *out_desc->mut_is_dynamic() = in_desc.is_dynamic();
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> UnpackOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> UnpackOp::GetSbp(user_op::SbpContext *ctx) {
      const user_op::TensorDesc& in = ctx->LogicalTensorDesc4InputArgNameAndIndex("in", 0);
      FOR_RANGE(int64_t, i, 0, in.shape().NumAxes()) {
        ctx->NewBuilder()
            .Split(user_op::OpArg("in", 0), i)
            .Split(user_op::OpArg("out", 0), i)
            .Build();
      }
      ctx->NewBuilder()
          .PartialSum(user_op::OpArg("in", 0))
          .PartialSum(user_op::OpArg("out", 0))
          .Build();
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> UnpackOp::InferOutputBlobTimeShape(user_op::InferOutputBlobTimeShapeFnContext *ctx) {
          const int32_t unpack_num = ctx->user_op_conf().attr<int32_t>("unpack_num");
          DimVector time_shape_dim_vec = ctx->TimeShape4InputArgNameAndIndex("in", 0).dim_vec();
          time_shape_dim_vec.emplace_back(unpack_num);
          *ctx->mut_output_blob_time_shape() = Shape(time_shape_dim_vec);
          return Maybe<void>::Ok();
        }

/* static */ Maybe<void> UnpackOp::InferDataType(user_op::InferContext *ctx) {
      user_op::TensorDesc* out_desc = ctx->OutputTensorDesc("out", 0);
      const user_op::TensorDesc& in_desc = ctx->InputTensorDesc("in", 0);
      *out_desc->mut_data_type() = in_desc.data_type();
      return Maybe<void>::Ok();
    }

