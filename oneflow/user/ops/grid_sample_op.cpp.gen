#include "oneflow/core/framework/op_generated.h"

namespace oneflow {

/* static */ Maybe<void> GridSampleOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      const user_op::TensorDesc& input = ctx->InputTensorDesc("input", 0);
      const user_op::TensorDesc& grid = ctx->InputTensorDesc("grid", 0);
      user_op::TensorDesc& output = *(ctx->OutputTensorDesc("output", 0));
      // Only support 4D or 5D input with NCHW layout
      // For 4D grid: input  = { N, C, H_in, W_in },
      //              grid   = { N, H_out, W_out, 2 }
      //              output = { N, C, H_out, W_out }
      // For 5D grid: input  = { N, C, D_in, H_in, W_in },
      //              grid   = { N, D_out, H_out, W_out, 3 }
      //              output = { N, C, D_out, H_out, W_out }
      const Shape& input_shape = input.shape();
      const Shape& grid_shape = grid.shape();

      bool is_4d_input = true;
      if (input_shape.NumAxes() == 4) {
        CHECK_EQ_OR_RETURN(grid_shape.NumAxes(), 4) << "Grid and input MUST have same dimention";
        CHECK_EQ_OR_RETURN(grid_shape.At(3), 2) << "Grid shape MUST (N, H_out, W_out, 2)";
        is_4d_input = true;
      } else if (input_shape.NumAxes() == 5) {
        CHECK_EQ_OR_RETURN(grid_shape.NumAxes(), 5) << "Grid and input MUST have same dimention";
        CHECK_EQ_OR_RETURN(grid_shape.At(4), 3) << "Grid shape MUST (N, H_out, W_out, 3)";
        if (ctx->Attr<std::string>("interpolation_mode") == "bicubic") {
          oneflow::Error::CheckFailedError() << "Mode='bicubic' supports only 4-D input";
        }
        is_4d_input = false;
      } else {
        CHECK_OR_RETURN(false) << "MUST be 4D or 5D input";
      }
      *output.mut_is_dynamic() = grid.is_dynamic();
      if (is_4d_input) {
        *(output.mut_shape()) = {input_shape.At(0), input_shape.At(1), grid_shape.At(1),
                                 grid_shape.At(2)};
      } else {
        *(output.mut_shape()) = {input_shape.At(0), input_shape.At(1), grid_shape.At(1),
                                 grid_shape.At(2), grid_shape.At(3)};
      }
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> GridSampleOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> GridSampleOp::GetSbp(user_op::SbpContext *ctx) {
      ctx->NewBuilder()
          .Split(user_op::OpArg("input", 0), 0)
          .Split(user_op::OpArg("grid", 0), 0)
          .Split(user_op::OpArg("output", 0), 0)
          .Build();
      ctx->NewBuilder()
          .Split(user_op::OpArg("input", 0), 1)
          .Broadcast(user_op::OpArg("grid", 0))
          .Split(user_op::OpArg("output", 0), 1)
          .Build();
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> GridSampleOp::CheckAttr(const user_op::UserOpDefWrapper &def, const user_op::UserOpConfWrapper &conf) {
return CheckAttr(ctx);
}

/* static */ Maybe<void> GridSampleOp::InferDataType(user_op::InferContext *ctx) {
      *ctx->OutputDType("output", 0) = ctx->InputDType("input", 0);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> GridSampleGradOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      *(ctx->OutputTensorDesc("dinput", 0)->mut_shape()) = ctx->InputTensorDesc("input", 0).shape();
      *(ctx->OutputTensorDesc("dgrid", 0)->mut_shape()) = ctx->InputTensorDesc("grid", 0).shape();
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> GridSampleGradOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> GridSampleGradOp::GetSbp(user_op::SbpContext *ctx) {
      ctx->NewBuilder()
          .Split(user_op::OpArg("doutput", 0), 0)
          .Split(user_op::OpArg("input", 0), 0)
          .Split(user_op::OpArg("grid", 0), 0)
          .Split(user_op::OpArg("dinput", 0), 0)
          .Split(user_op::OpArg("dgrid", 0), 0)
          .Build();
      ctx->NewBuilder()
          .Split(user_op::OpArg("doutput", 0), 1)
          .Split(user_op::OpArg("input", 0), 1)
          .Broadcast(user_op::OpArg("grid", 0))
          .Split(user_op::OpArg("dinput", 0), 1)
          .Broadcast(user_op::OpArg("dgrid", 0))
          .Build();
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> GridSampleGradOp::CheckAttr(const user_op::UserOpDefWrapper &def, const user_op::UserOpConfWrapper &conf) {
return CheckAttr(ctx);
}

/* static */ Maybe<void> GridSampleGradOp::InferDataType(user_op::InferContext *ctx) {
      *ctx->OutputDType("dinput", 0) = ctx->InputDType("input", 0);
      *ctx->OutputDType("dgrid", 0) = ctx->InputDType("grid", 0);
      return Maybe<void>::Ok();
    }

