#include "oneflow/core/framework/op_generated.h"

namespace oneflow {

/* static */ Maybe<void> SquareSumOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      user_op::TensorDesc* y = ctx->OutputTensorDesc("y", 0);
      *y->mut_shape() = Shape({1});
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> SquareSumOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> SquareSumOp::GetSbp(user_op::SbpContext *ctx) {
      const int64_t num_x_axes =
          ctx->LogicalTensorDesc4InputArgNameAndIndex("x", 0).shape().NumAxes();
      FOR_RANGE(int64_t, i, 0, num_x_axes) {
        ctx->NewBuilder()
            .Split(user_op::OpArg("x", 0), i)
            .PartialSum(user_op::OpArg("y", 0))
            .Build();
      }
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> SquareSumOp::InferDataType(user_op::InferContext *ctx) {
      *ctx->OutputDType("y", 0) = ctx->InputDType("x", 0);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> MultiSquareSumOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      user_op::TensorDesc* y = ctx->OutputTensorDesc("y", 0);
      *y->mut_shape() = Shape({1});
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> MultiSquareSumOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> MultiSquareSumOp::GetSbp(user_op::SbpContext *ctx) {
      int64_t min_num_axes = ctx->LogicalTensorDesc4InputArgNameAndIndex("x", 0).shape().NumAxes();
      for (int64_t i = 1; i < ctx->user_op_conf().input_size("x"); ++i) {
        min_num_axes = std::min(
            min_num_axes, ctx->LogicalTensorDesc4InputArgNameAndIndex("x", i).shape().NumAxes());
      }
      for (int64_t i = 0; i < min_num_axes; ++i) {
        ctx->NewBuilder().Split(ctx->inputs(), i).PartialSum(user_op::OpArg("y", 0)).Build();
      }
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> MultiSquareSumOp::InferDataType(user_op::InferContext *ctx) {
      const user_op::TensorDesc& x_0 = ctx->InputTensorDesc("x", 0);
      user_op::TensorDesc* y = ctx->OutputTensorDesc("y", 0);
      for (int64_t i = 1; i < ctx->input_size("x"); ++i) {
        const user_op::TensorDesc& x_i = ctx->InputTensorDesc("x", i);
        CHECK_EQ_OR_RETURN(x_i.data_type(), x_0.data_type());
      }
      *y->mut_data_type() = x_0.data_type();
      return Maybe<void>::Ok();
    }

