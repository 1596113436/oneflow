#include "oneflow/core/framework/op_generated.h"

namespace oneflow {

/* static */ Maybe<void> DistributedPartialFcSampleOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      const int64_t num_sample = ctx->Attr<int64_t>("num_sample");
      const user_op::TensorDesc& weight = ctx->InputTensorDesc("weight", 0);
      const user_op::TensorDesc& label = ctx->InputTensorDesc("label", 0);
      user_op::TensorDesc* mapped_label = ctx->OutputTensorDesc("mapped_label", 0);
      user_op::TensorDesc* sampled_weight = ctx->OutputTensorDesc("sampled_weight", 0);
      user_op::TensorDesc* sampled_label = ctx->OutputTensorDesc("sampled_label", 0);
      *mapped_label->mut_shape() = label.shape();
      *mapped_label->mut_is_dynamic() = label.is_dynamic();
      *sampled_weight->mut_shape() = weight.shape();
      sampled_weight->mut_shape()->Set(0, num_sample);
      *sampled_weight->mut_is_dynamic() = weight.is_dynamic();
      *sampled_label->mut_shape() = label.shape();
      sampled_label->mut_shape()->Set(0, num_sample);
      *sampled_label->mut_is_dynamic() = label.is_dynamic();
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> DistributedPartialFcSampleOp::InferPhysicalTensorDesc(user_op::InferContext *ctx) {
      const int64_t num_sample = ctx->Attr<int64_t>("num_sample");
      const int64_t parallel_num = ctx->parallel_ctx().parallel_num();
      CHECK_EQ_OR_RETURN(num_sample % parallel_num, 0);
      const int64_t num_sample_per_rank = num_sample / parallel_num;
      const user_op::TensorDesc& weight = ctx->InputTensorDesc("weight", 0);
      const user_op::TensorDesc& label = ctx->InputTensorDesc("label", 0);
      user_op::TensorDesc* mapped_label = ctx->OutputTensorDesc("mapped_label", 0);
      user_op::TensorDesc* sampled_weight = ctx->OutputTensorDesc("sampled_weight", 0);
      user_op::TensorDesc* sampled_label = ctx->OutputTensorDesc("sampled_label", 0);
      *mapped_label->mut_shape() = label.shape();
      *mapped_label->mut_is_dynamic() = label.is_dynamic();
      *sampled_weight->mut_shape() = weight.shape();
      sampled_weight->mut_shape()->Set(0, num_sample_per_rank);
      *sampled_weight->mut_is_dynamic() = weight.is_dynamic();
      *sampled_label->mut_shape() = label.shape();
      sampled_label->mut_shape()->Set(0, num_sample_per_rank);
      *sampled_label->mut_is_dynamic() = label.is_dynamic();
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> DistributedPartialFcSampleOp::GetSbp(user_op::SbpContext *ctx) {
      ctx->NewBuilder()
          .Split(user_op::OpArg("weight", 0), 0)
          .Broadcast(user_op::OpArg("label", 0))
          .Broadcast(user_op::OpArg("mapped_label", 0))
          .Split(user_op::OpArg("sampled_label", 0), 0)
          .Split(user_op::OpArg("sampled_weight", 0), 0)
          .Build();
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> DistributedPartialFcSampleOp::ModifyInputArg(GetInputArgModifier GetInputArgModifierFn, const user_op::UserOpConfWrapper &conf) {
      user_op::InputArgModifier* label_modifier = GetInputArgModifierFn("label", 0);
      CHECK_NOTNULL_OR_RETURN(label_modifier);
      label_modifier->set_requires_grad(false);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> DistributedPartialFcSampleOp::InferDataType(user_op::InferContext *ctx) {
      *ctx->OutputDType("mapped_label", 0) = ctx->InputDType("label", 0);
      *ctx->OutputDType("sampled_weight", 0) = ctx->InputDType("weight", 0);
      *ctx->OutputDType("sampled_label", 0) = ctx->InputDType("label", 0);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> DistributedPartialFcSampleDisableBoxingOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      user_op::TensorDesc* boxing_disabled_sampled_weight_diff =
          ctx->OutputTensorDesc("boxing_disabled_sampled_weight_diff", 0);
      *boxing_disabled_sampled_weight_diff->mut_shape() = ctx->InputShape("sampled_weight_diff", 0);
      CHECK_EQ_OR_RETURN(boxing_disabled_sampled_weight_diff->shape().At(0) % ctx->parallel_num(),
                         0);
      boxing_disabled_sampled_weight_diff->mut_shape()->Set(
          0, boxing_disabled_sampled_weight_diff->shape().At(0) / ctx->parallel_num());
      *boxing_disabled_sampled_weight_diff->mut_is_dynamic() =
          ctx->InputIsDynamic("sampled_weight_diff", 0);
      user_op::TensorDesc* boxing_disabled_sampled_label =
          ctx->OutputTensorDesc("boxing_disabled_sampled_label", 0);
      *boxing_disabled_sampled_label->mut_shape() = ctx->InputShape("sampled_label", 0);
      CHECK_EQ_OR_RETURN(boxing_disabled_sampled_label->shape().At(0) % ctx->parallel_num(), 0);
      boxing_disabled_sampled_label->mut_shape()->Set(
          0, boxing_disabled_sampled_label->shape().At(0) / ctx->parallel_num());
      *boxing_disabled_sampled_label->mut_is_dynamic() = ctx->InputIsDynamic("sampled_label", 0);
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> DistributedPartialFcSampleDisableBoxingOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> DistributedPartialFcSampleDisableBoxingOp::InferPhysicalTensorDesc(user_op::InferContext *ctx) {
      *ctx->OutputShape("boxing_disabled_sampled_weight_diff", 0) =
          ctx->InputShape("sampled_weight_diff", 0);
      *ctx->OutputIsDynamic("boxing_disabled_sampled_weight_diff", 0) =
          ctx->InputIsDynamic("sampled_weight_diff", 0);
      *ctx->OutputShape("boxing_disabled_sampled_label", 0) = ctx->InputShape("sampled_label", 0);
      *ctx->OutputIsDynamic("boxing_disabled_sampled_label", 0) =
          ctx->InputIsDynamic("sampled_label", 0);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> DistributedPartialFcSampleDisableBoxingOp::GetSbp(user_op::SbpContext *ctx) {
      ctx->NewBuilder()
          .Split(user_op::OpArg("sampled_weight_diff", 0), 0)
          .Split(user_op::OpArg("sampled_label", 0), 0)
          .Broadcast(user_op::OpArg("boxing_disabled_sampled_weight_diff", 0))
          .Broadcast(user_op::OpArg("boxing_disabled_sampled_label", 0))
          .Build();
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> DistributedPartialFcSampleDisableBoxingOp::InferDataType(user_op::InferContext *ctx) {
      *ctx->OutputDType("boxing_disabled_sampled_weight_diff", 0) =
          ctx->InputDType("sampled_weight_diff", 0);
      *ctx->OutputDType("boxing_disabled_sampled_label", 0) = ctx->InputDType("sampled_label", 0);
      return Maybe<void>::Ok();
    }

