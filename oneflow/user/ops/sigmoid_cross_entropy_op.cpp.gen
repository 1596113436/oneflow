#include "oneflow/core/framework/op_generated.h"

namespace oneflow {

/* static */ Maybe<void> SigmoidCrossEntropyOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      const user_op::TensorDesc& prediction_desc = ctx->InputTensorDesc("prediction", 0);
      const user_op::TensorDesc& label_desc = ctx->InputTensorDesc("label", 0);
      CHECK_EQ_OR_RETURN(label_desc.shape(), prediction_desc.shape());
      user_op::TensorDesc* loss_desc = ctx->OutputTensorDesc("loss", 0);
      *loss_desc->mut_shape() = prediction_desc.shape();
      *loss_desc->mut_is_dynamic() = prediction_desc.is_dynamic();
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> SigmoidCrossEntropyOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> SigmoidCrossEntropyOp::GetSbp(user_op::SbpContext *ctx) {
      const auto num_out_axes =
          ctx->LogicalTensorDesc4InputArgNameAndIndex("prediction", 0).shape().NumAxes();
      FOR_RANGE(int64_t, i, 0, num_out_axes) {
        ctx->NewBuilder()
            .Split(user_op::OpArg("prediction", 0), i)
            .Split(user_op::OpArg("label", 0), i)
            .Split(user_op::OpArg("loss", 0), i)
            .Build();
      }
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> SigmoidCrossEntropyOp::ModifyInputArg(GetInputArgModifier GetInputArgModifierFn, const user_op::UserOpConfWrapper &conf) {
      user_op::InputArgModifier* cond_arg_modifier = GetInputArgModifierFn("label", 0);
      cond_arg_modifier->set_requires_grad(false);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> SigmoidCrossEntropyOp::InferDataType(user_op::InferContext *ctx) {
      *ctx->OutputDType("loss", 0) = ctx->InputDType("prediction", 0);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> SigmoidCrossEntropyGradOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      const user_op::TensorDesc& prediction_desc = ctx->InputTensorDesc("prediction", 0);
      const user_op::TensorDesc& label_desc = ctx->InputTensorDesc("label", 0);
      const user_op::TensorDesc& loss_diff_desc = ctx->InputTensorDesc("loss_diff", 0);
      CHECK_EQ_OR_RETURN(label_desc.shape(), prediction_desc.shape());
      CHECK_EQ_OR_RETURN(loss_diff_desc.shape(), prediction_desc.shape());
      user_op::TensorDesc* prediction_diff = ctx->OutputTensorDesc("prediction_diff", 0);
      *prediction_diff->mut_shape() = prediction_desc.shape();
      *prediction_diff->mut_is_dynamic() = prediction_desc.is_dynamic();
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> SigmoidCrossEntropyGradOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> SigmoidCrossEntropyGradOp::GetSbp(user_op::SbpContext *ctx) {
      const auto num_dy_axes =
          ctx->LogicalTensorDesc4InputArgNameAndIndex("loss_diff", 0).shape().NumAxes();
      FOR_RANGE(int64_t, i, 0, num_dy_axes) {
        ctx->NewBuilder()
            .Split(user_op::OpArg("loss_diff", 0), i)
            .Split(user_op::OpArg("label", 0), i)
            .Split(user_op::OpArg("prediction", 0), i)
            .Split(user_op::OpArg("prediction_diff", 0), i)
            .Build();
      }
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> SigmoidCrossEntropyGradOp::ModifyInputArg(GetInputArgModifier GetInputArgModifierFn, const user_op::UserOpConfWrapper &conf) {
      user_op::InputArgModifier* cond_arg_modifier = GetInputArgModifierFn("label", 0);
      cond_arg_modifier->set_requires_grad(false);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> SigmoidCrossEntropyGradOp::InferDataType(user_op::InferContext *ctx) {
      *ctx->OutputDType("prediction_diff", 0) = ctx->InputDType("prediction", 0);
      return Maybe<void>::Ok();
    }

