#include "oneflow/core/framework/op_generated.h"

namespace oneflow {

/* static */ Maybe<void> UnfoldTensorOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      const user_op::TensorDesc& in = ctx->InputTensorDesc("x", 0);
      const int32_t dimension = ctx->Attr<int32_t>("dimension");
      const int32_t size = ctx->Attr<int32_t>("size");
      const int32_t step = ctx->Attr<int32_t>("step");

      const Shape& in_shape = ctx->InputShape("x", 0);
      const int32_t in_dim = in_shape.NumAxes();
      CHECK_GE_OR_RETURN(dimension, 0);
      CHECK_LE_OR_RETURN(dimension, in_dim - 1);

      const int32_t max_size = in_dim == 0 ? 1 : in_shape.At(dimension);
      CHECK_GT_OR_RETURN(size, 0);
      CHECK_LE_OR_RETURN(size, max_size);
      CHECK_GT_OR_RETURN(step, 0);

      DimVector out_shape(in_dim + 1);
      out_shape[in_dim] = size;
      FOR_RANGE(int32_t, d, 0, in_dim) {
        int32_t in_size_at_d = in.shape().At(d);
        if (d == dimension) {
          out_shape.at(d) = (in_size_at_d - size) / step + 1;
        } else {
          out_shape.at(d) = in_size_at_d;
        }
      }
      *ctx->OutputShape("y", 0) = Shape(out_shape);
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> UnfoldTensorOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> UnfoldTensorOp::GetSbp(user_op::SbpContext *ctx) {
      const int32_t dimension = ctx->Attr<int32_t>("dimension");
      const user_op::TensorDesc& x_tensor = ctx->LogicalTensorDesc4InputArgNameAndIndex("x", 0);
      FOR_RANGE(int64_t, i, 0, x_tensor.shape().NumAxes()) {
        if (i != dimension) {
          ctx->NewBuilder()
              .Split(user_op::OpArg("x", 0), i)
              .Split(user_op::OpArg("y", 0), i)
              .Build();
        }
      }
      ctx->NewBuilder().PartialSum(ctx->inputs()).PartialSum(ctx->outputs()).Build();
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> UnfoldTensorOp::InferDataType(user_op::InferContext *ctx) {
      *ctx->OutputDType("y", 0) = ctx->InputDType("x", 0);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> UnfoldTensorGradOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      const user_op::TensorDesc& in = ctx->InputTensorDesc("x", 0);
      const Shape& in_shape = in.shape();
      user_op::TensorDesc* dx_desc = ctx->OutputTensorDesc("dx", 0);
      *dx_desc->mut_shape() = Shape(in_shape.dim_vec());
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> UnfoldTensorGradOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> UnfoldTensorGradOp::GetSbp(user_op::SbpContext *ctx) {
      const int32_t dimension = ctx->Attr<int32_t>("dimension");
      const user_op::TensorDesc& x_tensor = ctx->LogicalTensorDesc4InputArgNameAndIndex("dx", 0);
      FOR_RANGE(int64_t, i, 0, x_tensor.shape().NumAxes()) {
        if (i != dimension) {
          ctx->NewBuilder()
              .Split(user_op::OpArg("dy", 0), i)
              .Split(user_op::OpArg("dx", 0), i)
              .Build();
        }
      }
      ctx->NewBuilder().PartialSum(ctx->inputs()).PartialSum(ctx->outputs()).Build();
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> UnfoldTensorGradOp::InferDataType(user_op::InferContext *ctx) {
      *ctx->OutputDType("dx", 0) = ctx->InputDType("dy", 0);
      return Maybe<void>::Ok();
    }

