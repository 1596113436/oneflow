#include "oneflow/core/framework/op_generated.h"

namespace oneflow {

/* static */ Maybe<void> WhereOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
return InferWhereTensorDesc(ctx);
}

/*static*/ Maybe<void> WhereOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> WhereOp::GetSbp(user_op::SbpContext *ctx) {
return GetWhereSbpSignatures(ctx);
}

/* static */ Maybe<void> WhereOp::ModifyInputArg(GetInputArgModifier GetInputArgModifierFn, const user_op::UserOpConfWrapper &conf) {
return GetWhereInputArgModify(ctx);
}

/* static */ Maybe<void> WhereOp::InferDataType(user_op::InferContext *ctx) {
      const DataType& cond_dtype = ctx->InputDType("condition", 0);
      CHECK_OR_RETURN(IsIntegralDataType(cond_dtype));
      const DataType& x_dtype = ctx->InputDType("x", 0);
      CHECK_EQ_OR_RETURN(x_dtype, ctx->InputDType("y", 0));
      *ctx->OutputDType("out", 0) = x_dtype;
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> WhereScalarXOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
return InferWhereXScalarTensorDesc(ctx);
}

/*static*/ Maybe<void> WhereScalarXOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> WhereScalarXOp::GetSbp(user_op::SbpContext *ctx) {
return GetWhereXScalarSbpSignatures(ctx);
}

/* static */ Maybe<void> WhereScalarXOp::ModifyInputArg(GetInputArgModifier GetInputArgModifierFn, const user_op::UserOpConfWrapper &conf) {
return GetWhereInputArgModify(ctx);
}

/* static */ Maybe<void> WhereScalarXOp::InferDataType(user_op::InferContext *ctx) {
      const DataType& cond_dtype = ctx->InputDType("condition", 0);
      CHECK_OR_RETURN(IsIntegralDataType(cond_dtype));
      const DataType& y_dtype = ctx->InputDType("y", 0);
      if (ctx->Attr<bool>("has_int_operand")) {
        CHECK_EQ_OR_RETURN(y_dtype, GetDataType<int64_t>::value)
            << "expected scalar type " << GetDataType<int64_t>::value << "but found " << y_dtype;
      } else if (ctx->Attr<bool>("has_float_operand")) {
        CHECK_EQ_OR_RETURN(y_dtype, GetDataType<double>::value)
            << "expected scalar type " << GetDataType<double>::value << "but found " << y_dtype;
      }
      *ctx->OutputDType("out", 0) = y_dtype;
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> WhereScalarYOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
return InferWhereYScalarTensorDesc(ctx);
}

/*static*/ Maybe<void> WhereScalarYOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> WhereScalarYOp::GetSbp(user_op::SbpContext *ctx) {
return GetWhereYScalarSbpSignatures(ctx);
}

/* static */ Maybe<void> WhereScalarYOp::ModifyInputArg(GetInputArgModifier GetInputArgModifierFn, const user_op::UserOpConfWrapper &conf) {
return GetWhereInputArgModify(ctx);
}

/* static */ Maybe<void> WhereScalarYOp::InferDataType(user_op::InferContext *ctx) {
      const DataType& cond_dtype = ctx->InputDType("condition", 0);
      CHECK_OR_RETURN(IsIntegralDataType(cond_dtype));
      const DataType& x_dtype = ctx->InputDType("x", 0);
      if (ctx->Attr<bool>("has_int_operand")) {
        CHECK_EQ_OR_RETURN(x_dtype, GetDataType<int64_t>::value)
            << "expected scalar type " << x_dtype << "but found " << GetDataType<int64_t>::value;
      } else if (ctx->Attr<bool>("has_float_operand")) {
        CHECK_EQ_OR_RETURN(x_dtype, GetDataType<double>::value)
            << "expected scalar type " << x_dtype << "but found " << GetDataType<double>::value;
      }
      *ctx->OutputDType("out", 0) = x_dtype;
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> WhereScalarXyOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
return InferWhereXYScalarTensorDesc(ctx);
}

/*static*/ Maybe<void> WhereScalarXyOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> WhereScalarXyOp::GetSbp(user_op::SbpContext *ctx) {
return GetWhereXYScalarSbpSignatures(ctx);
}

/* static */ Maybe<void> WhereScalarXyOp::ModifyInputArg(GetInputArgModifier GetInputArgModifierFn, const user_op::UserOpConfWrapper &conf) {
return GetWhereInputArgModify(ctx);
}

/* static */ Maybe<void> WhereScalarXyOp::InferDataType(user_op::InferContext *ctx) {
      const DataType& cond_dtype = ctx->InputDType("condition", 0);
      CHECK_OR_RETURN(IsIntegralDataType(cond_dtype));
      if (ctx->Attr<bool>("has_x_int_operand") && ctx->Attr<bool>("has_y_int_operand")) {
        *ctx->OutputDType("out", 0) = GetDataType<int64_t>::value;
      } else if (ctx->Attr<bool>("has_x_float_operand") && ctx->Attr<bool>("has_y_float_operand")) {
        *ctx->OutputDType("out", 0) = GetDataType<double>::value;
      } else {
        UNIMPLEMENTED();
      }
      return Maybe<void>::Ok();
    }

