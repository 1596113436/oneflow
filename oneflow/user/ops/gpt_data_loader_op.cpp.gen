#include "oneflow/core/framework/op_generated.h"

namespace oneflow {

/* static */ Maybe<void> MegatronGptMmapDataLoaderOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      int64_t batch_size = ctx->Attr<int64_t>("batch_size");
      int64_t sample_len = ctx->Attr<int64_t>("seq_length") + ctx->Attr<int64_t>("label_length");
      user_op::TensorDesc* out_desc = ctx->OutputTensorDesc("out", 0);
      *out_desc->mut_shape() = Shape({batch_size, sample_len});
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> MegatronGptMmapDataLoaderOp::GetSbp(user_op::SbpContext *ctx) {
      ctx->NewBuilder().Split(ctx->outputs(), 0).Build();
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> MegatronGptMmapDataLoaderOp::ModifyInputArg(GetInputArgModifier GetInputArgModifierFn, const user_op::UserOpConfWrapper &conf) {
      if (!conf.has_input("iteration", 0)) { return Maybe<void>::Ok(); }
      user_op::InputArgModifier* input_modifier = GetInputArgModifierFn("iteration", 0);
      CHECK_OR_RETURN(input_modifier != nullptr);
      input_modifier->set_is_mutable(true);
      input_modifier->set_requires_grad(false);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> MegatronGptMmapDataLoaderOp::InferNdSbp(user_op::InferNdSbpFnContext *ctx) {
      cfg::SbpParallel default_sbp;
      default_sbp.mutable_split_parallel()->set_axis(0);
      return user_op::InferNdSbp4SrcOp(ctx, default_sbp);
    }

/* static */ Maybe<void> MegatronGptMmapDataLoaderOp::InferDataType(user_op::InferContext *ctx) {
      *ctx->OutputTensorDesc("out", 0)->mut_data_type() = ctx->Attr<DataType>("dtype");
      return Maybe<void>::Ok();
    }

