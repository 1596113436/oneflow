#include "oneflow/core/framework/op_generated.h"

namespace oneflow {

/* static */ Maybe<void> BatchGatherOp::InferLogicalTensorDesc(user_op::InferContext *ctx) {
      const user_op::TensorDesc& in = ctx->InputTensorDesc("in", 0);
      CHECK_GT_OR_RETURN(in.shape().NumAxes(), 0);
      const user_op::TensorDesc& indices = ctx->InputTensorDesc("indices", 0);
      CHECK_GT_OR_RETURN(indices.shape().NumAxes(), 0);
      user_op::TensorDesc* out = ctx->OutputTensorDesc("out", 0);
      CHECK_LE_OR_RETURN(indices.shape().dim_vec().size(), in.shape().dim_vec().size());
      FOR_RANGE(int64_t, i, 0, indices.shape().dim_vec().size() - 1) {
        if (in.is_dynamic() && indices.is_dynamic() == false) {
          CHECK_GE_OR_RETURN(indices.shape().dim_vec().at(i), in.shape().dim_vec().at(i));
        } else if (in.is_dynamic() == false && indices.is_dynamic()) {
          UNIMPLEMENTED();
        } else {
          CHECK_EQ_OR_RETURN(indices.shape().dim_vec().at(i), in.shape().dim_vec().at(i));
        }
      }

      DimVector dim_vec(in.shape().dim_vec());
      dim_vec.at(indices.shape().NumAxes() - 1) = indices.shape().dim_vec().back();
      *out->mut_shape() = Shape(dim_vec);
      return Maybe<void>::Ok();
    }

/*static*/ Maybe<void> BatchGatherOp::InferPhysicalTensorDesc(user_op::InferContext* ctx) {return InferLogicalTensorDesc(ctx);}

/* static */ Maybe<void> BatchGatherOp::GetSbp(user_op::SbpContext *ctx) {
      const int64_t indices_num_axes =
          ctx->LogicalTensorDesc4InputArgNameAndIndex("indices", 0).shape().NumAxes();
      if (indices_num_axes > 1) {
        FOR_RANGE(int64_t, i, 0, indices_num_axes - 1) {
          ctx->NewBuilder()
              .Split(user_op::OpArg("indices", 0), i)
              .Split(user_op::OpArg("in", 0), i)
              .Split(user_op::OpArg("out", 0), i)
              .Build();
        }
        ctx->NewBuilder()
            .Broadcast(user_op::OpArg("indices", 0))
            .PartialSum(user_op::OpArg("in", 0))
            .PartialSum(user_op::OpArg("out", 0))
            .Build();
      } else {
        auto err = std::make_shared<cfg::ErrorProto>();
        err->set_msg("BatchGatherOp: indices_num_axes equals " + std::to_string(indices_num_axes)
                     + " (should be bigger than 1).");
        err->mutable_check_failed_error();
        return err;
      }
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> BatchGatherOp::ModifyInputArg(GetInputArgModifier GetInputArgModifierFn, const user_op::UserOpConfWrapper &conf) {
      user_op::InputArgModifier* indices_modifier = GetInputArgModifierFn("indices", 0);
      CHECK_OR_RETURN(indices_modifier != nullptr);
      indices_modifier->set_requires_grad(false);
      return Maybe<void>::Ok();
    }

/* static */ Maybe<void> BatchGatherOp::InferDataType(user_op::InferContext *ctx) {
      const user_op::TensorDesc& indices = ctx->InputTensorDesc("indices", 0);
      CHECK_OR_RETURN(IsIndexDataType(indices.data_type()));
      const user_op::TensorDesc& in = ctx->InputTensorDesc("in", 0);
      user_op::TensorDesc* out = ctx->OutputTensorDesc("out", 0);
      *out->mut_data_type() = in.data_type();
      return Maybe<void>::Ok();
    }

