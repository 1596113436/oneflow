/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* oneflow op schema                                                          *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/


#include "oneflow/core/framework/op_interp_ctx.h"

namespace oneflow {

class AbsGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AbsGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AbsGradOpInterpCtxImpl : public AbsGradOpInterpCtx {
 public:
  AbsGradOpInterpCtxImpl() = default;
  AbsGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AbsGradOp {
 public:
  AbsGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AbsOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AbsOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AbsOpInterpCtxImpl : public AbsOpInterpCtx {
 public:
  AbsOpInterpCtxImpl() = default;
  AbsOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AbsOp {
 public:
  AbsOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AccOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AccOpInterpCtx() = default;

  virtual const int32_t& max_acc_num() const = 0;
  virtual int32_t* mutable_max_acc_num() = 0;
  virtual void set_max_acc_num(const int32_t& max_acc_num) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AccOpInterpCtxImpl : public AccOpInterpCtx {
 public:
  AccOpInterpCtxImpl() = default;
  AccOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& max_acc_num() const { return impl_.max_acc_num(); }
  int32_t* mutable_max_acc_num() { return impl_.mutable_max_acc_num(); }
  void set_max_acc_num(const int32_t& max_acc_num) { impl_.set_max_acc_num(max_acc_num); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AccOp {
 public:
  AccOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& max_acc_num() const { return internal_->max_acc_num; }
  int32_t* mutable_max_acc_num() { return &internal_->max_acc_num; }
  void set_max_acc_num(const int32_t& max_acc_num) { internal_->max_acc_num = max_acc_num; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t max_acc_num = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AcosGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AcosGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AcosGradOpInterpCtxImpl : public AcosGradOpInterpCtx {
 public:
  AcosGradOpInterpCtxImpl() = default;
  AcosGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AcosGradOp {
 public:
  AcosGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AcosOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AcosOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AcosOpInterpCtxImpl : public AcosOpInterpCtx {
 public:
  AcosOpInterpCtxImpl() = default;
  AcosOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AcosOp {
 public:
  AcosOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AcoshGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AcoshGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AcoshGradOpInterpCtxImpl : public AcoshGradOpInterpCtx {
 public:
  AcoshGradOpInterpCtxImpl() = default;
  AcoshGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AcoshGradOp {
 public:
  AcoshGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AcoshOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AcoshOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AcoshOpInterpCtxImpl : public AcoshOpInterpCtx {
 public:
  AcoshOpInterpCtxImpl() = default;
  AcoshOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AcoshOp {
 public:
  AcoshOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AdagradUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AdagradUpdateOpInterpCtx() = default;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  virtual const float& l1() const = 0;
  virtual float* mutable_l1() = 0;
  virtual void set_l1(const float& l1) = 0;

  virtual const float& l2() const = 0;
  virtual float* mutable_l2() = 0;
  virtual void set_l2(const float& l2) = 0;

  virtual const float& learning_rate_val() const = 0;
  virtual float* mutable_learning_rate_val() = 0;
  virtual void set_learning_rate_val(const float& learning_rate_val) = 0;

  virtual const float& lr_decay() const = 0;
  virtual float* mutable_lr_decay() = 0;
  virtual void set_lr_decay(const float& lr_decay) = 0;

  virtual const double& scale() const = 0;
  virtual double* mutable_scale() = 0;
  virtual void set_scale(const double& scale) = 0;

  virtual const int32_t& train_step_val() const = 0;
  virtual int32_t* mutable_train_step_val() = 0;
  virtual void set_train_step_val(const int32_t& train_step_val) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AdagradUpdateOpInterpCtxImpl : public AdagradUpdateOpInterpCtx {
 public:
  AdagradUpdateOpInterpCtxImpl() = default;
  AdagradUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& epsilon() const { return impl_.epsilon(); }
  float* mutable_epsilon() { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) { impl_.set_epsilon(epsilon); }
  
  const float& l1() const { return impl_.l1(); }
  float* mutable_l1() { return impl_.mutable_l1(); }
  void set_l1(const float& l1) { impl_.set_l1(l1); }
  
  const float& l2() const { return impl_.l2(); }
  float* mutable_l2() { return impl_.mutable_l2(); }
  void set_l2(const float& l2) { impl_.set_l2(l2); }
  
  const float& learning_rate_val() const { return impl_.learning_rate_val(); }
  float* mutable_learning_rate_val() { return impl_.mutable_learning_rate_val(); }
  void set_learning_rate_val(const float& learning_rate_val) { impl_.set_learning_rate_val(learning_rate_val); }
  
  const float& lr_decay() const { return impl_.lr_decay(); }
  float* mutable_lr_decay() { return impl_.mutable_lr_decay(); }
  void set_lr_decay(const float& lr_decay) { impl_.set_lr_decay(lr_decay); }
  
  const double& scale() const { return impl_.scale(); }
  double* mutable_scale() { return impl_.mutable_scale(); }
  void set_scale(const double& scale) { impl_.set_scale(scale); }
  
  const int32_t& train_step_val() const { return impl_.train_step_val(); }
  int32_t* mutable_train_step_val() { return impl_.mutable_train_step_val(); }
  void set_train_step_val(const int32_t& train_step_val) { impl_.set_train_step_val(train_step_val); }
  
  const float& weight_decay() const { return impl_.weight_decay(); }
  float* mutable_weight_decay() { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) { impl_.set_weight_decay(weight_decay); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdagradUpdateOp {
 public:
  AdagradUpdateOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }
  
  const float& l1() const { return internal_->l1; }
  float* mutable_l1() { return &internal_->l1; }
  void set_l1(const float& l1) { internal_->l1 = l1; }
  
  const float& l2() const { return internal_->l2; }
  float* mutable_l2() { return &internal_->l2; }
  void set_l2(const float& l2) { internal_->l2 = l2; }
  
  const float& learning_rate_val() const { return internal_->learning_rate_val; }
  float* mutable_learning_rate_val() { return &internal_->learning_rate_val; }
  void set_learning_rate_val(const float& learning_rate_val) { internal_->learning_rate_val = learning_rate_val; }
  
  const float& lr_decay() const { return internal_->lr_decay; }
  float* mutable_lr_decay() { return &internal_->lr_decay; }
  void set_lr_decay(const float& lr_decay) { internal_->lr_decay = lr_decay; }
  
  const double& scale() const { return internal_->scale; }
  double* mutable_scale() { return &internal_->scale; }
  void set_scale(const double& scale) { internal_->scale = scale; }
  
  const int32_t& train_step_val() const { return internal_->train_step_val; }
  int32_t* mutable_train_step_val() { return &internal_->train_step_val; }
  void set_train_step_val(const int32_t& train_step_val) { internal_->train_step_val = train_step_val; }
  
  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float epsilon = 0.;
    float l1 = 0.;
    float l2 = 0.;
    float learning_rate_val = 0.;
    float lr_decay = 0.;
    double scale = 1.;
    int32_t train_step_val = 0;
    float weight_decay = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AdamBiasCorrectionFactorOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AdamBiasCorrectionFactorOpInterpCtx() = default;

  virtual const float& beta() const = 0;
  virtual float* mutable_beta() = 0;
  virtual void set_beta(const float& beta) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AdamBiasCorrectionFactorOpInterpCtxImpl : public AdamBiasCorrectionFactorOpInterpCtx {
 public:
  AdamBiasCorrectionFactorOpInterpCtxImpl() = default;
  AdamBiasCorrectionFactorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& beta() const { return impl_.beta(); }
  float* mutable_beta() { return impl_.mutable_beta(); }
  void set_beta(const float& beta) { impl_.set_beta(beta); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdamBiasCorrectionFactorOp {
 public:
  AdamBiasCorrectionFactorOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& beta() const { return internal_->beta; }
  float* mutable_beta() { return &internal_->beta; }
  void set_beta(const float& beta) { internal_->beta = beta; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float beta = 0.9;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AdamUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AdamUpdateOpInterpCtx() = default;

  virtual const bool& amsgrad() const = 0;
  virtual bool* mutable_amsgrad() = 0;
  virtual void set_amsgrad(const bool& amsgrad) = 0;

  virtual const float& beta1() const = 0;
  virtual float* mutable_beta1() = 0;
  virtual void set_beta1(const float& beta1) = 0;

  virtual const float& beta2() const = 0;
  virtual float* mutable_beta2() = 0;
  virtual void set_beta2(const float& beta2) = 0;

  virtual const float& bias_correction1_val() const = 0;
  virtual float* mutable_bias_correction1_val() = 0;
  virtual void set_bias_correction1_val(const float& bias_correction1_val) = 0;

  virtual const float& bias_correction2_val() const = 0;
  virtual float* mutable_bias_correction2_val() = 0;
  virtual void set_bias_correction2_val(const float& bias_correction2_val) = 0;

  virtual const bool& do_bias_correction() const = 0;
  virtual bool* mutable_do_bias_correction() = 0;
  virtual void set_do_bias_correction(const bool& do_bias_correction) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  virtual const float& l1() const = 0;
  virtual float* mutable_l1() = 0;
  virtual void set_l1(const float& l1) = 0;

  virtual const float& l2() const = 0;
  virtual float* mutable_l2() = 0;
  virtual void set_l2(const float& l2) = 0;

  virtual const float& learning_rate_val() const = 0;
  virtual float* mutable_learning_rate_val() = 0;
  virtual void set_learning_rate_val(const float& learning_rate_val) = 0;

  virtual const double& scale() const = 0;
  virtual double* mutable_scale() = 0;
  virtual void set_scale(const double& scale) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AdamUpdateOpInterpCtxImpl : public AdamUpdateOpInterpCtx {
 public:
  AdamUpdateOpInterpCtxImpl() = default;
  AdamUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& amsgrad() const { return impl_.amsgrad(); }
  bool* mutable_amsgrad() { return impl_.mutable_amsgrad(); }
  void set_amsgrad(const bool& amsgrad) { impl_.set_amsgrad(amsgrad); }
  
  const float& beta1() const { return impl_.beta1(); }
  float* mutable_beta1() { return impl_.mutable_beta1(); }
  void set_beta1(const float& beta1) { impl_.set_beta1(beta1); }
  
  const float& beta2() const { return impl_.beta2(); }
  float* mutable_beta2() { return impl_.mutable_beta2(); }
  void set_beta2(const float& beta2) { impl_.set_beta2(beta2); }
  
  const float& bias_correction1_val() const { return impl_.bias_correction1_val(); }
  float* mutable_bias_correction1_val() { return impl_.mutable_bias_correction1_val(); }
  void set_bias_correction1_val(const float& bias_correction1_val) { impl_.set_bias_correction1_val(bias_correction1_val); }
  
  const float& bias_correction2_val() const { return impl_.bias_correction2_val(); }
  float* mutable_bias_correction2_val() { return impl_.mutable_bias_correction2_val(); }
  void set_bias_correction2_val(const float& bias_correction2_val) { impl_.set_bias_correction2_val(bias_correction2_val); }
  
  const bool& do_bias_correction() const { return impl_.do_bias_correction(); }
  bool* mutable_do_bias_correction() { return impl_.mutable_do_bias_correction(); }
  void set_do_bias_correction(const bool& do_bias_correction) { impl_.set_do_bias_correction(do_bias_correction); }
  
  const float& epsilon() const { return impl_.epsilon(); }
  float* mutable_epsilon() { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) { impl_.set_epsilon(epsilon); }
  
  const float& l1() const { return impl_.l1(); }
  float* mutable_l1() { return impl_.mutable_l1(); }
  void set_l1(const float& l1) { impl_.set_l1(l1); }
  
  const float& l2() const { return impl_.l2(); }
  float* mutable_l2() { return impl_.mutable_l2(); }
  void set_l2(const float& l2) { impl_.set_l2(l2); }
  
  const float& learning_rate_val() const { return impl_.learning_rate_val(); }
  float* mutable_learning_rate_val() { return impl_.mutable_learning_rate_val(); }
  void set_learning_rate_val(const float& learning_rate_val) { impl_.set_learning_rate_val(learning_rate_val); }
  
  const double& scale() const { return impl_.scale(); }
  double* mutable_scale() { return impl_.mutable_scale(); }
  void set_scale(const double& scale) { impl_.set_scale(scale); }
  
  const float& weight_decay() const { return impl_.weight_decay(); }
  float* mutable_weight_decay() { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) { impl_.set_weight_decay(weight_decay); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdamUpdateOp {
 public:
  AdamUpdateOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& amsgrad() const { return internal_->amsgrad; }
  bool* mutable_amsgrad() { return &internal_->amsgrad; }
  void set_amsgrad(const bool& amsgrad) { internal_->amsgrad = amsgrad; }
  
  const float& beta1() const { return internal_->beta1; }
  float* mutable_beta1() { return &internal_->beta1; }
  void set_beta1(const float& beta1) { internal_->beta1 = beta1; }
  
  const float& beta2() const { return internal_->beta2; }
  float* mutable_beta2() { return &internal_->beta2; }
  void set_beta2(const float& beta2) { internal_->beta2 = beta2; }
  
  const float& bias_correction1_val() const { return internal_->bias_correction1_val; }
  float* mutable_bias_correction1_val() { return &internal_->bias_correction1_val; }
  void set_bias_correction1_val(const float& bias_correction1_val) { internal_->bias_correction1_val = bias_correction1_val; }
  
  const float& bias_correction2_val() const { return internal_->bias_correction2_val; }
  float* mutable_bias_correction2_val() { return &internal_->bias_correction2_val; }
  void set_bias_correction2_val(const float& bias_correction2_val) { internal_->bias_correction2_val = bias_correction2_val; }
  
  const bool& do_bias_correction() const { return internal_->do_bias_correction; }
  bool* mutable_do_bias_correction() { return &internal_->do_bias_correction; }
  void set_do_bias_correction(const bool& do_bias_correction) { internal_->do_bias_correction = do_bias_correction; }
  
  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }
  
  const float& l1() const { return internal_->l1; }
  float* mutable_l1() { return &internal_->l1; }
  void set_l1(const float& l1) { internal_->l1 = l1; }
  
  const float& l2() const { return internal_->l2; }
  float* mutable_l2() { return &internal_->l2; }
  void set_l2(const float& l2) { internal_->l2 = l2; }
  
  const float& learning_rate_val() const { return internal_->learning_rate_val; }
  float* mutable_learning_rate_val() { return &internal_->learning_rate_val; }
  void set_learning_rate_val(const float& learning_rate_val) { internal_->learning_rate_val = learning_rate_val; }
  
  const double& scale() const { return internal_->scale; }
  double* mutable_scale() { return &internal_->scale; }
  void set_scale(const double& scale) { internal_->scale = scale; }
  
  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool amsgrad = false;
    float beta1 = 0.9;
    float beta2 = 0.999;
    float bias_correction1_val = 1.;
    float bias_correction2_val = 1.;
    bool do_bias_correction = true;
    float epsilon = 0.;
    float l1 = 0.;
    float l2 = 0.;
    float learning_rate_val = 0.;
    double scale = 1.;
    float weight_decay = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AdaptiveAvgPool1DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AdaptiveAvgPool1DGradOpInterpCtx() = default;

  virtual const std::vector<std::int64_t>& output_size() const = 0;
  virtual std::vector<std::int64_t>* mutable_output_size() = 0;
  virtual void set_output_size(const std::vector<std::int64_t>& output_size) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AdaptiveAvgPool1DGradOpInterpCtxImpl : public AdaptiveAvgPool1DGradOpInterpCtx {
 public:
  AdaptiveAvgPool1DGradOpInterpCtxImpl() = default;
  AdaptiveAvgPool1DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int64_t>& output_size() const { return impl_.output_size(); }
  std::vector<std::int64_t>* mutable_output_size() { return impl_.mutable_output_size(); }
  void set_output_size(const std::vector<std::int64_t>& output_size) { impl_.set_output_size(output_size); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdaptiveAvgPool1DGradOp {
 public:
  AdaptiveAvgPool1DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int64_t>& output_size() const { return internal_->output_size; }
  std::vector<std::int64_t>* mutable_output_size() { return &internal_->output_size; }
  void set_output_size(const std::vector<std::int64_t>& output_size) { internal_->output_size = output_size; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int64_t> output_size;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AdaptiveAvgPool1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AdaptiveAvgPool1DOpInterpCtx() = default;

  virtual const std::vector<std::int64_t>& output_size() const = 0;
  virtual std::vector<std::int64_t>* mutable_output_size() = 0;
  virtual void set_output_size(const std::vector<std::int64_t>& output_size) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AdaptiveAvgPool1DOpInterpCtxImpl : public AdaptiveAvgPool1DOpInterpCtx {
 public:
  AdaptiveAvgPool1DOpInterpCtxImpl() = default;
  AdaptiveAvgPool1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int64_t>& output_size() const { return impl_.output_size(); }
  std::vector<std::int64_t>* mutable_output_size() { return impl_.mutable_output_size(); }
  void set_output_size(const std::vector<std::int64_t>& output_size) { impl_.set_output_size(output_size); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdaptiveAvgPool1DOp {
 public:
  AdaptiveAvgPool1DOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int64_t>& output_size() const { return internal_->output_size; }
  std::vector<std::int64_t>* mutable_output_size() { return &internal_->output_size; }
  void set_output_size(const std::vector<std::int64_t>& output_size) { internal_->output_size = output_size; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int64_t> output_size;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AdaptiveAvgPool2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AdaptiveAvgPool2DGradOpInterpCtx() = default;

  virtual const std::vector<std::int64_t>& output_size() const = 0;
  virtual std::vector<std::int64_t>* mutable_output_size() = 0;
  virtual void set_output_size(const std::vector<std::int64_t>& output_size) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AdaptiveAvgPool2DGradOpInterpCtxImpl : public AdaptiveAvgPool2DGradOpInterpCtx {
 public:
  AdaptiveAvgPool2DGradOpInterpCtxImpl() = default;
  AdaptiveAvgPool2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int64_t>& output_size() const { return impl_.output_size(); }
  std::vector<std::int64_t>* mutable_output_size() { return impl_.mutable_output_size(); }
  void set_output_size(const std::vector<std::int64_t>& output_size) { impl_.set_output_size(output_size); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdaptiveAvgPool2DGradOp {
 public:
  AdaptiveAvgPool2DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int64_t>& output_size() const { return internal_->output_size; }
  std::vector<std::int64_t>* mutable_output_size() { return &internal_->output_size; }
  void set_output_size(const std::vector<std::int64_t>& output_size) { internal_->output_size = output_size; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int64_t> output_size;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AdaptiveAvgPool2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AdaptiveAvgPool2DOpInterpCtx() = default;

  virtual const std::vector<std::int64_t>& output_size() const = 0;
  virtual std::vector<std::int64_t>* mutable_output_size() = 0;
  virtual void set_output_size(const std::vector<std::int64_t>& output_size) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AdaptiveAvgPool2DOpInterpCtxImpl : public AdaptiveAvgPool2DOpInterpCtx {
 public:
  AdaptiveAvgPool2DOpInterpCtxImpl() = default;
  AdaptiveAvgPool2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int64_t>& output_size() const { return impl_.output_size(); }
  std::vector<std::int64_t>* mutable_output_size() { return impl_.mutable_output_size(); }
  void set_output_size(const std::vector<std::int64_t>& output_size) { impl_.set_output_size(output_size); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdaptiveAvgPool2DOp {
 public:
  AdaptiveAvgPool2DOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int64_t>& output_size() const { return internal_->output_size; }
  std::vector<std::int64_t>* mutable_output_size() { return &internal_->output_size; }
  void set_output_size(const std::vector<std::int64_t>& output_size) { internal_->output_size = output_size; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int64_t> output_size;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AdaptiveAvgPool3DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AdaptiveAvgPool3DGradOpInterpCtx() = default;

  virtual const std::vector<std::int64_t>& output_size() const = 0;
  virtual std::vector<std::int64_t>* mutable_output_size() = 0;
  virtual void set_output_size(const std::vector<std::int64_t>& output_size) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AdaptiveAvgPool3DGradOpInterpCtxImpl : public AdaptiveAvgPool3DGradOpInterpCtx {
 public:
  AdaptiveAvgPool3DGradOpInterpCtxImpl() = default;
  AdaptiveAvgPool3DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int64_t>& output_size() const { return impl_.output_size(); }
  std::vector<std::int64_t>* mutable_output_size() { return impl_.mutable_output_size(); }
  void set_output_size(const std::vector<std::int64_t>& output_size) { impl_.set_output_size(output_size); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdaptiveAvgPool3DGradOp {
 public:
  AdaptiveAvgPool3DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int64_t>& output_size() const { return internal_->output_size; }
  std::vector<std::int64_t>* mutable_output_size() { return &internal_->output_size; }
  void set_output_size(const std::vector<std::int64_t>& output_size) { internal_->output_size = output_size; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int64_t> output_size;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AdaptiveAvgPool3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AdaptiveAvgPool3DOpInterpCtx() = default;

  virtual const std::vector<std::int64_t>& output_size() const = 0;
  virtual std::vector<std::int64_t>* mutable_output_size() = 0;
  virtual void set_output_size(const std::vector<std::int64_t>& output_size) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AdaptiveAvgPool3DOpInterpCtxImpl : public AdaptiveAvgPool3DOpInterpCtx {
 public:
  AdaptiveAvgPool3DOpInterpCtxImpl() = default;
  AdaptiveAvgPool3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int64_t>& output_size() const { return impl_.output_size(); }
  std::vector<std::int64_t>* mutable_output_size() { return impl_.mutable_output_size(); }
  void set_output_size(const std::vector<std::int64_t>& output_size) { impl_.set_output_size(output_size); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdaptiveAvgPool3DOp {
 public:
  AdaptiveAvgPool3DOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int64_t>& output_size() const { return internal_->output_size; }
  std::vector<std::int64_t>* mutable_output_size() { return &internal_->output_size; }
  void set_output_size(const std::vector<std::int64_t>& output_size) { internal_->output_size = output_size; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int64_t> output_size;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AddNOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AddNOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AddNOpInterpCtxImpl : public AddNOpInterpCtx {
 public:
  AddNOpInterpCtxImpl() = default;
  AddNOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AddNOp {
 public:
  AddNOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AffineGridGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AffineGridGradOpInterpCtx() = default;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const Shape& size() const = 0;
  virtual Shape* mutable_size() = 0;
  virtual void set_size(const Shape& size) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AffineGridGradOpInterpCtxImpl : public AffineGridGradOpInterpCtx {
 public:
  AffineGridGradOpInterpCtxImpl() = default;
  AffineGridGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& align_corners() const { return impl_.align_corners(); }
  bool* mutable_align_corners() { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) { impl_.set_align_corners(align_corners); }
  
  const Shape& size() const { return impl_.size(); }
  Shape* mutable_size() { return impl_.mutable_size(); }
  void set_size(const Shape& size) { impl_.set_size(size); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AffineGridGradOp {
 public:
  AffineGridGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }
  
  const Shape& size() const { return internal_->size; }
  Shape* mutable_size() { return &internal_->size; }
  void set_size(const Shape& size) { internal_->size = size; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool align_corners = false;
    Shape size;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AffineGridOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AffineGridOpInterpCtx() = default;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const Shape& size() const = 0;
  virtual Shape* mutable_size() = 0;
  virtual void set_size(const Shape& size) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AffineGridOpInterpCtxImpl : public AffineGridOpInterpCtx {
 public:
  AffineGridOpInterpCtxImpl() = default;
  AffineGridOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& align_corners() const { return impl_.align_corners(); }
  bool* mutable_align_corners() { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) { impl_.set_align_corners(align_corners); }
  
  const Shape& size() const { return impl_.size(); }
  Shape* mutable_size() { return impl_.mutable_size(); }
  void set_size(const Shape& size) { impl_.set_size(size); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AffineGridOp {
 public:
  AffineGridOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }
  
  const Shape& size() const { return internal_->size; }
  Shape* mutable_size() { return &internal_->size; }
  void set_size(const Shape& size) { internal_->size = size; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool align_corners = false;
    Shape size;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AmpWhiteIdentityOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AmpWhiteIdentityOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AmpWhiteIdentityOpInterpCtxImpl : public AmpWhiteIdentityOpInterpCtx {
 public:
  AmpWhiteIdentityOpInterpCtxImpl() = default;
  AmpWhiteIdentityOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AmpWhiteIdentityOp {
 public:
  AmpWhiteIdentityOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ArangeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ArangeOpInterpCtx() = default;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const double& float_delta() const = 0;
  virtual double* mutable_float_delta() = 0;
  virtual void set_float_delta(const double& float_delta) = 0;

  virtual const double& float_limit() const = 0;
  virtual double* mutable_float_limit() = 0;
  virtual void set_float_limit(const double& float_limit) = 0;

  virtual const double& float_start() const = 0;
  virtual double* mutable_float_start() = 0;
  virtual void set_float_start(const double& float_start) = 0;

  virtual const int64_t& integer_delta() const = 0;
  virtual int64_t* mutable_integer_delta() = 0;
  virtual void set_integer_delta(const int64_t& integer_delta) = 0;

  virtual const int64_t& integer_limit() const = 0;
  virtual int64_t* mutable_integer_limit() = 0;
  virtual void set_integer_limit(const int64_t& integer_limit) = 0;

  virtual const int64_t& integer_start() const = 0;
  virtual int64_t* mutable_integer_start() = 0;
  virtual void set_integer_start(const int64_t& integer_start) = 0;

  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ArangeOpInterpCtxImpl : public ArangeOpInterpCtx {
 public:
  ArangeOpInterpCtxImpl() = default;
  ArangeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const DataType& dtype() const { return impl_.dtype(); }
  DataType* mutable_dtype() { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) { impl_.set_dtype(dtype); }
  
  const double& float_delta() const { return impl_.float_delta(); }
  double* mutable_float_delta() { return impl_.mutable_float_delta(); }
  void set_float_delta(const double& float_delta) { impl_.set_float_delta(float_delta); }
  
  const double& float_limit() const { return impl_.float_limit(); }
  double* mutable_float_limit() { return impl_.mutable_float_limit(); }
  void set_float_limit(const double& float_limit) { impl_.set_float_limit(float_limit); }
  
  const double& float_start() const { return impl_.float_start(); }
  double* mutable_float_start() { return impl_.mutable_float_start(); }
  void set_float_start(const double& float_start) { impl_.set_float_start(float_start); }
  
  const int64_t& integer_delta() const { return impl_.integer_delta(); }
  int64_t* mutable_integer_delta() { return impl_.mutable_integer_delta(); }
  void set_integer_delta(const int64_t& integer_delta) { impl_.set_integer_delta(integer_delta); }
  
  const int64_t& integer_limit() const { return impl_.integer_limit(); }
  int64_t* mutable_integer_limit() { return impl_.mutable_integer_limit(); }
  void set_integer_limit(const int64_t& integer_limit) { impl_.set_integer_limit(integer_limit); }
  
  const int64_t& integer_start() const { return impl_.integer_start(); }
  int64_t* mutable_integer_start() { return impl_.mutable_integer_start(); }
  void set_integer_start(const int64_t& integer_start) { impl_.set_integer_start(integer_start); }
  
  const std::vector<std::string>& nd_sbp() const { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { impl_.set_nd_sbp(nd_sbp); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ArangeOp {
 public:
  ArangeOp() : internal_(std::make_shared<Internal>()) {}
  
  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }
  
  const double& float_delta() const { return internal_->float_delta; }
  double* mutable_float_delta() { return &internal_->float_delta; }
  void set_float_delta(const double& float_delta) { internal_->float_delta = float_delta; }
  
  const double& float_limit() const { return internal_->float_limit; }
  double* mutable_float_limit() { return &internal_->float_limit; }
  void set_float_limit(const double& float_limit) { internal_->float_limit = float_limit; }
  
  const double& float_start() const { return internal_->float_start; }
  double* mutable_float_start() { return &internal_->float_start; }
  void set_float_start(const double& float_start) { internal_->float_start = float_start; }
  
  const int64_t& integer_delta() const { return internal_->integer_delta; }
  int64_t* mutable_integer_delta() { return &internal_->integer_delta; }
  void set_integer_delta(const int64_t& integer_delta) { internal_->integer_delta = integer_delta; }
  
  const int64_t& integer_limit() const { return internal_->integer_limit; }
  int64_t* mutable_integer_limit() { return &internal_->integer_limit; }
  void set_integer_limit(const int64_t& integer_limit) { internal_->integer_limit = integer_limit; }
  
  const int64_t& integer_start() const { return internal_->integer_start; }
  int64_t* mutable_integer_start() { return &internal_->integer_start; }
  void set_integer_start(const int64_t& integer_start) { internal_->integer_start = integer_start; }
  
  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    DataType dtype;
    double float_delta = 0.;
    double float_limit = 0.;
    double float_start = 0.;
    int64_t integer_delta = 0;
    int64_t integer_limit = 0;
    int64_t integer_start = 0;
    std::vector<std::string> nd_sbp;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ArgSortOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ArgSortOpInterpCtx() = default;

  virtual const std::string& direction() const = 0;
  virtual std::string* mutable_direction() = 0;
  virtual void set_direction(const std::string& direction) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ArgSortOpInterpCtxImpl : public ArgSortOpInterpCtx {
 public:
  ArgSortOpInterpCtxImpl() = default;
  ArgSortOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& direction() const { return impl_.direction(); }
  std::string* mutable_direction() { return impl_.mutable_direction(); }
  void set_direction(const std::string& direction) { impl_.set_direction(direction); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ArgSortOp {
 public:
  ArgSortOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& direction() const { return internal_->direction; }
  std::string* mutable_direction() { return &internal_->direction; }
  void set_direction(const std::string& direction) { internal_->direction = direction; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string direction;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ArgmaxOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ArgmaxOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ArgmaxOpInterpCtxImpl : public ArgmaxOpInterpCtx {
 public:
  ArgmaxOpInterpCtxImpl() = default;
  ArgmaxOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ArgmaxOp {
 public:
  ArgmaxOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ArgwhereOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ArgwhereOpInterpCtx() = default;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ArgwhereOpInterpCtxImpl : public ArgwhereOpInterpCtx {
 public:
  ArgwhereOpInterpCtxImpl() = default;
  ArgwhereOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const DataType& dtype() const { return impl_.dtype(); }
  DataType* mutable_dtype() { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) { impl_.set_dtype(dtype); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ArgwhereOp {
 public:
  ArgwhereOp() : internal_(std::make_shared<Internal>()) {}
  
  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    DataType dtype;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AsinGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AsinGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AsinGradOpInterpCtxImpl : public AsinGradOpInterpCtx {
 public:
  AsinGradOpInterpCtxImpl() = default;
  AsinGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AsinGradOp {
 public:
  AsinGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AsinOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AsinOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AsinOpInterpCtxImpl : public AsinOpInterpCtx {
 public:
  AsinOpInterpCtxImpl() = default;
  AsinOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AsinOp {
 public:
  AsinOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AsinhGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AsinhGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AsinhGradOpInterpCtxImpl : public AsinhGradOpInterpCtx {
 public:
  AsinhGradOpInterpCtxImpl() = default;
  AsinhGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AsinhGradOp {
 public:
  AsinhGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AsinhOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AsinhOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AsinhOpInterpCtxImpl : public AsinhOpInterpCtx {
 public:
  AsinhOpInterpCtxImpl() = default;
  AsinhOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AsinhOp {
 public:
  AsinhOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AssignIfNotOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AssignIfNotOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AssignIfNotOpInterpCtxImpl : public AssignIfNotOpInterpCtx {
 public:
  AssignIfNotOpInterpCtxImpl() = default;
  AssignIfNotOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AssignIfNotOp {
 public:
  AssignIfNotOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AssignIfOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AssignIfOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AssignIfOpInterpCtxImpl : public AssignIfOpInterpCtx {
 public:
  AssignIfOpInterpCtxImpl() = default;
  AssignIfOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AssignIfOp {
 public:
  AssignIfOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AssignOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AssignOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AssignOpInterpCtxImpl : public AssignOpInterpCtx {
 public:
  AssignOpInterpCtxImpl() = default;
  AssignOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AssignOp {
 public:
  AssignOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class Atan2OpInterpCtx : public OpInterpCtx {
 public:
  virtual ~Atan2OpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class Atan2OpInterpCtxImpl : public Atan2OpInterpCtx {
 public:
  Atan2OpInterpCtxImpl() = default;
  Atan2OpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Atan2Op {
 public:
  Atan2Op() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class Atan2XGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~Atan2XGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class Atan2XGradOpInterpCtxImpl : public Atan2XGradOpInterpCtx {
 public:
  Atan2XGradOpInterpCtxImpl() = default;
  Atan2XGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Atan2XGradOp {
 public:
  Atan2XGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class Atan2YGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~Atan2YGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class Atan2YGradOpInterpCtxImpl : public Atan2YGradOpInterpCtx {
 public:
  Atan2YGradOpInterpCtxImpl() = default;
  Atan2YGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Atan2YGradOp {
 public:
  Atan2YGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AtanGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AtanGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AtanGradOpInterpCtxImpl : public AtanGradOpInterpCtx {
 public:
  AtanGradOpInterpCtxImpl() = default;
  AtanGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AtanGradOp {
 public:
  AtanGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AtanOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AtanOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AtanOpInterpCtxImpl : public AtanOpInterpCtx {
 public:
  AtanOpInterpCtxImpl() = default;
  AtanOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AtanOp {
 public:
  AtanOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AtanhGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AtanhGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AtanhGradOpInterpCtxImpl : public AtanhGradOpInterpCtx {
 public:
  AtanhGradOpInterpCtxImpl() = default;
  AtanhGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AtanhGradOp {
 public:
  AtanhGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AtanhOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AtanhOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AtanhOpInterpCtxImpl : public AtanhOpInterpCtx {
 public:
  AtanhOpInterpCtxImpl() = default;
  AtanhOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AtanhOp {
 public:
  AtanhOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AvgPool1DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AvgPool1DGradOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int32_t>& padding) = 0;

  virtual const std::vector<std::int32_t>& stride() const = 0;
  virtual std::vector<std::int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<std::int32_t>& stride) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AvgPool1DGradOpInterpCtxImpl : public AvgPool1DGradOpInterpCtx {
 public:
  AvgPool1DGradOpInterpCtxImpl() = default;
  AvgPool1DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const bool& count_include_pad() const { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) { impl_.set_count_include_pad(count_include_pad); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const int64_t& divisor_override() const { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) { impl_.set_divisor_override(divisor_override); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& padding() const { return impl_.padding(); }
  std::vector<std::int32_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int32_t>& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& stride() const { return impl_.stride(); }
  std::vector<std::int32_t>* mutable_stride() { return impl_.mutable_stride(); }
  void set_stride(const std::vector<std::int32_t>& stride) { impl_.set_stride(stride); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AvgPool1DGradOp {
 public:
  AvgPool1DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) { internal_->count_include_pad = count_include_pad; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) { internal_->divisor_override = divisor_override; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& padding() const { return internal_->padding; }
  std::vector<std::int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int32_t>& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& stride() const { return internal_->stride; }
  std::vector<std::int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<std::int32_t>& stride) { internal_->stride = stride; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    bool count_include_pad;
    std::string data_format;
    int64_t divisor_override;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> padding;
    std::vector<std::int32_t> stride;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AvgPool1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AvgPool1DOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int32_t>& padding) = 0;

  virtual const std::vector<std::int32_t>& stride() const = 0;
  virtual std::vector<std::int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<std::int32_t>& stride) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AvgPool1DOpInterpCtxImpl : public AvgPool1DOpInterpCtx {
 public:
  AvgPool1DOpInterpCtxImpl() = default;
  AvgPool1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const bool& count_include_pad() const { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) { impl_.set_count_include_pad(count_include_pad); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const int64_t& divisor_override() const { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) { impl_.set_divisor_override(divisor_override); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& padding() const { return impl_.padding(); }
  std::vector<std::int32_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int32_t>& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& stride() const { return impl_.stride(); }
  std::vector<std::int32_t>* mutable_stride() { return impl_.mutable_stride(); }
  void set_stride(const std::vector<std::int32_t>& stride) { impl_.set_stride(stride); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AvgPool1DOp {
 public:
  AvgPool1DOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) { internal_->count_include_pad = count_include_pad; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) { internal_->divisor_override = divisor_override; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& padding() const { return internal_->padding; }
  std::vector<std::int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int32_t>& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& stride() const { return internal_->stride; }
  std::vector<std::int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<std::int32_t>& stride) { internal_->stride = stride; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    bool count_include_pad;
    std::string data_format;
    int64_t divisor_override;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> padding;
    std::vector<std::int32_t> stride;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AvgPool2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AvgPool2DGradOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int32_t>& padding) = 0;

  virtual const std::vector<std::int32_t>& stride() const = 0;
  virtual std::vector<std::int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<std::int32_t>& stride) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AvgPool2DGradOpInterpCtxImpl : public AvgPool2DGradOpInterpCtx {
 public:
  AvgPool2DGradOpInterpCtxImpl() = default;
  AvgPool2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const bool& count_include_pad() const { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) { impl_.set_count_include_pad(count_include_pad); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const int64_t& divisor_override() const { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) { impl_.set_divisor_override(divisor_override); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& padding() const { return impl_.padding(); }
  std::vector<std::int32_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int32_t>& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& stride() const { return impl_.stride(); }
  std::vector<std::int32_t>* mutable_stride() { return impl_.mutable_stride(); }
  void set_stride(const std::vector<std::int32_t>& stride) { impl_.set_stride(stride); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AvgPool2DGradOp {
 public:
  AvgPool2DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) { internal_->count_include_pad = count_include_pad; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) { internal_->divisor_override = divisor_override; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& padding() const { return internal_->padding; }
  std::vector<std::int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int32_t>& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& stride() const { return internal_->stride; }
  std::vector<std::int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<std::int32_t>& stride) { internal_->stride = stride; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    bool count_include_pad;
    std::string data_format;
    int64_t divisor_override;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> padding;
    std::vector<std::int32_t> stride;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AvgPool2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AvgPool2DOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int32_t>& padding) = 0;

  virtual const std::vector<std::int32_t>& stride() const = 0;
  virtual std::vector<std::int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<std::int32_t>& stride) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AvgPool2DOpInterpCtxImpl : public AvgPool2DOpInterpCtx {
 public:
  AvgPool2DOpInterpCtxImpl() = default;
  AvgPool2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const bool& count_include_pad() const { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) { impl_.set_count_include_pad(count_include_pad); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const int64_t& divisor_override() const { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) { impl_.set_divisor_override(divisor_override); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& padding() const { return impl_.padding(); }
  std::vector<std::int32_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int32_t>& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& stride() const { return impl_.stride(); }
  std::vector<std::int32_t>* mutable_stride() { return impl_.mutable_stride(); }
  void set_stride(const std::vector<std::int32_t>& stride) { impl_.set_stride(stride); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AvgPool2DOp {
 public:
  AvgPool2DOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) { internal_->count_include_pad = count_include_pad; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) { internal_->divisor_override = divisor_override; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& padding() const { return internal_->padding; }
  std::vector<std::int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int32_t>& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& stride() const { return internal_->stride; }
  std::vector<std::int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<std::int32_t>& stride) { internal_->stride = stride; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    bool count_include_pad;
    std::string data_format;
    int64_t divisor_override;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> padding;
    std::vector<std::int32_t> stride;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AvgPool3DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AvgPool3DGradOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int32_t>& padding) = 0;

  virtual const std::vector<std::int32_t>& stride() const = 0;
  virtual std::vector<std::int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<std::int32_t>& stride) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AvgPool3DGradOpInterpCtxImpl : public AvgPool3DGradOpInterpCtx {
 public:
  AvgPool3DGradOpInterpCtxImpl() = default;
  AvgPool3DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const bool& count_include_pad() const { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) { impl_.set_count_include_pad(count_include_pad); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const int64_t& divisor_override() const { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) { impl_.set_divisor_override(divisor_override); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& padding() const { return impl_.padding(); }
  std::vector<std::int32_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int32_t>& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& stride() const { return impl_.stride(); }
  std::vector<std::int32_t>* mutable_stride() { return impl_.mutable_stride(); }
  void set_stride(const std::vector<std::int32_t>& stride) { impl_.set_stride(stride); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AvgPool3DGradOp {
 public:
  AvgPool3DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) { internal_->count_include_pad = count_include_pad; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) { internal_->divisor_override = divisor_override; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& padding() const { return internal_->padding; }
  std::vector<std::int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int32_t>& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& stride() const { return internal_->stride; }
  std::vector<std::int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<std::int32_t>& stride) { internal_->stride = stride; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    bool count_include_pad;
    std::string data_format;
    int64_t divisor_override;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> padding;
    std::vector<std::int32_t> stride;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class AvgPool3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~AvgPool3DOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int32_t>& padding) = 0;

  virtual const std::vector<std::int32_t>& stride() const = 0;
  virtual std::vector<std::int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<std::int32_t>& stride) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class AvgPool3DOpInterpCtxImpl : public AvgPool3DOpInterpCtx {
 public:
  AvgPool3DOpInterpCtxImpl() = default;
  AvgPool3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const bool& count_include_pad() const { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) { impl_.set_count_include_pad(count_include_pad); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const int64_t& divisor_override() const { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) { impl_.set_divisor_override(divisor_override); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& padding() const { return impl_.padding(); }
  std::vector<std::int32_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int32_t>& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& stride() const { return impl_.stride(); }
  std::vector<std::int32_t>* mutable_stride() { return impl_.mutable_stride(); }
  void set_stride(const std::vector<std::int32_t>& stride) { impl_.set_stride(stride); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AvgPool3DOp {
 public:
  AvgPool3DOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) { internal_->count_include_pad = count_include_pad; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) { internal_->divisor_override = divisor_override; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& padding() const { return internal_->padding; }
  std::vector<std::int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int32_t>& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& stride() const { return internal_->stride; }
  std::vector<std::int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<std::int32_t>& stride) { internal_->stride = stride; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    bool count_include_pad;
    std::string data_format;
    int64_t divisor_override;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> padding;
    std::vector<std::int32_t> stride;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BatchGatherOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BatchGatherOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BatchGatherOpInterpCtxImpl : public BatchGatherOpInterpCtx {
 public:
  BatchGatherOpInterpCtxImpl() = default;
  BatchGatherOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BatchGatherOp {
 public:
  BatchGatherOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BatchMatmulOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BatchMatmulOpInterpCtx() = default;

  virtual const double& alpha() const = 0;
  virtual double* mutable_alpha() = 0;
  virtual void set_alpha(const double& alpha) = 0;

  virtual const bool& transpose_a() const = 0;
  virtual bool* mutable_transpose_a() = 0;
  virtual void set_transpose_a(const bool& transpose_a) = 0;

  virtual const bool& transpose_b() const = 0;
  virtual bool* mutable_transpose_b() = 0;
  virtual void set_transpose_b(const bool& transpose_b) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BatchMatmulOpInterpCtxImpl : public BatchMatmulOpInterpCtx {
 public:
  BatchMatmulOpInterpCtxImpl() = default;
  BatchMatmulOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& alpha() const { return impl_.alpha(); }
  double* mutable_alpha() { return impl_.mutable_alpha(); }
  void set_alpha(const double& alpha) { impl_.set_alpha(alpha); }
  
  const bool& transpose_a() const { return impl_.transpose_a(); }
  bool* mutable_transpose_a() { return impl_.mutable_transpose_a(); }
  void set_transpose_a(const bool& transpose_a) { impl_.set_transpose_a(transpose_a); }
  
  const bool& transpose_b() const { return impl_.transpose_b(); }
  bool* mutable_transpose_b() { return impl_.mutable_transpose_b(); }
  void set_transpose_b(const bool& transpose_b) { impl_.set_transpose_b(transpose_b); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BatchMatmulOp {
 public:
  BatchMatmulOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& alpha() const { return internal_->alpha; }
  double* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const double& alpha) { internal_->alpha = alpha; }
  
  const bool& transpose_a() const { return internal_->transpose_a; }
  bool* mutable_transpose_a() { return &internal_->transpose_a; }
  void set_transpose_a(const bool& transpose_a) { internal_->transpose_a = transpose_a; }
  
  const bool& transpose_b() const { return internal_->transpose_b; }
  bool* mutable_transpose_b() { return &internal_->transpose_b; }
  void set_transpose_b(const bool& transpose_b) { internal_->transpose_b = transpose_b; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double alpha = 1.;
    bool transpose_a = false;
    bool transpose_b = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BernoulliOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BernoulliOpInterpCtx() = default;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const bool& has_seed() const = 0;
  virtual bool* mutable_has_seed() = 0;
  virtual void set_has_seed(const bool& has_seed) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BernoulliOpInterpCtxImpl : public BernoulliOpInterpCtx {
 public:
  BernoulliOpInterpCtxImpl() = default;
  BernoulliOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const DataType& dtype() const { return impl_.dtype(); }
  DataType* mutable_dtype() { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) { impl_.set_dtype(dtype); }
  
  const bool& has_seed() const { return impl_.has_seed(); }
  bool* mutable_has_seed() { return impl_.mutable_has_seed(); }
  void set_has_seed(const bool& has_seed) { impl_.set_has_seed(has_seed); }
  
  const int64_t& seed() const { return impl_.seed(); }
  int64_t* mutable_seed() { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) { impl_.set_seed(seed); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BernoulliOp {
 public:
  BernoulliOp() : internal_(std::make_shared<Internal>()) {}
  
  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }
  
  const bool& has_seed() const { return internal_->has_seed; }
  bool* mutable_has_seed() { return &internal_->has_seed; }
  void set_has_seed(const bool& has_seed) { internal_->has_seed = has_seed; }
  
  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    DataType dtype;
    bool has_seed = false;
    int64_t seed = -1;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BiasAddOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BiasAddOpInterpCtx() = default;

  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BiasAddOpInterpCtxImpl : public BiasAddOpInterpCtx {
 public:
  BiasAddOpInterpCtxImpl() = default;
  BiasAddOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& axis() const { return impl_.axis(); }
  int32_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) { impl_.set_axis(axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BiasAddOp {
 public:
  BiasAddOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t axis = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BinaryCrossEntropyGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BinaryCrossEntropyGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BinaryCrossEntropyGradOpInterpCtxImpl : public BinaryCrossEntropyGradOpInterpCtx {
 public:
  BinaryCrossEntropyGradOpInterpCtxImpl() = default;
  BinaryCrossEntropyGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BinaryCrossEntropyGradOp {
 public:
  BinaryCrossEntropyGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BinaryCrossEntropyOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BinaryCrossEntropyOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BinaryCrossEntropyOpInterpCtxImpl : public BinaryCrossEntropyOpInterpCtx {
 public:
  BinaryCrossEntropyOpInterpCtxImpl() = default;
  BinaryCrossEntropyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BinaryCrossEntropyOp {
 public:
  BinaryCrossEntropyOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BinaryCrossEntropyWithLogitsGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BinaryCrossEntropyWithLogitsGradOpInterpCtx() = default;

  virtual const bool& has_pos_weight() const = 0;
  virtual bool* mutable_has_pos_weight() = 0;
  virtual void set_has_pos_weight(const bool& has_pos_weight) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BinaryCrossEntropyWithLogitsGradOpInterpCtxImpl : public BinaryCrossEntropyWithLogitsGradOpInterpCtx {
 public:
  BinaryCrossEntropyWithLogitsGradOpInterpCtxImpl() = default;
  BinaryCrossEntropyWithLogitsGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& has_pos_weight() const { return impl_.has_pos_weight(); }
  bool* mutable_has_pos_weight() { return impl_.mutable_has_pos_weight(); }
  void set_has_pos_weight(const bool& has_pos_weight) { impl_.set_has_pos_weight(has_pos_weight); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BinaryCrossEntropyWithLogitsGradOp {
 public:
  BinaryCrossEntropyWithLogitsGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& has_pos_weight() const { return internal_->has_pos_weight; }
  bool* mutable_has_pos_weight() { return &internal_->has_pos_weight; }
  void set_has_pos_weight(const bool& has_pos_weight) { internal_->has_pos_weight = has_pos_weight; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool has_pos_weight = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BinaryCrossEntropyWithLogitsOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BinaryCrossEntropyWithLogitsOpInterpCtx() = default;

  virtual const bool& has_pos_weight() const = 0;
  virtual bool* mutable_has_pos_weight() = 0;
  virtual void set_has_pos_weight(const bool& has_pos_weight) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BinaryCrossEntropyWithLogitsOpInterpCtxImpl : public BinaryCrossEntropyWithLogitsOpInterpCtx {
 public:
  BinaryCrossEntropyWithLogitsOpInterpCtxImpl() = default;
  BinaryCrossEntropyWithLogitsOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& has_pos_weight() const { return impl_.has_pos_weight(); }
  bool* mutable_has_pos_weight() { return impl_.mutable_has_pos_weight(); }
  void set_has_pos_weight(const bool& has_pos_weight) { impl_.set_has_pos_weight(has_pos_weight); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BinaryCrossEntropyWithLogitsOp {
 public:
  BinaryCrossEntropyWithLogitsOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& has_pos_weight() const { return internal_->has_pos_weight; }
  bool* mutable_has_pos_weight() { return &internal_->has_pos_weight; }
  void set_has_pos_weight(const bool& has_pos_weight) { internal_->has_pos_weight = has_pos_weight; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool has_pos_weight = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastAddOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastAddOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastAddOpInterpCtxImpl : public BroadcastAddOpInterpCtx {
 public:
  BroadcastAddOpInterpCtxImpl() = default;
  BroadcastAddOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastAddOp {
 public:
  BroadcastAddOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastDivGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastDivGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastDivGradOpInterpCtxImpl : public BroadcastDivGradOpInterpCtx {
 public:
  BroadcastDivGradOpInterpCtxImpl() = default;
  BroadcastDivGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastDivGradOp {
 public:
  BroadcastDivGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastDivOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastDivOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastDivOpInterpCtxImpl : public BroadcastDivOpInterpCtx {
 public:
  BroadcastDivOpInterpCtxImpl() = default;
  BroadcastDivOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastDivOp {
 public:
  BroadcastDivOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastEqualOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastEqualOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastEqualOpInterpCtxImpl : public BroadcastEqualOpInterpCtx {
 public:
  BroadcastEqualOpInterpCtxImpl() = default;
  BroadcastEqualOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastEqualOp {
 public:
  BroadcastEqualOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastFloorModOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastFloorModOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastFloorModOpInterpCtxImpl : public BroadcastFloorModOpInterpCtx {
 public:
  BroadcastFloorModOpInterpCtxImpl() = default;
  BroadcastFloorModOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastFloorModOp {
 public:
  BroadcastFloorModOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastFmodOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastFmodOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastFmodOpInterpCtxImpl : public BroadcastFmodOpInterpCtx {
 public:
  BroadcastFmodOpInterpCtxImpl() = default;
  BroadcastFmodOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastFmodOp {
 public:
  BroadcastFmodOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastGreaterEqualOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastGreaterEqualOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastGreaterEqualOpInterpCtxImpl : public BroadcastGreaterEqualOpInterpCtx {
 public:
  BroadcastGreaterEqualOpInterpCtxImpl() = default;
  BroadcastGreaterEqualOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastGreaterEqualOp {
 public:
  BroadcastGreaterEqualOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastGreaterOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastGreaterOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastGreaterOpInterpCtxImpl : public BroadcastGreaterOpInterpCtx {
 public:
  BroadcastGreaterOpInterpCtxImpl() = default;
  BroadcastGreaterOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastGreaterOp {
 public:
  BroadcastGreaterOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastLessEqualOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastLessEqualOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastLessEqualOpInterpCtxImpl : public BroadcastLessEqualOpInterpCtx {
 public:
  BroadcastLessEqualOpInterpCtxImpl() = default;
  BroadcastLessEqualOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastLessEqualOp {
 public:
  BroadcastLessEqualOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastLessOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastLessOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastLessOpInterpCtxImpl : public BroadcastLessOpInterpCtx {
 public:
  BroadcastLessOpInterpCtxImpl() = default;
  BroadcastLessOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastLessOp {
 public:
  BroadcastLessOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastLikeOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& broadcast_axes() const = 0;
  virtual std::vector<std::int32_t>* mutable_broadcast_axes() = 0;
  virtual void set_broadcast_axes(const std::vector<std::int32_t>& broadcast_axes) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastLikeOpInterpCtxImpl : public BroadcastLikeOpInterpCtx {
 public:
  BroadcastLikeOpInterpCtxImpl() = default;
  BroadcastLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& broadcast_axes() const { return impl_.broadcast_axes(); }
  std::vector<std::int32_t>* mutable_broadcast_axes() { return impl_.mutable_broadcast_axes(); }
  void set_broadcast_axes(const std::vector<std::int32_t>& broadcast_axes) { impl_.set_broadcast_axes(broadcast_axes); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastLikeOp {
 public:
  BroadcastLikeOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& broadcast_axes() const { return internal_->broadcast_axes; }
  std::vector<std::int32_t>* mutable_broadcast_axes() { return &internal_->broadcast_axes; }
  void set_broadcast_axes(const std::vector<std::int32_t>& broadcast_axes) { internal_->broadcast_axes = broadcast_axes; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> broadcast_axes;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastLogicalAndOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastLogicalAndOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastLogicalAndOpInterpCtxImpl : public BroadcastLogicalAndOpInterpCtx {
 public:
  BroadcastLogicalAndOpInterpCtxImpl() = default;
  BroadcastLogicalAndOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastLogicalAndOp {
 public:
  BroadcastLogicalAndOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastLogicalOrOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastLogicalOrOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastLogicalOrOpInterpCtxImpl : public BroadcastLogicalOrOpInterpCtx {
 public:
  BroadcastLogicalOrOpInterpCtxImpl() = default;
  BroadcastLogicalOrOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastLogicalOrOp {
 public:
  BroadcastLogicalOrOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastLogicalXorOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastLogicalXorOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastLogicalXorOpInterpCtxImpl : public BroadcastLogicalXorOpInterpCtx {
 public:
  BroadcastLogicalXorOpInterpCtxImpl() = default;
  BroadcastLogicalXorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastLogicalXorOp {
 public:
  BroadcastLogicalXorOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastMatmulGradBOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastMatmulGradBOpInterpCtx() = default;

  virtual const double& alpha() const = 0;
  virtual double* mutable_alpha() = 0;
  virtual void set_alpha(const double& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastMatmulGradBOpInterpCtxImpl : public BroadcastMatmulGradBOpInterpCtx {
 public:
  BroadcastMatmulGradBOpInterpCtxImpl() = default;
  BroadcastMatmulGradBOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& alpha() const { return impl_.alpha(); }
  double* mutable_alpha() { return impl_.mutable_alpha(); }
  void set_alpha(const double& alpha) { impl_.set_alpha(alpha); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastMatmulGradBOp {
 public:
  BroadcastMatmulGradBOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& alpha() const { return internal_->alpha; }
  double* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const double& alpha) { internal_->alpha = alpha; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double alpha = 1.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastMatmulOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastMatmulOpInterpCtx() = default;

  virtual const double& alpha() const = 0;
  virtual double* mutable_alpha() = 0;
  virtual void set_alpha(const double& alpha) = 0;

  virtual const bool& transpose_a() const = 0;
  virtual bool* mutable_transpose_a() = 0;
  virtual void set_transpose_a(const bool& transpose_a) = 0;

  virtual const bool& transpose_b() const = 0;
  virtual bool* mutable_transpose_b() = 0;
  virtual void set_transpose_b(const bool& transpose_b) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastMatmulOpInterpCtxImpl : public BroadcastMatmulOpInterpCtx {
 public:
  BroadcastMatmulOpInterpCtxImpl() = default;
  BroadcastMatmulOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& alpha() const { return impl_.alpha(); }
  double* mutable_alpha() { return impl_.mutable_alpha(); }
  void set_alpha(const double& alpha) { impl_.set_alpha(alpha); }
  
  const bool& transpose_a() const { return impl_.transpose_a(); }
  bool* mutable_transpose_a() { return impl_.mutable_transpose_a(); }
  void set_transpose_a(const bool& transpose_a) { impl_.set_transpose_a(transpose_a); }
  
  const bool& transpose_b() const { return impl_.transpose_b(); }
  bool* mutable_transpose_b() { return impl_.mutable_transpose_b(); }
  void set_transpose_b(const bool& transpose_b) { impl_.set_transpose_b(transpose_b); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastMatmulOp {
 public:
  BroadcastMatmulOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& alpha() const { return internal_->alpha; }
  double* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const double& alpha) { internal_->alpha = alpha; }
  
  const bool& transpose_a() const { return internal_->transpose_a; }
  bool* mutable_transpose_a() { return &internal_->transpose_a; }
  void set_transpose_a(const bool& transpose_a) { internal_->transpose_a = transpose_a; }
  
  const bool& transpose_b() const { return internal_->transpose_b; }
  bool* mutable_transpose_b() { return &internal_->transpose_b; }
  void set_transpose_b(const bool& transpose_b) { internal_->transpose_b = transpose_b; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double alpha = 1.;
    bool transpose_a = false;
    bool transpose_b = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastMaximumOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastMaximumOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastMaximumOpInterpCtxImpl : public BroadcastMaximumOpInterpCtx {
 public:
  BroadcastMaximumOpInterpCtxImpl() = default;
  BroadcastMaximumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastMaximumOp {
 public:
  BroadcastMaximumOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastMinimumOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastMinimumOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastMinimumOpInterpCtxImpl : public BroadcastMinimumOpInterpCtx {
 public:
  BroadcastMinimumOpInterpCtxImpl() = default;
  BroadcastMinimumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastMinimumOp {
 public:
  BroadcastMinimumOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastMulOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastMulOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastMulOpInterpCtxImpl : public BroadcastMulOpInterpCtx {
 public:
  BroadcastMulOpInterpCtxImpl() = default;
  BroadcastMulOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastMulOp {
 public:
  BroadcastMulOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastNotEqualOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastNotEqualOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastNotEqualOpInterpCtxImpl : public BroadcastNotEqualOpInterpCtx {
 public:
  BroadcastNotEqualOpInterpCtxImpl() = default;
  BroadcastNotEqualOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastNotEqualOp {
 public:
  BroadcastNotEqualOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastPowOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastPowOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastPowOpInterpCtxImpl : public BroadcastPowOpInterpCtx {
 public:
  BroadcastPowOpInterpCtxImpl() = default;
  BroadcastPowOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastPowOp {
 public:
  BroadcastPowOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastPowXGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastPowXGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastPowXGradOpInterpCtxImpl : public BroadcastPowXGradOpInterpCtx {
 public:
  BroadcastPowXGradOpInterpCtxImpl() = default;
  BroadcastPowXGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastPowXGradOp {
 public:
  BroadcastPowXGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastPowYGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastPowYGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastPowYGradOpInterpCtxImpl : public BroadcastPowYGradOpInterpCtx {
 public:
  BroadcastPowYGradOpInterpCtxImpl() = default;
  BroadcastPowYGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastPowYGradOp {
 public:
  BroadcastPowYGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class BroadcastSubOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~BroadcastSubOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class BroadcastSubOpInterpCtxImpl : public BroadcastSubOpInterpCtx {
 public:
  BroadcastSubOpInterpCtxImpl() = default;
  BroadcastSubOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastSubOp {
 public:
  BroadcastSubOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class COCOReaderOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~COCOReaderOpInterpCtx() = default;

  virtual const std::string& annotation_file() const = 0;
  virtual std::string* mutable_annotation_file() = 0;
  virtual void set_annotation_file(const std::string& annotation_file) = 0;

  virtual const int64_t& batch_size() const = 0;
  virtual int64_t* mutable_batch_size() = 0;
  virtual void set_batch_size(const int64_t& batch_size) = 0;

  virtual const bool& group_by_ratio() const = 0;
  virtual bool* mutable_group_by_ratio() = 0;
  virtual void set_group_by_ratio(const bool& group_by_ratio) = 0;

  virtual const std::string& image_dir() const = 0;
  virtual std::string* mutable_image_dir() = 0;
  virtual void set_image_dir(const std::string& image_dir) = 0;

  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  virtual const int64_t& random_seed() const = 0;
  virtual int64_t* mutable_random_seed() = 0;
  virtual void set_random_seed(const int64_t& random_seed) = 0;

  virtual const bool& remove_images_without_annotations() const = 0;
  virtual bool* mutable_remove_images_without_annotations() = 0;
  virtual void set_remove_images_without_annotations(const bool& remove_images_without_annotations) = 0;

  virtual const int64_t& session_id() const = 0;
  virtual int64_t* mutable_session_id() = 0;
  virtual void set_session_id(const int64_t& session_id) = 0;

  virtual const bool& shuffle_after_epoch() const = 0;
  virtual bool* mutable_shuffle_after_epoch() = 0;
  virtual void set_shuffle_after_epoch(const bool& shuffle_after_epoch) = 0;

  virtual const bool& stride_partition() const = 0;
  virtual bool* mutable_stride_partition() = 0;
  virtual void set_stride_partition(const bool& stride_partition) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class COCOReaderOpInterpCtxImpl : public COCOReaderOpInterpCtx {
 public:
  COCOReaderOpInterpCtxImpl() = default;
  COCOReaderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& annotation_file() const { return impl_.annotation_file(); }
  std::string* mutable_annotation_file() { return impl_.mutable_annotation_file(); }
  void set_annotation_file(const std::string& annotation_file) { impl_.set_annotation_file(annotation_file); }
  
  const int64_t& batch_size() const { return impl_.batch_size(); }
  int64_t* mutable_batch_size() { return impl_.mutable_batch_size(); }
  void set_batch_size(const int64_t& batch_size) { impl_.set_batch_size(batch_size); }
  
  const bool& group_by_ratio() const { return impl_.group_by_ratio(); }
  bool* mutable_group_by_ratio() { return impl_.mutable_group_by_ratio(); }
  void set_group_by_ratio(const bool& group_by_ratio) { impl_.set_group_by_ratio(group_by_ratio); }
  
  const std::string& image_dir() const { return impl_.image_dir(); }
  std::string* mutable_image_dir() { return impl_.mutable_image_dir(); }
  void set_image_dir(const std::string& image_dir) { impl_.set_image_dir(image_dir); }
  
  const std::vector<std::string>& nd_sbp() const { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { impl_.set_nd_sbp(nd_sbp); }
  
  const int64_t& random_seed() const { return impl_.random_seed(); }
  int64_t* mutable_random_seed() { return impl_.mutable_random_seed(); }
  void set_random_seed(const int64_t& random_seed) { impl_.set_random_seed(random_seed); }
  
  const bool& remove_images_without_annotations() const { return impl_.remove_images_without_annotations(); }
  bool* mutable_remove_images_without_annotations() { return impl_.mutable_remove_images_without_annotations(); }
  void set_remove_images_without_annotations(const bool& remove_images_without_annotations) { impl_.set_remove_images_without_annotations(remove_images_without_annotations); }
  
  const int64_t& session_id() const { return impl_.session_id(); }
  int64_t* mutable_session_id() { return impl_.mutable_session_id(); }
  void set_session_id(const int64_t& session_id) { impl_.set_session_id(session_id); }
  
  const bool& shuffle_after_epoch() const { return impl_.shuffle_after_epoch(); }
  bool* mutable_shuffle_after_epoch() { return impl_.mutable_shuffle_after_epoch(); }
  void set_shuffle_after_epoch(const bool& shuffle_after_epoch) { impl_.set_shuffle_after_epoch(shuffle_after_epoch); }
  
  const bool& stride_partition() const { return impl_.stride_partition(); }
  bool* mutable_stride_partition() { return impl_.mutable_stride_partition(); }
  void set_stride_partition(const bool& stride_partition) { impl_.set_stride_partition(stride_partition); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class COCOReaderOp {
 public:
  COCOReaderOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& annotation_file() const { return internal_->annotation_file; }
  std::string* mutable_annotation_file() { return &internal_->annotation_file; }
  void set_annotation_file(const std::string& annotation_file) { internal_->annotation_file = annotation_file; }
  
  const int64_t& batch_size() const { return internal_->batch_size; }
  int64_t* mutable_batch_size() { return &internal_->batch_size; }
  void set_batch_size(const int64_t& batch_size) { internal_->batch_size = batch_size; }
  
  const bool& group_by_ratio() const { return internal_->group_by_ratio; }
  bool* mutable_group_by_ratio() { return &internal_->group_by_ratio; }
  void set_group_by_ratio(const bool& group_by_ratio) { internal_->group_by_ratio = group_by_ratio; }
  
  const std::string& image_dir() const { return internal_->image_dir; }
  std::string* mutable_image_dir() { return &internal_->image_dir; }
  void set_image_dir(const std::string& image_dir) { internal_->image_dir = image_dir; }
  
  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }
  
  const int64_t& random_seed() const { return internal_->random_seed; }
  int64_t* mutable_random_seed() { return &internal_->random_seed; }
  void set_random_seed(const int64_t& random_seed) { internal_->random_seed = random_seed; }
  
  const bool& remove_images_without_annotations() const { return internal_->remove_images_without_annotations; }
  bool* mutable_remove_images_without_annotations() { return &internal_->remove_images_without_annotations; }
  void set_remove_images_without_annotations(const bool& remove_images_without_annotations) { internal_->remove_images_without_annotations = remove_images_without_annotations; }
  
  const int64_t& session_id() const { return internal_->session_id; }
  int64_t* mutable_session_id() { return &internal_->session_id; }
  void set_session_id(const int64_t& session_id) { internal_->session_id = session_id; }
  
  const bool& shuffle_after_epoch() const { return internal_->shuffle_after_epoch; }
  bool* mutable_shuffle_after_epoch() { return &internal_->shuffle_after_epoch; }
  void set_shuffle_after_epoch(const bool& shuffle_after_epoch) { internal_->shuffle_after_epoch = shuffle_after_epoch; }
  
  const bool& stride_partition() const { return internal_->stride_partition; }
  bool* mutable_stride_partition() { return &internal_->stride_partition; }
  void set_stride_partition(const bool& stride_partition) { internal_->stride_partition = stride_partition; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string annotation_file;
    int64_t batch_size = 0;
    bool group_by_ratio = true;
    std::string image_dir;
    std::vector<std::string> nd_sbp;
    int64_t random_seed = -1;
    bool remove_images_without_annotations = true;
    int64_t session_id = 0;
    bool shuffle_after_epoch = true;
    bool stride_partition = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CastLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CastLikeOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CastLikeOpInterpCtxImpl : public CastLikeOpInterpCtx {
 public:
  CastLikeOpInterpCtxImpl() = default;
  CastLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CastLikeOp {
 public:
  CastLikeOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CastOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CastOpInterpCtx() = default;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CastOpInterpCtxImpl : public CastOpInterpCtx {
 public:
  CastOpInterpCtxImpl() = default;
  CastOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const DataType& dtype() const { return impl_.dtype(); }
  DataType* mutable_dtype() { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) { impl_.set_dtype(dtype); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CastOp {
 public:
  CastOp() : internal_(std::make_shared<Internal>()) {}
  
  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    DataType dtype;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CastToStaticShapeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CastToStaticShapeOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CastToStaticShapeOpInterpCtxImpl : public CastToStaticShapeOpInterpCtx {
 public:
  CastToStaticShapeOpInterpCtxImpl() = default;
  CastToStaticShapeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CastToStaticShapeOp {
 public:
  CastToStaticShapeOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CastToTickOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CastToTickOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CastToTickOpInterpCtxImpl : public CastToTickOpInterpCtx {
 public:
  CastToTickOpInterpCtxImpl() = default;
  CastToTickOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CastToTickOp {
 public:
  CastToTickOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CategoricalOrdinalEncodeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CategoricalOrdinalEncodeOpInterpCtx() = default;

  virtual const bool& hash_precomputed() const = 0;
  virtual bool* mutable_hash_precomputed() = 0;
  virtual void set_hash_precomputed(const bool& hash_precomputed) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CategoricalOrdinalEncodeOpInterpCtxImpl : public CategoricalOrdinalEncodeOpInterpCtx {
 public:
  CategoricalOrdinalEncodeOpInterpCtxImpl() = default;
  CategoricalOrdinalEncodeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& hash_precomputed() const { return impl_.hash_precomputed(); }
  bool* mutable_hash_precomputed() { return impl_.mutable_hash_precomputed(); }
  void set_hash_precomputed(const bool& hash_precomputed) { impl_.set_hash_precomputed(hash_precomputed); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CategoricalOrdinalEncodeOp {
 public:
  CategoricalOrdinalEncodeOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& hash_precomputed() const { return internal_->hash_precomputed; }
  bool* mutable_hash_precomputed() { return &internal_->hash_precomputed; }
  void set_hash_precomputed(const bool& hash_precomputed) { internal_->hash_precomputed = hash_precomputed; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool hash_precomputed = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CcreluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CcreluGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CcreluGradOpInterpCtxImpl : public CcreluGradOpInterpCtx {
 public:
  CcreluGradOpInterpCtxImpl() = default;
  CcreluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CcreluGradOp {
 public:
  CcreluGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CcreluOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CcreluOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CcreluOpInterpCtxImpl : public CcreluOpInterpCtx {
 public:
  CcreluOpInterpCtxImpl() = default;
  CcreluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CcreluOp {
 public:
  CcreluOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CeilGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CeilGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CeilGradOpInterpCtxImpl : public CeilGradOpInterpCtx {
 public:
  CeilGradOpInterpCtxImpl() = default;
  CeilGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CeilGradOp {
 public:
  CeilGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CeilOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CeilOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CeilOpInterpCtxImpl : public CeilOpInterpCtx {
 public:
  CeilOpInterpCtxImpl() = default;
  CeilOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CeilOp {
 public:
  CeilOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CeluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CeluGradOpInterpCtx() = default;

  virtual const double& alpha() const = 0;
  virtual double* mutable_alpha() = 0;
  virtual void set_alpha(const double& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CeluGradOpInterpCtxImpl : public CeluGradOpInterpCtx {
 public:
  CeluGradOpInterpCtxImpl() = default;
  CeluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& alpha() const { return impl_.alpha(); }
  double* mutable_alpha() { return impl_.mutable_alpha(); }
  void set_alpha(const double& alpha) { impl_.set_alpha(alpha); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CeluGradOp {
 public:
  CeluGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& alpha() const { return internal_->alpha; }
  double* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const double& alpha) { internal_->alpha = alpha; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double alpha = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CeluOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CeluOpInterpCtx() = default;

  virtual const double& alpha() const = 0;
  virtual double* mutable_alpha() = 0;
  virtual void set_alpha(const double& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CeluOpInterpCtxImpl : public CeluOpInterpCtx {
 public:
  CeluOpInterpCtxImpl() = default;
  CeluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& alpha() const { return impl_.alpha(); }
  double* mutable_alpha() { return impl_.mutable_alpha(); }
  void set_alpha(const double& alpha) { impl_.set_alpha(alpha); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CeluOp {
 public:
  CeluOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& alpha() const { return internal_->alpha; }
  double* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const double& alpha) { internal_->alpha = alpha; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double alpha = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ClipByScalarGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ClipByScalarGradOpInterpCtx() = default;

  virtual const double& floating_max() const = 0;
  virtual double* mutable_floating_max() = 0;
  virtual void set_floating_max(const double& floating_max) = 0;

  virtual const double& floating_min() const = 0;
  virtual double* mutable_floating_min() = 0;
  virtual void set_floating_min(const double& floating_min) = 0;

  virtual const int64_t& integral_max() const = 0;
  virtual int64_t* mutable_integral_max() = 0;
  virtual void set_integral_max(const int64_t& integral_max) = 0;

  virtual const int64_t& integral_min() const = 0;
  virtual int64_t* mutable_integral_min() = 0;
  virtual void set_integral_min(const int64_t& integral_min) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ClipByScalarGradOpInterpCtxImpl : public ClipByScalarGradOpInterpCtx {
 public:
  ClipByScalarGradOpInterpCtxImpl() = default;
  ClipByScalarGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& floating_max() const { return impl_.floating_max(); }
  double* mutable_floating_max() { return impl_.mutable_floating_max(); }
  void set_floating_max(const double& floating_max) { impl_.set_floating_max(floating_max); }
  
  const double& floating_min() const { return impl_.floating_min(); }
  double* mutable_floating_min() { return impl_.mutable_floating_min(); }
  void set_floating_min(const double& floating_min) { impl_.set_floating_min(floating_min); }
  
  const int64_t& integral_max() const { return impl_.integral_max(); }
  int64_t* mutable_integral_max() { return impl_.mutable_integral_max(); }
  void set_integral_max(const int64_t& integral_max) { impl_.set_integral_max(integral_max); }
  
  const int64_t& integral_min() const { return impl_.integral_min(); }
  int64_t* mutable_integral_min() { return impl_.mutable_integral_min(); }
  void set_integral_min(const int64_t& integral_min) { impl_.set_integral_min(integral_min); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ClipByScalarGradOp {
 public:
  ClipByScalarGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& floating_max() const { return internal_->floating_max; }
  double* mutable_floating_max() { return &internal_->floating_max; }
  void set_floating_max(const double& floating_max) { internal_->floating_max = floating_max; }
  
  const double& floating_min() const { return internal_->floating_min; }
  double* mutable_floating_min() { return &internal_->floating_min; }
  void set_floating_min(const double& floating_min) { internal_->floating_min = floating_min; }
  
  const int64_t& integral_max() const { return internal_->integral_max; }
  int64_t* mutable_integral_max() { return &internal_->integral_max; }
  void set_integral_max(const int64_t& integral_max) { internal_->integral_max = integral_max; }
  
  const int64_t& integral_min() const { return internal_->integral_min; }
  int64_t* mutable_integral_min() { return &internal_->integral_min; }
  void set_integral_min(const int64_t& integral_min) { internal_->integral_min = integral_min; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double floating_max = 0.;
    double floating_min = 0.;
    int64_t integral_max = 0;
    int64_t integral_min = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ClipByScalarMaxGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ClipByScalarMaxGradOpInterpCtx() = default;

  virtual const double& floating_max() const = 0;
  virtual double* mutable_floating_max() = 0;
  virtual void set_floating_max(const double& floating_max) = 0;

  virtual const int64_t& integral_max() const = 0;
  virtual int64_t* mutable_integral_max() = 0;
  virtual void set_integral_max(const int64_t& integral_max) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ClipByScalarMaxGradOpInterpCtxImpl : public ClipByScalarMaxGradOpInterpCtx {
 public:
  ClipByScalarMaxGradOpInterpCtxImpl() = default;
  ClipByScalarMaxGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& floating_max() const { return impl_.floating_max(); }
  double* mutable_floating_max() { return impl_.mutable_floating_max(); }
  void set_floating_max(const double& floating_max) { impl_.set_floating_max(floating_max); }
  
  const int64_t& integral_max() const { return impl_.integral_max(); }
  int64_t* mutable_integral_max() { return impl_.mutable_integral_max(); }
  void set_integral_max(const int64_t& integral_max) { impl_.set_integral_max(integral_max); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ClipByScalarMaxGradOp {
 public:
  ClipByScalarMaxGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& floating_max() const { return internal_->floating_max; }
  double* mutable_floating_max() { return &internal_->floating_max; }
  void set_floating_max(const double& floating_max) { internal_->floating_max = floating_max; }
  
  const int64_t& integral_max() const { return internal_->integral_max; }
  int64_t* mutable_integral_max() { return &internal_->integral_max; }
  void set_integral_max(const int64_t& integral_max) { internal_->integral_max = integral_max; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double floating_max = 0.;
    int64_t integral_max = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ClipByScalarMaxOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ClipByScalarMaxOpInterpCtx() = default;

  virtual const double& floating_max() const = 0;
  virtual double* mutable_floating_max() = 0;
  virtual void set_floating_max(const double& floating_max) = 0;

  virtual const int64_t& integral_max() const = 0;
  virtual int64_t* mutable_integral_max() = 0;
  virtual void set_integral_max(const int64_t& integral_max) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ClipByScalarMaxOpInterpCtxImpl : public ClipByScalarMaxOpInterpCtx {
 public:
  ClipByScalarMaxOpInterpCtxImpl() = default;
  ClipByScalarMaxOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& floating_max() const { return impl_.floating_max(); }
  double* mutable_floating_max() { return impl_.mutable_floating_max(); }
  void set_floating_max(const double& floating_max) { impl_.set_floating_max(floating_max); }
  
  const int64_t& integral_max() const { return impl_.integral_max(); }
  int64_t* mutable_integral_max() { return impl_.mutable_integral_max(); }
  void set_integral_max(const int64_t& integral_max) { impl_.set_integral_max(integral_max); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ClipByScalarMaxOp {
 public:
  ClipByScalarMaxOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& floating_max() const { return internal_->floating_max; }
  double* mutable_floating_max() { return &internal_->floating_max; }
  void set_floating_max(const double& floating_max) { internal_->floating_max = floating_max; }
  
  const int64_t& integral_max() const { return internal_->integral_max; }
  int64_t* mutable_integral_max() { return &internal_->integral_max; }
  void set_integral_max(const int64_t& integral_max) { internal_->integral_max = integral_max; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double floating_max = 0.;
    int64_t integral_max = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ClipByScalarMinGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ClipByScalarMinGradOpInterpCtx() = default;

  virtual const double& floating_min() const = 0;
  virtual double* mutable_floating_min() = 0;
  virtual void set_floating_min(const double& floating_min) = 0;

  virtual const int64_t& integral_min() const = 0;
  virtual int64_t* mutable_integral_min() = 0;
  virtual void set_integral_min(const int64_t& integral_min) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ClipByScalarMinGradOpInterpCtxImpl : public ClipByScalarMinGradOpInterpCtx {
 public:
  ClipByScalarMinGradOpInterpCtxImpl() = default;
  ClipByScalarMinGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& floating_min() const { return impl_.floating_min(); }
  double* mutable_floating_min() { return impl_.mutable_floating_min(); }
  void set_floating_min(const double& floating_min) { impl_.set_floating_min(floating_min); }
  
  const int64_t& integral_min() const { return impl_.integral_min(); }
  int64_t* mutable_integral_min() { return impl_.mutable_integral_min(); }
  void set_integral_min(const int64_t& integral_min) { impl_.set_integral_min(integral_min); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ClipByScalarMinGradOp {
 public:
  ClipByScalarMinGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& floating_min() const { return internal_->floating_min; }
  double* mutable_floating_min() { return &internal_->floating_min; }
  void set_floating_min(const double& floating_min) { internal_->floating_min = floating_min; }
  
  const int64_t& integral_min() const { return internal_->integral_min; }
  int64_t* mutable_integral_min() { return &internal_->integral_min; }
  void set_integral_min(const int64_t& integral_min) { internal_->integral_min = integral_min; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double floating_min = 0.;
    int64_t integral_min = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ClipByScalarMinOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ClipByScalarMinOpInterpCtx() = default;

  virtual const double& floating_min() const = 0;
  virtual double* mutable_floating_min() = 0;
  virtual void set_floating_min(const double& floating_min) = 0;

  virtual const int64_t& integral_min() const = 0;
  virtual int64_t* mutable_integral_min() = 0;
  virtual void set_integral_min(const int64_t& integral_min) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ClipByScalarMinOpInterpCtxImpl : public ClipByScalarMinOpInterpCtx {
 public:
  ClipByScalarMinOpInterpCtxImpl() = default;
  ClipByScalarMinOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& floating_min() const { return impl_.floating_min(); }
  double* mutable_floating_min() { return impl_.mutable_floating_min(); }
  void set_floating_min(const double& floating_min) { impl_.set_floating_min(floating_min); }
  
  const int64_t& integral_min() const { return impl_.integral_min(); }
  int64_t* mutable_integral_min() { return impl_.mutable_integral_min(); }
  void set_integral_min(const int64_t& integral_min) { impl_.set_integral_min(integral_min); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ClipByScalarMinOp {
 public:
  ClipByScalarMinOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& floating_min() const { return internal_->floating_min; }
  double* mutable_floating_min() { return &internal_->floating_min; }
  void set_floating_min(const double& floating_min) { internal_->floating_min = floating_min; }
  
  const int64_t& integral_min() const { return internal_->integral_min; }
  int64_t* mutable_integral_min() { return &internal_->integral_min; }
  void set_integral_min(const int64_t& integral_min) { internal_->integral_min = integral_min; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double floating_min = 0.;
    int64_t integral_min = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ClipByScalarOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ClipByScalarOpInterpCtx() = default;

  virtual const double& floating_max() const = 0;
  virtual double* mutable_floating_max() = 0;
  virtual void set_floating_max(const double& floating_max) = 0;

  virtual const double& floating_min() const = 0;
  virtual double* mutable_floating_min() = 0;
  virtual void set_floating_min(const double& floating_min) = 0;

  virtual const int64_t& integral_max() const = 0;
  virtual int64_t* mutable_integral_max() = 0;
  virtual void set_integral_max(const int64_t& integral_max) = 0;

  virtual const int64_t& integral_min() const = 0;
  virtual int64_t* mutable_integral_min() = 0;
  virtual void set_integral_min(const int64_t& integral_min) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ClipByScalarOpInterpCtxImpl : public ClipByScalarOpInterpCtx {
 public:
  ClipByScalarOpInterpCtxImpl() = default;
  ClipByScalarOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& floating_max() const { return impl_.floating_max(); }
  double* mutable_floating_max() { return impl_.mutable_floating_max(); }
  void set_floating_max(const double& floating_max) { impl_.set_floating_max(floating_max); }
  
  const double& floating_min() const { return impl_.floating_min(); }
  double* mutable_floating_min() { return impl_.mutable_floating_min(); }
  void set_floating_min(const double& floating_min) { impl_.set_floating_min(floating_min); }
  
  const int64_t& integral_max() const { return impl_.integral_max(); }
  int64_t* mutable_integral_max() { return impl_.mutable_integral_max(); }
  void set_integral_max(const int64_t& integral_max) { impl_.set_integral_max(integral_max); }
  
  const int64_t& integral_min() const { return impl_.integral_min(); }
  int64_t* mutable_integral_min() { return impl_.mutable_integral_min(); }
  void set_integral_min(const int64_t& integral_min) { impl_.set_integral_min(integral_min); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ClipByScalarOp {
 public:
  ClipByScalarOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& floating_max() const { return internal_->floating_max; }
  double* mutable_floating_max() { return &internal_->floating_max; }
  void set_floating_max(const double& floating_max) { internal_->floating_max = floating_max; }
  
  const double& floating_min() const { return internal_->floating_min; }
  double* mutable_floating_min() { return &internal_->floating_min; }
  void set_floating_min(const double& floating_min) { internal_->floating_min = floating_min; }
  
  const int64_t& integral_max() const { return internal_->integral_max; }
  int64_t* mutable_integral_max() { return &internal_->integral_max; }
  void set_integral_max(const int64_t& integral_max) { internal_->integral_max = integral_max; }
  
  const int64_t& integral_min() const { return internal_->integral_min; }
  int64_t* mutable_integral_min() { return &internal_->integral_min; }
  void set_integral_min(const int64_t& integral_min) { internal_->integral_min = integral_min; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double floating_max = 0.;
    double floating_min = 0.;
    int64_t integral_max = 0;
    int64_t integral_min = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CoinFlipOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CoinFlipOpInterpCtx() = default;

  virtual const int64_t& batch_size() const = 0;
  virtual int64_t* mutable_batch_size() = 0;
  virtual void set_batch_size(const int64_t& batch_size) = 0;

  virtual const bool& has_seed() const = 0;
  virtual bool* mutable_has_seed() = 0;
  virtual void set_has_seed(const bool& has_seed) = 0;

  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  virtual const float& probability() const = 0;
  virtual float* mutable_probability() = 0;
  virtual void set_probability(const float& probability) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CoinFlipOpInterpCtxImpl : public CoinFlipOpInterpCtx {
 public:
  CoinFlipOpInterpCtxImpl() = default;
  CoinFlipOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& batch_size() const { return impl_.batch_size(); }
  int64_t* mutable_batch_size() { return impl_.mutable_batch_size(); }
  void set_batch_size(const int64_t& batch_size) { impl_.set_batch_size(batch_size); }
  
  const bool& has_seed() const { return impl_.has_seed(); }
  bool* mutable_has_seed() { return impl_.mutable_has_seed(); }
  void set_has_seed(const bool& has_seed) { impl_.set_has_seed(has_seed); }
  
  const std::vector<std::string>& nd_sbp() const { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { impl_.set_nd_sbp(nd_sbp); }
  
  const float& probability() const { return impl_.probability(); }
  float* mutable_probability() { return impl_.mutable_probability(); }
  void set_probability(const float& probability) { impl_.set_probability(probability); }
  
  const int64_t& seed() const { return impl_.seed(); }
  int64_t* mutable_seed() { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) { impl_.set_seed(seed); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CoinFlipOp {
 public:
  CoinFlipOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& batch_size() const { return internal_->batch_size; }
  int64_t* mutable_batch_size() { return &internal_->batch_size; }
  void set_batch_size(const int64_t& batch_size) { internal_->batch_size = batch_size; }
  
  const bool& has_seed() const { return internal_->has_seed; }
  bool* mutable_has_seed() { return &internal_->has_seed; }
  void set_has_seed(const bool& has_seed) { internal_->has_seed = has_seed; }
  
  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }
  
  const float& probability() const { return internal_->probability; }
  float* mutable_probability() { return &internal_->probability; }
  void set_probability(const float& probability) { internal_->probability = probability; }
  
  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t batch_size = 0;
    bool has_seed = false;
    std::vector<std::string> nd_sbp;
    float probability = 0.5;
    int64_t seed = -1;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CombinedMarginLossGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CombinedMarginLossGradOpInterpCtx() = default;

  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  virtual const float& m1() const = 0;
  virtual float* mutable_m1() = 0;
  virtual void set_m1(const float& m1) = 0;

  virtual const float& m2() const = 0;
  virtual float* mutable_m2() = 0;
  virtual void set_m2(const float& m2) = 0;

  virtual const float& m3() const = 0;
  virtual float* mutable_m3() = 0;
  virtual void set_m3(const float& m3) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CombinedMarginLossGradOpInterpCtxImpl : public CombinedMarginLossGradOpInterpCtx {
 public:
  CombinedMarginLossGradOpInterpCtxImpl() = default;
  CombinedMarginLossGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& depth() const { return impl_.depth(); }
  int64_t* mutable_depth() { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) { impl_.set_depth(depth); }
  
  const float& m1() const { return impl_.m1(); }
  float* mutable_m1() { return impl_.mutable_m1(); }
  void set_m1(const float& m1) { impl_.set_m1(m1); }
  
  const float& m2() const { return impl_.m2(); }
  float* mutable_m2() { return impl_.mutable_m2(); }
  void set_m2(const float& m2) { impl_.set_m2(m2); }
  
  const float& m3() const { return impl_.m3(); }
  float* mutable_m3() { return impl_.mutable_m3(); }
  void set_m3(const float& m3) { impl_.set_m3(m3); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CombinedMarginLossGradOp {
 public:
  CombinedMarginLossGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }
  
  const float& m1() const { return internal_->m1; }
  float* mutable_m1() { return &internal_->m1; }
  void set_m1(const float& m1) { internal_->m1 = m1; }
  
  const float& m2() const { return internal_->m2; }
  float* mutable_m2() { return &internal_->m2; }
  void set_m2(const float& m2) { internal_->m2 = m2; }
  
  const float& m3() const { return internal_->m3; }
  float* mutable_m3() { return &internal_->m3; }
  void set_m3(const float& m3) { internal_->m3 = m3; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t depth = 0;
    float m1 = 0.;
    float m2 = 0.;
    float m3 = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CombinedMarginLossOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CombinedMarginLossOpInterpCtx() = default;

  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  virtual const float& m1() const = 0;
  virtual float* mutable_m1() = 0;
  virtual void set_m1(const float& m1) = 0;

  virtual const float& m2() const = 0;
  virtual float* mutable_m2() = 0;
  virtual void set_m2(const float& m2) = 0;

  virtual const float& m3() const = 0;
  virtual float* mutable_m3() = 0;
  virtual void set_m3(const float& m3) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CombinedMarginLossOpInterpCtxImpl : public CombinedMarginLossOpInterpCtx {
 public:
  CombinedMarginLossOpInterpCtxImpl() = default;
  CombinedMarginLossOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& depth() const { return impl_.depth(); }
  int64_t* mutable_depth() { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) { impl_.set_depth(depth); }
  
  const float& m1() const { return impl_.m1(); }
  float* mutable_m1() { return impl_.mutable_m1(); }
  void set_m1(const float& m1) { impl_.set_m1(m1); }
  
  const float& m2() const { return impl_.m2(); }
  float* mutable_m2() { return impl_.mutable_m2(); }
  void set_m2(const float& m2) { impl_.set_m2(m2); }
  
  const float& m3() const { return impl_.m3(); }
  float* mutable_m3() { return impl_.mutable_m3(); }
  void set_m3(const float& m3) { impl_.set_m3(m3); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CombinedMarginLossOp {
 public:
  CombinedMarginLossOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }
  
  const float& m1() const { return internal_->m1; }
  float* mutable_m1() { return &internal_->m1; }
  void set_m1(const float& m1) { internal_->m1 = m1; }
  
  const float& m2() const { return internal_->m2; }
  float* mutable_m2() { return &internal_->m2; }
  void set_m2(const float& m2) { internal_->m2 = m2; }
  
  const float& m3() const { return internal_->m3; }
  float* mutable_m3() { return &internal_->m3; }
  void set_m3(const float& m3) { internal_->m3 = m3; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t depth = 0;
    float m1 = 0.;
    float m2 = 0.;
    float m3 = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ConcatOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ConcatOpInterpCtx() = default;

  virtual const int64_t& axis() const = 0;
  virtual int64_t* mutable_axis() = 0;
  virtual void set_axis(const int64_t& axis) = 0;

  virtual const int64_t& max_dim_size() const = 0;
  virtual int64_t* mutable_max_dim_size() = 0;
  virtual void set_max_dim_size(const int64_t& max_dim_size) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ConcatOpInterpCtxImpl : public ConcatOpInterpCtx {
 public:
  ConcatOpInterpCtxImpl() = default;
  ConcatOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& axis() const { return impl_.axis(); }
  int64_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int64_t& axis) { impl_.set_axis(axis); }
  
  const int64_t& max_dim_size() const { return impl_.max_dim_size(); }
  int64_t* mutable_max_dim_size() { return impl_.mutable_max_dim_size(); }
  void set_max_dim_size(const int64_t& max_dim_size) { impl_.set_max_dim_size(max_dim_size); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConcatOp {
 public:
  ConcatOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& axis() const { return internal_->axis; }
  int64_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int64_t& axis) { internal_->axis = axis; }
  
  const int64_t& max_dim_size() const { return internal_->max_dim_size; }
  int64_t* mutable_max_dim_size() { return &internal_->max_dim_size; }
  void set_max_dim_size(const int64_t& max_dim_size) { internal_->max_dim_size = max_dim_size; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t axis = 0;
    int64_t max_dim_size = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ConstantOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ConstantOpInterpCtx() = default;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const double& floating_value() const = 0;
  virtual double* mutable_floating_value() = 0;
  virtual void set_floating_value(const double& floating_value) = 0;

  virtual const int64_t& integer_value() const = 0;
  virtual int64_t* mutable_integer_value() = 0;
  virtual void set_integer_value(const int64_t& integer_value) = 0;

  virtual const bool& is_floating_value() const = 0;
  virtual bool* mutable_is_floating_value() = 0;
  virtual void set_is_floating_value(const bool& is_floating_value) = 0;

  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ConstantOpInterpCtxImpl : public ConstantOpInterpCtx {
 public:
  ConstantOpInterpCtxImpl() = default;
  ConstantOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const DataType& dtype() const { return impl_.dtype(); }
  DataType* mutable_dtype() { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) { impl_.set_dtype(dtype); }
  
  const double& floating_value() const { return impl_.floating_value(); }
  double* mutable_floating_value() { return impl_.mutable_floating_value(); }
  void set_floating_value(const double& floating_value) { impl_.set_floating_value(floating_value); }
  
  const int64_t& integer_value() const { return impl_.integer_value(); }
  int64_t* mutable_integer_value() { return impl_.mutable_integer_value(); }
  void set_integer_value(const int64_t& integer_value) { impl_.set_integer_value(integer_value); }
  
  const bool& is_floating_value() const { return impl_.is_floating_value(); }
  bool* mutable_is_floating_value() { return impl_.mutable_is_floating_value(); }
  void set_is_floating_value(const bool& is_floating_value) { impl_.set_is_floating_value(is_floating_value); }
  
  const std::vector<std::string>& nd_sbp() const { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { impl_.set_nd_sbp(nd_sbp); }
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConstantOp {
 public:
  ConstantOp() : internal_(std::make_shared<Internal>()) {}
  
  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }
  
  const double& floating_value() const { return internal_->floating_value; }
  double* mutable_floating_value() { return &internal_->floating_value; }
  void set_floating_value(const double& floating_value) { internal_->floating_value = floating_value; }
  
  const int64_t& integer_value() const { return internal_->integer_value; }
  int64_t* mutable_integer_value() { return &internal_->integer_value; }
  void set_integer_value(const int64_t& integer_value) { internal_->integer_value = integer_value; }
  
  const bool& is_floating_value() const { return internal_->is_floating_value; }
  bool* mutable_is_floating_value() { return &internal_->is_floating_value; }
  void set_is_floating_value(const bool& is_floating_value) { internal_->is_floating_value = is_floating_value; }
  
  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    DataType dtype;
    double floating_value = 0.;
    int64_t integer_value = 0;
    bool is_floating_value = false;
    std::vector<std::string> nd_sbp;
    Shape shape;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ConstantPad1DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ConstantPad1DGradOpInterpCtx() = default;

  virtual const double& floating_value() const = 0;
  virtual double* mutable_floating_value() = 0;
  virtual void set_floating_value(const double& floating_value) = 0;

  virtual const int64_t& integral_value() const = 0;
  virtual int64_t* mutable_integral_value() = 0;
  virtual void set_integral_value(const int64_t& integral_value) = 0;

  virtual const std::vector<std::int64_t>& padding() const = 0;
  virtual std::vector<std::int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int64_t>& padding) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ConstantPad1DGradOpInterpCtxImpl : public ConstantPad1DGradOpInterpCtx {
 public:
  ConstantPad1DGradOpInterpCtxImpl() = default;
  ConstantPad1DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& floating_value() const { return impl_.floating_value(); }
  double* mutable_floating_value() { return impl_.mutable_floating_value(); }
  void set_floating_value(const double& floating_value) { impl_.set_floating_value(floating_value); }
  
  const int64_t& integral_value() const { return impl_.integral_value(); }
  int64_t* mutable_integral_value() { return impl_.mutable_integral_value(); }
  void set_integral_value(const int64_t& integral_value) { impl_.set_integral_value(integral_value); }
  
  const std::vector<std::int64_t>& padding() const { return impl_.padding(); }
  std::vector<std::int64_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int64_t>& padding) { impl_.set_padding(padding); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConstantPad1DGradOp {
 public:
  ConstantPad1DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& floating_value() const { return internal_->floating_value; }
  double* mutable_floating_value() { return &internal_->floating_value; }
  void set_floating_value(const double& floating_value) { internal_->floating_value = floating_value; }
  
  const int64_t& integral_value() const { return internal_->integral_value; }
  int64_t* mutable_integral_value() { return &internal_->integral_value; }
  void set_integral_value(const int64_t& integral_value) { internal_->integral_value = integral_value; }
  
  const std::vector<std::int64_t>& padding() const { return internal_->padding; }
  std::vector<std::int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int64_t>& padding) { internal_->padding = padding; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double floating_value = 0.;
    int64_t integral_value = 0;
    std::vector<std::int64_t> padding;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ConstantPad1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ConstantPad1DOpInterpCtx() = default;

  virtual const double& floating_value() const = 0;
  virtual double* mutable_floating_value() = 0;
  virtual void set_floating_value(const double& floating_value) = 0;

  virtual const int64_t& integral_value() const = 0;
  virtual int64_t* mutable_integral_value() = 0;
  virtual void set_integral_value(const int64_t& integral_value) = 0;

  virtual const std::vector<std::int64_t>& padding() const = 0;
  virtual std::vector<std::int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int64_t>& padding) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ConstantPad1DOpInterpCtxImpl : public ConstantPad1DOpInterpCtx {
 public:
  ConstantPad1DOpInterpCtxImpl() = default;
  ConstantPad1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& floating_value() const { return impl_.floating_value(); }
  double* mutable_floating_value() { return impl_.mutable_floating_value(); }
  void set_floating_value(const double& floating_value) { impl_.set_floating_value(floating_value); }
  
  const int64_t& integral_value() const { return impl_.integral_value(); }
  int64_t* mutable_integral_value() { return impl_.mutable_integral_value(); }
  void set_integral_value(const int64_t& integral_value) { impl_.set_integral_value(integral_value); }
  
  const std::vector<std::int64_t>& padding() const { return impl_.padding(); }
  std::vector<std::int64_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int64_t>& padding) { impl_.set_padding(padding); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConstantPad1DOp {
 public:
  ConstantPad1DOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& floating_value() const { return internal_->floating_value; }
  double* mutable_floating_value() { return &internal_->floating_value; }
  void set_floating_value(const double& floating_value) { internal_->floating_value = floating_value; }
  
  const int64_t& integral_value() const { return internal_->integral_value; }
  int64_t* mutable_integral_value() { return &internal_->integral_value; }
  void set_integral_value(const int64_t& integral_value) { internal_->integral_value = integral_value; }
  
  const std::vector<std::int64_t>& padding() const { return internal_->padding; }
  std::vector<std::int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int64_t>& padding) { internal_->padding = padding; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double floating_value = 0.;
    int64_t integral_value = 0;
    std::vector<std::int64_t> padding;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ConstantPad2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ConstantPad2DGradOpInterpCtx() = default;

  virtual const double& floating_value() const = 0;
  virtual double* mutable_floating_value() = 0;
  virtual void set_floating_value(const double& floating_value) = 0;

  virtual const int64_t& integral_value() const = 0;
  virtual int64_t* mutable_integral_value() = 0;
  virtual void set_integral_value(const int64_t& integral_value) = 0;

  virtual const std::vector<std::int64_t>& padding() const = 0;
  virtual std::vector<std::int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int64_t>& padding) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ConstantPad2DGradOpInterpCtxImpl : public ConstantPad2DGradOpInterpCtx {
 public:
  ConstantPad2DGradOpInterpCtxImpl() = default;
  ConstantPad2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& floating_value() const { return impl_.floating_value(); }
  double* mutable_floating_value() { return impl_.mutable_floating_value(); }
  void set_floating_value(const double& floating_value) { impl_.set_floating_value(floating_value); }
  
  const int64_t& integral_value() const { return impl_.integral_value(); }
  int64_t* mutable_integral_value() { return impl_.mutable_integral_value(); }
  void set_integral_value(const int64_t& integral_value) { impl_.set_integral_value(integral_value); }
  
  const std::vector<std::int64_t>& padding() const { return impl_.padding(); }
  std::vector<std::int64_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int64_t>& padding) { impl_.set_padding(padding); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConstantPad2DGradOp {
 public:
  ConstantPad2DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& floating_value() const { return internal_->floating_value; }
  double* mutable_floating_value() { return &internal_->floating_value; }
  void set_floating_value(const double& floating_value) { internal_->floating_value = floating_value; }
  
  const int64_t& integral_value() const { return internal_->integral_value; }
  int64_t* mutable_integral_value() { return &internal_->integral_value; }
  void set_integral_value(const int64_t& integral_value) { internal_->integral_value = integral_value; }
  
  const std::vector<std::int64_t>& padding() const { return internal_->padding; }
  std::vector<std::int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int64_t>& padding) { internal_->padding = padding; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double floating_value = 0.;
    int64_t integral_value = 0;
    std::vector<std::int64_t> padding;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ConstantPad2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ConstantPad2DOpInterpCtx() = default;

  virtual const double& floating_value() const = 0;
  virtual double* mutable_floating_value() = 0;
  virtual void set_floating_value(const double& floating_value) = 0;

  virtual const int64_t& integral_value() const = 0;
  virtual int64_t* mutable_integral_value() = 0;
  virtual void set_integral_value(const int64_t& integral_value) = 0;

  virtual const std::vector<std::int64_t>& padding() const = 0;
  virtual std::vector<std::int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int64_t>& padding) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ConstantPad2DOpInterpCtxImpl : public ConstantPad2DOpInterpCtx {
 public:
  ConstantPad2DOpInterpCtxImpl() = default;
  ConstantPad2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& floating_value() const { return impl_.floating_value(); }
  double* mutable_floating_value() { return impl_.mutable_floating_value(); }
  void set_floating_value(const double& floating_value) { impl_.set_floating_value(floating_value); }
  
  const int64_t& integral_value() const { return impl_.integral_value(); }
  int64_t* mutable_integral_value() { return impl_.mutable_integral_value(); }
  void set_integral_value(const int64_t& integral_value) { impl_.set_integral_value(integral_value); }
  
  const std::vector<std::int64_t>& padding() const { return impl_.padding(); }
  std::vector<std::int64_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int64_t>& padding) { impl_.set_padding(padding); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConstantPad2DOp {
 public:
  ConstantPad2DOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& floating_value() const { return internal_->floating_value; }
  double* mutable_floating_value() { return &internal_->floating_value; }
  void set_floating_value(const double& floating_value) { internal_->floating_value = floating_value; }
  
  const int64_t& integral_value() const { return internal_->integral_value; }
  int64_t* mutable_integral_value() { return &internal_->integral_value; }
  void set_integral_value(const int64_t& integral_value) { internal_->integral_value = integral_value; }
  
  const std::vector<std::int64_t>& padding() const { return internal_->padding; }
  std::vector<std::int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int64_t>& padding) { internal_->padding = padding; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double floating_value = 0.;
    int64_t integral_value = 0;
    std::vector<std::int64_t> padding;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ConstantPad3DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ConstantPad3DGradOpInterpCtx() = default;

  virtual const double& floating_value() const = 0;
  virtual double* mutable_floating_value() = 0;
  virtual void set_floating_value(const double& floating_value) = 0;

  virtual const int64_t& integral_value() const = 0;
  virtual int64_t* mutable_integral_value() = 0;
  virtual void set_integral_value(const int64_t& integral_value) = 0;

  virtual const std::vector<std::int64_t>& padding() const = 0;
  virtual std::vector<std::int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int64_t>& padding) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ConstantPad3DGradOpInterpCtxImpl : public ConstantPad3DGradOpInterpCtx {
 public:
  ConstantPad3DGradOpInterpCtxImpl() = default;
  ConstantPad3DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& floating_value() const { return impl_.floating_value(); }
  double* mutable_floating_value() { return impl_.mutable_floating_value(); }
  void set_floating_value(const double& floating_value) { impl_.set_floating_value(floating_value); }
  
  const int64_t& integral_value() const { return impl_.integral_value(); }
  int64_t* mutable_integral_value() { return impl_.mutable_integral_value(); }
  void set_integral_value(const int64_t& integral_value) { impl_.set_integral_value(integral_value); }
  
  const std::vector<std::int64_t>& padding() const { return impl_.padding(); }
  std::vector<std::int64_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int64_t>& padding) { impl_.set_padding(padding); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConstantPad3DGradOp {
 public:
  ConstantPad3DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& floating_value() const { return internal_->floating_value; }
  double* mutable_floating_value() { return &internal_->floating_value; }
  void set_floating_value(const double& floating_value) { internal_->floating_value = floating_value; }
  
  const int64_t& integral_value() const { return internal_->integral_value; }
  int64_t* mutable_integral_value() { return &internal_->integral_value; }
  void set_integral_value(const int64_t& integral_value) { internal_->integral_value = integral_value; }
  
  const std::vector<std::int64_t>& padding() const { return internal_->padding; }
  std::vector<std::int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int64_t>& padding) { internal_->padding = padding; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double floating_value = 0.;
    int64_t integral_value = 0;
    std::vector<std::int64_t> padding;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ConstantPad3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ConstantPad3DOpInterpCtx() = default;

  virtual const double& floating_value() const = 0;
  virtual double* mutable_floating_value() = 0;
  virtual void set_floating_value(const double& floating_value) = 0;

  virtual const int64_t& integral_value() const = 0;
  virtual int64_t* mutable_integral_value() = 0;
  virtual void set_integral_value(const int64_t& integral_value) = 0;

  virtual const std::vector<std::int64_t>& padding() const = 0;
  virtual std::vector<std::int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int64_t>& padding) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ConstantPad3DOpInterpCtxImpl : public ConstantPad3DOpInterpCtx {
 public:
  ConstantPad3DOpInterpCtxImpl() = default;
  ConstantPad3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& floating_value() const { return impl_.floating_value(); }
  double* mutable_floating_value() { return impl_.mutable_floating_value(); }
  void set_floating_value(const double& floating_value) { impl_.set_floating_value(floating_value); }
  
  const int64_t& integral_value() const { return impl_.integral_value(); }
  int64_t* mutable_integral_value() { return impl_.mutable_integral_value(); }
  void set_integral_value(const int64_t& integral_value) { impl_.set_integral_value(integral_value); }
  
  const std::vector<std::int64_t>& padding() const { return impl_.padding(); }
  std::vector<std::int64_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int64_t>& padding) { impl_.set_padding(padding); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConstantPad3DOp {
 public:
  ConstantPad3DOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& floating_value() const { return internal_->floating_value; }
  double* mutable_floating_value() { return &internal_->floating_value; }
  void set_floating_value(const double& floating_value) { internal_->floating_value = floating_value; }
  
  const int64_t& integral_value() const { return internal_->integral_value; }
  int64_t* mutable_integral_value() { return &internal_->integral_value; }
  void set_integral_value(const int64_t& integral_value) { internal_->integral_value = integral_value; }
  
  const std::vector<std::int64_t>& padding() const { return internal_->padding; }
  std::vector<std::int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int64_t>& padding) { internal_->padding = padding; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double floating_value = 0.;
    int64_t integral_value = 0;
    std::vector<std::int64_t> padding;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class Conv1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~Conv1DOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<std::int32_t>& dilation_rate() const = 0;
  virtual std::vector<std::int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) = 0;

  virtual const int32_t& filters() const = 0;
  virtual int32_t* mutable_filters() = 0;
  virtual void set_filters(const int32_t& filters) = 0;

  virtual const int32_t& group() const = 0;
  virtual int32_t* mutable_group() = 0;
  virtual void set_group(const int32_t& group) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class Conv1DOpInterpCtxImpl : public Conv1DOpInterpCtx {
 public:
  Conv1DOpInterpCtxImpl() = default;
  Conv1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::vector<std::int32_t>& dilation_rate() const { return impl_.dilation_rate(); }
  std::vector<std::int32_t>* mutable_dilation_rate() { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { impl_.set_dilation_rate(dilation_rate); }
  
  const int32_t& filters() const { return impl_.filters(); }
  int32_t* mutable_filters() { return impl_.mutable_filters(); }
  void set_filters(const int32_t& filters) { impl_.set_filters(filters); }
  
  const int32_t& group() const { return impl_.group(); }
  int32_t* mutable_group() { return impl_.mutable_group(); }
  void set_group(const int32_t& group) { impl_.set_group(group); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Conv1DOp {
 public:
  Conv1DOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::vector<std::int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<std::int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { internal_->dilation_rate = dilation_rate; }
  
  const int32_t& filters() const { return internal_->filters; }
  int32_t* mutable_filters() { return &internal_->filters; }
  void set_filters(const int32_t& filters) { internal_->filters = filters; }
  
  const int32_t& group() const { return internal_->group; }
  int32_t* mutable_group() { return &internal_->group; }
  void set_group(const int32_t& group) { internal_->group = group; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    std::vector<std::int32_t> dilation_rate;
    int32_t filters;
    int32_t group = 1;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class Conv2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~Conv2DOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<std::int32_t>& dilation_rate() const = 0;
  virtual std::vector<std::int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) = 0;

  virtual const int32_t& filters() const = 0;
  virtual int32_t* mutable_filters() = 0;
  virtual void set_filters(const int32_t& filters) = 0;

  virtual const int32_t& group() const = 0;
  virtual int32_t* mutable_group() = 0;
  virtual void set_group(const int32_t& group) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class Conv2DOpInterpCtxImpl : public Conv2DOpInterpCtx {
 public:
  Conv2DOpInterpCtxImpl() = default;
  Conv2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::vector<std::int32_t>& dilation_rate() const { return impl_.dilation_rate(); }
  std::vector<std::int32_t>* mutable_dilation_rate() { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { impl_.set_dilation_rate(dilation_rate); }
  
  const int32_t& filters() const { return impl_.filters(); }
  int32_t* mutable_filters() { return impl_.mutable_filters(); }
  void set_filters(const int32_t& filters) { impl_.set_filters(filters); }
  
  const int32_t& group() const { return impl_.group(); }
  int32_t* mutable_group() { return impl_.mutable_group(); }
  void set_group(const int32_t& group) { impl_.set_group(group); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Conv2DOp {
 public:
  Conv2DOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::vector<std::int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<std::int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { internal_->dilation_rate = dilation_rate; }
  
  const int32_t& filters() const { return internal_->filters; }
  int32_t* mutable_filters() { return &internal_->filters; }
  void set_filters(const int32_t& filters) { internal_->filters = filters; }
  
  const int32_t& group() const { return internal_->group; }
  int32_t* mutable_group() { return &internal_->group; }
  void set_group(const int32_t& group) { internal_->group = group; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    std::vector<std::int32_t> dilation_rate;
    int32_t filters;
    int32_t group = 1;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class Conv3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~Conv3DOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<std::int32_t>& dilation_rate() const = 0;
  virtual std::vector<std::int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) = 0;

  virtual const int32_t& filters() const = 0;
  virtual int32_t* mutable_filters() = 0;
  virtual void set_filters(const int32_t& filters) = 0;

  virtual const int32_t& group() const = 0;
  virtual int32_t* mutable_group() = 0;
  virtual void set_group(const int32_t& group) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class Conv3DOpInterpCtxImpl : public Conv3DOpInterpCtx {
 public:
  Conv3DOpInterpCtxImpl() = default;
  Conv3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::vector<std::int32_t>& dilation_rate() const { return impl_.dilation_rate(); }
  std::vector<std::int32_t>* mutable_dilation_rate() { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { impl_.set_dilation_rate(dilation_rate); }
  
  const int32_t& filters() const { return impl_.filters(); }
  int32_t* mutable_filters() { return impl_.mutable_filters(); }
  void set_filters(const int32_t& filters) { impl_.set_filters(filters); }
  
  const int32_t& group() const { return impl_.group(); }
  int32_t* mutable_group() { return impl_.mutable_group(); }
  void set_group(const int32_t& group) { impl_.set_group(group); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Conv3DOp {
 public:
  Conv3DOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::vector<std::int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<std::int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { internal_->dilation_rate = dilation_rate; }
  
  const int32_t& filters() const { return internal_->filters; }
  int32_t* mutable_filters() { return &internal_->filters; }
  void set_filters(const int32_t& filters) { internal_->filters = filters; }
  
  const int32_t& group() const { return internal_->group; }
  int32_t* mutable_group() { return &internal_->group; }
  void set_group(const int32_t& group) { internal_->group = group; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    std::vector<std::int32_t> dilation_rate;
    int32_t filters;
    int32_t group = 1;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ConvBiasGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ConvBiasGradOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const int32_t& num_spatial_dims() const = 0;
  virtual int32_t* mutable_num_spatial_dims() = 0;
  virtual void set_num_spatial_dims(const int32_t& num_spatial_dims) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ConvBiasGradOpInterpCtxImpl : public ConvBiasGradOpInterpCtx {
 public:
  ConvBiasGradOpInterpCtxImpl() = default;
  ConvBiasGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const int32_t& num_spatial_dims() const { return impl_.num_spatial_dims(); }
  int32_t* mutable_num_spatial_dims() { return impl_.mutable_num_spatial_dims(); }
  void set_num_spatial_dims(const int32_t& num_spatial_dims) { impl_.set_num_spatial_dims(num_spatial_dims); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConvBiasGradOp {
 public:
  ConvBiasGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const int32_t& num_spatial_dims() const { return internal_->num_spatial_dims; }
  int32_t* mutable_num_spatial_dims() { return &internal_->num_spatial_dims; }
  void set_num_spatial_dims(const int32_t& num_spatial_dims) { internal_->num_spatial_dims = num_spatial_dims; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    int32_t num_spatial_dims = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ConvDataGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ConvDataGradOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<std::int32_t>& dilation_rate() const = 0;
  virtual std::vector<std::int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) = 0;

  virtual const int32_t& groups() const = 0;
  virtual int32_t* mutable_groups() = 0;
  virtual void set_groups(const int32_t& groups) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const int32_t& num_spatial_dims() const = 0;
  virtual int32_t* mutable_num_spatial_dims() = 0;
  virtual void set_num_spatial_dims(const int32_t& num_spatial_dims) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ConvDataGradOpInterpCtxImpl : public ConvDataGradOpInterpCtx {
 public:
  ConvDataGradOpInterpCtxImpl() = default;
  ConvDataGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::vector<std::int32_t>& dilation_rate() const { return impl_.dilation_rate(); }
  std::vector<std::int32_t>* mutable_dilation_rate() { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { impl_.set_dilation_rate(dilation_rate); }
  
  const int32_t& groups() const { return impl_.groups(); }
  int32_t* mutable_groups() { return impl_.mutable_groups(); }
  void set_groups(const int32_t& groups) { impl_.set_groups(groups); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const int32_t& num_spatial_dims() const { return impl_.num_spatial_dims(); }
  int32_t* mutable_num_spatial_dims() { return impl_.mutable_num_spatial_dims(); }
  void set_num_spatial_dims(const int32_t& num_spatial_dims) { impl_.set_num_spatial_dims(num_spatial_dims); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConvDataGradOp {
 public:
  ConvDataGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::vector<std::int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<std::int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { internal_->dilation_rate = dilation_rate; }
  
  const int32_t& groups() const { return internal_->groups; }
  int32_t* mutable_groups() { return &internal_->groups; }
  void set_groups(const int32_t& groups) { internal_->groups = groups; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const int32_t& num_spatial_dims() const { return internal_->num_spatial_dims; }
  int32_t* mutable_num_spatial_dims() { return &internal_->num_spatial_dims; }
  void set_num_spatial_dims(const int32_t& num_spatial_dims) { internal_->num_spatial_dims = num_spatial_dims; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    std::vector<std::int32_t> dilation_rate;
    int32_t groups = 0;
    std::vector<std::int32_t> kernel_size;
    int32_t num_spatial_dims = 0;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ConvFilterGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ConvFilterGradOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<std::int32_t>& dilation_rate() const = 0;
  virtual std::vector<std::int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) = 0;

  virtual const int32_t& groups() const = 0;
  virtual int32_t* mutable_groups() = 0;
  virtual void set_groups(const int32_t& groups) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const int32_t& num_spatial_dims() const = 0;
  virtual int32_t* mutable_num_spatial_dims() = 0;
  virtual void set_num_spatial_dims(const int32_t& num_spatial_dims) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ConvFilterGradOpInterpCtxImpl : public ConvFilterGradOpInterpCtx {
 public:
  ConvFilterGradOpInterpCtxImpl() = default;
  ConvFilterGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::vector<std::int32_t>& dilation_rate() const { return impl_.dilation_rate(); }
  std::vector<std::int32_t>* mutable_dilation_rate() { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { impl_.set_dilation_rate(dilation_rate); }
  
  const int32_t& groups() const { return impl_.groups(); }
  int32_t* mutable_groups() { return impl_.mutable_groups(); }
  void set_groups(const int32_t& groups) { impl_.set_groups(groups); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const int32_t& num_spatial_dims() const { return impl_.num_spatial_dims(); }
  int32_t* mutable_num_spatial_dims() { return impl_.mutable_num_spatial_dims(); }
  void set_num_spatial_dims(const int32_t& num_spatial_dims) { impl_.set_num_spatial_dims(num_spatial_dims); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConvFilterGradOp {
 public:
  ConvFilterGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::vector<std::int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<std::int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { internal_->dilation_rate = dilation_rate; }
  
  const int32_t& groups() const { return internal_->groups; }
  int32_t* mutable_groups() { return &internal_->groups; }
  void set_groups(const int32_t& groups) { internal_->groups = groups; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const int32_t& num_spatial_dims() const { return internal_->num_spatial_dims; }
  int32_t* mutable_num_spatial_dims() { return &internal_->num_spatial_dims; }
  void set_num_spatial_dims(const int32_t& num_spatial_dims) { internal_->num_spatial_dims = num_spatial_dims; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    std::vector<std::int32_t> dilation_rate;
    int32_t groups = 0;
    std::vector<std::int32_t> kernel_size;
    int32_t num_spatial_dims = 0;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CopyOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CopyOpInterpCtx() = default;

  virtual const int64_t& device_id() const = 0;
  virtual int64_t* mutable_device_id() = 0;
  virtual void set_device_id(const int64_t& device_id) = 0;

  virtual const std::string& device_type() const = 0;
  virtual std::string* mutable_device_type() = 0;
  virtual void set_device_type(const std::string& device_type) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CopyOpInterpCtxImpl : public CopyOpInterpCtx {
 public:
  CopyOpInterpCtxImpl() = default;
  CopyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& device_id() const { return impl_.device_id(); }
  int64_t* mutable_device_id() { return impl_.mutable_device_id(); }
  void set_device_id(const int64_t& device_id) { impl_.set_device_id(device_id); }
  
  const std::string& device_type() const { return impl_.device_type(); }
  std::string* mutable_device_type() { return impl_.mutable_device_type(); }
  void set_device_type(const std::string& device_type) { impl_.set_device_type(device_type); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CopyOp {
 public:
  CopyOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& device_id() const { return internal_->device_id; }
  int64_t* mutable_device_id() { return &internal_->device_id; }
  void set_device_id(const int64_t& device_id) { internal_->device_id = device_id; }
  
  const std::string& device_type() const { return internal_->device_type; }
  std::string* mutable_device_type() { return &internal_->device_type; }
  void set_device_type(const std::string& device_type) { internal_->device_type = device_type; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t device_id = 0;
    std::string device_type;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CosGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CosGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CosGradOpInterpCtxImpl : public CosGradOpInterpCtx {
 public:
  CosGradOpInterpCtxImpl() = default;
  CosGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CosGradOp {
 public:
  CosGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CosOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CosOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CosOpInterpCtxImpl : public CosOpInterpCtx {
 public:
  CosOpInterpCtxImpl() = default;
  CosOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CosOp {
 public:
  CosOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CoshGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CoshGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CoshGradOpInterpCtxImpl : public CoshGradOpInterpCtx {
 public:
  CoshGradOpInterpCtxImpl() = default;
  CoshGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CoshGradOp {
 public:
  CoshGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CoshOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CoshOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CoshOpInterpCtxImpl : public CoshOpInterpCtx {
 public:
  CoshOpInterpCtxImpl() = default;
  CoshOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CoshOp {
 public:
  CoshOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CountNotFiniteOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CountNotFiniteOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CountNotFiniteOpInterpCtxImpl : public CountNotFiniteOpInterpCtx {
 public:
  CountNotFiniteOpInterpCtxImpl() = default;
  CountNotFiniteOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CountNotFiniteOp {
 public:
  CountNotFiniteOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CpuOnlyReluTestOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CpuOnlyReluTestOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CpuOnlyReluTestOpInterpCtxImpl : public CpuOnlyReluTestOpInterpCtx {
 public:
  CpuOnlyReluTestOpInterpCtxImpl() = default;
  CpuOnlyReluTestOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CpuOnlyReluTestOp {
 public:
  CpuOnlyReluTestOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CreateSummaryWriterOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CreateSummaryWriterOpInterpCtx() = default;

  virtual const std::string& logdir() const = 0;
  virtual std::string* mutable_logdir() = 0;
  virtual void set_logdir(const std::string& logdir) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CreateSummaryWriterOpInterpCtxImpl : public CreateSummaryWriterOpInterpCtx {
 public:
  CreateSummaryWriterOpInterpCtxImpl() = default;
  CreateSummaryWriterOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& logdir() const { return impl_.logdir(); }
  std::string* mutable_logdir() { return impl_.mutable_logdir(); }
  void set_logdir(const std::string& logdir) { impl_.set_logdir(logdir); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CreateSummaryWriterOp {
 public:
  CreateSummaryWriterOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& logdir() const { return internal_->logdir; }
  std::string* mutable_logdir() { return &internal_->logdir; }
  void set_logdir(const std::string& logdir) { internal_->logdir = logdir; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string logdir;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CropMirrorNormalizeFromTensorbufferOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CropMirrorNormalizeFromTensorbufferOpInterpCtx() = default;

  virtual const std::string& color_space() const = 0;
  virtual std::string* mutable_color_space() = 0;
  virtual void set_color_space(const std::string& color_space) = 0;

  virtual const int64_t& crop_h() const = 0;
  virtual int64_t* mutable_crop_h() = 0;
  virtual void set_crop_h(const int64_t& crop_h) = 0;

  virtual const float& crop_pos_x() const = 0;
  virtual float* mutable_crop_pos_x() = 0;
  virtual void set_crop_pos_x(const float& crop_pos_x) = 0;

  virtual const float& crop_pos_y() const = 0;
  virtual float* mutable_crop_pos_y() = 0;
  virtual void set_crop_pos_y(const float& crop_pos_y) = 0;

  virtual const int64_t& crop_w() const = 0;
  virtual int64_t* mutable_crop_w() = 0;
  virtual void set_crop_w(const int64_t& crop_w) = 0;

  virtual const std::vector<float>& mean() const = 0;
  virtual std::vector<float>* mutable_mean() = 0;
  virtual void set_mean(const std::vector<float>& mean) = 0;

  virtual const DataType& output_dtype() const = 0;
  virtual DataType* mutable_output_dtype() = 0;
  virtual void set_output_dtype(const DataType& output_dtype) = 0;

  virtual const std::string& output_layout() const = 0;
  virtual std::string* mutable_output_layout() = 0;
  virtual void set_output_layout(const std::string& output_layout) = 0;

  virtual const std::vector<float>& std() const = 0;
  virtual std::vector<float>* mutable_std() = 0;
  virtual void set_std(const std::vector<float>& std) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CropMirrorNormalizeFromTensorbufferOpInterpCtxImpl : public CropMirrorNormalizeFromTensorbufferOpInterpCtx {
 public:
  CropMirrorNormalizeFromTensorbufferOpInterpCtxImpl() = default;
  CropMirrorNormalizeFromTensorbufferOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& color_space() const { return impl_.color_space(); }
  std::string* mutable_color_space() { return impl_.mutable_color_space(); }
  void set_color_space(const std::string& color_space) { impl_.set_color_space(color_space); }
  
  const int64_t& crop_h() const { return impl_.crop_h(); }
  int64_t* mutable_crop_h() { return impl_.mutable_crop_h(); }
  void set_crop_h(const int64_t& crop_h) { impl_.set_crop_h(crop_h); }
  
  const float& crop_pos_x() const { return impl_.crop_pos_x(); }
  float* mutable_crop_pos_x() { return impl_.mutable_crop_pos_x(); }
  void set_crop_pos_x(const float& crop_pos_x) { impl_.set_crop_pos_x(crop_pos_x); }
  
  const float& crop_pos_y() const { return impl_.crop_pos_y(); }
  float* mutable_crop_pos_y() { return impl_.mutable_crop_pos_y(); }
  void set_crop_pos_y(const float& crop_pos_y) { impl_.set_crop_pos_y(crop_pos_y); }
  
  const int64_t& crop_w() const { return impl_.crop_w(); }
  int64_t* mutable_crop_w() { return impl_.mutable_crop_w(); }
  void set_crop_w(const int64_t& crop_w) { impl_.set_crop_w(crop_w); }
  
  const std::vector<float>& mean() const { return impl_.mean(); }
  std::vector<float>* mutable_mean() { return impl_.mutable_mean(); }
  void set_mean(const std::vector<float>& mean) { impl_.set_mean(mean); }
  
  const DataType& output_dtype() const { return impl_.output_dtype(); }
  DataType* mutable_output_dtype() { return impl_.mutable_output_dtype(); }
  void set_output_dtype(const DataType& output_dtype) { impl_.set_output_dtype(output_dtype); }
  
  const std::string& output_layout() const { return impl_.output_layout(); }
  std::string* mutable_output_layout() { return impl_.mutable_output_layout(); }
  void set_output_layout(const std::string& output_layout) { impl_.set_output_layout(output_layout); }
  
  const std::vector<float>& std() const { return impl_.std(); }
  std::vector<float>* mutable_std() { return impl_.mutable_std(); }
  void set_std(const std::vector<float>& std) { impl_.set_std(std); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CropMirrorNormalizeFromTensorbufferOp {
 public:
  CropMirrorNormalizeFromTensorbufferOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& color_space() const { return internal_->color_space; }
  std::string* mutable_color_space() { return &internal_->color_space; }
  void set_color_space(const std::string& color_space) { internal_->color_space = color_space; }
  
  const int64_t& crop_h() const { return internal_->crop_h; }
  int64_t* mutable_crop_h() { return &internal_->crop_h; }
  void set_crop_h(const int64_t& crop_h) { internal_->crop_h = crop_h; }
  
  const float& crop_pos_x() const { return internal_->crop_pos_x; }
  float* mutable_crop_pos_x() { return &internal_->crop_pos_x; }
  void set_crop_pos_x(const float& crop_pos_x) { internal_->crop_pos_x = crop_pos_x; }
  
  const float& crop_pos_y() const { return internal_->crop_pos_y; }
  float* mutable_crop_pos_y() { return &internal_->crop_pos_y; }
  void set_crop_pos_y(const float& crop_pos_y) { internal_->crop_pos_y = crop_pos_y; }
  
  const int64_t& crop_w() const { return internal_->crop_w; }
  int64_t* mutable_crop_w() { return &internal_->crop_w; }
  void set_crop_w(const int64_t& crop_w) { internal_->crop_w = crop_w; }
  
  const std::vector<float>& mean() const { return internal_->mean; }
  std::vector<float>* mutable_mean() { return &internal_->mean; }
  void set_mean(const std::vector<float>& mean) { internal_->mean = mean; }
  
  const DataType& output_dtype() const { return internal_->output_dtype; }
  DataType* mutable_output_dtype() { return &internal_->output_dtype; }
  void set_output_dtype(const DataType& output_dtype) { internal_->output_dtype = output_dtype; }
  
  const std::string& output_layout() const { return internal_->output_layout; }
  std::string* mutable_output_layout() { return &internal_->output_layout; }
  void set_output_layout(const std::string& output_layout) { internal_->output_layout = output_layout; }
  
  const std::vector<float>& std() const { return internal_->std; }
  std::vector<float>* mutable_std() { return &internal_->std; }
  void set_std(const std::vector<float>& std) { internal_->std = std; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string color_space = "BGR";
    int64_t crop_h = 0;
    float crop_pos_x = 0.5;
    float crop_pos_y = 0.5;
    int64_t crop_w = 0;
    std::vector<float> mean;
    DataType output_dtype;
    std::string output_layout = "NCHW";
    std::vector<float> std;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CropMirrorNormalizeFromUint8OpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CropMirrorNormalizeFromUint8OpInterpCtx() = default;

  virtual const std::string& color_space() const = 0;
  virtual std::string* mutable_color_space() = 0;
  virtual void set_color_space(const std::string& color_space) = 0;

  virtual const int64_t& crop_h() const = 0;
  virtual int64_t* mutable_crop_h() = 0;
  virtual void set_crop_h(const int64_t& crop_h) = 0;

  virtual const float& crop_pos_x() const = 0;
  virtual float* mutable_crop_pos_x() = 0;
  virtual void set_crop_pos_x(const float& crop_pos_x) = 0;

  virtual const float& crop_pos_y() const = 0;
  virtual float* mutable_crop_pos_y() = 0;
  virtual void set_crop_pos_y(const float& crop_pos_y) = 0;

  virtual const int64_t& crop_w() const = 0;
  virtual int64_t* mutable_crop_w() = 0;
  virtual void set_crop_w(const int64_t& crop_w) = 0;

  virtual const std::vector<float>& mean() const = 0;
  virtual std::vector<float>* mutable_mean() = 0;
  virtual void set_mean(const std::vector<float>& mean) = 0;

  virtual const DataType& output_dtype() const = 0;
  virtual DataType* mutable_output_dtype() = 0;
  virtual void set_output_dtype(const DataType& output_dtype) = 0;

  virtual const std::string& output_layout() const = 0;
  virtual std::string* mutable_output_layout() = 0;
  virtual void set_output_layout(const std::string& output_layout) = 0;

  virtual const std::vector<float>& std() const = 0;
  virtual std::vector<float>* mutable_std() = 0;
  virtual void set_std(const std::vector<float>& std) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CropMirrorNormalizeFromUint8OpInterpCtxImpl : public CropMirrorNormalizeFromUint8OpInterpCtx {
 public:
  CropMirrorNormalizeFromUint8OpInterpCtxImpl() = default;
  CropMirrorNormalizeFromUint8OpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& color_space() const { return impl_.color_space(); }
  std::string* mutable_color_space() { return impl_.mutable_color_space(); }
  void set_color_space(const std::string& color_space) { impl_.set_color_space(color_space); }
  
  const int64_t& crop_h() const { return impl_.crop_h(); }
  int64_t* mutable_crop_h() { return impl_.mutable_crop_h(); }
  void set_crop_h(const int64_t& crop_h) { impl_.set_crop_h(crop_h); }
  
  const float& crop_pos_x() const { return impl_.crop_pos_x(); }
  float* mutable_crop_pos_x() { return impl_.mutable_crop_pos_x(); }
  void set_crop_pos_x(const float& crop_pos_x) { impl_.set_crop_pos_x(crop_pos_x); }
  
  const float& crop_pos_y() const { return impl_.crop_pos_y(); }
  float* mutable_crop_pos_y() { return impl_.mutable_crop_pos_y(); }
  void set_crop_pos_y(const float& crop_pos_y) { impl_.set_crop_pos_y(crop_pos_y); }
  
  const int64_t& crop_w() const { return impl_.crop_w(); }
  int64_t* mutable_crop_w() { return impl_.mutable_crop_w(); }
  void set_crop_w(const int64_t& crop_w) { impl_.set_crop_w(crop_w); }
  
  const std::vector<float>& mean() const { return impl_.mean(); }
  std::vector<float>* mutable_mean() { return impl_.mutable_mean(); }
  void set_mean(const std::vector<float>& mean) { impl_.set_mean(mean); }
  
  const DataType& output_dtype() const { return impl_.output_dtype(); }
  DataType* mutable_output_dtype() { return impl_.mutable_output_dtype(); }
  void set_output_dtype(const DataType& output_dtype) { impl_.set_output_dtype(output_dtype); }
  
  const std::string& output_layout() const { return impl_.output_layout(); }
  std::string* mutable_output_layout() { return impl_.mutable_output_layout(); }
  void set_output_layout(const std::string& output_layout) { impl_.set_output_layout(output_layout); }
  
  const std::vector<float>& std() const { return impl_.std(); }
  std::vector<float>* mutable_std() { return impl_.mutable_std(); }
  void set_std(const std::vector<float>& std) { impl_.set_std(std); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CropMirrorNormalizeFromUint8Op {
 public:
  CropMirrorNormalizeFromUint8Op() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& color_space() const { return internal_->color_space; }
  std::string* mutable_color_space() { return &internal_->color_space; }
  void set_color_space(const std::string& color_space) { internal_->color_space = color_space; }
  
  const int64_t& crop_h() const { return internal_->crop_h; }
  int64_t* mutable_crop_h() { return &internal_->crop_h; }
  void set_crop_h(const int64_t& crop_h) { internal_->crop_h = crop_h; }
  
  const float& crop_pos_x() const { return internal_->crop_pos_x; }
  float* mutable_crop_pos_x() { return &internal_->crop_pos_x; }
  void set_crop_pos_x(const float& crop_pos_x) { internal_->crop_pos_x = crop_pos_x; }
  
  const float& crop_pos_y() const { return internal_->crop_pos_y; }
  float* mutable_crop_pos_y() { return &internal_->crop_pos_y; }
  void set_crop_pos_y(const float& crop_pos_y) { internal_->crop_pos_y = crop_pos_y; }
  
  const int64_t& crop_w() const { return internal_->crop_w; }
  int64_t* mutable_crop_w() { return &internal_->crop_w; }
  void set_crop_w(const int64_t& crop_w) { internal_->crop_w = crop_w; }
  
  const std::vector<float>& mean() const { return internal_->mean; }
  std::vector<float>* mutable_mean() { return &internal_->mean; }
  void set_mean(const std::vector<float>& mean) { internal_->mean = mean; }
  
  const DataType& output_dtype() const { return internal_->output_dtype; }
  DataType* mutable_output_dtype() { return &internal_->output_dtype; }
  void set_output_dtype(const DataType& output_dtype) { internal_->output_dtype = output_dtype; }
  
  const std::string& output_layout() const { return internal_->output_layout; }
  std::string* mutable_output_layout() { return &internal_->output_layout; }
  void set_output_layout(const std::string& output_layout) { internal_->output_layout = output_layout; }
  
  const std::vector<float>& std() const { return internal_->std; }
  std::vector<float>* mutable_std() { return &internal_->std; }
  void set_std(const std::vector<float>& std) { internal_->std = std; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string color_space = "BGR";
    int64_t crop_h = 0;
    float crop_pos_x = 0.5;
    float crop_pos_y = 0.5;
    int64_t crop_w = 0;
    std::vector<float> mean;
    DataType output_dtype;
    std::string output_layout = "NCHW";
    std::vector<float> std;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CtcGreedyDecoderOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CtcGreedyDecoderOpInterpCtx() = default;

  virtual const bool& merge_repeated() const = 0;
  virtual bool* mutable_merge_repeated() = 0;
  virtual void set_merge_repeated(const bool& merge_repeated) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CtcGreedyDecoderOpInterpCtxImpl : public CtcGreedyDecoderOpInterpCtx {
 public:
  CtcGreedyDecoderOpInterpCtxImpl() = default;
  CtcGreedyDecoderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& merge_repeated() const { return impl_.merge_repeated(); }
  bool* mutable_merge_repeated() { return impl_.mutable_merge_repeated(); }
  void set_merge_repeated(const bool& merge_repeated) { impl_.set_merge_repeated(merge_repeated); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CtcGreedyDecoderOp {
 public:
  CtcGreedyDecoderOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& merge_repeated() const { return internal_->merge_repeated; }
  bool* mutable_merge_repeated() { return &internal_->merge_repeated; }
  void set_merge_repeated(const bool& merge_repeated) { internal_->merge_repeated = merge_repeated; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool merge_repeated = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CtcLossGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CtcLossGradOpInterpCtx() = default;

  virtual const int32_t& blank() const = 0;
  virtual int32_t* mutable_blank() = 0;
  virtual void set_blank(const int32_t& blank) = 0;

  virtual const int64_t& max_target_length() const = 0;
  virtual int64_t* mutable_max_target_length() = 0;
  virtual void set_max_target_length(const int64_t& max_target_length) = 0;

  virtual const bool& zero_infinity() const = 0;
  virtual bool* mutable_zero_infinity() = 0;
  virtual void set_zero_infinity(const bool& zero_infinity) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CtcLossGradOpInterpCtxImpl : public CtcLossGradOpInterpCtx {
 public:
  CtcLossGradOpInterpCtxImpl() = default;
  CtcLossGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& blank() const { return impl_.blank(); }
  int32_t* mutable_blank() { return impl_.mutable_blank(); }
  void set_blank(const int32_t& blank) { impl_.set_blank(blank); }
  
  const int64_t& max_target_length() const { return impl_.max_target_length(); }
  int64_t* mutable_max_target_length() { return impl_.mutable_max_target_length(); }
  void set_max_target_length(const int64_t& max_target_length) { impl_.set_max_target_length(max_target_length); }
  
  const bool& zero_infinity() const { return impl_.zero_infinity(); }
  bool* mutable_zero_infinity() { return impl_.mutable_zero_infinity(); }
  void set_zero_infinity(const bool& zero_infinity) { impl_.set_zero_infinity(zero_infinity); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CtcLossGradOp {
 public:
  CtcLossGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& blank() const { return internal_->blank; }
  int32_t* mutable_blank() { return &internal_->blank; }
  void set_blank(const int32_t& blank) { internal_->blank = blank; }
  
  const int64_t& max_target_length() const { return internal_->max_target_length; }
  int64_t* mutable_max_target_length() { return &internal_->max_target_length; }
  void set_max_target_length(const int64_t& max_target_length) { internal_->max_target_length = max_target_length; }
  
  const bool& zero_infinity() const { return internal_->zero_infinity; }
  bool* mutable_zero_infinity() { return &internal_->zero_infinity; }
  void set_zero_infinity(const bool& zero_infinity) { internal_->zero_infinity = zero_infinity; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t blank = 0;
    int64_t max_target_length = 0;
    bool zero_infinity = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CtcLossOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CtcLossOpInterpCtx() = default;

  virtual const int32_t& blank() const = 0;
  virtual int32_t* mutable_blank() = 0;
  virtual void set_blank(const int32_t& blank) = 0;

  virtual const int64_t& max_target_length() const = 0;
  virtual int64_t* mutable_max_target_length() = 0;
  virtual void set_max_target_length(const int64_t& max_target_length) = 0;

  virtual const bool& zero_infinity() const = 0;
  virtual bool* mutable_zero_infinity() = 0;
  virtual void set_zero_infinity(const bool& zero_infinity) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CtcLossOpInterpCtxImpl : public CtcLossOpInterpCtx {
 public:
  CtcLossOpInterpCtxImpl() = default;
  CtcLossOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& blank() const { return impl_.blank(); }
  int32_t* mutable_blank() { return impl_.mutable_blank(); }
  void set_blank(const int32_t& blank) { impl_.set_blank(blank); }
  
  const int64_t& max_target_length() const { return impl_.max_target_length(); }
  int64_t* mutable_max_target_length() { return impl_.mutable_max_target_length(); }
  void set_max_target_length(const int64_t& max_target_length) { impl_.set_max_target_length(max_target_length); }
  
  const bool& zero_infinity() const { return impl_.zero_infinity(); }
  bool* mutable_zero_infinity() { return impl_.mutable_zero_infinity(); }
  void set_zero_infinity(const bool& zero_infinity) { impl_.set_zero_infinity(zero_infinity); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CtcLossOp {
 public:
  CtcLossOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& blank() const { return internal_->blank; }
  int32_t* mutable_blank() { return &internal_->blank; }
  void set_blank(const int32_t& blank) { internal_->blank = blank; }
  
  const int64_t& max_target_length() const { return internal_->max_target_length; }
  int64_t* mutable_max_target_length() { return &internal_->max_target_length; }
  void set_max_target_length(const int64_t& max_target_length) { internal_->max_target_length = max_target_length; }
  
  const bool& zero_infinity() const { return internal_->zero_infinity; }
  bool* mutable_zero_infinity() { return &internal_->zero_infinity; }
  void set_zero_infinity(const bool& zero_infinity) { internal_->zero_infinity = zero_infinity; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t blank = 0;
    int64_t max_target_length = 0;
    bool zero_infinity = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CudnnFusedNormalizationAddReluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CudnnFusedNormalizationAddReluGradOpInterpCtx() = default;

  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CudnnFusedNormalizationAddReluGradOpInterpCtxImpl : public CudnnFusedNormalizationAddReluGradOpInterpCtx {
 public:
  CudnnFusedNormalizationAddReluGradOpInterpCtxImpl() = default;
  CudnnFusedNormalizationAddReluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& axis() const { return impl_.axis(); }
  int32_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) { impl_.set_axis(axis); }
  
  const float& epsilon() const { return impl_.epsilon(); }
  float* mutable_epsilon() { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) { impl_.set_epsilon(epsilon); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CudnnFusedNormalizationAddReluGradOp {
 public:
  CudnnFusedNormalizationAddReluGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }
  
  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t axis = 0;
    float epsilon = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class CudnnFusedNormalizationAddReluOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~CudnnFusedNormalizationAddReluOpInterpCtx() = default;

  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  virtual const float& momentum() const = 0;
  virtual float* mutable_momentum() = 0;
  virtual void set_momentum(const float& momentum) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class CudnnFusedNormalizationAddReluOpInterpCtxImpl : public CudnnFusedNormalizationAddReluOpInterpCtx {
 public:
  CudnnFusedNormalizationAddReluOpInterpCtxImpl() = default;
  CudnnFusedNormalizationAddReluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& axis() const { return impl_.axis(); }
  int32_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) { impl_.set_axis(axis); }
  
  const float& epsilon() const { return impl_.epsilon(); }
  float* mutable_epsilon() { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) { impl_.set_epsilon(epsilon); }
  
  const float& momentum() const { return impl_.momentum(); }
  float* mutable_momentum() { return impl_.mutable_momentum(); }
  void set_momentum(const float& momentum) { impl_.set_momentum(momentum); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CudnnFusedNormalizationAddReluOp {
 public:
  CudnnFusedNormalizationAddReluOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }
  
  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }
  
  const float& momentum() const { return internal_->momentum; }
  float* mutable_momentum() { return &internal_->momentum; }
  void set_momentum(const float& momentum) { internal_->momentum = momentum; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t axis = 0;
    float epsilon = 0.;
    float momentum = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class Deconv1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~Deconv1DOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<std::int32_t>& dilation_rate() const = 0;
  virtual std::vector<std::int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) = 0;

  virtual const int32_t& filters() const = 0;
  virtual int32_t* mutable_filters() = 0;
  virtual void set_filters(const int32_t& filters) = 0;

  virtual const int32_t& groups() const = 0;
  virtual int32_t* mutable_groups() = 0;
  virtual void set_groups(const int32_t& groups) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& output_padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_output_padding() = 0;
  virtual void set_output_padding(const std::vector<std::int32_t>& output_padding) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class Deconv1DOpInterpCtxImpl : public Deconv1DOpInterpCtx {
 public:
  Deconv1DOpInterpCtxImpl() = default;
  Deconv1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::vector<std::int32_t>& dilation_rate() const { return impl_.dilation_rate(); }
  std::vector<std::int32_t>* mutable_dilation_rate() { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { impl_.set_dilation_rate(dilation_rate); }
  
  const int32_t& filters() const { return impl_.filters(); }
  int32_t* mutable_filters() { return impl_.mutable_filters(); }
  void set_filters(const int32_t& filters) { impl_.set_filters(filters); }
  
  const int32_t& groups() const { return impl_.groups(); }
  int32_t* mutable_groups() { return impl_.mutable_groups(); }
  void set_groups(const int32_t& groups) { impl_.set_groups(groups); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& output_padding() const { return impl_.output_padding(); }
  std::vector<std::int32_t>* mutable_output_padding() { return impl_.mutable_output_padding(); }
  void set_output_padding(const std::vector<std::int32_t>& output_padding) { impl_.set_output_padding(output_padding); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Deconv1DOp {
 public:
  Deconv1DOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::vector<std::int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<std::int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { internal_->dilation_rate = dilation_rate; }
  
  const int32_t& filters() const { return internal_->filters; }
  int32_t* mutable_filters() { return &internal_->filters; }
  void set_filters(const int32_t& filters) { internal_->filters = filters; }
  
  const int32_t& groups() const { return internal_->groups; }
  int32_t* mutable_groups() { return &internal_->groups; }
  void set_groups(const int32_t& groups) { internal_->groups = groups; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& output_padding() const { return internal_->output_padding; }
  std::vector<std::int32_t>* mutable_output_padding() { return &internal_->output_padding; }
  void set_output_padding(const std::vector<std::int32_t>& output_padding) { internal_->output_padding = output_padding; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    std::vector<std::int32_t> dilation_rate;
    int32_t filters = 0;
    int32_t groups = 1;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> output_padding;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class Deconv2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~Deconv2DOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<std::int32_t>& dilation_rate() const = 0;
  virtual std::vector<std::int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) = 0;

  virtual const int32_t& filters() const = 0;
  virtual int32_t* mutable_filters() = 0;
  virtual void set_filters(const int32_t& filters) = 0;

  virtual const int32_t& groups() const = 0;
  virtual int32_t* mutable_groups() = 0;
  virtual void set_groups(const int32_t& groups) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& output_padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_output_padding() = 0;
  virtual void set_output_padding(const std::vector<std::int32_t>& output_padding) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class Deconv2DOpInterpCtxImpl : public Deconv2DOpInterpCtx {
 public:
  Deconv2DOpInterpCtxImpl() = default;
  Deconv2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::vector<std::int32_t>& dilation_rate() const { return impl_.dilation_rate(); }
  std::vector<std::int32_t>* mutable_dilation_rate() { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { impl_.set_dilation_rate(dilation_rate); }
  
  const int32_t& filters() const { return impl_.filters(); }
  int32_t* mutable_filters() { return impl_.mutable_filters(); }
  void set_filters(const int32_t& filters) { impl_.set_filters(filters); }
  
  const int32_t& groups() const { return impl_.groups(); }
  int32_t* mutable_groups() { return impl_.mutable_groups(); }
  void set_groups(const int32_t& groups) { impl_.set_groups(groups); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& output_padding() const { return impl_.output_padding(); }
  std::vector<std::int32_t>* mutable_output_padding() { return impl_.mutable_output_padding(); }
  void set_output_padding(const std::vector<std::int32_t>& output_padding) { impl_.set_output_padding(output_padding); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Deconv2DOp {
 public:
  Deconv2DOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::vector<std::int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<std::int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { internal_->dilation_rate = dilation_rate; }
  
  const int32_t& filters() const { return internal_->filters; }
  int32_t* mutable_filters() { return &internal_->filters; }
  void set_filters(const int32_t& filters) { internal_->filters = filters; }
  
  const int32_t& groups() const { return internal_->groups; }
  int32_t* mutable_groups() { return &internal_->groups; }
  void set_groups(const int32_t& groups) { internal_->groups = groups; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& output_padding() const { return internal_->output_padding; }
  std::vector<std::int32_t>* mutable_output_padding() { return &internal_->output_padding; }
  void set_output_padding(const std::vector<std::int32_t>& output_padding) { internal_->output_padding = output_padding; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    std::vector<std::int32_t> dilation_rate;
    int32_t filters = 0;
    int32_t groups = 1;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> output_padding;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class Deconv3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~Deconv3DOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<std::int32_t>& dilation_rate() const = 0;
  virtual std::vector<std::int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) = 0;

  virtual const int32_t& filters() const = 0;
  virtual int32_t* mutable_filters() = 0;
  virtual void set_filters(const int32_t& filters) = 0;

  virtual const int32_t& groups() const = 0;
  virtual int32_t* mutable_groups() = 0;
  virtual void set_groups(const int32_t& groups) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& output_padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_output_padding() = 0;
  virtual void set_output_padding(const std::vector<std::int32_t>& output_padding) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class Deconv3DOpInterpCtxImpl : public Deconv3DOpInterpCtx {
 public:
  Deconv3DOpInterpCtxImpl() = default;
  Deconv3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::vector<std::int32_t>& dilation_rate() const { return impl_.dilation_rate(); }
  std::vector<std::int32_t>* mutable_dilation_rate() { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { impl_.set_dilation_rate(dilation_rate); }
  
  const int32_t& filters() const { return impl_.filters(); }
  int32_t* mutable_filters() { return impl_.mutable_filters(); }
  void set_filters(const int32_t& filters) { impl_.set_filters(filters); }
  
  const int32_t& groups() const { return impl_.groups(); }
  int32_t* mutable_groups() { return impl_.mutable_groups(); }
  void set_groups(const int32_t& groups) { impl_.set_groups(groups); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& output_padding() const { return impl_.output_padding(); }
  std::vector<std::int32_t>* mutable_output_padding() { return impl_.mutable_output_padding(); }
  void set_output_padding(const std::vector<std::int32_t>& output_padding) { impl_.set_output_padding(output_padding); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Deconv3DOp {
 public:
  Deconv3DOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::vector<std::int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<std::int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { internal_->dilation_rate = dilation_rate; }
  
  const int32_t& filters() const { return internal_->filters; }
  int32_t* mutable_filters() { return &internal_->filters; }
  void set_filters(const int32_t& filters) { internal_->filters = filters; }
  
  const int32_t& groups() const { return internal_->groups; }
  int32_t* mutable_groups() { return &internal_->groups; }
  void set_groups(const int32_t& groups) { internal_->groups = groups; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& output_padding() const { return internal_->output_padding; }
  std::vector<std::int32_t>* mutable_output_padding() { return &internal_->output_padding; }
  void set_output_padding(const std::vector<std::int32_t>& output_padding) { internal_->output_padding = output_padding; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    std::vector<std::int32_t> dilation_rate;
    int32_t filters = 0;
    int32_t groups = 1;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> output_padding;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class DiagGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~DiagGradOpInterpCtx() = default;

  virtual const int32_t& diagonal() const = 0;
  virtual int32_t* mutable_diagonal() = 0;
  virtual void set_diagonal(const int32_t& diagonal) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class DiagGradOpInterpCtxImpl : public DiagGradOpInterpCtx {
 public:
  DiagGradOpInterpCtxImpl() = default;
  DiagGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& diagonal() const { return impl_.diagonal(); }
  int32_t* mutable_diagonal() { return impl_.mutable_diagonal(); }
  void set_diagonal(const int32_t& diagonal) { impl_.set_diagonal(diagonal); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DiagGradOp {
 public:
  DiagGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& diagonal() const { return internal_->diagonal; }
  int32_t* mutable_diagonal() { return &internal_->diagonal; }
  void set_diagonal(const int32_t& diagonal) { internal_->diagonal = diagonal; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t diagonal = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class DiagOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~DiagOpInterpCtx() = default;

  virtual const int32_t& diagonal() const = 0;
  virtual int32_t* mutable_diagonal() = 0;
  virtual void set_diagonal(const int32_t& diagonal) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class DiagOpInterpCtxImpl : public DiagOpInterpCtx {
 public:
  DiagOpInterpCtxImpl() = default;
  DiagOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& diagonal() const { return impl_.diagonal(); }
  int32_t* mutable_diagonal() { return impl_.mutable_diagonal(); }
  void set_diagonal(const int32_t& diagonal) { impl_.set_diagonal(diagonal); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DiagOp {
 public:
  DiagOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& diagonal() const { return internal_->diagonal; }
  int32_t* mutable_diagonal() { return &internal_->diagonal; }
  void set_diagonal(const int32_t& diagonal) { internal_->diagonal = diagonal; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t diagonal = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class DimGatherOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~DimGatherOpInterpCtx() = default;

  virtual const int32_t& dim() const = 0;
  virtual int32_t* mutable_dim() = 0;
  virtual void set_dim(const int32_t& dim) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class DimGatherOpInterpCtxImpl : public DimGatherOpInterpCtx {
 public:
  DimGatherOpInterpCtxImpl() = default;
  DimGatherOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& dim() const { return impl_.dim(); }
  int32_t* mutable_dim() { return impl_.mutable_dim(); }
  void set_dim(const int32_t& dim) { impl_.set_dim(dim); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DimGatherOp {
 public:
  DimGatherOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& dim() const { return internal_->dim; }
  int32_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int32_t& dim) { internal_->dim = dim; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t dim = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class DimScatterAddLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~DimScatterAddLikeOpInterpCtx() = default;

  virtual const int32_t& dim() const = 0;
  virtual int32_t* mutable_dim() = 0;
  virtual void set_dim(const int32_t& dim) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class DimScatterAddLikeOpInterpCtxImpl : public DimScatterAddLikeOpInterpCtx {
 public:
  DimScatterAddLikeOpInterpCtxImpl() = default;
  DimScatterAddLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& dim() const { return impl_.dim(); }
  int32_t* mutable_dim() { return impl_.mutable_dim(); }
  void set_dim(const int32_t& dim) { impl_.set_dim(dim); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DimScatterAddLikeOp {
 public:
  DimScatterAddLikeOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& dim() const { return internal_->dim; }
  int32_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int32_t& dim) { internal_->dim = dim; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t dim = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class DimScatterAddOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~DimScatterAddOpInterpCtx() = default;

  virtual const int32_t& dim() const = 0;
  virtual int32_t* mutable_dim() = 0;
  virtual void set_dim(const int32_t& dim) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class DimScatterAddOpInterpCtxImpl : public DimScatterAddOpInterpCtx {
 public:
  DimScatterAddOpInterpCtxImpl() = default;
  DimScatterAddOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& dim() const { return impl_.dim(); }
  int32_t* mutable_dim() { return impl_.mutable_dim(); }
  void set_dim(const int32_t& dim) { impl_.set_dim(dim); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DimScatterAddOp {
 public:
  DimScatterAddOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& dim() const { return internal_->dim; }
  int32_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int32_t& dim) { internal_->dim = dim; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t dim = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class DimScatterAddScalarOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~DimScatterAddScalarOpInterpCtx() = default;

  virtual const int32_t& dim() const = 0;
  virtual int32_t* mutable_dim() = 0;
  virtual void set_dim(const int32_t& dim) = 0;

  virtual const float& src_scalar() const = 0;
  virtual float* mutable_src_scalar() = 0;
  virtual void set_src_scalar(const float& src_scalar) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class DimScatterAddScalarOpInterpCtxImpl : public DimScatterAddScalarOpInterpCtx {
 public:
  DimScatterAddScalarOpInterpCtxImpl() = default;
  DimScatterAddScalarOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& dim() const { return impl_.dim(); }
  int32_t* mutable_dim() { return impl_.mutable_dim(); }
  void set_dim(const int32_t& dim) { impl_.set_dim(dim); }
  
  const float& src_scalar() const { return impl_.src_scalar(); }
  float* mutable_src_scalar() { return impl_.mutable_src_scalar(); }
  void set_src_scalar(const float& src_scalar) { impl_.set_src_scalar(src_scalar); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DimScatterAddScalarOp {
 public:
  DimScatterAddScalarOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& dim() const { return internal_->dim; }
  int32_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int32_t& dim) { internal_->dim = dim; }
  
  const float& src_scalar() const { return internal_->src_scalar; }
  float* mutable_src_scalar() { return &internal_->src_scalar; }
  void set_src_scalar(const float& src_scalar) { internal_->src_scalar = src_scalar; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t dim = 0;
    float src_scalar = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class DimScatterMulOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~DimScatterMulOpInterpCtx() = default;

  virtual const int32_t& dim() const = 0;
  virtual int32_t* mutable_dim() = 0;
  virtual void set_dim(const int32_t& dim) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class DimScatterMulOpInterpCtxImpl : public DimScatterMulOpInterpCtx {
 public:
  DimScatterMulOpInterpCtxImpl() = default;
  DimScatterMulOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& dim() const { return impl_.dim(); }
  int32_t* mutable_dim() { return impl_.mutable_dim(); }
  void set_dim(const int32_t& dim) { impl_.set_dim(dim); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DimScatterMulOp {
 public:
  DimScatterMulOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& dim() const { return internal_->dim; }
  int32_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int32_t& dim) { internal_->dim = dim; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t dim = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class DimScatterMulScalarOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~DimScatterMulScalarOpInterpCtx() = default;

  virtual const int32_t& dim() const = 0;
  virtual int32_t* mutable_dim() = 0;
  virtual void set_dim(const int32_t& dim) = 0;

  virtual const float& src_scalar() const = 0;
  virtual float* mutable_src_scalar() = 0;
  virtual void set_src_scalar(const float& src_scalar) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class DimScatterMulScalarOpInterpCtxImpl : public DimScatterMulScalarOpInterpCtx {
 public:
  DimScatterMulScalarOpInterpCtxImpl() = default;
  DimScatterMulScalarOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& dim() const { return impl_.dim(); }
  int32_t* mutable_dim() { return impl_.mutable_dim(); }
  void set_dim(const int32_t& dim) { impl_.set_dim(dim); }
  
  const float& src_scalar() const { return impl_.src_scalar(); }
  float* mutable_src_scalar() { return impl_.mutable_src_scalar(); }
  void set_src_scalar(const float& src_scalar) { impl_.set_src_scalar(src_scalar); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DimScatterMulScalarOp {
 public:
  DimScatterMulScalarOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& dim() const { return internal_->dim; }
  int32_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int32_t& dim) { internal_->dim = dim; }
  
  const float& src_scalar() const { return internal_->src_scalar; }
  float* mutable_src_scalar() { return &internal_->src_scalar; }
  void set_src_scalar(const float& src_scalar) { internal_->src_scalar = src_scalar; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t dim = 0;
    float src_scalar = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class DimScatterUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~DimScatterUpdateOpInterpCtx() = default;

  virtual const int32_t& dim() const = 0;
  virtual int32_t* mutable_dim() = 0;
  virtual void set_dim(const int32_t& dim) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class DimScatterUpdateOpInterpCtxImpl : public DimScatterUpdateOpInterpCtx {
 public:
  DimScatterUpdateOpInterpCtxImpl() = default;
  DimScatterUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& dim() const { return impl_.dim(); }
  int32_t* mutable_dim() { return impl_.mutable_dim(); }
  void set_dim(const int32_t& dim) { impl_.set_dim(dim); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DimScatterUpdateOp {
 public:
  DimScatterUpdateOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& dim() const { return internal_->dim; }
  int32_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int32_t& dim) { internal_->dim = dim; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t dim = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class DimScatterUpdateScalarOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~DimScatterUpdateScalarOpInterpCtx() = default;

  virtual const int32_t& dim() const = 0;
  virtual int32_t* mutable_dim() = 0;
  virtual void set_dim(const int32_t& dim) = 0;

  virtual const float& src_scalar() const = 0;
  virtual float* mutable_src_scalar() = 0;
  virtual void set_src_scalar(const float& src_scalar) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class DimScatterUpdateScalarOpInterpCtxImpl : public DimScatterUpdateScalarOpInterpCtx {
 public:
  DimScatterUpdateScalarOpInterpCtxImpl() = default;
  DimScatterUpdateScalarOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& dim() const { return impl_.dim(); }
  int32_t* mutable_dim() { return impl_.mutable_dim(); }
  void set_dim(const int32_t& dim) { impl_.set_dim(dim); }
  
  const float& src_scalar() const { return impl_.src_scalar(); }
  float* mutable_src_scalar() { return impl_.mutable_src_scalar(); }
  void set_src_scalar(const float& src_scalar) { impl_.set_src_scalar(src_scalar); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DimScatterUpdateScalarOp {
 public:
  DimScatterUpdateScalarOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& dim() const { return internal_->dim; }
  int32_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int32_t& dim) { internal_->dim = dim; }
  
  const float& src_scalar() const { return internal_->src_scalar; }
  float* mutable_src_scalar() { return &internal_->src_scalar; }
  void set_src_scalar(const float& src_scalar) { internal_->src_scalar = src_scalar; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t dim = 0;
    float src_scalar = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class DistributedPartialFcSampleDisableBoxingOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~DistributedPartialFcSampleDisableBoxingOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class DistributedPartialFcSampleDisableBoxingOpInterpCtxImpl : public DistributedPartialFcSampleDisableBoxingOpInterpCtx {
 public:
  DistributedPartialFcSampleDisableBoxingOpInterpCtxImpl() = default;
  DistributedPartialFcSampleDisableBoxingOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DistributedPartialFcSampleDisableBoxingOp {
 public:
  DistributedPartialFcSampleDisableBoxingOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class DistributedPartialFcSampleOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~DistributedPartialFcSampleOpInterpCtx() = default;

  virtual const int64_t& num_sample() const = 0;
  virtual int64_t* mutable_num_sample() = 0;
  virtual void set_num_sample(const int64_t& num_sample) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class DistributedPartialFcSampleOpInterpCtxImpl : public DistributedPartialFcSampleOpInterpCtx {
 public:
  DistributedPartialFcSampleOpInterpCtxImpl() = default;
  DistributedPartialFcSampleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& num_sample() const { return impl_.num_sample(); }
  int64_t* mutable_num_sample() { return impl_.mutable_num_sample(); }
  void set_num_sample(const int64_t& num_sample) { impl_.set_num_sample(num_sample); }
  
  const int64_t& seed() const { return impl_.seed(); }
  int64_t* mutable_seed() { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) { impl_.set_seed(seed); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DistributedPartialFcSampleOp {
 public:
  DistributedPartialFcSampleOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& num_sample() const { return internal_->num_sample; }
  int64_t* mutable_num_sample() { return &internal_->num_sample; }
  void set_num_sample(const int64_t& num_sample) { internal_->num_sample = num_sample; }
  
  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t num_sample = 0;
    int64_t seed = -1;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class DotOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~DotOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class DotOpInterpCtxImpl : public DotOpInterpCtx {
 public:
  DotOpInterpCtxImpl() = default;
  DotOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DotOp {
 public:
  DotOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class DropoutGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~DropoutGradOpInterpCtx() = default;

  virtual const float& scale() const = 0;
  virtual float* mutable_scale() = 0;
  virtual void set_scale(const float& scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class DropoutGradOpInterpCtxImpl : public DropoutGradOpInterpCtx {
 public:
  DropoutGradOpInterpCtxImpl() = default;
  DropoutGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& scale() const { return impl_.scale(); }
  float* mutable_scale() { return impl_.mutable_scale(); }
  void set_scale(const float& scale) { impl_.set_scale(scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DropoutGradOp {
 public:
  DropoutGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& scale() const { return internal_->scale; }
  float* mutable_scale() { return &internal_->scale; }
  void set_scale(const float& scale) { internal_->scale = scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float scale = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class DropoutOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~DropoutOpInterpCtx() = default;

  virtual const float& rate() const = 0;
  virtual float* mutable_rate() = 0;
  virtual void set_rate(const float& rate) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class DropoutOpInterpCtxImpl : public DropoutOpInterpCtx {
 public:
  DropoutOpInterpCtxImpl() = default;
  DropoutOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& rate() const { return impl_.rate(); }
  float* mutable_rate() { return impl_.mutable_rate(); }
  void set_rate(const float& rate) { impl_.set_rate(rate); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DropoutOp {
 public:
  DropoutOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& rate() const { return internal_->rate; }
  float* mutable_rate() { return &internal_->rate; }
  void set_rate(const float& rate) { internal_->rate = rate; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float rate = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class DynamicLossScaleScheduleOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~DynamicLossScaleScheduleOpInterpCtx() = default;

  virtual const int64_t& increment_period() const = 0;
  virtual int64_t* mutable_increment_period() = 0;
  virtual void set_increment_period(const int64_t& increment_period) = 0;

  virtual const float& multiplier() const = 0;
  virtual float* mutable_multiplier() = 0;
  virtual void set_multiplier(const float& multiplier) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class DynamicLossScaleScheduleOpInterpCtxImpl : public DynamicLossScaleScheduleOpInterpCtx {
 public:
  DynamicLossScaleScheduleOpInterpCtxImpl() = default;
  DynamicLossScaleScheduleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& increment_period() const { return impl_.increment_period(); }
  int64_t* mutable_increment_period() { return impl_.mutable_increment_period(); }
  void set_increment_period(const int64_t& increment_period) { impl_.set_increment_period(increment_period); }
  
  const float& multiplier() const { return impl_.multiplier(); }
  float* mutable_multiplier() { return impl_.mutable_multiplier(); }
  void set_multiplier(const float& multiplier) { impl_.set_multiplier(multiplier); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DynamicLossScaleScheduleOp {
 public:
  DynamicLossScaleScheduleOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& increment_period() const { return internal_->increment_period; }
  int64_t* mutable_increment_period() { return &internal_->increment_period; }
  void set_increment_period(const int64_t& increment_period) { internal_->increment_period = increment_period; }
  
  const float& multiplier() const { return internal_->multiplier; }
  float* mutable_multiplier() { return &internal_->multiplier; }
  void set_multiplier(const float& multiplier) { internal_->multiplier = multiplier; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t increment_period = 2000;
    float multiplier = 2.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class EagerBToSOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~EagerBToSOpInterpCtx() = default;

  virtual const std::string& in_parallel_conf() const = 0;
  virtual std::string* mutable_in_parallel_conf() = 0;
  virtual void set_in_parallel_conf(const std::string& in_parallel_conf) = 0;

  virtual const std::string& out_parallel_conf() const = 0;
  virtual std::string* mutable_out_parallel_conf() = 0;
  virtual void set_out_parallel_conf(const std::string& out_parallel_conf) = 0;

  virtual const int64_t& out_split_axis() const = 0;
  virtual int64_t* mutable_out_split_axis() = 0;
  virtual void set_out_split_axis(const int64_t& out_split_axis) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class EagerBToSOpInterpCtxImpl : public EagerBToSOpInterpCtx {
 public:
  EagerBToSOpInterpCtxImpl() = default;
  EagerBToSOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& in_parallel_conf() const { return impl_.in_parallel_conf(); }
  std::string* mutable_in_parallel_conf() { return impl_.mutable_in_parallel_conf(); }
  void set_in_parallel_conf(const std::string& in_parallel_conf) { impl_.set_in_parallel_conf(in_parallel_conf); }
  
  const std::string& out_parallel_conf() const { return impl_.out_parallel_conf(); }
  std::string* mutable_out_parallel_conf() { return impl_.mutable_out_parallel_conf(); }
  void set_out_parallel_conf(const std::string& out_parallel_conf) { impl_.set_out_parallel_conf(out_parallel_conf); }
  
  const int64_t& out_split_axis() const { return impl_.out_split_axis(); }
  int64_t* mutable_out_split_axis() { return impl_.mutable_out_split_axis(); }
  void set_out_split_axis(const int64_t& out_split_axis) { impl_.set_out_split_axis(out_split_axis); }
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerBToSOp {
 public:
  EagerBToSOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& in_parallel_conf() const { return internal_->in_parallel_conf; }
  std::string* mutable_in_parallel_conf() { return &internal_->in_parallel_conf; }
  void set_in_parallel_conf(const std::string& in_parallel_conf) { internal_->in_parallel_conf = in_parallel_conf; }
  
  const std::string& out_parallel_conf() const { return internal_->out_parallel_conf; }
  std::string* mutable_out_parallel_conf() { return &internal_->out_parallel_conf; }
  void set_out_parallel_conf(const std::string& out_parallel_conf) { internal_->out_parallel_conf = out_parallel_conf; }
  
  const int64_t& out_split_axis() const { return internal_->out_split_axis; }
  int64_t* mutable_out_split_axis() { return &internal_->out_split_axis; }
  void set_out_split_axis(const int64_t& out_split_axis) { internal_->out_split_axis = out_split_axis; }
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string in_parallel_conf;
    std::string out_parallel_conf;
    int64_t out_split_axis = -1;
    Shape shape;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class EagerNaiveSToSOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~EagerNaiveSToSOpInterpCtx() = default;

  virtual const std::string& in_parallel_conf() const = 0;
  virtual std::string* mutable_in_parallel_conf() = 0;
  virtual void set_in_parallel_conf(const std::string& in_parallel_conf) = 0;

  virtual const int64_t& in_split_axis() const = 0;
  virtual int64_t* mutable_in_split_axis() = 0;
  virtual void set_in_split_axis(const int64_t& in_split_axis) = 0;

  virtual const std::string& out_parallel_conf() const = 0;
  virtual std::string* mutable_out_parallel_conf() = 0;
  virtual void set_out_parallel_conf(const std::string& out_parallel_conf) = 0;

  virtual const int64_t& out_split_axis() const = 0;
  virtual int64_t* mutable_out_split_axis() = 0;
  virtual void set_out_split_axis(const int64_t& out_split_axis) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class EagerNaiveSToSOpInterpCtxImpl : public EagerNaiveSToSOpInterpCtx {
 public:
  EagerNaiveSToSOpInterpCtxImpl() = default;
  EagerNaiveSToSOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& in_parallel_conf() const { return impl_.in_parallel_conf(); }
  std::string* mutable_in_parallel_conf() { return impl_.mutable_in_parallel_conf(); }
  void set_in_parallel_conf(const std::string& in_parallel_conf) { impl_.set_in_parallel_conf(in_parallel_conf); }
  
  const int64_t& in_split_axis() const { return impl_.in_split_axis(); }
  int64_t* mutable_in_split_axis() { return impl_.mutable_in_split_axis(); }
  void set_in_split_axis(const int64_t& in_split_axis) { impl_.set_in_split_axis(in_split_axis); }
  
  const std::string& out_parallel_conf() const { return impl_.out_parallel_conf(); }
  std::string* mutable_out_parallel_conf() { return impl_.mutable_out_parallel_conf(); }
  void set_out_parallel_conf(const std::string& out_parallel_conf) { impl_.set_out_parallel_conf(out_parallel_conf); }
  
  const int64_t& out_split_axis() const { return impl_.out_split_axis(); }
  int64_t* mutable_out_split_axis() { return impl_.mutable_out_split_axis(); }
  void set_out_split_axis(const int64_t& out_split_axis) { impl_.set_out_split_axis(out_split_axis); }
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerNaiveSToSOp {
 public:
  EagerNaiveSToSOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& in_parallel_conf() const { return internal_->in_parallel_conf; }
  std::string* mutable_in_parallel_conf() { return &internal_->in_parallel_conf; }
  void set_in_parallel_conf(const std::string& in_parallel_conf) { internal_->in_parallel_conf = in_parallel_conf; }
  
  const int64_t& in_split_axis() const { return internal_->in_split_axis; }
  int64_t* mutable_in_split_axis() { return &internal_->in_split_axis; }
  void set_in_split_axis(const int64_t& in_split_axis) { internal_->in_split_axis = in_split_axis; }
  
  const std::string& out_parallel_conf() const { return internal_->out_parallel_conf; }
  std::string* mutable_out_parallel_conf() { return &internal_->out_parallel_conf; }
  void set_out_parallel_conf(const std::string& out_parallel_conf) { internal_->out_parallel_conf = out_parallel_conf; }
  
  const int64_t& out_split_axis() const { return internal_->out_split_axis; }
  int64_t* mutable_out_split_axis() { return &internal_->out_split_axis; }
  void set_out_split_axis(const int64_t& out_split_axis) { internal_->out_split_axis = out_split_axis; }
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string in_parallel_conf;
    int64_t in_split_axis = -1;
    std::string out_parallel_conf;
    int64_t out_split_axis = -1;
    Shape shape;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class EagerNcclAllGatherOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~EagerNcclAllGatherOpInterpCtx() = default;

  virtual const std::string& parallel_conf() const = 0;
  virtual std::string* mutable_parallel_conf() = 0;
  virtual void set_parallel_conf(const std::string& parallel_conf) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class EagerNcclAllGatherOpInterpCtxImpl : public EagerNcclAllGatherOpInterpCtx {
 public:
  EagerNcclAllGatherOpInterpCtxImpl() = default;
  EagerNcclAllGatherOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& parallel_conf() const { return impl_.parallel_conf(); }
  std::string* mutable_parallel_conf() { return impl_.mutable_parallel_conf(); }
  void set_parallel_conf(const std::string& parallel_conf) { impl_.set_parallel_conf(parallel_conf); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerNcclAllGatherOp {
 public:
  EagerNcclAllGatherOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& parallel_conf() const { return internal_->parallel_conf; }
  std::string* mutable_parallel_conf() { return &internal_->parallel_conf; }
  void set_parallel_conf(const std::string& parallel_conf) { internal_->parallel_conf = parallel_conf; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string parallel_conf;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class EagerNcclAllReduceOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~EagerNcclAllReduceOpInterpCtx() = default;

  virtual const bool& async_launch() const = 0;
  virtual bool* mutable_async_launch() = 0;
  virtual void set_async_launch(const bool& async_launch) = 0;

  virtual const std::string& parallel_conf() const = 0;
  virtual std::string* mutable_parallel_conf() = 0;
  virtual void set_parallel_conf(const std::string& parallel_conf) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class EagerNcclAllReduceOpInterpCtxImpl : public EagerNcclAllReduceOpInterpCtx {
 public:
  EagerNcclAllReduceOpInterpCtxImpl() = default;
  EagerNcclAllReduceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& async_launch() const { return impl_.async_launch(); }
  bool* mutable_async_launch() { return impl_.mutable_async_launch(); }
  void set_async_launch(const bool& async_launch) { impl_.set_async_launch(async_launch); }
  
  const std::string& parallel_conf() const { return impl_.parallel_conf(); }
  std::string* mutable_parallel_conf() { return impl_.mutable_parallel_conf(); }
  void set_parallel_conf(const std::string& parallel_conf) { impl_.set_parallel_conf(parallel_conf); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerNcclAllReduceOp {
 public:
  EagerNcclAllReduceOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& async_launch() const { return internal_->async_launch; }
  bool* mutable_async_launch() { return &internal_->async_launch; }
  void set_async_launch(const bool& async_launch) { internal_->async_launch = async_launch; }
  
  const std::string& parallel_conf() const { return internal_->parallel_conf; }
  std::string* mutable_parallel_conf() { return &internal_->parallel_conf; }
  void set_parallel_conf(const std::string& parallel_conf) { internal_->parallel_conf = parallel_conf; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool async_launch = false;
    std::string parallel_conf;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class EagerNcclBroadcastOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~EagerNcclBroadcastOpInterpCtx() = default;

  virtual const std::string& parallel_conf() const = 0;
  virtual std::string* mutable_parallel_conf() = 0;
  virtual void set_parallel_conf(const std::string& parallel_conf) = 0;

  virtual const int64_t& root() const = 0;
  virtual int64_t* mutable_root() = 0;
  virtual void set_root(const int64_t& root) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class EagerNcclBroadcastOpInterpCtxImpl : public EagerNcclBroadcastOpInterpCtx {
 public:
  EagerNcclBroadcastOpInterpCtxImpl() = default;
  EagerNcclBroadcastOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& parallel_conf() const { return impl_.parallel_conf(); }
  std::string* mutable_parallel_conf() { return impl_.mutable_parallel_conf(); }
  void set_parallel_conf(const std::string& parallel_conf) { impl_.set_parallel_conf(parallel_conf); }
  
  const int64_t& root() const { return impl_.root(); }
  int64_t* mutable_root() { return impl_.mutable_root(); }
  void set_root(const int64_t& root) { impl_.set_root(root); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerNcclBroadcastOp {
 public:
  EagerNcclBroadcastOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& parallel_conf() const { return internal_->parallel_conf; }
  std::string* mutable_parallel_conf() { return &internal_->parallel_conf; }
  void set_parallel_conf(const std::string& parallel_conf) { internal_->parallel_conf = parallel_conf; }
  
  const int64_t& root() const { return internal_->root; }
  int64_t* mutable_root() { return &internal_->root; }
  void set_root(const int64_t& root) { internal_->root = root; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string parallel_conf;
    int64_t root = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class EagerNcclReduceOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~EagerNcclReduceOpInterpCtx() = default;

  virtual const std::string& parallel_conf() const = 0;
  virtual std::string* mutable_parallel_conf() = 0;
  virtual void set_parallel_conf(const std::string& parallel_conf) = 0;

  virtual const int64_t& root() const = 0;
  virtual int64_t* mutable_root() = 0;
  virtual void set_root(const int64_t& root) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class EagerNcclReduceOpInterpCtxImpl : public EagerNcclReduceOpInterpCtx {
 public:
  EagerNcclReduceOpInterpCtxImpl() = default;
  EagerNcclReduceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& parallel_conf() const { return impl_.parallel_conf(); }
  std::string* mutable_parallel_conf() { return impl_.mutable_parallel_conf(); }
  void set_parallel_conf(const std::string& parallel_conf) { impl_.set_parallel_conf(parallel_conf); }
  
  const int64_t& root() const { return impl_.root(); }
  int64_t* mutable_root() { return impl_.mutable_root(); }
  void set_root(const int64_t& root) { impl_.set_root(root); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerNcclReduceOp {
 public:
  EagerNcclReduceOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& parallel_conf() const { return internal_->parallel_conf; }
  std::string* mutable_parallel_conf() { return &internal_->parallel_conf; }
  void set_parallel_conf(const std::string& parallel_conf) { internal_->parallel_conf = parallel_conf; }
  
  const int64_t& root() const { return internal_->root; }
  int64_t* mutable_root() { return &internal_->root; }
  void set_root(const int64_t& root) { internal_->root = root; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string parallel_conf;
    int64_t root = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class EagerNcclReduceScatterOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~EagerNcclReduceScatterOpInterpCtx() = default;

  virtual const std::string& op_type() const = 0;
  virtual std::string* mutable_op_type() = 0;
  virtual void set_op_type(const std::string& op_type) = 0;

  virtual const std::string& parallel_conf() const = 0;
  virtual std::string* mutable_parallel_conf() = 0;
  virtual void set_parallel_conf(const std::string& parallel_conf) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class EagerNcclReduceScatterOpInterpCtxImpl : public EagerNcclReduceScatterOpInterpCtx {
 public:
  EagerNcclReduceScatterOpInterpCtxImpl() = default;
  EagerNcclReduceScatterOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& op_type() const { return impl_.op_type(); }
  std::string* mutable_op_type() { return impl_.mutable_op_type(); }
  void set_op_type(const std::string& op_type) { impl_.set_op_type(op_type); }
  
  const std::string& parallel_conf() const { return impl_.parallel_conf(); }
  std::string* mutable_parallel_conf() { return impl_.mutable_parallel_conf(); }
  void set_parallel_conf(const std::string& parallel_conf) { impl_.set_parallel_conf(parallel_conf); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerNcclReduceScatterOp {
 public:
  EagerNcclReduceScatterOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& op_type() const { return internal_->op_type; }
  std::string* mutable_op_type() { return &internal_->op_type; }
  void set_op_type(const std::string& op_type) { internal_->op_type = op_type; }
  
  const std::string& parallel_conf() const { return internal_->parallel_conf; }
  std::string* mutable_parallel_conf() { return &internal_->parallel_conf; }
  void set_parallel_conf(const std::string& parallel_conf) { internal_->parallel_conf = parallel_conf; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string op_type = "sum";
    std::string parallel_conf;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class EagerNcclS2sOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~EagerNcclS2sOpInterpCtx() = default;

  virtual const int64_t& in_split_axis() const = 0;
  virtual int64_t* mutable_in_split_axis() = 0;
  virtual void set_in_split_axis(const int64_t& in_split_axis) = 0;

  virtual const int64_t& out_split_axis() const = 0;
  virtual int64_t* mutable_out_split_axis() = 0;
  virtual void set_out_split_axis(const int64_t& out_split_axis) = 0;

  virtual const std::string& parallel_conf() const = 0;
  virtual std::string* mutable_parallel_conf() = 0;
  virtual void set_parallel_conf(const std::string& parallel_conf) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class EagerNcclS2sOpInterpCtxImpl : public EagerNcclS2sOpInterpCtx {
 public:
  EagerNcclS2sOpInterpCtxImpl() = default;
  EagerNcclS2sOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& in_split_axis() const { return impl_.in_split_axis(); }
  int64_t* mutable_in_split_axis() { return impl_.mutable_in_split_axis(); }
  void set_in_split_axis(const int64_t& in_split_axis) { impl_.set_in_split_axis(in_split_axis); }
  
  const int64_t& out_split_axis() const { return impl_.out_split_axis(); }
  int64_t* mutable_out_split_axis() { return impl_.mutable_out_split_axis(); }
  void set_out_split_axis(const int64_t& out_split_axis) { impl_.set_out_split_axis(out_split_axis); }
  
  const std::string& parallel_conf() const { return impl_.parallel_conf(); }
  std::string* mutable_parallel_conf() { return impl_.mutable_parallel_conf(); }
  void set_parallel_conf(const std::string& parallel_conf) { impl_.set_parallel_conf(parallel_conf); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerNcclS2sOp {
 public:
  EagerNcclS2sOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& in_split_axis() const { return internal_->in_split_axis; }
  int64_t* mutable_in_split_axis() { return &internal_->in_split_axis; }
  void set_in_split_axis(const int64_t& in_split_axis) { internal_->in_split_axis = in_split_axis; }
  
  const int64_t& out_split_axis() const { return internal_->out_split_axis; }
  int64_t* mutable_out_split_axis() { return &internal_->out_split_axis; }
  void set_out_split_axis(const int64_t& out_split_axis) { internal_->out_split_axis = out_split_axis; }
  
  const std::string& parallel_conf() const { return internal_->parallel_conf; }
  std::string* mutable_parallel_conf() { return &internal_->parallel_conf; }
  void set_parallel_conf(const std::string& parallel_conf) { internal_->parallel_conf = parallel_conf; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t in_split_axis = -1;
    int64_t out_split_axis = -1;
    std::string parallel_conf;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class EagerPToBOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~EagerPToBOpInterpCtx() = default;

  virtual const std::string& in_parallel_conf() const = 0;
  virtual std::string* mutable_in_parallel_conf() = 0;
  virtual void set_in_parallel_conf(const std::string& in_parallel_conf) = 0;

  virtual const std::string& out_parallel_conf() const = 0;
  virtual std::string* mutable_out_parallel_conf() = 0;
  virtual void set_out_parallel_conf(const std::string& out_parallel_conf) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class EagerPToBOpInterpCtxImpl : public EagerPToBOpInterpCtx {
 public:
  EagerPToBOpInterpCtxImpl() = default;
  EagerPToBOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& in_parallel_conf() const { return impl_.in_parallel_conf(); }
  std::string* mutable_in_parallel_conf() { return impl_.mutable_in_parallel_conf(); }
  void set_in_parallel_conf(const std::string& in_parallel_conf) { impl_.set_in_parallel_conf(in_parallel_conf); }
  
  const std::string& out_parallel_conf() const { return impl_.out_parallel_conf(); }
  std::string* mutable_out_parallel_conf() { return impl_.mutable_out_parallel_conf(); }
  void set_out_parallel_conf(const std::string& out_parallel_conf) { impl_.set_out_parallel_conf(out_parallel_conf); }
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerPToBOp {
 public:
  EagerPToBOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& in_parallel_conf() const { return internal_->in_parallel_conf; }
  std::string* mutable_in_parallel_conf() { return &internal_->in_parallel_conf; }
  void set_in_parallel_conf(const std::string& in_parallel_conf) { internal_->in_parallel_conf = in_parallel_conf; }
  
  const std::string& out_parallel_conf() const { return internal_->out_parallel_conf; }
  std::string* mutable_out_parallel_conf() { return &internal_->out_parallel_conf; }
  void set_out_parallel_conf(const std::string& out_parallel_conf) { internal_->out_parallel_conf = out_parallel_conf; }
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string in_parallel_conf;
    std::string out_parallel_conf;
    Shape shape;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class EagerPToSOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~EagerPToSOpInterpCtx() = default;

  virtual const std::string& in_parallel_conf() const = 0;
  virtual std::string* mutable_in_parallel_conf() = 0;
  virtual void set_in_parallel_conf(const std::string& in_parallel_conf) = 0;

  virtual const std::string& out_parallel_conf() const = 0;
  virtual std::string* mutable_out_parallel_conf() = 0;
  virtual void set_out_parallel_conf(const std::string& out_parallel_conf) = 0;

  virtual const int64_t& out_split_axis() const = 0;
  virtual int64_t* mutable_out_split_axis() = 0;
  virtual void set_out_split_axis(const int64_t& out_split_axis) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class EagerPToSOpInterpCtxImpl : public EagerPToSOpInterpCtx {
 public:
  EagerPToSOpInterpCtxImpl() = default;
  EagerPToSOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& in_parallel_conf() const { return impl_.in_parallel_conf(); }
  std::string* mutable_in_parallel_conf() { return impl_.mutable_in_parallel_conf(); }
  void set_in_parallel_conf(const std::string& in_parallel_conf) { impl_.set_in_parallel_conf(in_parallel_conf); }
  
  const std::string& out_parallel_conf() const { return impl_.out_parallel_conf(); }
  std::string* mutable_out_parallel_conf() { return impl_.mutable_out_parallel_conf(); }
  void set_out_parallel_conf(const std::string& out_parallel_conf) { impl_.set_out_parallel_conf(out_parallel_conf); }
  
  const int64_t& out_split_axis() const { return impl_.out_split_axis(); }
  int64_t* mutable_out_split_axis() { return impl_.mutable_out_split_axis(); }
  void set_out_split_axis(const int64_t& out_split_axis) { impl_.set_out_split_axis(out_split_axis); }
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerPToSOp {
 public:
  EagerPToSOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& in_parallel_conf() const { return internal_->in_parallel_conf; }
  std::string* mutable_in_parallel_conf() { return &internal_->in_parallel_conf; }
  void set_in_parallel_conf(const std::string& in_parallel_conf) { internal_->in_parallel_conf = in_parallel_conf; }
  
  const std::string& out_parallel_conf() const { return internal_->out_parallel_conf; }
  std::string* mutable_out_parallel_conf() { return &internal_->out_parallel_conf; }
  void set_out_parallel_conf(const std::string& out_parallel_conf) { internal_->out_parallel_conf = out_parallel_conf; }
  
  const int64_t& out_split_axis() const { return internal_->out_split_axis; }
  int64_t* mutable_out_split_axis() { return &internal_->out_split_axis; }
  void set_out_split_axis(const int64_t& out_split_axis) { internal_->out_split_axis = out_split_axis; }
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string in_parallel_conf;
    std::string out_parallel_conf;
    int64_t out_split_axis = -1;
    Shape shape;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class EagerSToBOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~EagerSToBOpInterpCtx() = default;

  virtual const std::string& in_parallel_conf() const = 0;
  virtual std::string* mutable_in_parallel_conf() = 0;
  virtual void set_in_parallel_conf(const std::string& in_parallel_conf) = 0;

  virtual const int64_t& in_split_axis() const = 0;
  virtual int64_t* mutable_in_split_axis() = 0;
  virtual void set_in_split_axis(const int64_t& in_split_axis) = 0;

  virtual const std::string& out_parallel_conf() const = 0;
  virtual std::string* mutable_out_parallel_conf() = 0;
  virtual void set_out_parallel_conf(const std::string& out_parallel_conf) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class EagerSToBOpInterpCtxImpl : public EagerSToBOpInterpCtx {
 public:
  EagerSToBOpInterpCtxImpl() = default;
  EagerSToBOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& in_parallel_conf() const { return impl_.in_parallel_conf(); }
  std::string* mutable_in_parallel_conf() { return impl_.mutable_in_parallel_conf(); }
  void set_in_parallel_conf(const std::string& in_parallel_conf) { impl_.set_in_parallel_conf(in_parallel_conf); }
  
  const int64_t& in_split_axis() const { return impl_.in_split_axis(); }
  int64_t* mutable_in_split_axis() { return impl_.mutable_in_split_axis(); }
  void set_in_split_axis(const int64_t& in_split_axis) { impl_.set_in_split_axis(in_split_axis); }
  
  const std::string& out_parallel_conf() const { return impl_.out_parallel_conf(); }
  std::string* mutable_out_parallel_conf() { return impl_.mutable_out_parallel_conf(); }
  void set_out_parallel_conf(const std::string& out_parallel_conf) { impl_.set_out_parallel_conf(out_parallel_conf); }
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerSToBOp {
 public:
  EagerSToBOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& in_parallel_conf() const { return internal_->in_parallel_conf; }
  std::string* mutable_in_parallel_conf() { return &internal_->in_parallel_conf; }
  void set_in_parallel_conf(const std::string& in_parallel_conf) { internal_->in_parallel_conf = in_parallel_conf; }
  
  const int64_t& in_split_axis() const { return internal_->in_split_axis; }
  int64_t* mutable_in_split_axis() { return &internal_->in_split_axis; }
  void set_in_split_axis(const int64_t& in_split_axis) { internal_->in_split_axis = in_split_axis; }
  
  const std::string& out_parallel_conf() const { return internal_->out_parallel_conf; }
  std::string* mutable_out_parallel_conf() { return &internal_->out_parallel_conf; }
  void set_out_parallel_conf(const std::string& out_parallel_conf) { internal_->out_parallel_conf = out_parallel_conf; }
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string in_parallel_conf;
    int64_t in_split_axis = -1;
    std::string out_parallel_conf;
    Shape shape;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class EagerSymmetricSToPOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~EagerSymmetricSToPOpInterpCtx() = default;

  virtual const int64_t& in_split_axis() const = 0;
  virtual int64_t* mutable_in_split_axis() = 0;
  virtual void set_in_split_axis(const int64_t& in_split_axis) = 0;

  virtual const std::string& parallel_conf() const = 0;
  virtual std::string* mutable_parallel_conf() = 0;
  virtual void set_parallel_conf(const std::string& parallel_conf) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class EagerSymmetricSToPOpInterpCtxImpl : public EagerSymmetricSToPOpInterpCtx {
 public:
  EagerSymmetricSToPOpInterpCtxImpl() = default;
  EagerSymmetricSToPOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& in_split_axis() const { return impl_.in_split_axis(); }
  int64_t* mutable_in_split_axis() { return impl_.mutable_in_split_axis(); }
  void set_in_split_axis(const int64_t& in_split_axis) { impl_.set_in_split_axis(in_split_axis); }
  
  const std::string& parallel_conf() const { return impl_.parallel_conf(); }
  std::string* mutable_parallel_conf() { return impl_.mutable_parallel_conf(); }
  void set_parallel_conf(const std::string& parallel_conf) { impl_.set_parallel_conf(parallel_conf); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerSymmetricSToPOp {
 public:
  EagerSymmetricSToPOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& in_split_axis() const { return internal_->in_split_axis; }
  int64_t* mutable_in_split_axis() { return &internal_->in_split_axis; }
  void set_in_split_axis(const int64_t& in_split_axis) { internal_->in_split_axis = in_split_axis; }
  
  const std::string& parallel_conf() const { return internal_->parallel_conf; }
  std::string* mutable_parallel_conf() { return &internal_->parallel_conf; }
  void set_parallel_conf(const std::string& parallel_conf) { internal_->parallel_conf = parallel_conf; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t in_split_axis = -1;
    std::string parallel_conf;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ElementwiseMaximumBackwardOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ElementwiseMaximumBackwardOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ElementwiseMaximumBackwardOpInterpCtxImpl : public ElementwiseMaximumBackwardOpInterpCtx {
 public:
  ElementwiseMaximumBackwardOpInterpCtxImpl() = default;
  ElementwiseMaximumBackwardOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ElementwiseMaximumBackwardOp {
 public:
  ElementwiseMaximumBackwardOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ElementwiseMaximumOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ElementwiseMaximumOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ElementwiseMaximumOpInterpCtxImpl : public ElementwiseMaximumOpInterpCtx {
 public:
  ElementwiseMaximumOpInterpCtxImpl() = default;
  ElementwiseMaximumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ElementwiseMaximumOp {
 public:
  ElementwiseMaximumOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ElementwiseMinimumBackwardOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ElementwiseMinimumBackwardOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ElementwiseMinimumBackwardOpInterpCtxImpl : public ElementwiseMinimumBackwardOpInterpCtx {
 public:
  ElementwiseMinimumBackwardOpInterpCtxImpl() = default;
  ElementwiseMinimumBackwardOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ElementwiseMinimumBackwardOp {
 public:
  ElementwiseMinimumBackwardOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ElementwiseMinimumOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ElementwiseMinimumOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ElementwiseMinimumOpInterpCtxImpl : public ElementwiseMinimumOpInterpCtx {
 public:
  ElementwiseMinimumOpInterpCtxImpl() = default;
  ElementwiseMinimumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ElementwiseMinimumOp {
 public:
  ElementwiseMinimumOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class EluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~EluGradOpInterpCtx() = default;

  virtual const double& alpha() const = 0;
  virtual double* mutable_alpha() = 0;
  virtual void set_alpha(const double& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class EluGradOpInterpCtxImpl : public EluGradOpInterpCtx {
 public:
  EluGradOpInterpCtxImpl() = default;
  EluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& alpha() const { return impl_.alpha(); }
  double* mutable_alpha() { return impl_.mutable_alpha(); }
  void set_alpha(const double& alpha) { impl_.set_alpha(alpha); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EluGradOp {
 public:
  EluGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& alpha() const { return internal_->alpha; }
  double* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const double& alpha) { internal_->alpha = alpha; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double alpha = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class EluOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~EluOpInterpCtx() = default;

  virtual const double& alpha() const = 0;
  virtual double* mutable_alpha() = 0;
  virtual void set_alpha(const double& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class EluOpInterpCtxImpl : public EluOpInterpCtx {
 public:
  EluOpInterpCtxImpl() = default;
  EluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& alpha() const { return impl_.alpha(); }
  double* mutable_alpha() { return impl_.mutable_alpha(); }
  void set_alpha(const double& alpha) { impl_.set_alpha(alpha); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EluOp {
 public:
  EluOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& alpha() const { return internal_->alpha; }
  double* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const double& alpha) { internal_->alpha = alpha; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double alpha = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class EmptyOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~EmptyOpInterpCtx() = default;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class EmptyOpInterpCtxImpl : public EmptyOpInterpCtx {
 public:
  EmptyOpInterpCtxImpl() = default;
  EmptyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const DataType& dtype() const { return impl_.dtype(); }
  DataType* mutable_dtype() { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) { impl_.set_dtype(dtype); }
  
  const std::vector<std::string>& nd_sbp() const { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { impl_.set_nd_sbp(nd_sbp); }
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EmptyOp {
 public:
  EmptyOp() : internal_(std::make_shared<Internal>()) {}
  
  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }
  
  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    DataType dtype;
    std::vector<std::string> nd_sbp;
    Shape shape;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ErfGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ErfGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ErfGradOpInterpCtxImpl : public ErfGradOpInterpCtx {
 public:
  ErfGradOpInterpCtxImpl() = default;
  ErfGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ErfGradOp {
 public:
  ErfGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ErfOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ErfOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ErfOpInterpCtxImpl : public ErfOpInterpCtx {
 public:
  ErfOpInterpCtxImpl() = default;
  ErfOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ErfOp {
 public:
  ErfOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ErfcGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ErfcGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ErfcGradOpInterpCtxImpl : public ErfcGradOpInterpCtx {
 public:
  ErfcGradOpInterpCtxImpl() = default;
  ErfcGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ErfcGradOp {
 public:
  ErfcGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ErfcOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ErfcOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ErfcOpInterpCtxImpl : public ErfcOpInterpCtx {
 public:
  ErfcOpInterpCtxImpl() = default;
  ErfcOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ErfcOp {
 public:
  ErfcOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ExpGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ExpGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ExpGradOpInterpCtxImpl : public ExpGradOpInterpCtx {
 public:
  ExpGradOpInterpCtxImpl() = default;
  ExpGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ExpGradOp {
 public:
  ExpGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ExpOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ExpOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ExpOpInterpCtxImpl : public ExpOpInterpCtx {
 public:
  ExpOpInterpCtxImpl() = default;
  ExpOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ExpOp {
 public:
  ExpOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ExpandDimsOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ExpandDimsOpInterpCtx() = default;

  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ExpandDimsOpInterpCtxImpl : public ExpandDimsOpInterpCtx {
 public:
  ExpandDimsOpInterpCtxImpl() = default;
  ExpandDimsOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& axis() const { return impl_.axis(); }
  int32_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) { impl_.set_axis(axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ExpandDimsOp {
 public:
  ExpandDimsOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t axis = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ExpandGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ExpandGradOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& logical_expand_shape() const = 0;
  virtual std::vector<std::int32_t>* mutable_logical_expand_shape() = 0;
  virtual void set_logical_expand_shape(const std::vector<std::int32_t>& logical_expand_shape) = 0;

  virtual const std::vector<std::int32_t>& logical_out_shape() const = 0;
  virtual std::vector<std::int32_t>* mutable_logical_out_shape() = 0;
  virtual void set_logical_out_shape(const std::vector<std::int32_t>& logical_out_shape) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ExpandGradOpInterpCtxImpl : public ExpandGradOpInterpCtx {
 public:
  ExpandGradOpInterpCtxImpl() = default;
  ExpandGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& logical_expand_shape() const { return impl_.logical_expand_shape(); }
  std::vector<std::int32_t>* mutable_logical_expand_shape() { return impl_.mutable_logical_expand_shape(); }
  void set_logical_expand_shape(const std::vector<std::int32_t>& logical_expand_shape) { impl_.set_logical_expand_shape(logical_expand_shape); }
  
  const std::vector<std::int32_t>& logical_out_shape() const { return impl_.logical_out_shape(); }
  std::vector<std::int32_t>* mutable_logical_out_shape() { return impl_.mutable_logical_out_shape(); }
  void set_logical_out_shape(const std::vector<std::int32_t>& logical_out_shape) { impl_.set_logical_out_shape(logical_out_shape); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ExpandGradOp {
 public:
  ExpandGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& logical_expand_shape() const { return internal_->logical_expand_shape; }
  std::vector<std::int32_t>* mutable_logical_expand_shape() { return &internal_->logical_expand_shape; }
  void set_logical_expand_shape(const std::vector<std::int32_t>& logical_expand_shape) { internal_->logical_expand_shape = logical_expand_shape; }
  
  const std::vector<std::int32_t>& logical_out_shape() const { return internal_->logical_out_shape; }
  std::vector<std::int32_t>* mutable_logical_out_shape() { return &internal_->logical_out_shape; }
  void set_logical_out_shape(const std::vector<std::int32_t>& logical_out_shape) { internal_->logical_out_shape = logical_out_shape; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> logical_expand_shape;
    std::vector<std::int32_t> logical_out_shape;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ExpandOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ExpandOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& logical_expand_shape() const = 0;
  virtual std::vector<std::int32_t>* mutable_logical_expand_shape() = 0;
  virtual void set_logical_expand_shape(const std::vector<std::int32_t>& logical_expand_shape) = 0;

  virtual const std::vector<std::int32_t>& logical_in_shape() const = 0;
  virtual std::vector<std::int32_t>* mutable_logical_in_shape() = 0;
  virtual void set_logical_in_shape(const std::vector<std::int32_t>& logical_in_shape) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ExpandOpInterpCtxImpl : public ExpandOpInterpCtx {
 public:
  ExpandOpInterpCtxImpl() = default;
  ExpandOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& logical_expand_shape() const { return impl_.logical_expand_shape(); }
  std::vector<std::int32_t>* mutable_logical_expand_shape() { return impl_.mutable_logical_expand_shape(); }
  void set_logical_expand_shape(const std::vector<std::int32_t>& logical_expand_shape) { impl_.set_logical_expand_shape(logical_expand_shape); }
  
  const std::vector<std::int32_t>& logical_in_shape() const { return impl_.logical_in_shape(); }
  std::vector<std::int32_t>* mutable_logical_in_shape() { return impl_.mutable_logical_in_shape(); }
  void set_logical_in_shape(const std::vector<std::int32_t>& logical_in_shape) { impl_.set_logical_in_shape(logical_in_shape); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ExpandOp {
 public:
  ExpandOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& logical_expand_shape() const { return internal_->logical_expand_shape; }
  std::vector<std::int32_t>* mutable_logical_expand_shape() { return &internal_->logical_expand_shape; }
  void set_logical_expand_shape(const std::vector<std::int32_t>& logical_expand_shape) { internal_->logical_expand_shape = logical_expand_shape; }
  
  const std::vector<std::int32_t>& logical_in_shape() const { return internal_->logical_in_shape; }
  std::vector<std::int32_t>* mutable_logical_in_shape() { return &internal_->logical_in_shape; }
  void set_logical_in_shape(const std::vector<std::int32_t>& logical_in_shape) { internal_->logical_in_shape = logical_in_shape; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> logical_expand_shape;
    std::vector<std::int32_t> logical_in_shape;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class Expm1GradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~Expm1GradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class Expm1GradOpInterpCtxImpl : public Expm1GradOpInterpCtx {
 public:
  Expm1GradOpInterpCtxImpl() = default;
  Expm1GradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Expm1GradOp {
 public:
  Expm1GradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class Expm1OpInterpCtx : public OpInterpCtx {
 public:
  virtual ~Expm1OpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class Expm1OpInterpCtxImpl : public Expm1OpInterpCtx {
 public:
  Expm1OpInterpCtxImpl() = default;
  Expm1OpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Expm1Op {
 public:
  Expm1Op() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class EyeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~EyeOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class EyeOpInterpCtxImpl : public EyeOpInterpCtx {
 public:
  EyeOpInterpCtxImpl() = default;
  EyeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EyeOp {
 public:
  EyeOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FakeQuantizationOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FakeQuantizationOpInterpCtx() = default;

  virtual const int32_t& quantization_bit() const = 0;
  virtual int32_t* mutable_quantization_bit() = 0;
  virtual void set_quantization_bit(const int32_t& quantization_bit) = 0;

  virtual const std::string& quantization_formula() const = 0;
  virtual std::string* mutable_quantization_formula() = 0;
  virtual void set_quantization_formula(const std::string& quantization_formula) = 0;

  virtual const std::string& quantization_scheme() const = 0;
  virtual std::string* mutable_quantization_scheme() = 0;
  virtual void set_quantization_scheme(const std::string& quantization_scheme) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FakeQuantizationOpInterpCtxImpl : public FakeQuantizationOpInterpCtx {
 public:
  FakeQuantizationOpInterpCtxImpl() = default;
  FakeQuantizationOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& quantization_bit() const { return impl_.quantization_bit(); }
  int32_t* mutable_quantization_bit() { return impl_.mutable_quantization_bit(); }
  void set_quantization_bit(const int32_t& quantization_bit) { impl_.set_quantization_bit(quantization_bit); }
  
  const std::string& quantization_formula() const { return impl_.quantization_formula(); }
  std::string* mutable_quantization_formula() { return impl_.mutable_quantization_formula(); }
  void set_quantization_formula(const std::string& quantization_formula) { impl_.set_quantization_formula(quantization_formula); }
  
  const std::string& quantization_scheme() const { return impl_.quantization_scheme(); }
  std::string* mutable_quantization_scheme() { return impl_.mutable_quantization_scheme(); }
  void set_quantization_scheme(const std::string& quantization_scheme) { impl_.set_quantization_scheme(quantization_scheme); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FakeQuantizationOp {
 public:
  FakeQuantizationOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& quantization_bit() const { return internal_->quantization_bit; }
  int32_t* mutable_quantization_bit() { return &internal_->quantization_bit; }
  void set_quantization_bit(const int32_t& quantization_bit) { internal_->quantization_bit = quantization_bit; }
  
  const std::string& quantization_formula() const { return internal_->quantization_formula; }
  std::string* mutable_quantization_formula() { return &internal_->quantization_formula; }
  void set_quantization_formula(const std::string& quantization_formula) { internal_->quantization_formula = quantization_formula; }
  
  const std::string& quantization_scheme() const { return internal_->quantization_scheme; }
  std::string* mutable_quantization_scheme() { return &internal_->quantization_scheme; }
  void set_quantization_scheme(const std::string& quantization_scheme) { internal_->quantization_scheme = quantization_scheme; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t quantization_bit = 8;
    std::string quantization_formula = "google";
    std::string quantization_scheme = "symmetric";
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FlattenOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FlattenOpInterpCtx() = default;

  virtual const int32_t& end_dim() const = 0;
  virtual int32_t* mutable_end_dim() = 0;
  virtual void set_end_dim(const int32_t& end_dim) = 0;

  virtual const int32_t& start_dim() const = 0;
  virtual int32_t* mutable_start_dim() = 0;
  virtual void set_start_dim(const int32_t& start_dim) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FlattenOpInterpCtxImpl : public FlattenOpInterpCtx {
 public:
  FlattenOpInterpCtxImpl() = default;
  FlattenOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& end_dim() const { return impl_.end_dim(); }
  int32_t* mutable_end_dim() { return impl_.mutable_end_dim(); }
  void set_end_dim(const int32_t& end_dim) { impl_.set_end_dim(end_dim); }
  
  const int32_t& start_dim() const { return impl_.start_dim(); }
  int32_t* mutable_start_dim() { return impl_.mutable_start_dim(); }
  void set_start_dim(const int32_t& start_dim) { impl_.set_start_dim(start_dim); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FlattenOp {
 public:
  FlattenOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& end_dim() const { return internal_->end_dim; }
  int32_t* mutable_end_dim() { return &internal_->end_dim; }
  void set_end_dim(const int32_t& end_dim) { internal_->end_dim = end_dim; }
  
  const int32_t& start_dim() const { return internal_->start_dim; }
  int32_t* mutable_start_dim() { return &internal_->start_dim; }
  void set_start_dim(const int32_t& start_dim) { internal_->start_dim = start_dim; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t end_dim = -1;
    int32_t start_dim = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FlipGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FlipGradOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& dims() const = 0;
  virtual std::vector<std::int32_t>* mutable_dims() = 0;
  virtual void set_dims(const std::vector<std::int32_t>& dims) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FlipGradOpInterpCtxImpl : public FlipGradOpInterpCtx {
 public:
  FlipGradOpInterpCtxImpl() = default;
  FlipGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& dims() const { return impl_.dims(); }
  std::vector<std::int32_t>* mutable_dims() { return impl_.mutable_dims(); }
  void set_dims(const std::vector<std::int32_t>& dims) { impl_.set_dims(dims); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FlipGradOp {
 public:
  FlipGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& dims() const { return internal_->dims; }
  std::vector<std::int32_t>* mutable_dims() { return &internal_->dims; }
  void set_dims(const std::vector<std::int32_t>& dims) { internal_->dims = dims; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> dims;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FlipOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FlipOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& dims() const = 0;
  virtual std::vector<std::int32_t>* mutable_dims() = 0;
  virtual void set_dims(const std::vector<std::int32_t>& dims) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FlipOpInterpCtxImpl : public FlipOpInterpCtx {
 public:
  FlipOpInterpCtxImpl() = default;
  FlipOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& dims() const { return impl_.dims(); }
  std::vector<std::int32_t>* mutable_dims() { return impl_.mutable_dims(); }
  void set_dims(const std::vector<std::int32_t>& dims) { impl_.set_dims(dims); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FlipOp {
 public:
  FlipOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& dims() const { return internal_->dims; }
  std::vector<std::int32_t>* mutable_dims() { return &internal_->dims; }
  void set_dims(const std::vector<std::int32_t>& dims) { internal_->dims = dims; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> dims;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FloorGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FloorGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FloorGradOpInterpCtxImpl : public FloorGradOpInterpCtx {
 public:
  FloorGradOpInterpCtxImpl() = default;
  FloorGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FloorGradOp {
 public:
  FloorGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FloorOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FloorOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FloorOpInterpCtxImpl : public FloorOpInterpCtx {
 public:
  FloorOpInterpCtxImpl() = default;
  FloorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FloorOp {
 public:
  FloorOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FloordivOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FloordivOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FloordivOpInterpCtxImpl : public FloordivOpInterpCtx {
 public:
  FloordivOpInterpCtxImpl() = default;
  FloordivOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FloordivOp {
 public:
  FloordivOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FloordivXGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FloordivXGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FloordivXGradOpInterpCtxImpl : public FloordivXGradOpInterpCtx {
 public:
  FloordivXGradOpInterpCtxImpl() = default;
  FloordivXGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FloordivXGradOp {
 public:
  FloordivXGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FloordivYGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FloordivYGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FloordivYGradOpInterpCtxImpl : public FloordivYGradOpInterpCtx {
 public:
  FloordivYGradOpInterpCtxImpl() = default;
  FloordivYGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FloordivYGradOp {
 public:
  FloordivYGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FlushSummaryWriterOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FlushSummaryWriterOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FlushSummaryWriterOpInterpCtxImpl : public FlushSummaryWriterOpInterpCtx {
 public:
  FlushSummaryWriterOpInterpCtxImpl() = default;
  FlushSummaryWriterOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FlushSummaryWriterOp {
 public:
  FlushSummaryWriterOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FoldOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FoldOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& dilation_rate() const = 0;
  virtual std::vector<std::int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& output_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_output_size() = 0;
  virtual void set_output_size(const std::vector<std::int32_t>& output_size) = 0;

  virtual const std::vector<std::int32_t>& padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int32_t>& padding) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FoldOpInterpCtxImpl : public FoldOpInterpCtx {
 public:
  FoldOpInterpCtxImpl() = default;
  FoldOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& dilation_rate() const { return impl_.dilation_rate(); }
  std::vector<std::int32_t>* mutable_dilation_rate() { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { impl_.set_dilation_rate(dilation_rate); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& output_size() const { return impl_.output_size(); }
  std::vector<std::int32_t>* mutable_output_size() { return impl_.mutable_output_size(); }
  void set_output_size(const std::vector<std::int32_t>& output_size) { impl_.set_output_size(output_size); }
  
  const std::vector<std::int32_t>& padding() const { return impl_.padding(); }
  std::vector<std::int32_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int32_t>& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FoldOp {
 public:
  FoldOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<std::int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { internal_->dilation_rate = dilation_rate; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& output_size() const { return internal_->output_size; }
  std::vector<std::int32_t>* mutable_output_size() { return &internal_->output_size; }
  void set_output_size(const std::vector<std::int32_t>& output_size) { internal_->output_size = output_size; }
  
  const std::vector<std::int32_t>& padding() const { return internal_->padding; }
  std::vector<std::int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int32_t>& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> dilation_rate;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> output_size;
    std::vector<std::int32_t> padding;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FusedBiasAddGeluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FusedBiasAddGeluGradOpInterpCtx() = default;

  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FusedBiasAddGeluGradOpInterpCtxImpl : public FusedBiasAddGeluGradOpInterpCtx {
 public:
  FusedBiasAddGeluGradOpInterpCtxImpl() = default;
  FusedBiasAddGeluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& axis() const { return impl_.axis(); }
  int32_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) { impl_.set_axis(axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedBiasAddGeluGradOp {
 public:
  FusedBiasAddGeluGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t axis = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FusedBiasAddGeluOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FusedBiasAddGeluOpInterpCtx() = default;

  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FusedBiasAddGeluOpInterpCtxImpl : public FusedBiasAddGeluOpInterpCtx {
 public:
  FusedBiasAddGeluOpInterpCtxImpl() = default;
  FusedBiasAddGeluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& axis() const { return impl_.axis(); }
  int32_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) { impl_.set_axis(axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedBiasAddGeluOp {
 public:
  FusedBiasAddGeluOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t axis = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FusedBiasAddMaskScaleOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FusedBiasAddMaskScaleOpInterpCtx() = default;

  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  virtual const float& scale() const = 0;
  virtual float* mutable_scale() = 0;
  virtual void set_scale(const float& scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FusedBiasAddMaskScaleOpInterpCtxImpl : public FusedBiasAddMaskScaleOpInterpCtx {
 public:
  FusedBiasAddMaskScaleOpInterpCtxImpl() = default;
  FusedBiasAddMaskScaleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& axis() const { return impl_.axis(); }
  int32_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) { impl_.set_axis(axis); }
  
  const float& scale() const { return impl_.scale(); }
  float* mutable_scale() { return impl_.mutable_scale(); }
  void set_scale(const float& scale) { impl_.set_scale(scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedBiasAddMaskScaleOp {
 public:
  FusedBiasAddMaskScaleOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }
  
  const float& scale() const { return internal_->scale; }
  float* mutable_scale() { return &internal_->scale; }
  void set_scale(const float& scale) { internal_->scale = scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t axis = 0;
    float scale = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FusedCastScaleOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FusedCastScaleOpInterpCtx() = default;

  virtual const double& scale() const = 0;
  virtual double* mutable_scale() = 0;
  virtual void set_scale(const double& scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FusedCastScaleOpInterpCtxImpl : public FusedCastScaleOpInterpCtx {
 public:
  FusedCastScaleOpInterpCtxImpl() = default;
  FusedCastScaleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& scale() const { return impl_.scale(); }
  double* mutable_scale() { return impl_.mutable_scale(); }
  void set_scale(const double& scale) { impl_.set_scale(scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedCastScaleOp {
 public:
  FusedCastScaleOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& scale() const { return internal_->scale; }
  double* mutable_scale() { return &internal_->scale; }
  void set_scale(const double& scale) { internal_->scale = scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double scale = 1.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FusedScaleMaskSoftmaxDropoutGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FusedScaleMaskSoftmaxDropoutGradOpInterpCtx() = default;

  virtual const float& dropout_scale_value() const = 0;
  virtual float* mutable_dropout_scale_value() = 0;
  virtual void set_dropout_scale_value(const float& dropout_scale_value) = 0;

  virtual const float& scale_value() const = 0;
  virtual float* mutable_scale_value() = 0;
  virtual void set_scale_value(const float& scale_value) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FusedScaleMaskSoftmaxDropoutGradOpInterpCtxImpl : public FusedScaleMaskSoftmaxDropoutGradOpInterpCtx {
 public:
  FusedScaleMaskSoftmaxDropoutGradOpInterpCtxImpl() = default;
  FusedScaleMaskSoftmaxDropoutGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& dropout_scale_value() const { return impl_.dropout_scale_value(); }
  float* mutable_dropout_scale_value() { return impl_.mutable_dropout_scale_value(); }
  void set_dropout_scale_value(const float& dropout_scale_value) { impl_.set_dropout_scale_value(dropout_scale_value); }
  
  const float& scale_value() const { return impl_.scale_value(); }
  float* mutable_scale_value() { return impl_.mutable_scale_value(); }
  void set_scale_value(const float& scale_value) { impl_.set_scale_value(scale_value); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedScaleMaskSoftmaxDropoutGradOp {
 public:
  FusedScaleMaskSoftmaxDropoutGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& dropout_scale_value() const { return internal_->dropout_scale_value; }
  float* mutable_dropout_scale_value() { return &internal_->dropout_scale_value; }
  void set_dropout_scale_value(const float& dropout_scale_value) { internal_->dropout_scale_value = dropout_scale_value; }
  
  const float& scale_value() const { return internal_->scale_value; }
  float* mutable_scale_value() { return &internal_->scale_value; }
  void set_scale_value(const float& scale_value) { internal_->scale_value = scale_value; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float dropout_scale_value = 0.;
    float scale_value = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FusedScaleMaskSoftmaxDropoutOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FusedScaleMaskSoftmaxDropoutOpInterpCtx() = default;

  virtual const float& dropout_scale_value() const = 0;
  virtual float* mutable_dropout_scale_value() = 0;
  virtual void set_dropout_scale_value(const float& dropout_scale_value) = 0;

  virtual const float& mask_fill_value() const = 0;
  virtual float* mutable_mask_fill_value() = 0;
  virtual void set_mask_fill_value(const float& mask_fill_value) = 0;

  virtual const float& scale_value() const = 0;
  virtual float* mutable_scale_value() = 0;
  virtual void set_scale_value(const float& scale_value) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FusedScaleMaskSoftmaxDropoutOpInterpCtxImpl : public FusedScaleMaskSoftmaxDropoutOpInterpCtx {
 public:
  FusedScaleMaskSoftmaxDropoutOpInterpCtxImpl() = default;
  FusedScaleMaskSoftmaxDropoutOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& dropout_scale_value() const { return impl_.dropout_scale_value(); }
  float* mutable_dropout_scale_value() { return impl_.mutable_dropout_scale_value(); }
  void set_dropout_scale_value(const float& dropout_scale_value) { impl_.set_dropout_scale_value(dropout_scale_value); }
  
  const float& mask_fill_value() const { return impl_.mask_fill_value(); }
  float* mutable_mask_fill_value() { return impl_.mutable_mask_fill_value(); }
  void set_mask_fill_value(const float& mask_fill_value) { impl_.set_mask_fill_value(mask_fill_value); }
  
  const float& scale_value() const { return impl_.scale_value(); }
  float* mutable_scale_value() { return impl_.mutable_scale_value(); }
  void set_scale_value(const float& scale_value) { impl_.set_scale_value(scale_value); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedScaleMaskSoftmaxDropoutOp {
 public:
  FusedScaleMaskSoftmaxDropoutOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& dropout_scale_value() const { return internal_->dropout_scale_value; }
  float* mutable_dropout_scale_value() { return &internal_->dropout_scale_value; }
  void set_dropout_scale_value(const float& dropout_scale_value) { internal_->dropout_scale_value = dropout_scale_value; }
  
  const float& mask_fill_value() const { return internal_->mask_fill_value; }
  float* mutable_mask_fill_value() { return &internal_->mask_fill_value; }
  void set_mask_fill_value(const float& mask_fill_value) { internal_->mask_fill_value = mask_fill_value; }
  
  const float& scale_value() const { return internal_->scale_value; }
  float* mutable_scale_value() { return &internal_->scale_value; }
  void set_scale_value(const float& scale_value) { internal_->scale_value = scale_value; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float dropout_scale_value = 1.;
    float mask_fill_value = 0.;
    float scale_value = 1.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FusedScaleMaskSoftmaxGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FusedScaleMaskSoftmaxGradOpInterpCtx() = default;

  virtual const float& scale_value() const = 0;
  virtual float* mutable_scale_value() = 0;
  virtual void set_scale_value(const float& scale_value) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FusedScaleMaskSoftmaxGradOpInterpCtxImpl : public FusedScaleMaskSoftmaxGradOpInterpCtx {
 public:
  FusedScaleMaskSoftmaxGradOpInterpCtxImpl() = default;
  FusedScaleMaskSoftmaxGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& scale_value() const { return impl_.scale_value(); }
  float* mutable_scale_value() { return impl_.mutable_scale_value(); }
  void set_scale_value(const float& scale_value) { impl_.set_scale_value(scale_value); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedScaleMaskSoftmaxGradOp {
 public:
  FusedScaleMaskSoftmaxGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& scale_value() const { return internal_->scale_value; }
  float* mutable_scale_value() { return &internal_->scale_value; }
  void set_scale_value(const float& scale_value) { internal_->scale_value = scale_value; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float scale_value = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FusedScaleMaskSoftmaxOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FusedScaleMaskSoftmaxOpInterpCtx() = default;

  virtual const float& mask_fill_value() const = 0;
  virtual float* mutable_mask_fill_value() = 0;
  virtual void set_mask_fill_value(const float& mask_fill_value) = 0;

  virtual const float& scale_value() const = 0;
  virtual float* mutable_scale_value() = 0;
  virtual void set_scale_value(const float& scale_value) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FusedScaleMaskSoftmaxOpInterpCtxImpl : public FusedScaleMaskSoftmaxOpInterpCtx {
 public:
  FusedScaleMaskSoftmaxOpInterpCtxImpl() = default;
  FusedScaleMaskSoftmaxOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& mask_fill_value() const { return impl_.mask_fill_value(); }
  float* mutable_mask_fill_value() { return impl_.mutable_mask_fill_value(); }
  void set_mask_fill_value(const float& mask_fill_value) { impl_.set_mask_fill_value(mask_fill_value); }
  
  const float& scale_value() const { return impl_.scale_value(); }
  float* mutable_scale_value() { return impl_.mutable_scale_value(); }
  void set_scale_value(const float& scale_value) { impl_.set_scale_value(scale_value); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedScaleMaskSoftmaxOp {
 public:
  FusedScaleMaskSoftmaxOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& mask_fill_value() const { return internal_->mask_fill_value; }
  float* mutable_mask_fill_value() { return &internal_->mask_fill_value; }
  void set_mask_fill_value(const float& mask_fill_value) { internal_->mask_fill_value = mask_fill_value; }
  
  const float& scale_value() const { return internal_->scale_value; }
  float* mutable_scale_value() { return &internal_->scale_value; }
  void set_scale_value(const float& scale_value) { internal_->scale_value = scale_value; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float mask_fill_value = 0.;
    float scale_value = 1.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FusedScaleTrilOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FusedScaleTrilOpInterpCtx() = default;

  virtual const int64_t& diagonal() const = 0;
  virtual int64_t* mutable_diagonal() = 0;
  virtual void set_diagonal(const int64_t& diagonal) = 0;

  virtual const double& floating_fill_value() const = 0;
  virtual double* mutable_floating_fill_value() = 0;
  virtual void set_floating_fill_value(const double& floating_fill_value) = 0;

  virtual const double& floating_scale_value() const = 0;
  virtual double* mutable_floating_scale_value() = 0;
  virtual void set_floating_scale_value(const double& floating_scale_value) = 0;

  virtual const int64_t& integer_fill_value() const = 0;
  virtual int64_t* mutable_integer_fill_value() = 0;
  virtual void set_integer_fill_value(const int64_t& integer_fill_value) = 0;

  virtual const int64_t& integer_scale_value() const = 0;
  virtual int64_t* mutable_integer_scale_value() = 0;
  virtual void set_integer_scale_value(const int64_t& integer_scale_value) = 0;

  virtual const bool& is_floating_fill_value() const = 0;
  virtual bool* mutable_is_floating_fill_value() = 0;
  virtual void set_is_floating_fill_value(const bool& is_floating_fill_value) = 0;

  virtual const bool& is_floating_scale_value() const = 0;
  virtual bool* mutable_is_floating_scale_value() = 0;
  virtual void set_is_floating_scale_value(const bool& is_floating_scale_value) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FusedScaleTrilOpInterpCtxImpl : public FusedScaleTrilOpInterpCtx {
 public:
  FusedScaleTrilOpInterpCtxImpl() = default;
  FusedScaleTrilOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& diagonal() const { return impl_.diagonal(); }
  int64_t* mutable_diagonal() { return impl_.mutable_diagonal(); }
  void set_diagonal(const int64_t& diagonal) { impl_.set_diagonal(diagonal); }
  
  const double& floating_fill_value() const { return impl_.floating_fill_value(); }
  double* mutable_floating_fill_value() { return impl_.mutable_floating_fill_value(); }
  void set_floating_fill_value(const double& floating_fill_value) { impl_.set_floating_fill_value(floating_fill_value); }
  
  const double& floating_scale_value() const { return impl_.floating_scale_value(); }
  double* mutable_floating_scale_value() { return impl_.mutable_floating_scale_value(); }
  void set_floating_scale_value(const double& floating_scale_value) { impl_.set_floating_scale_value(floating_scale_value); }
  
  const int64_t& integer_fill_value() const { return impl_.integer_fill_value(); }
  int64_t* mutable_integer_fill_value() { return impl_.mutable_integer_fill_value(); }
  void set_integer_fill_value(const int64_t& integer_fill_value) { impl_.set_integer_fill_value(integer_fill_value); }
  
  const int64_t& integer_scale_value() const { return impl_.integer_scale_value(); }
  int64_t* mutable_integer_scale_value() { return impl_.mutable_integer_scale_value(); }
  void set_integer_scale_value(const int64_t& integer_scale_value) { impl_.set_integer_scale_value(integer_scale_value); }
  
  const bool& is_floating_fill_value() const { return impl_.is_floating_fill_value(); }
  bool* mutable_is_floating_fill_value() { return impl_.mutable_is_floating_fill_value(); }
  void set_is_floating_fill_value(const bool& is_floating_fill_value) { impl_.set_is_floating_fill_value(is_floating_fill_value); }
  
  const bool& is_floating_scale_value() const { return impl_.is_floating_scale_value(); }
  bool* mutable_is_floating_scale_value() { return impl_.mutable_is_floating_scale_value(); }
  void set_is_floating_scale_value(const bool& is_floating_scale_value) { impl_.set_is_floating_scale_value(is_floating_scale_value); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedScaleTrilOp {
 public:
  FusedScaleTrilOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& diagonal() const { return internal_->diagonal; }
  int64_t* mutable_diagonal() { return &internal_->diagonal; }
  void set_diagonal(const int64_t& diagonal) { internal_->diagonal = diagonal; }
  
  const double& floating_fill_value() const { return internal_->floating_fill_value; }
  double* mutable_floating_fill_value() { return &internal_->floating_fill_value; }
  void set_floating_fill_value(const double& floating_fill_value) { internal_->floating_fill_value = floating_fill_value; }
  
  const double& floating_scale_value() const { return internal_->floating_scale_value; }
  double* mutable_floating_scale_value() { return &internal_->floating_scale_value; }
  void set_floating_scale_value(const double& floating_scale_value) { internal_->floating_scale_value = floating_scale_value; }
  
  const int64_t& integer_fill_value() const { return internal_->integer_fill_value; }
  int64_t* mutable_integer_fill_value() { return &internal_->integer_fill_value; }
  void set_integer_fill_value(const int64_t& integer_fill_value) { internal_->integer_fill_value = integer_fill_value; }
  
  const int64_t& integer_scale_value() const { return internal_->integer_scale_value; }
  int64_t* mutable_integer_scale_value() { return &internal_->integer_scale_value; }
  void set_integer_scale_value(const int64_t& integer_scale_value) { internal_->integer_scale_value = integer_scale_value; }
  
  const bool& is_floating_fill_value() const { return internal_->is_floating_fill_value; }
  bool* mutable_is_floating_fill_value() { return &internal_->is_floating_fill_value; }
  void set_is_floating_fill_value(const bool& is_floating_fill_value) { internal_->is_floating_fill_value = is_floating_fill_value; }
  
  const bool& is_floating_scale_value() const { return internal_->is_floating_scale_value; }
  bool* mutable_is_floating_scale_value() { return &internal_->is_floating_scale_value; }
  void set_is_floating_scale_value(const bool& is_floating_scale_value) { internal_->is_floating_scale_value = is_floating_scale_value; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t diagonal = 0;
    double floating_fill_value = 0.;
    double floating_scale_value = 1.;
    int64_t integer_fill_value = 0;
    int64_t integer_scale_value = 1;
    bool is_floating_fill_value = false;
    bool is_floating_scale_value = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FusedSelfAttentionQueryMulKeyAndValueGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FusedSelfAttentionQueryMulKeyAndValueGradOpInterpCtx() = default;

  virtual const float& alpha() const = 0;
  virtual float* mutable_alpha() = 0;
  virtual void set_alpha(const float& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FusedSelfAttentionQueryMulKeyAndValueGradOpInterpCtxImpl : public FusedSelfAttentionQueryMulKeyAndValueGradOpInterpCtx {
 public:
  FusedSelfAttentionQueryMulKeyAndValueGradOpInterpCtxImpl() = default;
  FusedSelfAttentionQueryMulKeyAndValueGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& alpha() const { return impl_.alpha(); }
  float* mutable_alpha() { return impl_.mutable_alpha(); }
  void set_alpha(const float& alpha) { impl_.set_alpha(alpha); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedSelfAttentionQueryMulKeyAndValueGradOp {
 public:
  FusedSelfAttentionQueryMulKeyAndValueGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& alpha() const { return internal_->alpha; }
  float* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const float& alpha) { internal_->alpha = alpha; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float alpha = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FusedSelfAttentionQueryMulKeyAndValueOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FusedSelfAttentionQueryMulKeyAndValueOpInterpCtx() = default;

  virtual const float& alpha() const = 0;
  virtual float* mutable_alpha() = 0;
  virtual void set_alpha(const float& alpha) = 0;

  virtual const int64_t& head_size() const = 0;
  virtual int64_t* mutable_head_size() = 0;
  virtual void set_head_size(const int64_t& head_size) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FusedSelfAttentionQueryMulKeyAndValueOpInterpCtxImpl : public FusedSelfAttentionQueryMulKeyAndValueOpInterpCtx {
 public:
  FusedSelfAttentionQueryMulKeyAndValueOpInterpCtxImpl() = default;
  FusedSelfAttentionQueryMulKeyAndValueOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& alpha() const { return impl_.alpha(); }
  float* mutable_alpha() { return impl_.mutable_alpha(); }
  void set_alpha(const float& alpha) { impl_.set_alpha(alpha); }
  
  const int64_t& head_size() const { return impl_.head_size(); }
  int64_t* mutable_head_size() { return impl_.mutable_head_size(); }
  void set_head_size(const int64_t& head_size) { impl_.set_head_size(head_size); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedSelfAttentionQueryMulKeyAndValueOp {
 public:
  FusedSelfAttentionQueryMulKeyAndValueOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& alpha() const { return internal_->alpha; }
  float* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const float& alpha) { internal_->alpha = alpha; }
  
  const int64_t& head_size() const { return internal_->head_size; }
  int64_t* mutable_head_size() { return &internal_->head_size; }
  void set_head_size(const int64_t& head_size) { internal_->head_size = head_size; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float alpha = 0.;
    int64_t head_size = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FusedTrilScaleSoftmaxMaskScaleGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FusedTrilScaleSoftmaxMaskScaleGradOpInterpCtx() = default;

  virtual const int64_t& diagonal() const = 0;
  virtual int64_t* mutable_diagonal() = 0;
  virtual void set_diagonal(const int64_t& diagonal) = 0;

  virtual const float& mask_scale_value() const = 0;
  virtual float* mutable_mask_scale_value() = 0;
  virtual void set_mask_scale_value(const float& mask_scale_value) = 0;

  virtual const float& tril_scale_value() const = 0;
  virtual float* mutable_tril_scale_value() = 0;
  virtual void set_tril_scale_value(const float& tril_scale_value) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FusedTrilScaleSoftmaxMaskScaleGradOpInterpCtxImpl : public FusedTrilScaleSoftmaxMaskScaleGradOpInterpCtx {
 public:
  FusedTrilScaleSoftmaxMaskScaleGradOpInterpCtxImpl() = default;
  FusedTrilScaleSoftmaxMaskScaleGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& diagonal() const { return impl_.diagonal(); }
  int64_t* mutable_diagonal() { return impl_.mutable_diagonal(); }
  void set_diagonal(const int64_t& diagonal) { impl_.set_diagonal(diagonal); }
  
  const float& mask_scale_value() const { return impl_.mask_scale_value(); }
  float* mutable_mask_scale_value() { return impl_.mutable_mask_scale_value(); }
  void set_mask_scale_value(const float& mask_scale_value) { impl_.set_mask_scale_value(mask_scale_value); }
  
  const float& tril_scale_value() const { return impl_.tril_scale_value(); }
  float* mutable_tril_scale_value() { return impl_.mutable_tril_scale_value(); }
  void set_tril_scale_value(const float& tril_scale_value) { impl_.set_tril_scale_value(tril_scale_value); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedTrilScaleSoftmaxMaskScaleGradOp {
 public:
  FusedTrilScaleSoftmaxMaskScaleGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& diagonal() const { return internal_->diagonal; }
  int64_t* mutable_diagonal() { return &internal_->diagonal; }
  void set_diagonal(const int64_t& diagonal) { internal_->diagonal = diagonal; }
  
  const float& mask_scale_value() const { return internal_->mask_scale_value; }
  float* mutable_mask_scale_value() { return &internal_->mask_scale_value; }
  void set_mask_scale_value(const float& mask_scale_value) { internal_->mask_scale_value = mask_scale_value; }
  
  const float& tril_scale_value() const { return internal_->tril_scale_value; }
  float* mutable_tril_scale_value() { return &internal_->tril_scale_value; }
  void set_tril_scale_value(const float& tril_scale_value) { internal_->tril_scale_value = tril_scale_value; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t diagonal = 0;
    float mask_scale_value = 0.;
    float tril_scale_value = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class FusedTrilScaleSoftmaxMaskScaleOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~FusedTrilScaleSoftmaxMaskScaleOpInterpCtx() = default;

  virtual const int64_t& diagonal() const = 0;
  virtual int64_t* mutable_diagonal() = 0;
  virtual void set_diagonal(const int64_t& diagonal) = 0;

  virtual const float& mask_scale_value() const = 0;
  virtual float* mutable_mask_scale_value() = 0;
  virtual void set_mask_scale_value(const float& mask_scale_value) = 0;

  virtual const float& tril_fill_value() const = 0;
  virtual float* mutable_tril_fill_value() = 0;
  virtual void set_tril_fill_value(const float& tril_fill_value) = 0;

  virtual const float& tril_scale_value() const = 0;
  virtual float* mutable_tril_scale_value() = 0;
  virtual void set_tril_scale_value(const float& tril_scale_value) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class FusedTrilScaleSoftmaxMaskScaleOpInterpCtxImpl : public FusedTrilScaleSoftmaxMaskScaleOpInterpCtx {
 public:
  FusedTrilScaleSoftmaxMaskScaleOpInterpCtxImpl() = default;
  FusedTrilScaleSoftmaxMaskScaleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& diagonal() const { return impl_.diagonal(); }
  int64_t* mutable_diagonal() { return impl_.mutable_diagonal(); }
  void set_diagonal(const int64_t& diagonal) { impl_.set_diagonal(diagonal); }
  
  const float& mask_scale_value() const { return impl_.mask_scale_value(); }
  float* mutable_mask_scale_value() { return impl_.mutable_mask_scale_value(); }
  void set_mask_scale_value(const float& mask_scale_value) { impl_.set_mask_scale_value(mask_scale_value); }
  
  const float& tril_fill_value() const { return impl_.tril_fill_value(); }
  float* mutable_tril_fill_value() { return impl_.mutable_tril_fill_value(); }
  void set_tril_fill_value(const float& tril_fill_value) { impl_.set_tril_fill_value(tril_fill_value); }
  
  const float& tril_scale_value() const { return impl_.tril_scale_value(); }
  float* mutable_tril_scale_value() { return impl_.mutable_tril_scale_value(); }
  void set_tril_scale_value(const float& tril_scale_value) { impl_.set_tril_scale_value(tril_scale_value); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedTrilScaleSoftmaxMaskScaleOp {
 public:
  FusedTrilScaleSoftmaxMaskScaleOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& diagonal() const { return internal_->diagonal; }
  int64_t* mutable_diagonal() { return &internal_->diagonal; }
  void set_diagonal(const int64_t& diagonal) { internal_->diagonal = diagonal; }
  
  const float& mask_scale_value() const { return internal_->mask_scale_value; }
  float* mutable_mask_scale_value() { return &internal_->mask_scale_value; }
  void set_mask_scale_value(const float& mask_scale_value) { internal_->mask_scale_value = mask_scale_value; }
  
  const float& tril_fill_value() const { return internal_->tril_fill_value; }
  float* mutable_tril_fill_value() { return &internal_->tril_fill_value; }
  void set_tril_fill_value(const float& tril_fill_value) { internal_->tril_fill_value = tril_fill_value; }
  
  const float& tril_scale_value() const { return internal_->tril_scale_value; }
  float* mutable_tril_scale_value() { return &internal_->tril_scale_value; }
  void set_tril_scale_value(const float& tril_scale_value) { internal_->tril_scale_value = tril_scale_value; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t diagonal = 0;
    float mask_scale_value = 1.;
    float tril_fill_value = 0.;
    float tril_scale_value = 1.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class GatherNdOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~GatherNdOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class GatherNdOpInterpCtxImpl : public GatherNdOpInterpCtx {
 public:
  GatherNdOpInterpCtxImpl() = default;
  GatherNdOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class GatherNdOp {
 public:
  GatherNdOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class GatherOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~GatherOpInterpCtx() = default;

  virtual const int64_t& axis() const = 0;
  virtual int64_t* mutable_axis() = 0;
  virtual void set_axis(const int64_t& axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class GatherOpInterpCtxImpl : public GatherOpInterpCtx {
 public:
  GatherOpInterpCtxImpl() = default;
  GatherOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& axis() const { return impl_.axis(); }
  int64_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int64_t& axis) { impl_.set_axis(axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class GatherOp {
 public:
  GatherOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& axis() const { return internal_->axis; }
  int64_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int64_t& axis) { internal_->axis = axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t axis = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class GeluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~GeluGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class GeluGradOpInterpCtxImpl : public GeluGradOpInterpCtx {
 public:
  GeluGradOpInterpCtxImpl() = default;
  GeluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class GeluGradOp {
 public:
  GeluGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class GeluOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~GeluOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class GeluOpInterpCtxImpl : public GeluOpInterpCtx {
 public:
  GeluOpInterpCtxImpl() = default;
  GeluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class GeluOp {
 public:
  GeluOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class GenTensorBufferOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~GenTensorBufferOpInterpCtx() = default;

  virtual const DataType& data_type() const = 0;
  virtual DataType* mutable_data_type() = 0;
  virtual void set_data_type(const DataType& data_type) = 0;

  virtual const bool& dynamic_out() const = 0;
  virtual bool* mutable_dynamic_out() = 0;
  virtual void set_dynamic_out(const bool& dynamic_out) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  virtual const std::vector<Shape>& shape_list() const = 0;
  virtual std::vector<Shape>* mutable_shape_list() = 0;
  virtual void set_shape_list(const std::vector<Shape>& shape_list) = 0;

  virtual const std::vector<float>& value_list() const = 0;
  virtual std::vector<float>* mutable_value_list() = 0;
  virtual void set_value_list(const std::vector<float>& value_list) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class GenTensorBufferOpInterpCtxImpl : public GenTensorBufferOpInterpCtx {
 public:
  GenTensorBufferOpInterpCtxImpl() = default;
  GenTensorBufferOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const DataType& data_type() const { return impl_.data_type(); }
  DataType* mutable_data_type() { return impl_.mutable_data_type(); }
  void set_data_type(const DataType& data_type) { impl_.set_data_type(data_type); }
  
  const bool& dynamic_out() const { return impl_.dynamic_out(); }
  bool* mutable_dynamic_out() { return impl_.mutable_dynamic_out(); }
  void set_dynamic_out(const bool& dynamic_out) { impl_.set_dynamic_out(dynamic_out); }
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  const std::vector<Shape>& shape_list() const { return impl_.shape_list(); }
  std::vector<Shape>* mutable_shape_list() { return impl_.mutable_shape_list(); }
  void set_shape_list(const std::vector<Shape>& shape_list) { impl_.set_shape_list(shape_list); }
  
  const std::vector<float>& value_list() const { return impl_.value_list(); }
  std::vector<float>* mutable_value_list() { return impl_.mutable_value_list(); }
  void set_value_list(const std::vector<float>& value_list) { impl_.set_value_list(value_list); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class GenTensorBufferOp {
 public:
  GenTensorBufferOp() : internal_(std::make_shared<Internal>()) {}
  
  const DataType& data_type() const { return internal_->data_type; }
  DataType* mutable_data_type() { return &internal_->data_type; }
  void set_data_type(const DataType& data_type) { internal_->data_type = data_type; }
  
  const bool& dynamic_out() const { return internal_->dynamic_out; }
  bool* mutable_dynamic_out() { return &internal_->dynamic_out; }
  void set_dynamic_out(const bool& dynamic_out) { internal_->dynamic_out = dynamic_out; }
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  const std::vector<Shape>& shape_list() const { return internal_->shape_list; }
  std::vector<Shape>* mutable_shape_list() { return &internal_->shape_list; }
  void set_shape_list(const std::vector<Shape>& shape_list) { internal_->shape_list = shape_list; }
  
  const std::vector<float>& value_list() const { return internal_->value_list; }
  std::vector<float>* mutable_value_list() { return &internal_->value_list; }
  void set_value_list(const std::vector<float>& value_list) { internal_->value_list = value_list; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    DataType data_type;
    bool dynamic_out = false;
    Shape shape;
    std::vector<Shape> shape_list;
    std::vector<float> value_list;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class GenerateRandomBatchPermutationIndicesOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~GenerateRandomBatchPermutationIndicesOpInterpCtx() = default;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class GenerateRandomBatchPermutationIndicesOpInterpCtxImpl : public GenerateRandomBatchPermutationIndicesOpInterpCtx {
 public:
  GenerateRandomBatchPermutationIndicesOpInterpCtxImpl() = default;
  GenerateRandomBatchPermutationIndicesOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& seed() const { return impl_.seed(); }
  int64_t* mutable_seed() { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) { impl_.set_seed(seed); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class GenerateRandomBatchPermutationIndicesOp {
 public:
  GenerateRandomBatchPermutationIndicesOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t seed = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class GridSampleGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~GridSampleGradOpInterpCtx() = default;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& interpolation_mode() const = 0;
  virtual std::string* mutable_interpolation_mode() = 0;
  virtual void set_interpolation_mode(const std::string& interpolation_mode) = 0;

  virtual const std::string& padding_mode() const = 0;
  virtual std::string* mutable_padding_mode() = 0;
  virtual void set_padding_mode(const std::string& padding_mode) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class GridSampleGradOpInterpCtxImpl : public GridSampleGradOpInterpCtx {
 public:
  GridSampleGradOpInterpCtxImpl() = default;
  GridSampleGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& align_corners() const { return impl_.align_corners(); }
  bool* mutable_align_corners() { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) { impl_.set_align_corners(align_corners); }
  
  const std::string& interpolation_mode() const { return impl_.interpolation_mode(); }
  std::string* mutable_interpolation_mode() { return impl_.mutable_interpolation_mode(); }
  void set_interpolation_mode(const std::string& interpolation_mode) { impl_.set_interpolation_mode(interpolation_mode); }
  
  const std::string& padding_mode() const { return impl_.padding_mode(); }
  std::string* mutable_padding_mode() { return impl_.mutable_padding_mode(); }
  void set_padding_mode(const std::string& padding_mode) { impl_.set_padding_mode(padding_mode); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class GridSampleGradOp {
 public:
  GridSampleGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }
  
  const std::string& interpolation_mode() const { return internal_->interpolation_mode; }
  std::string* mutable_interpolation_mode() { return &internal_->interpolation_mode; }
  void set_interpolation_mode(const std::string& interpolation_mode) { internal_->interpolation_mode = interpolation_mode; }
  
  const std::string& padding_mode() const { return internal_->padding_mode; }
  std::string* mutable_padding_mode() { return &internal_->padding_mode; }
  void set_padding_mode(const std::string& padding_mode) { internal_->padding_mode = padding_mode; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool align_corners = false;
    std::string interpolation_mode;
    std::string padding_mode;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class GridSampleOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~GridSampleOpInterpCtx() = default;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& interpolation_mode() const = 0;
  virtual std::string* mutable_interpolation_mode() = 0;
  virtual void set_interpolation_mode(const std::string& interpolation_mode) = 0;

  virtual const std::string& padding_mode() const = 0;
  virtual std::string* mutable_padding_mode() = 0;
  virtual void set_padding_mode(const std::string& padding_mode) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class GridSampleOpInterpCtxImpl : public GridSampleOpInterpCtx {
 public:
  GridSampleOpInterpCtxImpl() = default;
  GridSampleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& align_corners() const { return impl_.align_corners(); }
  bool* mutable_align_corners() { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) { impl_.set_align_corners(align_corners); }
  
  const std::string& interpolation_mode() const { return impl_.interpolation_mode(); }
  std::string* mutable_interpolation_mode() { return impl_.mutable_interpolation_mode(); }
  void set_interpolation_mode(const std::string& interpolation_mode) { impl_.set_interpolation_mode(interpolation_mode); }
  
  const std::string& padding_mode() const { return impl_.padding_mode(); }
  std::string* mutable_padding_mode() { return impl_.mutable_padding_mode(); }
  void set_padding_mode(const std::string& padding_mode) { impl_.set_padding_mode(padding_mode); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class GridSampleOp {
 public:
  GridSampleOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }
  
  const std::string& interpolation_mode() const { return internal_->interpolation_mode; }
  std::string* mutable_interpolation_mode() { return &internal_->interpolation_mode; }
  void set_interpolation_mode(const std::string& interpolation_mode) { internal_->interpolation_mode = interpolation_mode; }
  
  const std::string& padding_mode() const { return internal_->padding_mode; }
  std::string* mutable_padding_mode() { return &internal_->padding_mode; }
  void set_padding_mode(const std::string& padding_mode) { internal_->padding_mode = padding_mode; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool align_corners = false;
    std::string interpolation_mode;
    std::string padding_mode;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class HardsigmoidGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~HardsigmoidGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class HardsigmoidGradOpInterpCtxImpl : public HardsigmoidGradOpInterpCtx {
 public:
  HardsigmoidGradOpInterpCtxImpl() = default;
  HardsigmoidGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class HardsigmoidGradOp {
 public:
  HardsigmoidGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class HardsigmoidOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~HardsigmoidOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class HardsigmoidOpInterpCtxImpl : public HardsigmoidOpInterpCtx {
 public:
  HardsigmoidOpInterpCtxImpl() = default;
  HardsigmoidOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class HardsigmoidOp {
 public:
  HardsigmoidOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class HardswishGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~HardswishGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class HardswishGradOpInterpCtxImpl : public HardswishGradOpInterpCtx {
 public:
  HardswishGradOpInterpCtxImpl() = default;
  HardswishGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class HardswishGradOp {
 public:
  HardswishGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class HardswishOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~HardswishOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class HardswishOpInterpCtxImpl : public HardswishOpInterpCtx {
 public:
  HardswishOpInterpCtxImpl() = default;
  HardswishOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class HardswishOp {
 public:
  HardswishOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class HardtanhGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~HardtanhGradOpInterpCtx() = default;

  virtual const double& max_val() const = 0;
  virtual double* mutable_max_val() = 0;
  virtual void set_max_val(const double& max_val) = 0;

  virtual const double& min_val() const = 0;
  virtual double* mutable_min_val() = 0;
  virtual void set_min_val(const double& min_val) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class HardtanhGradOpInterpCtxImpl : public HardtanhGradOpInterpCtx {
 public:
  HardtanhGradOpInterpCtxImpl() = default;
  HardtanhGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& max_val() const { return impl_.max_val(); }
  double* mutable_max_val() { return impl_.mutable_max_val(); }
  void set_max_val(const double& max_val) { impl_.set_max_val(max_val); }
  
  const double& min_val() const { return impl_.min_val(); }
  double* mutable_min_val() { return impl_.mutable_min_val(); }
  void set_min_val(const double& min_val) { impl_.set_min_val(min_val); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class HardtanhGradOp {
 public:
  HardtanhGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& max_val() const { return internal_->max_val; }
  double* mutable_max_val() { return &internal_->max_val; }
  void set_max_val(const double& max_val) { internal_->max_val = max_val; }
  
  const double& min_val() const { return internal_->min_val; }
  double* mutable_min_val() { return &internal_->min_val; }
  void set_min_val(const double& min_val) { internal_->min_val = min_val; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double max_val = 0.;
    double min_val = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class HardtanhOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~HardtanhOpInterpCtx() = default;

  virtual const double& max_val() const = 0;
  virtual double* mutable_max_val() = 0;
  virtual void set_max_val(const double& max_val) = 0;

  virtual const double& min_val() const = 0;
  virtual double* mutable_min_val() = 0;
  virtual void set_min_val(const double& min_val) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class HardtanhOpInterpCtxImpl : public HardtanhOpInterpCtx {
 public:
  HardtanhOpInterpCtxImpl() = default;
  HardtanhOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& max_val() const { return impl_.max_val(); }
  double* mutable_max_val() { return impl_.mutable_max_val(); }
  void set_max_val(const double& max_val) { impl_.set_max_val(max_val); }
  
  const double& min_val() const { return impl_.min_val(); }
  double* mutable_min_val() { return impl_.mutable_min_val(); }
  void set_min_val(const double& min_val) { impl_.set_min_val(min_val); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class HardtanhOp {
 public:
  HardtanhOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& max_val() const { return internal_->max_val; }
  double* mutable_max_val() { return &internal_->max_val; }
  void set_max_val(const double& max_val) { internal_->max_val = max_val; }
  
  const double& min_val() const { return internal_->min_val; }
  double* mutable_min_val() { return &internal_->min_val; }
  void set_min_val(const double& min_val) { internal_->min_val = min_val; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double max_val = 0.;
    double min_val = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class HierarchicalParallelCastLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~HierarchicalParallelCastLikeOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class HierarchicalParallelCastLikeOpInterpCtxImpl : public HierarchicalParallelCastLikeOpInterpCtx {
 public:
  HierarchicalParallelCastLikeOpInterpCtxImpl() = default;
  HierarchicalParallelCastLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class HierarchicalParallelCastLikeOp {
 public:
  HierarchicalParallelCastLikeOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class HierarchicalParallelCastOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~HierarchicalParallelCastOpInterpCtx() = default;

  virtual const std::string& grad_mode() const = 0;
  virtual std::string* mutable_grad_mode() = 0;
  virtual void set_grad_mode(const std::string& grad_mode) = 0;

  virtual const std::vector<std::string>& grad_nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_grad_nd_sbp() = 0;
  virtual void set_grad_nd_sbp(const std::vector<std::string>& grad_nd_sbp) = 0;

  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class HierarchicalParallelCastOpInterpCtxImpl : public HierarchicalParallelCastOpInterpCtx {
 public:
  HierarchicalParallelCastOpInterpCtxImpl() = default;
  HierarchicalParallelCastOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& grad_mode() const { return impl_.grad_mode(); }
  std::string* mutable_grad_mode() { return impl_.mutable_grad_mode(); }
  void set_grad_mode(const std::string& grad_mode) { impl_.set_grad_mode(grad_mode); }
  
  const std::vector<std::string>& grad_nd_sbp() const { return impl_.grad_nd_sbp(); }
  std::vector<std::string>* mutable_grad_nd_sbp() { return impl_.mutable_grad_nd_sbp(); }
  void set_grad_nd_sbp(const std::vector<std::string>& grad_nd_sbp) { impl_.set_grad_nd_sbp(grad_nd_sbp); }
  
  const std::vector<std::string>& nd_sbp() const { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { impl_.set_nd_sbp(nd_sbp); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class HierarchicalParallelCastOp {
 public:
  HierarchicalParallelCastOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& grad_mode() const { return internal_->grad_mode; }
  std::string* mutable_grad_mode() { return &internal_->grad_mode; }
  void set_grad_mode(const std::string& grad_mode) { internal_->grad_mode = grad_mode; }
  
  const std::vector<std::string>& grad_nd_sbp() const { return internal_->grad_nd_sbp; }
  std::vector<std::string>* mutable_grad_nd_sbp() { return &internal_->grad_nd_sbp; }
  void set_grad_nd_sbp(const std::vector<std::string>& grad_nd_sbp) { internal_->grad_nd_sbp = grad_nd_sbp; }
  
  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string grad_mode;
    std::vector<std::string> grad_nd_sbp;
    std::vector<std::string> nd_sbp;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class IdentityBufferOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~IdentityBufferOpInterpCtx() = default;

  virtual const int64_t& buffer_size() const = 0;
  virtual int64_t* mutable_buffer_size() = 0;
  virtual void set_buffer_size(const int64_t& buffer_size) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class IdentityBufferOpInterpCtxImpl : public IdentityBufferOpInterpCtx {
 public:
  IdentityBufferOpInterpCtxImpl() = default;
  IdentityBufferOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& buffer_size() const { return impl_.buffer_size(); }
  int64_t* mutable_buffer_size() { return impl_.mutable_buffer_size(); }
  void set_buffer_size(const int64_t& buffer_size) { impl_.set_buffer_size(buffer_size); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class IdentityBufferOp {
 public:
  IdentityBufferOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& buffer_size() const { return internal_->buffer_size; }
  int64_t* mutable_buffer_size() { return &internal_->buffer_size; }
  void set_buffer_size(const int64_t& buffer_size) { internal_->buffer_size = buffer_size; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t buffer_size = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class IdentityOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~IdentityOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class IdentityOpInterpCtxImpl : public IdentityOpInterpCtx {
 public:
  IdentityOpInterpCtxImpl() = default;
  IdentityOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class IdentityOp {
 public:
  IdentityOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ImageBatchAlignOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ImageBatchAlignOpInterpCtx() = default;

  virtual const int32_t& alignment() const = 0;
  virtual int32_t* mutable_alignment() = 0;
  virtual void set_alignment(const int32_t& alignment) = 0;

  virtual const DataType& data_type() const = 0;
  virtual DataType* mutable_data_type() = 0;
  virtual void set_data_type(const DataType& data_type) = 0;

  virtual const bool& dynamic_out() const = 0;
  virtual bool* mutable_dynamic_out() = 0;
  virtual void set_dynamic_out(const bool& dynamic_out) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ImageBatchAlignOpInterpCtxImpl : public ImageBatchAlignOpInterpCtx {
 public:
  ImageBatchAlignOpInterpCtxImpl() = default;
  ImageBatchAlignOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& alignment() const { return impl_.alignment(); }
  int32_t* mutable_alignment() { return impl_.mutable_alignment(); }
  void set_alignment(const int32_t& alignment) { impl_.set_alignment(alignment); }
  
  const DataType& data_type() const { return impl_.data_type(); }
  DataType* mutable_data_type() { return impl_.mutable_data_type(); }
  void set_data_type(const DataType& data_type) { impl_.set_data_type(data_type); }
  
  const bool& dynamic_out() const { return impl_.dynamic_out(); }
  bool* mutable_dynamic_out() { return impl_.mutable_dynamic_out(); }
  void set_dynamic_out(const bool& dynamic_out) { impl_.set_dynamic_out(dynamic_out); }
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ImageBatchAlignOp {
 public:
  ImageBatchAlignOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& alignment() const { return internal_->alignment; }
  int32_t* mutable_alignment() { return &internal_->alignment; }
  void set_alignment(const int32_t& alignment) { internal_->alignment = alignment; }
  
  const DataType& data_type() const { return internal_->data_type; }
  DataType* mutable_data_type() { return &internal_->data_type; }
  void set_data_type(const DataType& data_type) { internal_->data_type = data_type; }
  
  const bool& dynamic_out() const { return internal_->dynamic_out; }
  bool* mutable_dynamic_out() { return &internal_->dynamic_out; }
  void set_dynamic_out(const bool& dynamic_out) { internal_->dynamic_out = dynamic_out; }
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t alignment = 0;
    DataType data_type;
    bool dynamic_out = false;
    Shape shape;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ImageDecodeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ImageDecodeOpInterpCtx() = default;

  virtual const std::string& color_space() const = 0;
  virtual std::string* mutable_color_space() = 0;
  virtual void set_color_space(const std::string& color_space) = 0;

  virtual const DataType& data_type() const = 0;
  virtual DataType* mutable_data_type() = 0;
  virtual void set_data_type(const DataType& data_type) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ImageDecodeOpInterpCtxImpl : public ImageDecodeOpInterpCtx {
 public:
  ImageDecodeOpInterpCtxImpl() = default;
  ImageDecodeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& color_space() const { return impl_.color_space(); }
  std::string* mutable_color_space() { return impl_.mutable_color_space(); }
  void set_color_space(const std::string& color_space) { impl_.set_color_space(color_space); }
  
  const DataType& data_type() const { return impl_.data_type(); }
  DataType* mutable_data_type() { return impl_.mutable_data_type(); }
  void set_data_type(const DataType& data_type) { impl_.set_data_type(data_type); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ImageDecodeOp {
 public:
  ImageDecodeOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& color_space() const { return internal_->color_space; }
  std::string* mutable_color_space() { return &internal_->color_space; }
  void set_color_space(const std::string& color_space) { internal_->color_space = color_space; }
  
  const DataType& data_type() const { return internal_->data_type; }
  DataType* mutable_data_type() { return &internal_->data_type; }
  void set_data_type(const DataType& data_type) { internal_->data_type = data_type; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string color_space = "BGR";
    DataType data_type;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ImageFlipOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ImageFlipOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ImageFlipOpInterpCtxImpl : public ImageFlipOpInterpCtx {
 public:
  ImageFlipOpInterpCtxImpl() = default;
  ImageFlipOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ImageFlipOp {
 public:
  ImageFlipOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ImageNormalizeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ImageNormalizeOpInterpCtx() = default;

  virtual const std::vector<float>& mean() const = 0;
  virtual std::vector<float>* mutable_mean() = 0;
  virtual void set_mean(const std::vector<float>& mean) = 0;

  virtual const std::vector<float>& std() const = 0;
  virtual std::vector<float>* mutable_std() = 0;
  virtual void set_std(const std::vector<float>& std) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ImageNormalizeOpInterpCtxImpl : public ImageNormalizeOpInterpCtx {
 public:
  ImageNormalizeOpInterpCtxImpl() = default;
  ImageNormalizeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<float>& mean() const { return impl_.mean(); }
  std::vector<float>* mutable_mean() { return impl_.mutable_mean(); }
  void set_mean(const std::vector<float>& mean) { impl_.set_mean(mean); }
  
  const std::vector<float>& std() const { return impl_.std(); }
  std::vector<float>* mutable_std() { return impl_.mutable_std(); }
  void set_std(const std::vector<float>& std) { impl_.set_std(std); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ImageNormalizeOp {
 public:
  ImageNormalizeOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<float>& mean() const { return internal_->mean; }
  std::vector<float>* mutable_mean() { return &internal_->mean; }
  void set_mean(const std::vector<float>& mean) { internal_->mean = mean; }
  
  const std::vector<float>& std() const { return internal_->std; }
  std::vector<float>* mutable_std() { return &internal_->std; }
  void set_std(const std::vector<float>& std) { internal_->std = std; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<float> mean;
    std::vector<float> std;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ImageRandomCropOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ImageRandomCropOpInterpCtx() = default;

  virtual const bool& has_seed() const = 0;
  virtual bool* mutable_has_seed() = 0;
  virtual void set_has_seed(const bool& has_seed) = 0;

  virtual const int32_t& num_attempts() const = 0;
  virtual int32_t* mutable_num_attempts() = 0;
  virtual void set_num_attempts(const int32_t& num_attempts) = 0;

  virtual const std::vector<float>& random_area() const = 0;
  virtual std::vector<float>* mutable_random_area() = 0;
  virtual void set_random_area(const std::vector<float>& random_area) = 0;

  virtual const std::vector<float>& random_aspect_ratio() const = 0;
  virtual std::vector<float>* mutable_random_aspect_ratio() = 0;
  virtual void set_random_aspect_ratio(const std::vector<float>& random_aspect_ratio) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ImageRandomCropOpInterpCtxImpl : public ImageRandomCropOpInterpCtx {
 public:
  ImageRandomCropOpInterpCtxImpl() = default;
  ImageRandomCropOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& has_seed() const { return impl_.has_seed(); }
  bool* mutable_has_seed() { return impl_.mutable_has_seed(); }
  void set_has_seed(const bool& has_seed) { impl_.set_has_seed(has_seed); }
  
  const int32_t& num_attempts() const { return impl_.num_attempts(); }
  int32_t* mutable_num_attempts() { return impl_.mutable_num_attempts(); }
  void set_num_attempts(const int32_t& num_attempts) { impl_.set_num_attempts(num_attempts); }
  
  const std::vector<float>& random_area() const { return impl_.random_area(); }
  std::vector<float>* mutable_random_area() { return impl_.mutable_random_area(); }
  void set_random_area(const std::vector<float>& random_area) { impl_.set_random_area(random_area); }
  
  const std::vector<float>& random_aspect_ratio() const { return impl_.random_aspect_ratio(); }
  std::vector<float>* mutable_random_aspect_ratio() { return impl_.mutable_random_aspect_ratio(); }
  void set_random_aspect_ratio(const std::vector<float>& random_aspect_ratio) { impl_.set_random_aspect_ratio(random_aspect_ratio); }
  
  const int64_t& seed() const { return impl_.seed(); }
  int64_t* mutable_seed() { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) { impl_.set_seed(seed); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ImageRandomCropOp {
 public:
  ImageRandomCropOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& has_seed() const { return internal_->has_seed; }
  bool* mutable_has_seed() { return &internal_->has_seed; }
  void set_has_seed(const bool& has_seed) { internal_->has_seed = has_seed; }
  
  const int32_t& num_attempts() const { return internal_->num_attempts; }
  int32_t* mutable_num_attempts() { return &internal_->num_attempts; }
  void set_num_attempts(const int32_t& num_attempts) { internal_->num_attempts = num_attempts; }
  
  const std::vector<float>& random_area() const { return internal_->random_area; }
  std::vector<float>* mutable_random_area() { return &internal_->random_area; }
  void set_random_area(const std::vector<float>& random_area) { internal_->random_area = random_area; }
  
  const std::vector<float>& random_aspect_ratio() const { return internal_->random_aspect_ratio; }
  std::vector<float>* mutable_random_aspect_ratio() { return &internal_->random_aspect_ratio; }
  void set_random_aspect_ratio(const std::vector<float>& random_aspect_ratio) { internal_->random_aspect_ratio = random_aspect_ratio; }
  
  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool has_seed = false;
    int32_t num_attempts = 10;
    std::vector<float> random_area;
    std::vector<float> random_aspect_ratio;
    int64_t seed = -1;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ImageResizeKeepAspectRatioOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ImageResizeKeepAspectRatioOpInterpCtx() = default;

  virtual const std::string& interpolation_type() const = 0;
  virtual std::string* mutable_interpolation_type() = 0;
  virtual void set_interpolation_type(const std::string& interpolation_type) = 0;

  virtual const int32_t& max_size() const = 0;
  virtual int32_t* mutable_max_size() = 0;
  virtual void set_max_size(const int32_t& max_size) = 0;

  virtual const int32_t& min_size() const = 0;
  virtual int32_t* mutable_min_size() = 0;
  virtual void set_min_size(const int32_t& min_size) = 0;

  virtual const bool& resize_longer() const = 0;
  virtual bool* mutable_resize_longer() = 0;
  virtual void set_resize_longer(const bool& resize_longer) = 0;

  virtual const int32_t& target_size() const = 0;
  virtual int32_t* mutable_target_size() = 0;
  virtual void set_target_size(const int32_t& target_size) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ImageResizeKeepAspectRatioOpInterpCtxImpl : public ImageResizeKeepAspectRatioOpInterpCtx {
 public:
  ImageResizeKeepAspectRatioOpInterpCtxImpl() = default;
  ImageResizeKeepAspectRatioOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& interpolation_type() const { return impl_.interpolation_type(); }
  std::string* mutable_interpolation_type() { return impl_.mutable_interpolation_type(); }
  void set_interpolation_type(const std::string& interpolation_type) { impl_.set_interpolation_type(interpolation_type); }
  
  const int32_t& max_size() const { return impl_.max_size(); }
  int32_t* mutable_max_size() { return impl_.mutable_max_size(); }
  void set_max_size(const int32_t& max_size) { impl_.set_max_size(max_size); }
  
  const int32_t& min_size() const { return impl_.min_size(); }
  int32_t* mutable_min_size() { return impl_.mutable_min_size(); }
  void set_min_size(const int32_t& min_size) { impl_.set_min_size(min_size); }
  
  const bool& resize_longer() const { return impl_.resize_longer(); }
  bool* mutable_resize_longer() { return impl_.mutable_resize_longer(); }
  void set_resize_longer(const bool& resize_longer) { impl_.set_resize_longer(resize_longer); }
  
  const int32_t& target_size() const { return impl_.target_size(); }
  int32_t* mutable_target_size() { return impl_.mutable_target_size(); }
  void set_target_size(const int32_t& target_size) { impl_.set_target_size(target_size); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ImageResizeKeepAspectRatioOp {
 public:
  ImageResizeKeepAspectRatioOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& interpolation_type() const { return internal_->interpolation_type; }
  std::string* mutable_interpolation_type() { return &internal_->interpolation_type; }
  void set_interpolation_type(const std::string& interpolation_type) { internal_->interpolation_type = interpolation_type; }
  
  const int32_t& max_size() const { return internal_->max_size; }
  int32_t* mutable_max_size() { return &internal_->max_size; }
  void set_max_size(const int32_t& max_size) { internal_->max_size = max_size; }
  
  const int32_t& min_size() const { return internal_->min_size; }
  int32_t* mutable_min_size() { return &internal_->min_size; }
  void set_min_size(const int32_t& min_size) { internal_->min_size = min_size; }
  
  const bool& resize_longer() const { return internal_->resize_longer; }
  bool* mutable_resize_longer() { return &internal_->resize_longer; }
  void set_resize_longer(const bool& resize_longer) { internal_->resize_longer = resize_longer; }
  
  const int32_t& target_size() const { return internal_->target_size; }
  int32_t* mutable_target_size() { return &internal_->target_size; }
  void set_target_size(const int32_t& target_size) { internal_->target_size = target_size; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string interpolation_type = "bilinear";
    int32_t max_size = 0;
    int32_t min_size = 0;
    bool resize_longer = false;
    int32_t target_size = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ImageResizeToFixedOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ImageResizeToFixedOpInterpCtx() = default;

  virtual const int64_t& channels() const = 0;
  virtual int64_t* mutable_channels() = 0;
  virtual void set_channels(const int64_t& channels) = 0;

  virtual const DataType& data_type() const = 0;
  virtual DataType* mutable_data_type() = 0;
  virtual void set_data_type(const DataType& data_type) = 0;

  virtual const std::string& interpolation_type() const = 0;
  virtual std::string* mutable_interpolation_type() = 0;
  virtual void set_interpolation_type(const std::string& interpolation_type) = 0;

  virtual const int64_t& target_height() const = 0;
  virtual int64_t* mutable_target_height() = 0;
  virtual void set_target_height(const int64_t& target_height) = 0;

  virtual const int64_t& target_width() const = 0;
  virtual int64_t* mutable_target_width() = 0;
  virtual void set_target_width(const int64_t& target_width) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ImageResizeToFixedOpInterpCtxImpl : public ImageResizeToFixedOpInterpCtx {
 public:
  ImageResizeToFixedOpInterpCtxImpl() = default;
  ImageResizeToFixedOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& channels() const { return impl_.channels(); }
  int64_t* mutable_channels() { return impl_.mutable_channels(); }
  void set_channels(const int64_t& channels) { impl_.set_channels(channels); }
  
  const DataType& data_type() const { return impl_.data_type(); }
  DataType* mutable_data_type() { return impl_.mutable_data_type(); }
  void set_data_type(const DataType& data_type) { impl_.set_data_type(data_type); }
  
  const std::string& interpolation_type() const { return impl_.interpolation_type(); }
  std::string* mutable_interpolation_type() { return impl_.mutable_interpolation_type(); }
  void set_interpolation_type(const std::string& interpolation_type) { impl_.set_interpolation_type(interpolation_type); }
  
  const int64_t& target_height() const { return impl_.target_height(); }
  int64_t* mutable_target_height() { return impl_.mutable_target_height(); }
  void set_target_height(const int64_t& target_height) { impl_.set_target_height(target_height); }
  
  const int64_t& target_width() const { return impl_.target_width(); }
  int64_t* mutable_target_width() { return impl_.mutable_target_width(); }
  void set_target_width(const int64_t& target_width) { impl_.set_target_width(target_width); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ImageResizeToFixedOp {
 public:
  ImageResizeToFixedOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& channels() const { return internal_->channels; }
  int64_t* mutable_channels() { return &internal_->channels; }
  void set_channels(const int64_t& channels) { internal_->channels = channels; }
  
  const DataType& data_type() const { return internal_->data_type; }
  DataType* mutable_data_type() { return &internal_->data_type; }
  void set_data_type(const DataType& data_type) { internal_->data_type = data_type; }
  
  const std::string& interpolation_type() const { return internal_->interpolation_type; }
  std::string* mutable_interpolation_type() { return &internal_->interpolation_type; }
  void set_interpolation_type(const std::string& interpolation_type) { internal_->interpolation_type = interpolation_type; }
  
  const int64_t& target_height() const { return internal_->target_height; }
  int64_t* mutable_target_height() { return &internal_->target_height; }
  void set_target_height(const int64_t& target_height) { internal_->target_height = target_height; }
  
  const int64_t& target_width() const { return internal_->target_width; }
  int64_t* mutable_target_width() { return &internal_->target_width; }
  void set_target_width(const int64_t& target_width) { internal_->target_width = target_width; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t channels = 3;
    DataType data_type;
    std::string interpolation_type = "bilinear";
    int64_t target_height = 0;
    int64_t target_width = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ImageTargetResizeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ImageTargetResizeOpInterpCtx() = default;

  virtual const int32_t& max_size() const = 0;
  virtual int32_t* mutable_max_size() = 0;
  virtual void set_max_size(const int32_t& max_size) = 0;

  virtual const int32_t& target_size() const = 0;
  virtual int32_t* mutable_target_size() = 0;
  virtual void set_target_size(const int32_t& target_size) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ImageTargetResizeOpInterpCtxImpl : public ImageTargetResizeOpInterpCtx {
 public:
  ImageTargetResizeOpInterpCtxImpl() = default;
  ImageTargetResizeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& max_size() const { return impl_.max_size(); }
  int32_t* mutable_max_size() { return impl_.mutable_max_size(); }
  void set_max_size(const int32_t& max_size) { impl_.set_max_size(max_size); }
  
  const int32_t& target_size() const { return impl_.target_size(); }
  int32_t* mutable_target_size() { return impl_.mutable_target_size(); }
  void set_target_size(const int32_t& target_size) { impl_.set_target_size(target_size); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ImageTargetResizeOp {
 public:
  ImageTargetResizeOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& max_size() const { return internal_->max_size; }
  int32_t* mutable_max_size() { return &internal_->max_size; }
  void set_max_size(const int32_t& max_size) { internal_->max_size = max_size; }
  
  const int32_t& target_size() const { return internal_->target_size; }
  int32_t* mutable_target_size() { return &internal_->target_size; }
  void set_target_size(const int32_t& target_size) { internal_->target_size = target_size; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t max_size = 0;
    int32_t target_size = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class InTopKOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~InTopKOpInterpCtx() = default;

  virtual const int32_t& k() const = 0;
  virtual int32_t* mutable_k() = 0;
  virtual void set_k(const int32_t& k) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class InTopKOpInterpCtxImpl : public InTopKOpInterpCtx {
 public:
  InTopKOpInterpCtxImpl() = default;
  InTopKOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& k() const { return impl_.k(); }
  int32_t* mutable_k() { return impl_.mutable_k(); }
  void set_k(const int32_t& k) { impl_.set_k(k); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class InTopKOp {
 public:
  InTopKOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& k() const { return internal_->k; }
  int32_t* mutable_k() { return &internal_->k; }
  void set_k(const int32_t& k) { internal_->k = k; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t k = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class IndexedSlicesAdamUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~IndexedSlicesAdamUpdateOpInterpCtx() = default;

  virtual const bool& amsgrad() const = 0;
  virtual bool* mutable_amsgrad() = 0;
  virtual void set_amsgrad(const bool& amsgrad) = 0;

  virtual const float& beta1() const = 0;
  virtual float* mutable_beta1() = 0;
  virtual void set_beta1(const float& beta1) = 0;

  virtual const float& beta2() const = 0;
  virtual float* mutable_beta2() = 0;
  virtual void set_beta2(const float& beta2) = 0;

  virtual const bool& do_bias_correction() const = 0;
  virtual bool* mutable_do_bias_correction() = 0;
  virtual void set_do_bias_correction(const bool& do_bias_correction) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  virtual const float& learning_rate_val() const = 0;
  virtual float* mutable_learning_rate_val() = 0;
  virtual void set_learning_rate_val(const float& learning_rate_val) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class IndexedSlicesAdamUpdateOpInterpCtxImpl : public IndexedSlicesAdamUpdateOpInterpCtx {
 public:
  IndexedSlicesAdamUpdateOpInterpCtxImpl() = default;
  IndexedSlicesAdamUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& amsgrad() const { return impl_.amsgrad(); }
  bool* mutable_amsgrad() { return impl_.mutable_amsgrad(); }
  void set_amsgrad(const bool& amsgrad) { impl_.set_amsgrad(amsgrad); }
  
  const float& beta1() const { return impl_.beta1(); }
  float* mutable_beta1() { return impl_.mutable_beta1(); }
  void set_beta1(const float& beta1) { impl_.set_beta1(beta1); }
  
  const float& beta2() const { return impl_.beta2(); }
  float* mutable_beta2() { return impl_.mutable_beta2(); }
  void set_beta2(const float& beta2) { impl_.set_beta2(beta2); }
  
  const bool& do_bias_correction() const { return impl_.do_bias_correction(); }
  bool* mutable_do_bias_correction() { return impl_.mutable_do_bias_correction(); }
  void set_do_bias_correction(const bool& do_bias_correction) { impl_.set_do_bias_correction(do_bias_correction); }
  
  const float& epsilon() const { return impl_.epsilon(); }
  float* mutable_epsilon() { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) { impl_.set_epsilon(epsilon); }
  
  const float& learning_rate_val() const { return impl_.learning_rate_val(); }
  float* mutable_learning_rate_val() { return impl_.mutable_learning_rate_val(); }
  void set_learning_rate_val(const float& learning_rate_val) { impl_.set_learning_rate_val(learning_rate_val); }
  
  const float& weight_decay() const { return impl_.weight_decay(); }
  float* mutable_weight_decay() { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) { impl_.set_weight_decay(weight_decay); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class IndexedSlicesAdamUpdateOp {
 public:
  IndexedSlicesAdamUpdateOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& amsgrad() const { return internal_->amsgrad; }
  bool* mutable_amsgrad() { return &internal_->amsgrad; }
  void set_amsgrad(const bool& amsgrad) { internal_->amsgrad = amsgrad; }
  
  const float& beta1() const { return internal_->beta1; }
  float* mutable_beta1() { return &internal_->beta1; }
  void set_beta1(const float& beta1) { internal_->beta1 = beta1; }
  
  const float& beta2() const { return internal_->beta2; }
  float* mutable_beta2() { return &internal_->beta2; }
  void set_beta2(const float& beta2) { internal_->beta2 = beta2; }
  
  const bool& do_bias_correction() const { return internal_->do_bias_correction; }
  bool* mutable_do_bias_correction() { return &internal_->do_bias_correction; }
  void set_do_bias_correction(const bool& do_bias_correction) { internal_->do_bias_correction = do_bias_correction; }
  
  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }
  
  const float& learning_rate_val() const { return internal_->learning_rate_val; }
  float* mutable_learning_rate_val() { return &internal_->learning_rate_val; }
  void set_learning_rate_val(const float& learning_rate_val) { internal_->learning_rate_val = learning_rate_val; }
  
  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool amsgrad = false;
    float beta1 = 0.9;
    float beta2 = 0.999;
    bool do_bias_correction = true;
    float epsilon = 0.;
    float learning_rate_val = 0.;
    float weight_decay = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class IndexedSlicesMomentumUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~IndexedSlicesMomentumUpdateOpInterpCtx() = default;

  virtual const float& beta() const = 0;
  virtual float* mutable_beta() = 0;
  virtual void set_beta(const float& beta) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class IndexedSlicesMomentumUpdateOpInterpCtxImpl : public IndexedSlicesMomentumUpdateOpInterpCtx {
 public:
  IndexedSlicesMomentumUpdateOpInterpCtxImpl() = default;
  IndexedSlicesMomentumUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& beta() const { return impl_.beta(); }
  float* mutable_beta() { return impl_.mutable_beta(); }
  void set_beta(const float& beta) { impl_.set_beta(beta); }
  
  const float& weight_decay() const { return impl_.weight_decay(); }
  float* mutable_weight_decay() { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) { impl_.set_weight_decay(weight_decay); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class IndexedSlicesMomentumUpdateOp {
 public:
  IndexedSlicesMomentumUpdateOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& beta() const { return internal_->beta; }
  float* mutable_beta() { return &internal_->beta; }
  void set_beta(const float& beta) { internal_->beta = beta; }
  
  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float beta = 0.9;
    float weight_decay = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class IndexedSlicesReduceSumOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~IndexedSlicesReduceSumOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class IndexedSlicesReduceSumOpInterpCtxImpl : public IndexedSlicesReduceSumOpInterpCtx {
 public:
  IndexedSlicesReduceSumOpInterpCtxImpl() = default;
  IndexedSlicesReduceSumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class IndexedSlicesReduceSumOp {
 public:
  IndexedSlicesReduceSumOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class IndexedSlicesSgdUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~IndexedSlicesSgdUpdateOpInterpCtx() = default;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class IndexedSlicesSgdUpdateOpInterpCtxImpl : public IndexedSlicesSgdUpdateOpInterpCtx {
 public:
  IndexedSlicesSgdUpdateOpInterpCtxImpl() = default;
  IndexedSlicesSgdUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& weight_decay() const { return impl_.weight_decay(); }
  float* mutable_weight_decay() { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) { impl_.set_weight_decay(weight_decay); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class IndexedSlicesSgdUpdateOp {
 public:
  IndexedSlicesSgdUpdateOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float weight_decay = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class KlDivLossGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~KlDivLossGradOpInterpCtx() = default;

  virtual const bool& log_target() const = 0;
  virtual bool* mutable_log_target() = 0;
  virtual void set_log_target(const bool& log_target) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class KlDivLossGradOpInterpCtxImpl : public KlDivLossGradOpInterpCtx {
 public:
  KlDivLossGradOpInterpCtxImpl() = default;
  KlDivLossGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& log_target() const { return impl_.log_target(); }
  bool* mutable_log_target() { return impl_.mutable_log_target(); }
  void set_log_target(const bool& log_target) { impl_.set_log_target(log_target); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class KlDivLossGradOp {
 public:
  KlDivLossGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& log_target() const { return internal_->log_target; }
  bool* mutable_log_target() { return &internal_->log_target; }
  void set_log_target(const bool& log_target) { internal_->log_target = log_target; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool log_target = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class KlDivLossOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~KlDivLossOpInterpCtx() = default;

  virtual const bool& log_target() const = 0;
  virtual bool* mutable_log_target() = 0;
  virtual void set_log_target(const bool& log_target) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class KlDivLossOpInterpCtxImpl : public KlDivLossOpInterpCtx {
 public:
  KlDivLossOpInterpCtxImpl() = default;
  KlDivLossOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& log_target() const { return impl_.log_target(); }
  bool* mutable_log_target() { return impl_.mutable_log_target(); }
  void set_log_target(const bool& log_target) { impl_.set_log_target(log_target); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class KlDivLossOp {
 public:
  KlDivLossOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& log_target() const { return internal_->log_target; }
  bool* mutable_log_target() { return &internal_->log_target; }
  void set_log_target(const bool& log_target) { internal_->log_target = log_target; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool log_target = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class L1L2RegularizeGradientOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~L1L2RegularizeGradientOpInterpCtx() = default;

  virtual const float& l1() const = 0;
  virtual float* mutable_l1() = 0;
  virtual void set_l1(const float& l1) = 0;

  virtual const float& l2() const = 0;
  virtual float* mutable_l2() = 0;
  virtual void set_l2(const float& l2) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class L1L2RegularizeGradientOpInterpCtxImpl : public L1L2RegularizeGradientOpInterpCtx {
 public:
  L1L2RegularizeGradientOpInterpCtxImpl() = default;
  L1L2RegularizeGradientOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& l1() const { return impl_.l1(); }
  float* mutable_l1() { return impl_.mutable_l1(); }
  void set_l1(const float& l1) { impl_.set_l1(l1); }
  
  const float& l2() const { return impl_.l2(); }
  float* mutable_l2() { return impl_.mutable_l2(); }
  void set_l2(const float& l2) { impl_.set_l2(l2); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class L1L2RegularizeGradientOp {
 public:
  L1L2RegularizeGradientOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& l1() const { return internal_->l1; }
  float* mutable_l1() { return &internal_->l1; }
  void set_l1(const float& l1) { internal_->l1 = l1; }
  
  const float& l2() const { return internal_->l2; }
  float* mutable_l2() { return &internal_->l2; }
  void set_l2(const float& l2) { internal_->l2 = l2; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float l1 = 0.;
    float l2 = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class L2NormalizeGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~L2NormalizeGradOpInterpCtx() = default;

  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class L2NormalizeGradOpInterpCtxImpl : public L2NormalizeGradOpInterpCtx {
 public:
  L2NormalizeGradOpInterpCtxImpl() = default;
  L2NormalizeGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& axis() const { return impl_.axis(); }
  int32_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) { impl_.set_axis(axis); }
  
  const float& epsilon() const { return impl_.epsilon(); }
  float* mutable_epsilon() { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) { impl_.set_epsilon(epsilon); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class L2NormalizeGradOp {
 public:
  L2NormalizeGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }
  
  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t axis = 0;
    float epsilon = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class L2NormalizeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~L2NormalizeOpInterpCtx() = default;

  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class L2NormalizeOpInterpCtxImpl : public L2NormalizeOpInterpCtx {
 public:
  L2NormalizeOpInterpCtxImpl() = default;
  L2NormalizeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& axis() const { return impl_.axis(); }
  int32_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) { impl_.set_axis(axis); }
  
  const float& epsilon() const { return impl_.epsilon(); }
  float* mutable_epsilon() { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) { impl_.set_epsilon(epsilon); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class L2NormalizeOp {
 public:
  L2NormalizeOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }
  
  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t axis = 0;
    float epsilon = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LambUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LambUpdateOpInterpCtx() = default;

  virtual const float& beta1() const = 0;
  virtual float* mutable_beta1() = 0;
  virtual void set_beta1(const float& beta1) = 0;

  virtual const float& beta2() const = 0;
  virtual float* mutable_beta2() = 0;
  virtual void set_beta2(const float& beta2) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  virtual const float& l1() const = 0;
  virtual float* mutable_l1() = 0;
  virtual void set_l1(const float& l1) = 0;

  virtual const float& l2() const = 0;
  virtual float* mutable_l2() = 0;
  virtual void set_l2(const float& l2) = 0;

  virtual const double& scale() const = 0;
  virtual double* mutable_scale() = 0;
  virtual void set_scale(const double& scale) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LambUpdateOpInterpCtxImpl : public LambUpdateOpInterpCtx {
 public:
  LambUpdateOpInterpCtxImpl() = default;
  LambUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& beta1() const { return impl_.beta1(); }
  float* mutable_beta1() { return impl_.mutable_beta1(); }
  void set_beta1(const float& beta1) { impl_.set_beta1(beta1); }
  
  const float& beta2() const { return impl_.beta2(); }
  float* mutable_beta2() { return impl_.mutable_beta2(); }
  void set_beta2(const float& beta2) { impl_.set_beta2(beta2); }
  
  const float& epsilon() const { return impl_.epsilon(); }
  float* mutable_epsilon() { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) { impl_.set_epsilon(epsilon); }
  
  const float& l1() const { return impl_.l1(); }
  float* mutable_l1() { return impl_.mutable_l1(); }
  void set_l1(const float& l1) { impl_.set_l1(l1); }
  
  const float& l2() const { return impl_.l2(); }
  float* mutable_l2() { return impl_.mutable_l2(); }
  void set_l2(const float& l2) { impl_.set_l2(l2); }
  
  const double& scale() const { return impl_.scale(); }
  double* mutable_scale() { return impl_.mutable_scale(); }
  void set_scale(const double& scale) { impl_.set_scale(scale); }
  
  const float& weight_decay() const { return impl_.weight_decay(); }
  float* mutable_weight_decay() { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) { impl_.set_weight_decay(weight_decay); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LambUpdateOp {
 public:
  LambUpdateOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& beta1() const { return internal_->beta1; }
  float* mutable_beta1() { return &internal_->beta1; }
  void set_beta1(const float& beta1) { internal_->beta1 = beta1; }
  
  const float& beta2() const { return internal_->beta2; }
  float* mutable_beta2() { return &internal_->beta2; }
  void set_beta2(const float& beta2) { internal_->beta2 = beta2; }
  
  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }
  
  const float& l1() const { return internal_->l1; }
  float* mutable_l1() { return &internal_->l1; }
  void set_l1(const float& l1) { internal_->l1 = l1; }
  
  const float& l2() const { return internal_->l2; }
  float* mutable_l2() { return &internal_->l2; }
  void set_l2(const float& l2) { internal_->l2 = l2; }
  
  const double& scale() const { return internal_->scale; }
  double* mutable_scale() { return &internal_->scale; }
  void set_scale(const double& scale) { internal_->scale = scale; }
  
  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float beta1 = 0.;
    float beta2 = 0.;
    float epsilon = 0.;
    float l1 = 0.;
    float l2 = 0.;
    double scale = 1.;
    float weight_decay = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LarsUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LarsUpdateOpInterpCtx() = default;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  virtual const float& l1() const = 0;
  virtual float* mutable_l1() = 0;
  virtual void set_l1(const float& l1) = 0;

  virtual const float& l2() const = 0;
  virtual float* mutable_l2() = 0;
  virtual void set_l2(const float& l2) = 0;

  virtual const float& lars_coefficient() const = 0;
  virtual float* mutable_lars_coefficient() = 0;
  virtual void set_lars_coefficient(const float& lars_coefficient) = 0;

  virtual const float& momentum_beta() const = 0;
  virtual float* mutable_momentum_beta() = 0;
  virtual void set_momentum_beta(const float& momentum_beta) = 0;

  virtual const double& scale() const = 0;
  virtual double* mutable_scale() = 0;
  virtual void set_scale(const double& scale) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LarsUpdateOpInterpCtxImpl : public LarsUpdateOpInterpCtx {
 public:
  LarsUpdateOpInterpCtxImpl() = default;
  LarsUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& epsilon() const { return impl_.epsilon(); }
  float* mutable_epsilon() { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) { impl_.set_epsilon(epsilon); }
  
  const float& l1() const { return impl_.l1(); }
  float* mutable_l1() { return impl_.mutable_l1(); }
  void set_l1(const float& l1) { impl_.set_l1(l1); }
  
  const float& l2() const { return impl_.l2(); }
  float* mutable_l2() { return impl_.mutable_l2(); }
  void set_l2(const float& l2) { impl_.set_l2(l2); }
  
  const float& lars_coefficient() const { return impl_.lars_coefficient(); }
  float* mutable_lars_coefficient() { return impl_.mutable_lars_coefficient(); }
  void set_lars_coefficient(const float& lars_coefficient) { impl_.set_lars_coefficient(lars_coefficient); }
  
  const float& momentum_beta() const { return impl_.momentum_beta(); }
  float* mutable_momentum_beta() { return impl_.mutable_momentum_beta(); }
  void set_momentum_beta(const float& momentum_beta) { impl_.set_momentum_beta(momentum_beta); }
  
  const double& scale() const { return impl_.scale(); }
  double* mutable_scale() { return impl_.mutable_scale(); }
  void set_scale(const double& scale) { impl_.set_scale(scale); }
  
  const float& weight_decay() const { return impl_.weight_decay(); }
  float* mutable_weight_decay() { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) { impl_.set_weight_decay(weight_decay); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LarsUpdateOp {
 public:
  LarsUpdateOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }
  
  const float& l1() const { return internal_->l1; }
  float* mutable_l1() { return &internal_->l1; }
  void set_l1(const float& l1) { internal_->l1 = l1; }
  
  const float& l2() const { return internal_->l2; }
  float* mutable_l2() { return &internal_->l2; }
  void set_l2(const float& l2) { internal_->l2 = l2; }
  
  const float& lars_coefficient() const { return internal_->lars_coefficient; }
  float* mutable_lars_coefficient() { return &internal_->lars_coefficient; }
  void set_lars_coefficient(const float& lars_coefficient) { internal_->lars_coefficient = lars_coefficient; }
  
  const float& momentum_beta() const { return internal_->momentum_beta; }
  float* mutable_momentum_beta() { return &internal_->momentum_beta; }
  void set_momentum_beta(const float& momentum_beta) { internal_->momentum_beta = momentum_beta; }
  
  const double& scale() const { return internal_->scale; }
  double* mutable_scale() { return &internal_->scale; }
  void set_scale(const double& scale) { internal_->scale = scale; }
  
  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float epsilon = 0.;
    float l1 = 0.;
    float l2 = 0.;
    float lars_coefficient = 0.0001;
    float momentum_beta = 0.9;
    double scale = 1.;
    float weight_decay = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LayerNormGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LayerNormGradOpInterpCtx() = default;

  virtual const int64_t& begin_norm_axis() const = 0;
  virtual int64_t* mutable_begin_norm_axis() = 0;
  virtual void set_begin_norm_axis(const int64_t& begin_norm_axis) = 0;

  virtual const double& epsilon() const = 0;
  virtual double* mutable_epsilon() = 0;
  virtual void set_epsilon(const double& epsilon) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LayerNormGradOpInterpCtxImpl : public LayerNormGradOpInterpCtx {
 public:
  LayerNormGradOpInterpCtxImpl() = default;
  LayerNormGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& begin_norm_axis() const { return impl_.begin_norm_axis(); }
  int64_t* mutable_begin_norm_axis() { return impl_.mutable_begin_norm_axis(); }
  void set_begin_norm_axis(const int64_t& begin_norm_axis) { impl_.set_begin_norm_axis(begin_norm_axis); }
  
  const double& epsilon() const { return impl_.epsilon(); }
  double* mutable_epsilon() { return impl_.mutable_epsilon(); }
  void set_epsilon(const double& epsilon) { impl_.set_epsilon(epsilon); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LayerNormGradOp {
 public:
  LayerNormGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& begin_norm_axis() const { return internal_->begin_norm_axis; }
  int64_t* mutable_begin_norm_axis() { return &internal_->begin_norm_axis; }
  void set_begin_norm_axis(const int64_t& begin_norm_axis) { internal_->begin_norm_axis = begin_norm_axis; }
  
  const double& epsilon() const { return internal_->epsilon; }
  double* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const double& epsilon) { internal_->epsilon = epsilon; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t begin_norm_axis = 0;
    double epsilon = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LayerNormOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LayerNormOpInterpCtx() = default;

  virtual const int64_t& begin_norm_axis() const = 0;
  virtual int64_t* mutable_begin_norm_axis() = 0;
  virtual void set_begin_norm_axis(const int64_t& begin_norm_axis) = 0;

  virtual const int64_t& begin_params_axis() const = 0;
  virtual int64_t* mutable_begin_params_axis() = 0;
  virtual void set_begin_params_axis(const int64_t& begin_params_axis) = 0;

  virtual const bool& center() const = 0;
  virtual bool* mutable_center() = 0;
  virtual void set_center(const bool& center) = 0;

  virtual const double& epsilon() const = 0;
  virtual double* mutable_epsilon() = 0;
  virtual void set_epsilon(const double& epsilon) = 0;

  virtual const bool& scale() const = 0;
  virtual bool* mutable_scale() = 0;
  virtual void set_scale(const bool& scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LayerNormOpInterpCtxImpl : public LayerNormOpInterpCtx {
 public:
  LayerNormOpInterpCtxImpl() = default;
  LayerNormOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& begin_norm_axis() const { return impl_.begin_norm_axis(); }
  int64_t* mutable_begin_norm_axis() { return impl_.mutable_begin_norm_axis(); }
  void set_begin_norm_axis(const int64_t& begin_norm_axis) { impl_.set_begin_norm_axis(begin_norm_axis); }
  
  const int64_t& begin_params_axis() const { return impl_.begin_params_axis(); }
  int64_t* mutable_begin_params_axis() { return impl_.mutable_begin_params_axis(); }
  void set_begin_params_axis(const int64_t& begin_params_axis) { impl_.set_begin_params_axis(begin_params_axis); }
  
  const bool& center() const { return impl_.center(); }
  bool* mutable_center() { return impl_.mutable_center(); }
  void set_center(const bool& center) { impl_.set_center(center); }
  
  const double& epsilon() const { return impl_.epsilon(); }
  double* mutable_epsilon() { return impl_.mutable_epsilon(); }
  void set_epsilon(const double& epsilon) { impl_.set_epsilon(epsilon); }
  
  const bool& scale() const { return impl_.scale(); }
  bool* mutable_scale() { return impl_.mutable_scale(); }
  void set_scale(const bool& scale) { impl_.set_scale(scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LayerNormOp {
 public:
  LayerNormOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& begin_norm_axis() const { return internal_->begin_norm_axis; }
  int64_t* mutable_begin_norm_axis() { return &internal_->begin_norm_axis; }
  void set_begin_norm_axis(const int64_t& begin_norm_axis) { internal_->begin_norm_axis = begin_norm_axis; }
  
  const int64_t& begin_params_axis() const { return internal_->begin_params_axis; }
  int64_t* mutable_begin_params_axis() { return &internal_->begin_params_axis; }
  void set_begin_params_axis(const int64_t& begin_params_axis) { internal_->begin_params_axis = begin_params_axis; }
  
  const bool& center() const { return internal_->center; }
  bool* mutable_center() { return &internal_->center; }
  void set_center(const bool& center) { internal_->center = center; }
  
  const double& epsilon() const { return internal_->epsilon; }
  double* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const double& epsilon) { internal_->epsilon = epsilon; }
  
  const bool& scale() const { return internal_->scale; }
  bool* mutable_scale() { return &internal_->scale; }
  void set_scale(const bool& scale) { internal_->scale = scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t begin_norm_axis = 0;
    int64_t begin_params_axis = 0;
    bool center = false;
    double epsilon = 0.;
    bool scale = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LayerNormParamGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LayerNormParamGradOpInterpCtx() = default;

  virtual const int64_t& begin_params_axis() const = 0;
  virtual int64_t* mutable_begin_params_axis() = 0;
  virtual void set_begin_params_axis(const int64_t& begin_params_axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LayerNormParamGradOpInterpCtxImpl : public LayerNormParamGradOpInterpCtx {
 public:
  LayerNormParamGradOpInterpCtxImpl() = default;
  LayerNormParamGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& begin_params_axis() const { return impl_.begin_params_axis(); }
  int64_t* mutable_begin_params_axis() { return impl_.mutable_begin_params_axis(); }
  void set_begin_params_axis(const int64_t& begin_params_axis) { impl_.set_begin_params_axis(begin_params_axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LayerNormParamGradOp {
 public:
  LayerNormParamGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& begin_params_axis() const { return internal_->begin_params_axis; }
  int64_t* mutable_begin_params_axis() { return &internal_->begin_params_axis; }
  void set_begin_params_axis(const int64_t& begin_params_axis) { internal_->begin_params_axis = begin_params_axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t begin_params_axis = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LeakyReluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LeakyReluGradOpInterpCtx() = default;

  virtual const float& alpha() const = 0;
  virtual float* mutable_alpha() = 0;
  virtual void set_alpha(const float& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LeakyReluGradOpInterpCtxImpl : public LeakyReluGradOpInterpCtx {
 public:
  LeakyReluGradOpInterpCtxImpl() = default;
  LeakyReluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& alpha() const { return impl_.alpha(); }
  float* mutable_alpha() { return impl_.mutable_alpha(); }
  void set_alpha(const float& alpha) { impl_.set_alpha(alpha); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LeakyReluGradOp {
 public:
  LeakyReluGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& alpha() const { return internal_->alpha; }
  float* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const float& alpha) { internal_->alpha = alpha; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float alpha = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LeakyReluOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LeakyReluOpInterpCtx() = default;

  virtual const float& alpha() const = 0;
  virtual float* mutable_alpha() = 0;
  virtual void set_alpha(const float& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LeakyReluOpInterpCtxImpl : public LeakyReluOpInterpCtx {
 public:
  LeakyReluOpInterpCtxImpl() = default;
  LeakyReluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& alpha() const { return impl_.alpha(); }
  float* mutable_alpha() { return impl_.mutable_alpha(); }
  void set_alpha(const float& alpha) { impl_.set_alpha(alpha); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LeakyReluOp {
 public:
  LeakyReluOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& alpha() const { return internal_->alpha; }
  float* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const float& alpha) { internal_->alpha = alpha; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float alpha = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LgammaGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LgammaGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LgammaGradOpInterpCtxImpl : public LgammaGradOpInterpCtx {
 public:
  LgammaGradOpInterpCtxImpl() = default;
  LgammaGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LgammaGradOp {
 public:
  LgammaGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LgammaOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LgammaOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LgammaOpInterpCtxImpl : public LgammaOpInterpCtx {
 public:
  LgammaOpInterpCtxImpl() = default;
  LgammaOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LgammaOp {
 public:
  LgammaOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class Log1pGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~Log1pGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class Log1pGradOpInterpCtxImpl : public Log1pGradOpInterpCtx {
 public:
  Log1pGradOpInterpCtxImpl() = default;
  Log1pGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Log1pGradOp {
 public:
  Log1pGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class Log1pOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~Log1pOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class Log1pOpInterpCtxImpl : public Log1pOpInterpCtx {
 public:
  Log1pOpInterpCtxImpl() = default;
  Log1pOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Log1pOp {
 public:
  Log1pOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LogGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LogGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LogGradOpInterpCtxImpl : public LogGradOpInterpCtx {
 public:
  LogGradOpInterpCtxImpl() = default;
  LogGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogGradOp {
 public:
  LogGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LogOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LogOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LogOpInterpCtxImpl : public LogOpInterpCtx {
 public:
  LogOpInterpCtxImpl() = default;
  LogOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogOp {
 public:
  LogOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LogSigmoidGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LogSigmoidGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LogSigmoidGradOpInterpCtxImpl : public LogSigmoidGradOpInterpCtx {
 public:
  LogSigmoidGradOpInterpCtxImpl() = default;
  LogSigmoidGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogSigmoidGradOp {
 public:
  LogSigmoidGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LogSigmoidOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LogSigmoidOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LogSigmoidOpInterpCtxImpl : public LogSigmoidOpInterpCtx {
 public:
  LogSigmoidOpInterpCtxImpl() = default;
  LogSigmoidOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogSigmoidOp {
 public:
  LogSigmoidOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LogSoftmaxGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LogSoftmaxGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LogSoftmaxGradOpInterpCtxImpl : public LogSoftmaxGradOpInterpCtx {
 public:
  LogSoftmaxGradOpInterpCtxImpl() = default;
  LogSoftmaxGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogSoftmaxGradOp {
 public:
  LogSoftmaxGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LogSoftmaxOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LogSoftmaxOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LogSoftmaxOpInterpCtxImpl : public LogSoftmaxOpInterpCtx {
 public:
  LogSoftmaxOpInterpCtxImpl() = default;
  LogSoftmaxOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogSoftmaxOp {
 public:
  LogSoftmaxOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LogicalNotOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LogicalNotOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LogicalNotOpInterpCtxImpl : public LogicalNotOpInterpCtx {
 public:
  LogicalNotOpInterpCtxImpl() = default;
  LogicalNotOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogicalNotOp {
 public:
  LogicalNotOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LogicalSliceAssignOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LogicalSliceAssignOpInterpCtx() = default;

  virtual const std::vector<std::int64_t>& start() const = 0;
  virtual std::vector<std::int64_t>* mutable_start() = 0;
  virtual void set_start(const std::vector<std::int64_t>& start) = 0;

  virtual const std::vector<std::int64_t>& step() const = 0;
  virtual std::vector<std::int64_t>* mutable_step() = 0;
  virtual void set_step(const std::vector<std::int64_t>& step) = 0;

  virtual const std::vector<std::int64_t>& stop() const = 0;
  virtual std::vector<std::int64_t>* mutable_stop() = 0;
  virtual void set_stop(const std::vector<std::int64_t>& stop) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LogicalSliceAssignOpInterpCtxImpl : public LogicalSliceAssignOpInterpCtx {
 public:
  LogicalSliceAssignOpInterpCtxImpl() = default;
  LogicalSliceAssignOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int64_t>& start() const { return impl_.start(); }
  std::vector<std::int64_t>* mutable_start() { return impl_.mutable_start(); }
  void set_start(const std::vector<std::int64_t>& start) { impl_.set_start(start); }
  
  const std::vector<std::int64_t>& step() const { return impl_.step(); }
  std::vector<std::int64_t>* mutable_step() { return impl_.mutable_step(); }
  void set_step(const std::vector<std::int64_t>& step) { impl_.set_step(step); }
  
  const std::vector<std::int64_t>& stop() const { return impl_.stop(); }
  std::vector<std::int64_t>* mutable_stop() { return impl_.mutable_stop(); }
  void set_stop(const std::vector<std::int64_t>& stop) { impl_.set_stop(stop); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogicalSliceAssignOp {
 public:
  LogicalSliceAssignOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int64_t>& start() const { return internal_->start; }
  std::vector<std::int64_t>* mutable_start() { return &internal_->start; }
  void set_start(const std::vector<std::int64_t>& start) { internal_->start = start; }
  
  const std::vector<std::int64_t>& step() const { return internal_->step; }
  std::vector<std::int64_t>* mutable_step() { return &internal_->step; }
  void set_step(const std::vector<std::int64_t>& step) { internal_->step = step; }
  
  const std::vector<std::int64_t>& stop() const { return internal_->stop; }
  std::vector<std::int64_t>* mutable_stop() { return &internal_->stop; }
  void set_stop(const std::vector<std::int64_t>& stop) { internal_->stop = stop; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int64_t> start;
    std::vector<std::int64_t> step;
    std::vector<std::int64_t> stop;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class LogicalSliceOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~LogicalSliceOpInterpCtx() = default;

  virtual const std::vector<std::int64_t>& start() const = 0;
  virtual std::vector<std::int64_t>* mutable_start() = 0;
  virtual void set_start(const std::vector<std::int64_t>& start) = 0;

  virtual const std::vector<std::int64_t>& step() const = 0;
  virtual std::vector<std::int64_t>* mutable_step() = 0;
  virtual void set_step(const std::vector<std::int64_t>& step) = 0;

  virtual const std::vector<std::int64_t>& stop() const = 0;
  virtual std::vector<std::int64_t>* mutable_stop() = 0;
  virtual void set_stop(const std::vector<std::int64_t>& stop) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class LogicalSliceOpInterpCtxImpl : public LogicalSliceOpInterpCtx {
 public:
  LogicalSliceOpInterpCtxImpl() = default;
  LogicalSliceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int64_t>& start() const { return impl_.start(); }
  std::vector<std::int64_t>* mutable_start() { return impl_.mutable_start(); }
  void set_start(const std::vector<std::int64_t>& start) { impl_.set_start(start); }
  
  const std::vector<std::int64_t>& step() const { return impl_.step(); }
  std::vector<std::int64_t>* mutable_step() { return impl_.mutable_step(); }
  void set_step(const std::vector<std::int64_t>& step) { impl_.set_step(step); }
  
  const std::vector<std::int64_t>& stop() const { return impl_.stop(); }
  std::vector<std::int64_t>* mutable_stop() { return impl_.mutable_stop(); }
  void set_stop(const std::vector<std::int64_t>& stop) { impl_.set_stop(stop); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogicalSliceOp {
 public:
  LogicalSliceOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int64_t>& start() const { return internal_->start; }
  std::vector<std::int64_t>* mutable_start() { return &internal_->start; }
  void set_start(const std::vector<std::int64_t>& start) { internal_->start = start; }
  
  const std::vector<std::int64_t>& step() const { return internal_->step; }
  std::vector<std::int64_t>* mutable_step() { return &internal_->step; }
  void set_step(const std::vector<std::int64_t>& step) { internal_->step = step; }
  
  const std::vector<std::int64_t>& stop() const { return internal_->stop; }
  std::vector<std::int64_t>* mutable_stop() { return &internal_->stop; }
  void set_stop(const std::vector<std::int64_t>& stop) { internal_->stop = stop; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int64_t> start;
    std::vector<std::int64_t> step;
    std::vector<std::int64_t> stop;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MaskedFillOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MaskedFillOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MaskedFillOpInterpCtxImpl : public MaskedFillOpInterpCtx {
 public:
  MaskedFillOpInterpCtxImpl() = default;
  MaskedFillOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MaskedFillOp {
 public:
  MaskedFillOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MatmulOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MatmulOpInterpCtx() = default;

  virtual const double& alpha() const = 0;
  virtual double* mutable_alpha() = 0;
  virtual void set_alpha(const double& alpha) = 0;

  virtual const bool& transpose_a() const = 0;
  virtual bool* mutable_transpose_a() = 0;
  virtual void set_transpose_a(const bool& transpose_a) = 0;

  virtual const bool& transpose_b() const = 0;
  virtual bool* mutable_transpose_b() = 0;
  virtual void set_transpose_b(const bool& transpose_b) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MatmulOpInterpCtxImpl : public MatmulOpInterpCtx {
 public:
  MatmulOpInterpCtxImpl() = default;
  MatmulOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& alpha() const { return impl_.alpha(); }
  double* mutable_alpha() { return impl_.mutable_alpha(); }
  void set_alpha(const double& alpha) { impl_.set_alpha(alpha); }
  
  const bool& transpose_a() const { return impl_.transpose_a(); }
  bool* mutable_transpose_a() { return impl_.mutable_transpose_a(); }
  void set_transpose_a(const bool& transpose_a) { impl_.set_transpose_a(transpose_a); }
  
  const bool& transpose_b() const { return impl_.transpose_b(); }
  bool* mutable_transpose_b() { return impl_.mutable_transpose_b(); }
  void set_transpose_b(const bool& transpose_b) { impl_.set_transpose_b(transpose_b); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MatmulOp {
 public:
  MatmulOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& alpha() const { return internal_->alpha; }
  double* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const double& alpha) { internal_->alpha = alpha; }
  
  const bool& transpose_a() const { return internal_->transpose_a; }
  bool* mutable_transpose_a() { return &internal_->transpose_a; }
  void set_transpose_a(const bool& transpose_a) { internal_->transpose_a = transpose_a; }
  
  const bool& transpose_b() const { return internal_->transpose_b; }
  bool* mutable_transpose_b() { return &internal_->transpose_b; }
  void set_transpose_b(const bool& transpose_b) { internal_->transpose_b = transpose_b; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double alpha = 1.;
    bool transpose_a = false;
    bool transpose_b = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MaxPool1DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MaxPool1DGradOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int32_t>& padding) = 0;

  virtual const std::vector<std::int32_t>& stride() const = 0;
  virtual std::vector<std::int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<std::int32_t>& stride) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MaxPool1DGradOpInterpCtxImpl : public MaxPool1DGradOpInterpCtx {
 public:
  MaxPool1DGradOpInterpCtxImpl() = default;
  MaxPool1DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const bool& count_include_pad() const { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) { impl_.set_count_include_pad(count_include_pad); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const int64_t& divisor_override() const { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) { impl_.set_divisor_override(divisor_override); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& padding() const { return impl_.padding(); }
  std::vector<std::int32_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int32_t>& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& stride() const { return impl_.stride(); }
  std::vector<std::int32_t>* mutable_stride() { return impl_.mutable_stride(); }
  void set_stride(const std::vector<std::int32_t>& stride) { impl_.set_stride(stride); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MaxPool1DGradOp {
 public:
  MaxPool1DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) { internal_->count_include_pad = count_include_pad; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) { internal_->divisor_override = divisor_override; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& padding() const { return internal_->padding; }
  std::vector<std::int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int32_t>& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& stride() const { return internal_->stride; }
  std::vector<std::int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<std::int32_t>& stride) { internal_->stride = stride; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    bool count_include_pad;
    std::string data_format;
    int64_t divisor_override;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> padding;
    std::vector<std::int32_t> stride;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MaxPool1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MaxPool1DOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int32_t>& padding) = 0;

  virtual const std::vector<std::int32_t>& stride() const = 0;
  virtual std::vector<std::int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<std::int32_t>& stride) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MaxPool1DOpInterpCtxImpl : public MaxPool1DOpInterpCtx {
 public:
  MaxPool1DOpInterpCtxImpl() = default;
  MaxPool1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const bool& count_include_pad() const { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) { impl_.set_count_include_pad(count_include_pad); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const int64_t& divisor_override() const { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) { impl_.set_divisor_override(divisor_override); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& padding() const { return impl_.padding(); }
  std::vector<std::int32_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int32_t>& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& stride() const { return impl_.stride(); }
  std::vector<std::int32_t>* mutable_stride() { return impl_.mutable_stride(); }
  void set_stride(const std::vector<std::int32_t>& stride) { impl_.set_stride(stride); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MaxPool1DOp {
 public:
  MaxPool1DOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) { internal_->count_include_pad = count_include_pad; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) { internal_->divisor_override = divisor_override; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& padding() const { return internal_->padding; }
  std::vector<std::int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int32_t>& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& stride() const { return internal_->stride; }
  std::vector<std::int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<std::int32_t>& stride) { internal_->stride = stride; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    bool count_include_pad;
    std::string data_format;
    int64_t divisor_override;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> padding;
    std::vector<std::int32_t> stride;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MaxPool2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MaxPool2DGradOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int32_t>& padding) = 0;

  virtual const std::vector<std::int32_t>& stride() const = 0;
  virtual std::vector<std::int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<std::int32_t>& stride) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MaxPool2DGradOpInterpCtxImpl : public MaxPool2DGradOpInterpCtx {
 public:
  MaxPool2DGradOpInterpCtxImpl() = default;
  MaxPool2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const bool& count_include_pad() const { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) { impl_.set_count_include_pad(count_include_pad); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const int64_t& divisor_override() const { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) { impl_.set_divisor_override(divisor_override); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& padding() const { return impl_.padding(); }
  std::vector<std::int32_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int32_t>& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& stride() const { return impl_.stride(); }
  std::vector<std::int32_t>* mutable_stride() { return impl_.mutable_stride(); }
  void set_stride(const std::vector<std::int32_t>& stride) { impl_.set_stride(stride); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MaxPool2DGradOp {
 public:
  MaxPool2DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) { internal_->count_include_pad = count_include_pad; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) { internal_->divisor_override = divisor_override; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& padding() const { return internal_->padding; }
  std::vector<std::int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int32_t>& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& stride() const { return internal_->stride; }
  std::vector<std::int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<std::int32_t>& stride) { internal_->stride = stride; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    bool count_include_pad;
    std::string data_format;
    int64_t divisor_override;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> padding;
    std::vector<std::int32_t> stride;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MaxPool2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MaxPool2DOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int32_t>& padding) = 0;

  virtual const std::vector<std::int32_t>& stride() const = 0;
  virtual std::vector<std::int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<std::int32_t>& stride) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MaxPool2DOpInterpCtxImpl : public MaxPool2DOpInterpCtx {
 public:
  MaxPool2DOpInterpCtxImpl() = default;
  MaxPool2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const bool& count_include_pad() const { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) { impl_.set_count_include_pad(count_include_pad); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const int64_t& divisor_override() const { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) { impl_.set_divisor_override(divisor_override); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& padding() const { return impl_.padding(); }
  std::vector<std::int32_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int32_t>& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& stride() const { return impl_.stride(); }
  std::vector<std::int32_t>* mutable_stride() { return impl_.mutable_stride(); }
  void set_stride(const std::vector<std::int32_t>& stride) { impl_.set_stride(stride); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MaxPool2DOp {
 public:
  MaxPool2DOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) { internal_->count_include_pad = count_include_pad; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) { internal_->divisor_override = divisor_override; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& padding() const { return internal_->padding; }
  std::vector<std::int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int32_t>& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& stride() const { return internal_->stride; }
  std::vector<std::int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<std::int32_t>& stride) { internal_->stride = stride; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    bool count_include_pad;
    std::string data_format;
    int64_t divisor_override;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> padding;
    std::vector<std::int32_t> stride;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MaxPool3DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MaxPool3DGradOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int32_t>& padding) = 0;

  virtual const std::vector<std::int32_t>& stride() const = 0;
  virtual std::vector<std::int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<std::int32_t>& stride) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MaxPool3DGradOpInterpCtxImpl : public MaxPool3DGradOpInterpCtx {
 public:
  MaxPool3DGradOpInterpCtxImpl() = default;
  MaxPool3DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const bool& count_include_pad() const { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) { impl_.set_count_include_pad(count_include_pad); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const int64_t& divisor_override() const { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) { impl_.set_divisor_override(divisor_override); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& padding() const { return impl_.padding(); }
  std::vector<std::int32_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int32_t>& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& stride() const { return impl_.stride(); }
  std::vector<std::int32_t>* mutable_stride() { return impl_.mutable_stride(); }
  void set_stride(const std::vector<std::int32_t>& stride) { impl_.set_stride(stride); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MaxPool3DGradOp {
 public:
  MaxPool3DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) { internal_->count_include_pad = count_include_pad; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) { internal_->divisor_override = divisor_override; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& padding() const { return internal_->padding; }
  std::vector<std::int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int32_t>& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& stride() const { return internal_->stride; }
  std::vector<std::int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<std::int32_t>& stride) { internal_->stride = stride; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    bool count_include_pad;
    std::string data_format;
    int64_t divisor_override;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> padding;
    std::vector<std::int32_t> stride;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MaxPool3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MaxPool3DOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int32_t>& padding) = 0;

  virtual const std::vector<std::int32_t>& stride() const = 0;
  virtual std::vector<std::int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<std::int32_t>& stride) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MaxPool3DOpInterpCtxImpl : public MaxPool3DOpInterpCtx {
 public:
  MaxPool3DOpInterpCtxImpl() = default;
  MaxPool3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const bool& count_include_pad() const { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) { impl_.set_count_include_pad(count_include_pad); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const int64_t& divisor_override() const { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) { impl_.set_divisor_override(divisor_override); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& padding() const { return impl_.padding(); }
  std::vector<std::int32_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int32_t>& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& stride() const { return impl_.stride(); }
  std::vector<std::int32_t>* mutable_stride() { return impl_.mutable_stride(); }
  void set_stride(const std::vector<std::int32_t>& stride) { impl_.set_stride(stride); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MaxPool3DOp {
 public:
  MaxPool3DOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) { internal_->count_include_pad = count_include_pad; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) { internal_->divisor_override = divisor_override; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& padding() const { return internal_->padding; }
  std::vector<std::int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int32_t>& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& stride() const { return internal_->stride; }
  std::vector<std::int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<std::int32_t>& stride) { internal_->stride = stride; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    bool count_include_pad;
    std::string data_format;
    int64_t divisor_override;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> padding;
    std::vector<std::int32_t> stride;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MegatronGptMmapDataLoaderOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MegatronGptMmapDataLoaderOpInterpCtx() = default;

  virtual const int64_t& batch_size() const = 0;
  virtual int64_t* mutable_batch_size() = 0;
  virtual void set_batch_size(const int64_t& batch_size) = 0;

  virtual const std::string& data_file_prefix() const = 0;
  virtual std::string* mutable_data_file_prefix() = 0;
  virtual void set_data_file_prefix(const std::string& data_file_prefix) = 0;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const int64_t& label_length() const = 0;
  virtual int64_t* mutable_label_length() = 0;
  virtual void set_label_length(const int64_t& label_length) = 0;

  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  virtual const int64_t& num_samples() const = 0;
  virtual int64_t* mutable_num_samples() = 0;
  virtual void set_num_samples(const int64_t& num_samples) = 0;

  virtual const int64_t& random_seed() const = 0;
  virtual int64_t* mutable_random_seed() = 0;
  virtual void set_random_seed(const int64_t& random_seed) = 0;

  virtual const int64_t& seq_length() const = 0;
  virtual int64_t* mutable_seq_length() = 0;
  virtual void set_seq_length(const int64_t& seq_length) = 0;

  virtual const bool& shuffle() const = 0;
  virtual bool* mutable_shuffle() = 0;
  virtual void set_shuffle(const bool& shuffle) = 0;

  virtual const int64_t& split_index() const = 0;
  virtual int64_t* mutable_split_index() = 0;
  virtual void set_split_index(const int64_t& split_index) = 0;

  virtual const std::vector<std::int64_t>& split_sizes() const = 0;
  virtual std::vector<std::int64_t>* mutable_split_sizes() = 0;
  virtual void set_split_sizes(const std::vector<std::int64_t>& split_sizes) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MegatronGptMmapDataLoaderOpInterpCtxImpl : public MegatronGptMmapDataLoaderOpInterpCtx {
 public:
  MegatronGptMmapDataLoaderOpInterpCtxImpl() = default;
  MegatronGptMmapDataLoaderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& batch_size() const { return impl_.batch_size(); }
  int64_t* mutable_batch_size() { return impl_.mutable_batch_size(); }
  void set_batch_size(const int64_t& batch_size) { impl_.set_batch_size(batch_size); }
  
  const std::string& data_file_prefix() const { return impl_.data_file_prefix(); }
  std::string* mutable_data_file_prefix() { return impl_.mutable_data_file_prefix(); }
  void set_data_file_prefix(const std::string& data_file_prefix) { impl_.set_data_file_prefix(data_file_prefix); }
  
  const DataType& dtype() const { return impl_.dtype(); }
  DataType* mutable_dtype() { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) { impl_.set_dtype(dtype); }
  
  const int64_t& label_length() const { return impl_.label_length(); }
  int64_t* mutable_label_length() { return impl_.mutable_label_length(); }
  void set_label_length(const int64_t& label_length) { impl_.set_label_length(label_length); }
  
  const std::vector<std::string>& nd_sbp() const { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { impl_.set_nd_sbp(nd_sbp); }
  
  const int64_t& num_samples() const { return impl_.num_samples(); }
  int64_t* mutable_num_samples() { return impl_.mutable_num_samples(); }
  void set_num_samples(const int64_t& num_samples) { impl_.set_num_samples(num_samples); }
  
  const int64_t& random_seed() const { return impl_.random_seed(); }
  int64_t* mutable_random_seed() { return impl_.mutable_random_seed(); }
  void set_random_seed(const int64_t& random_seed) { impl_.set_random_seed(random_seed); }
  
  const int64_t& seq_length() const { return impl_.seq_length(); }
  int64_t* mutable_seq_length() { return impl_.mutable_seq_length(); }
  void set_seq_length(const int64_t& seq_length) { impl_.set_seq_length(seq_length); }
  
  const bool& shuffle() const { return impl_.shuffle(); }
  bool* mutable_shuffle() { return impl_.mutable_shuffle(); }
  void set_shuffle(const bool& shuffle) { impl_.set_shuffle(shuffle); }
  
  const int64_t& split_index() const { return impl_.split_index(); }
  int64_t* mutable_split_index() { return impl_.mutable_split_index(); }
  void set_split_index(const int64_t& split_index) { impl_.set_split_index(split_index); }
  
  const std::vector<std::int64_t>& split_sizes() const { return impl_.split_sizes(); }
  std::vector<std::int64_t>* mutable_split_sizes() { return impl_.mutable_split_sizes(); }
  void set_split_sizes(const std::vector<std::int64_t>& split_sizes) { impl_.set_split_sizes(split_sizes); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MegatronGptMmapDataLoaderOp {
 public:
  MegatronGptMmapDataLoaderOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& batch_size() const { return internal_->batch_size; }
  int64_t* mutable_batch_size() { return &internal_->batch_size; }
  void set_batch_size(const int64_t& batch_size) { internal_->batch_size = batch_size; }
  
  const std::string& data_file_prefix() const { return internal_->data_file_prefix; }
  std::string* mutable_data_file_prefix() { return &internal_->data_file_prefix; }
  void set_data_file_prefix(const std::string& data_file_prefix) { internal_->data_file_prefix = data_file_prefix; }
  
  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }
  
  const int64_t& label_length() const { return internal_->label_length; }
  int64_t* mutable_label_length() { return &internal_->label_length; }
  void set_label_length(const int64_t& label_length) { internal_->label_length = label_length; }
  
  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }
  
  const int64_t& num_samples() const { return internal_->num_samples; }
  int64_t* mutable_num_samples() { return &internal_->num_samples; }
  void set_num_samples(const int64_t& num_samples) { internal_->num_samples = num_samples; }
  
  const int64_t& random_seed() const { return internal_->random_seed; }
  int64_t* mutable_random_seed() { return &internal_->random_seed; }
  void set_random_seed(const int64_t& random_seed) { internal_->random_seed = random_seed; }
  
  const int64_t& seq_length() const { return internal_->seq_length; }
  int64_t* mutable_seq_length() { return &internal_->seq_length; }
  void set_seq_length(const int64_t& seq_length) { internal_->seq_length = seq_length; }
  
  const bool& shuffle() const { return internal_->shuffle; }
  bool* mutable_shuffle() { return &internal_->shuffle; }
  void set_shuffle(const bool& shuffle) { internal_->shuffle = shuffle; }
  
  const int64_t& split_index() const { return internal_->split_index; }
  int64_t* mutable_split_index() { return &internal_->split_index; }
  void set_split_index(const int64_t& split_index) { internal_->split_index = split_index; }
  
  const std::vector<std::int64_t>& split_sizes() const { return internal_->split_sizes; }
  std::vector<std::int64_t>* mutable_split_sizes() { return &internal_->split_sizes; }
  void set_split_sizes(const std::vector<std::int64_t>& split_sizes) { internal_->split_sizes = split_sizes; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t batch_size = 0;
    std::string data_file_prefix;
    DataType dtype;
    int64_t label_length = 1;
    std::vector<std::string> nd_sbp;
    int64_t num_samples = 0;
    int64_t random_seed = 0;
    int64_t seq_length = 0;
    bool shuffle = false;
    int64_t split_index = 0;
    std::vector<std::int64_t> split_sizes;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MinMaxObserverOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MinMaxObserverOpInterpCtx() = default;

  virtual const bool& per_layer_quantization() const = 0;
  virtual bool* mutable_per_layer_quantization() = 0;
  virtual void set_per_layer_quantization(const bool& per_layer_quantization) = 0;

  virtual const int32_t& quantization_bit() const = 0;
  virtual int32_t* mutable_quantization_bit() = 0;
  virtual void set_quantization_bit(const int32_t& quantization_bit) = 0;

  virtual const std::string& quantization_formula() const = 0;
  virtual std::string* mutable_quantization_formula() = 0;
  virtual void set_quantization_formula(const std::string& quantization_formula) = 0;

  virtual const std::string& quantization_scheme() const = 0;
  virtual std::string* mutable_quantization_scheme() = 0;
  virtual void set_quantization_scheme(const std::string& quantization_scheme) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MinMaxObserverOpInterpCtxImpl : public MinMaxObserverOpInterpCtx {
 public:
  MinMaxObserverOpInterpCtxImpl() = default;
  MinMaxObserverOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& per_layer_quantization() const { return impl_.per_layer_quantization(); }
  bool* mutable_per_layer_quantization() { return impl_.mutable_per_layer_quantization(); }
  void set_per_layer_quantization(const bool& per_layer_quantization) { impl_.set_per_layer_quantization(per_layer_quantization); }
  
  const int32_t& quantization_bit() const { return impl_.quantization_bit(); }
  int32_t* mutable_quantization_bit() { return impl_.mutable_quantization_bit(); }
  void set_quantization_bit(const int32_t& quantization_bit) { impl_.set_quantization_bit(quantization_bit); }
  
  const std::string& quantization_formula() const { return impl_.quantization_formula(); }
  std::string* mutable_quantization_formula() { return impl_.mutable_quantization_formula(); }
  void set_quantization_formula(const std::string& quantization_formula) { impl_.set_quantization_formula(quantization_formula); }
  
  const std::string& quantization_scheme() const { return impl_.quantization_scheme(); }
  std::string* mutable_quantization_scheme() { return impl_.mutable_quantization_scheme(); }
  void set_quantization_scheme(const std::string& quantization_scheme) { impl_.set_quantization_scheme(quantization_scheme); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MinMaxObserverOp {
 public:
  MinMaxObserverOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& per_layer_quantization() const { return internal_->per_layer_quantization; }
  bool* mutable_per_layer_quantization() { return &internal_->per_layer_quantization; }
  void set_per_layer_quantization(const bool& per_layer_quantization) { internal_->per_layer_quantization = per_layer_quantization; }
  
  const int32_t& quantization_bit() const { return internal_->quantization_bit; }
  int32_t* mutable_quantization_bit() { return &internal_->quantization_bit; }
  void set_quantization_bit(const int32_t& quantization_bit) { internal_->quantization_bit = quantization_bit; }
  
  const std::string& quantization_formula() const { return internal_->quantization_formula; }
  std::string* mutable_quantization_formula() { return &internal_->quantization_formula; }
  void set_quantization_formula(const std::string& quantization_formula) { internal_->quantization_formula = quantization_formula; }
  
  const std::string& quantization_scheme() const { return internal_->quantization_scheme; }
  std::string* mutable_quantization_scheme() { return &internal_->quantization_scheme; }
  void set_quantization_scheme(const std::string& quantization_scheme) { internal_->quantization_scheme = quantization_scheme; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool per_layer_quantization = true;
    int32_t quantization_bit = 8;
    std::string quantization_formula = "google";
    std::string quantization_scheme = "symmetric";
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MishGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MishGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MishGradOpInterpCtxImpl : public MishGradOpInterpCtx {
 public:
  MishGradOpInterpCtxImpl() = default;
  MishGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MishGradOp {
 public:
  MishGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MishOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MishOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MishOpInterpCtxImpl : public MishOpInterpCtx {
 public:
  MishOpInterpCtxImpl() = default;
  MishOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MishOp {
 public:
  MishOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MomentumUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MomentumUpdateOpInterpCtx() = default;

  virtual const float& beta() const = 0;
  virtual float* mutable_beta() = 0;
  virtual void set_beta(const float& beta) = 0;

  virtual const float& l1() const = 0;
  virtual float* mutable_l1() = 0;
  virtual void set_l1(const float& l1) = 0;

  virtual const float& l2() const = 0;
  virtual float* mutable_l2() = 0;
  virtual void set_l2(const float& l2) = 0;

  virtual const float& learning_rate_val() const = 0;
  virtual float* mutable_learning_rate_val() = 0;
  virtual void set_learning_rate_val(const float& learning_rate_val) = 0;

  virtual const double& scale() const = 0;
  virtual double* mutable_scale() = 0;
  virtual void set_scale(const double& scale) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MomentumUpdateOpInterpCtxImpl : public MomentumUpdateOpInterpCtx {
 public:
  MomentumUpdateOpInterpCtxImpl() = default;
  MomentumUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& beta() const { return impl_.beta(); }
  float* mutable_beta() { return impl_.mutable_beta(); }
  void set_beta(const float& beta) { impl_.set_beta(beta); }
  
  const float& l1() const { return impl_.l1(); }
  float* mutable_l1() { return impl_.mutable_l1(); }
  void set_l1(const float& l1) { impl_.set_l1(l1); }
  
  const float& l2() const { return impl_.l2(); }
  float* mutable_l2() { return impl_.mutable_l2(); }
  void set_l2(const float& l2) { impl_.set_l2(l2); }
  
  const float& learning_rate_val() const { return impl_.learning_rate_val(); }
  float* mutable_learning_rate_val() { return impl_.mutable_learning_rate_val(); }
  void set_learning_rate_val(const float& learning_rate_val) { impl_.set_learning_rate_val(learning_rate_val); }
  
  const double& scale() const { return impl_.scale(); }
  double* mutable_scale() { return impl_.mutable_scale(); }
  void set_scale(const double& scale) { impl_.set_scale(scale); }
  
  const float& weight_decay() const { return impl_.weight_decay(); }
  float* mutable_weight_decay() { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) { impl_.set_weight_decay(weight_decay); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MomentumUpdateOp {
 public:
  MomentumUpdateOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& beta() const { return internal_->beta; }
  float* mutable_beta() { return &internal_->beta; }
  void set_beta(const float& beta) { internal_->beta = beta; }
  
  const float& l1() const { return internal_->l1; }
  float* mutable_l1() { return &internal_->l1; }
  void set_l1(const float& l1) { internal_->l1 = l1; }
  
  const float& l2() const { return internal_->l2; }
  float* mutable_l2() { return &internal_->l2; }
  void set_l2(const float& l2) { internal_->l2 = l2; }
  
  const float& learning_rate_val() const { return internal_->learning_rate_val; }
  float* mutable_learning_rate_val() { return &internal_->learning_rate_val; }
  void set_learning_rate_val(const float& learning_rate_val) { internal_->learning_rate_val = learning_rate_val; }
  
  const double& scale() const { return internal_->scale; }
  double* mutable_scale() { return &internal_->scale; }
  void set_scale(const double& scale) { internal_->scale = scale; }
  
  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float beta = 0.9;
    float l1 = 0.;
    float l2 = 0.;
    float learning_rate_val = 0.;
    double scale = 1.;
    float weight_decay = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MovingAverageMinMaxObserverOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MovingAverageMinMaxObserverOpInterpCtx() = default;

  virtual const float& momentum() const = 0;
  virtual float* mutable_momentum() = 0;
  virtual void set_momentum(const float& momentum) = 0;

  virtual const int32_t& quantization_bit() const = 0;
  virtual int32_t* mutable_quantization_bit() = 0;
  virtual void set_quantization_bit(const int32_t& quantization_bit) = 0;

  virtual const std::string& quantization_formula() const = 0;
  virtual std::string* mutable_quantization_formula() = 0;
  virtual void set_quantization_formula(const std::string& quantization_formula) = 0;

  virtual const std::string& quantization_scheme() const = 0;
  virtual std::string* mutable_quantization_scheme() = 0;
  virtual void set_quantization_scheme(const std::string& quantization_scheme) = 0;

  virtual const int64_t& stop_update_after_iters() const = 0;
  virtual int64_t* mutable_stop_update_after_iters() = 0;
  virtual void set_stop_update_after_iters(const int64_t& stop_update_after_iters) = 0;

  virtual const bool& training() const = 0;
  virtual bool* mutable_training() = 0;
  virtual void set_training(const bool& training) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MovingAverageMinMaxObserverOpInterpCtxImpl : public MovingAverageMinMaxObserverOpInterpCtx {
 public:
  MovingAverageMinMaxObserverOpInterpCtxImpl() = default;
  MovingAverageMinMaxObserverOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& momentum() const { return impl_.momentum(); }
  float* mutable_momentum() { return impl_.mutable_momentum(); }
  void set_momentum(const float& momentum) { impl_.set_momentum(momentum); }
  
  const int32_t& quantization_bit() const { return impl_.quantization_bit(); }
  int32_t* mutable_quantization_bit() { return impl_.mutable_quantization_bit(); }
  void set_quantization_bit(const int32_t& quantization_bit) { impl_.set_quantization_bit(quantization_bit); }
  
  const std::string& quantization_formula() const { return impl_.quantization_formula(); }
  std::string* mutable_quantization_formula() { return impl_.mutable_quantization_formula(); }
  void set_quantization_formula(const std::string& quantization_formula) { impl_.set_quantization_formula(quantization_formula); }
  
  const std::string& quantization_scheme() const { return impl_.quantization_scheme(); }
  std::string* mutable_quantization_scheme() { return impl_.mutable_quantization_scheme(); }
  void set_quantization_scheme(const std::string& quantization_scheme) { impl_.set_quantization_scheme(quantization_scheme); }
  
  const int64_t& stop_update_after_iters() const { return impl_.stop_update_after_iters(); }
  int64_t* mutable_stop_update_after_iters() { return impl_.mutable_stop_update_after_iters(); }
  void set_stop_update_after_iters(const int64_t& stop_update_after_iters) { impl_.set_stop_update_after_iters(stop_update_after_iters); }
  
  const bool& training() const { return impl_.training(); }
  bool* mutable_training() { return impl_.mutable_training(); }
  void set_training(const bool& training) { impl_.set_training(training); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MovingAverageMinMaxObserverOp {
 public:
  MovingAverageMinMaxObserverOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& momentum() const { return internal_->momentum; }
  float* mutable_momentum() { return &internal_->momentum; }
  void set_momentum(const float& momentum) { internal_->momentum = momentum; }
  
  const int32_t& quantization_bit() const { return internal_->quantization_bit; }
  int32_t* mutable_quantization_bit() { return &internal_->quantization_bit; }
  void set_quantization_bit(const int32_t& quantization_bit) { internal_->quantization_bit = quantization_bit; }
  
  const std::string& quantization_formula() const { return internal_->quantization_formula; }
  std::string* mutable_quantization_formula() { return &internal_->quantization_formula; }
  void set_quantization_formula(const std::string& quantization_formula) { internal_->quantization_formula = quantization_formula; }
  
  const std::string& quantization_scheme() const { return internal_->quantization_scheme; }
  std::string* mutable_quantization_scheme() { return &internal_->quantization_scheme; }
  void set_quantization_scheme(const std::string& quantization_scheme) { internal_->quantization_scheme = quantization_scheme; }
  
  const int64_t& stop_update_after_iters() const { return internal_->stop_update_after_iters; }
  int64_t* mutable_stop_update_after_iters() { return &internal_->stop_update_after_iters; }
  void set_stop_update_after_iters(const int64_t& stop_update_after_iters) { internal_->stop_update_after_iters = stop_update_after_iters; }
  
  const bool& training() const { return internal_->training; }
  bool* mutable_training() { return &internal_->training; }
  void set_training(const bool& training) { internal_->training = training; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float momentum = 0.95;
    int32_t quantization_bit = 8;
    std::string quantization_formula = "google";
    std::string quantization_scheme = "symmetric";
    int64_t stop_update_after_iters = 0;
    bool training = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MultiCountNotFiniteOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MultiCountNotFiniteOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MultiCountNotFiniteOpInterpCtxImpl : public MultiCountNotFiniteOpInterpCtx {
 public:
  MultiCountNotFiniteOpInterpCtxImpl() = default;
  MultiCountNotFiniteOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MultiCountNotFiniteOp {
 public:
  MultiCountNotFiniteOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MultiSquareSumOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MultiSquareSumOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MultiSquareSumOpInterpCtxImpl : public MultiSquareSumOpInterpCtx {
 public:
  MultiSquareSumOpInterpCtxImpl() = default;
  MultiSquareSumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MultiSquareSumOp {
 public:
  MultiSquareSumOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class MultiplyOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~MultiplyOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class MultiplyOpInterpCtxImpl : public MultiplyOpInterpCtx {
 public:
  MultiplyOpInterpCtxImpl() = default;
  MultiplyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MultiplyOp {
 public:
  MultiplyOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class NarrowGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~NarrowGradOpInterpCtx() = default;

  virtual const int64_t& dim() const = 0;
  virtual int64_t* mutable_dim() = 0;
  virtual void set_dim(const int64_t& dim) = 0;

  virtual const int64_t& length() const = 0;
  virtual int64_t* mutable_length() = 0;
  virtual void set_length(const int64_t& length) = 0;

  virtual const int64_t& start() const = 0;
  virtual int64_t* mutable_start() = 0;
  virtual void set_start(const int64_t& start) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class NarrowGradOpInterpCtxImpl : public NarrowGradOpInterpCtx {
 public:
  NarrowGradOpInterpCtxImpl() = default;
  NarrowGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& dim() const { return impl_.dim(); }
  int64_t* mutable_dim() { return impl_.mutable_dim(); }
  void set_dim(const int64_t& dim) { impl_.set_dim(dim); }
  
  const int64_t& length() const { return impl_.length(); }
  int64_t* mutable_length() { return impl_.mutable_length(); }
  void set_length(const int64_t& length) { impl_.set_length(length); }
  
  const int64_t& start() const { return impl_.start(); }
  int64_t* mutable_start() { return impl_.mutable_start(); }
  void set_start(const int64_t& start) { impl_.set_start(start); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NarrowGradOp {
 public:
  NarrowGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& dim() const { return internal_->dim; }
  int64_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int64_t& dim) { internal_->dim = dim; }
  
  const int64_t& length() const { return internal_->length; }
  int64_t* mutable_length() { return &internal_->length; }
  void set_length(const int64_t& length) { internal_->length = length; }
  
  const int64_t& start() const { return internal_->start; }
  int64_t* mutable_start() { return &internal_->start; }
  void set_start(const int64_t& start) { internal_->start = start; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t dim = 0;
    int64_t length = 0;
    int64_t start = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class NarrowOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~NarrowOpInterpCtx() = default;

  virtual const int64_t& dim() const = 0;
  virtual int64_t* mutable_dim() = 0;
  virtual void set_dim(const int64_t& dim) = 0;

  virtual const int64_t& length() const = 0;
  virtual int64_t* mutable_length() = 0;
  virtual void set_length(const int64_t& length) = 0;

  virtual const int64_t& start() const = 0;
  virtual int64_t* mutable_start() = 0;
  virtual void set_start(const int64_t& start) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class NarrowOpInterpCtxImpl : public NarrowOpInterpCtx {
 public:
  NarrowOpInterpCtxImpl() = default;
  NarrowOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& dim() const { return impl_.dim(); }
  int64_t* mutable_dim() { return impl_.mutable_dim(); }
  void set_dim(const int64_t& dim) { impl_.set_dim(dim); }
  
  const int64_t& length() const { return impl_.length(); }
  int64_t* mutable_length() { return impl_.mutable_length(); }
  void set_length(const int64_t& length) { impl_.set_length(length); }
  
  const int64_t& start() const { return impl_.start(); }
  int64_t* mutable_start() { return impl_.mutable_start(); }
  void set_start(const int64_t& start) { impl_.set_start(start); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NarrowOp {
 public:
  NarrowOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& dim() const { return internal_->dim; }
  int64_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int64_t& dim) { internal_->dim = dim; }
  
  const int64_t& length() const { return internal_->length; }
  int64_t* mutable_length() { return &internal_->length; }
  void set_length(const int64_t& length) { internal_->length = length; }
  
  const int64_t& start() const { return internal_->start; }
  int64_t* mutable_start() { return &internal_->start; }
  void set_start(const int64_t& start) { internal_->start = start; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t dim = 0;
    int64_t length = 0;
    int64_t start = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class NegativeGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~NegativeGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class NegativeGradOpInterpCtxImpl : public NegativeGradOpInterpCtx {
 public:
  NegativeGradOpInterpCtxImpl() = default;
  NegativeGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NegativeGradOp {
 public:
  NegativeGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class NegativeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~NegativeOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class NegativeOpInterpCtxImpl : public NegativeOpInterpCtx {
 public:
  NegativeOpInterpCtxImpl() = default;
  NegativeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NegativeOp {
 public:
  NegativeOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class NllGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~NllGradOpInterpCtx() = default;

  virtual const int64_t& ignore_index() const = 0;
  virtual int64_t* mutable_ignore_index() = 0;
  virtual void set_ignore_index(const int64_t& ignore_index) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class NllGradOpInterpCtxImpl : public NllGradOpInterpCtx {
 public:
  NllGradOpInterpCtxImpl() = default;
  NllGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& ignore_index() const { return impl_.ignore_index(); }
  int64_t* mutable_ignore_index() { return impl_.mutable_ignore_index(); }
  void set_ignore_index(const int64_t& ignore_index) { impl_.set_ignore_index(ignore_index); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NllGradOp {
 public:
  NllGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& ignore_index() const { return internal_->ignore_index; }
  int64_t* mutable_ignore_index() { return &internal_->ignore_index; }
  void set_ignore_index(const int64_t& ignore_index) { internal_->ignore_index = ignore_index; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t ignore_index = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class NllOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~NllOpInterpCtx() = default;

  virtual const int64_t& ignore_index() const = 0;
  virtual int64_t* mutable_ignore_index() = 0;
  virtual void set_ignore_index(const int64_t& ignore_index) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class NllOpInterpCtxImpl : public NllOpInterpCtx {
 public:
  NllOpInterpCtxImpl() = default;
  NllOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& ignore_index() const { return impl_.ignore_index(); }
  int64_t* mutable_ignore_index() { return impl_.mutable_ignore_index(); }
  void set_ignore_index(const int64_t& ignore_index) { impl_.set_ignore_index(ignore_index); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NllOp {
 public:
  NllOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& ignore_index() const { return internal_->ignore_index; }
  int64_t* mutable_ignore_index() { return &internal_->ignore_index; }
  void set_ignore_index(const int64_t& ignore_index) { internal_->ignore_index = ignore_index; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t ignore_index = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class NmsOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~NmsOpInterpCtx() = default;

  virtual const float& iou_threshold() const = 0;
  virtual float* mutable_iou_threshold() = 0;
  virtual void set_iou_threshold(const float& iou_threshold) = 0;

  virtual const int32_t& keep_n() const = 0;
  virtual int32_t* mutable_keep_n() = 0;
  virtual void set_keep_n(const int32_t& keep_n) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class NmsOpInterpCtxImpl : public NmsOpInterpCtx {
 public:
  NmsOpInterpCtxImpl() = default;
  NmsOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& iou_threshold() const { return impl_.iou_threshold(); }
  float* mutable_iou_threshold() { return impl_.mutable_iou_threshold(); }
  void set_iou_threshold(const float& iou_threshold) { impl_.set_iou_threshold(iou_threshold); }
  
  const int32_t& keep_n() const { return impl_.keep_n(); }
  int32_t* mutable_keep_n() { return impl_.mutable_keep_n(); }
  void set_keep_n(const int32_t& keep_n) { impl_.set_keep_n(keep_n); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NmsOp {
 public:
  NmsOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& iou_threshold() const { return internal_->iou_threshold; }
  float* mutable_iou_threshold() { return &internal_->iou_threshold; }
  void set_iou_threshold(const float& iou_threshold) { internal_->iou_threshold = iou_threshold; }
  
  const int32_t& keep_n() const { return internal_->keep_n; }
  int32_t* mutable_keep_n() { return &internal_->keep_n; }
  void set_keep_n(const int32_t& keep_n) { internal_->keep_n = keep_n; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float iou_threshold = 0.;
    int32_t keep_n = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class NormalOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~NormalOpInterpCtx() = default;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const double& mean() const = 0;
  virtual double* mutable_mean() = 0;
  virtual void set_mean(const double& mean) = 0;

  virtual const std::string& nd_sbp() const = 0;
  virtual std::string* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::string& nd_sbp) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  virtual const double& std() const = 0;
  virtual double* mutable_std() = 0;
  virtual void set_std(const double& std) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class NormalOpInterpCtxImpl : public NormalOpInterpCtx {
 public:
  NormalOpInterpCtxImpl() = default;
  NormalOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const DataType& dtype() const { return impl_.dtype(); }
  DataType* mutable_dtype() { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) { impl_.set_dtype(dtype); }
  
  const double& mean() const { return impl_.mean(); }
  double* mutable_mean() { return impl_.mutable_mean(); }
  void set_mean(const double& mean) { impl_.set_mean(mean); }
  
  const std::string& nd_sbp() const { return impl_.nd_sbp(); }
  std::string* mutable_nd_sbp() { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::string& nd_sbp) { impl_.set_nd_sbp(nd_sbp); }
  
  const int64_t& seed() const { return impl_.seed(); }
  int64_t* mutable_seed() { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) { impl_.set_seed(seed); }
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  const double& std() const { return impl_.std(); }
  double* mutable_std() { return impl_.mutable_std(); }
  void set_std(const double& std) { impl_.set_std(std); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NormalOp {
 public:
  NormalOp() : internal_(std::make_shared<Internal>()) {}
  
  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }
  
  const double& mean() const { return internal_->mean; }
  double* mutable_mean() { return &internal_->mean; }
  void set_mean(const double& mean) { internal_->mean = mean; }
  
  const std::string& nd_sbp() const { return internal_->nd_sbp; }
  std::string* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::string& nd_sbp) { internal_->nd_sbp = nd_sbp; }
  
  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  const double& std() const { return internal_->std; }
  double* mutable_std() { return &internal_->std; }
  void set_std(const double& std) { internal_->std = std; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    DataType dtype;
    double mean = 0.;
    std::string nd_sbp;
    int64_t seed = 0;
    Shape shape;
    double std = 1.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class NormalizationAddReluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~NormalizationAddReluGradOpInterpCtx() = default;

  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class NormalizationAddReluGradOpInterpCtxImpl : public NormalizationAddReluGradOpInterpCtx {
 public:
  NormalizationAddReluGradOpInterpCtxImpl() = default;
  NormalizationAddReluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& axis() const { return impl_.axis(); }
  int32_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) { impl_.set_axis(axis); }
  
  const float& epsilon() const { return impl_.epsilon(); }
  float* mutable_epsilon() { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) { impl_.set_epsilon(epsilon); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NormalizationAddReluGradOp {
 public:
  NormalizationAddReluGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }
  
  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t axis = 0;
    float epsilon = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class NormalizationGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~NormalizationGradOpInterpCtx() = default;

  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class NormalizationGradOpInterpCtxImpl : public NormalizationGradOpInterpCtx {
 public:
  NormalizationGradOpInterpCtxImpl() = default;
  NormalizationGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& axis() const { return impl_.axis(); }
  int32_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) { impl_.set_axis(axis); }
  
  const float& epsilon() const { return impl_.epsilon(); }
  float* mutable_epsilon() { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) { impl_.set_epsilon(epsilon); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NormalizationGradOp {
 public:
  NormalizationGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }
  
  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t axis = 0;
    float epsilon = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class NormalizationOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~NormalizationOpInterpCtx() = default;

  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  virtual const float& momentum() const = 0;
  virtual float* mutable_momentum() = 0;
  virtual void set_momentum(const float& momentum) = 0;

  virtual const bool& training() const = 0;
  virtual bool* mutable_training() = 0;
  virtual void set_training(const bool& training) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class NormalizationOpInterpCtxImpl : public NormalizationOpInterpCtx {
 public:
  NormalizationOpInterpCtxImpl() = default;
  NormalizationOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& axis() const { return impl_.axis(); }
  int32_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) { impl_.set_axis(axis); }
  
  const float& epsilon() const { return impl_.epsilon(); }
  float* mutable_epsilon() { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) { impl_.set_epsilon(epsilon); }
  
  const float& momentum() const { return impl_.momentum(); }
  float* mutable_momentum() { return impl_.mutable_momentum(); }
  void set_momentum(const float& momentum) { impl_.set_momentum(momentum); }
  
  const bool& training() const { return impl_.training(); }
  bool* mutable_training() { return impl_.mutable_training(); }
  void set_training(const bool& training) { impl_.set_training(training); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NormalizationOp {
 public:
  NormalizationOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }
  
  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }
  
  const float& momentum() const { return internal_->momentum; }
  float* mutable_momentum() { return &internal_->momentum; }
  void set_momentum(const float& momentum) { internal_->momentum = momentum; }
  
  const bool& training() const { return internal_->training; }
  bool* mutable_training() { return &internal_->training; }
  void set_training(const bool& training) { internal_->training = training; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t axis = 0;
    float epsilon = 0.;
    float momentum = 0.;
    bool training = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class NvtxEndOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~NvtxEndOpInterpCtx() = default;

  virtual const std::string& mark_prefix() const = 0;
  virtual std::string* mutable_mark_prefix() = 0;
  virtual void set_mark_prefix(const std::string& mark_prefix) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class NvtxEndOpInterpCtxImpl : public NvtxEndOpInterpCtx {
 public:
  NvtxEndOpInterpCtxImpl() = default;
  NvtxEndOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& mark_prefix() const { return impl_.mark_prefix(); }
  std::string* mutable_mark_prefix() { return impl_.mutable_mark_prefix(); }
  void set_mark_prefix(const std::string& mark_prefix) { impl_.set_mark_prefix(mark_prefix); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NvtxEndOp {
 public:
  NvtxEndOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& mark_prefix() const { return internal_->mark_prefix; }
  std::string* mutable_mark_prefix() { return &internal_->mark_prefix; }
  void set_mark_prefix(const std::string& mark_prefix) { internal_->mark_prefix = mark_prefix; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string mark_prefix;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class NvtxStartOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~NvtxStartOpInterpCtx() = default;

  virtual const std::string& mark_prefix() const = 0;
  virtual std::string* mutable_mark_prefix() = 0;
  virtual void set_mark_prefix(const std::string& mark_prefix) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class NvtxStartOpInterpCtxImpl : public NvtxStartOpInterpCtx {
 public:
  NvtxStartOpInterpCtxImpl() = default;
  NvtxStartOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& mark_prefix() const { return impl_.mark_prefix(); }
  std::string* mutable_mark_prefix() { return impl_.mutable_mark_prefix(); }
  void set_mark_prefix(const std::string& mark_prefix) { impl_.set_mark_prefix(mark_prefix); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NvtxStartOp {
 public:
  NvtxStartOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& mark_prefix() const { return internal_->mark_prefix; }
  std::string* mutable_mark_prefix() { return &internal_->mark_prefix; }
  void set_mark_prefix(const std::string& mark_prefix) { internal_->mark_prefix = mark_prefix; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string mark_prefix;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class OFRecordReaderOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~OFRecordReaderOpInterpCtx() = default;

  virtual const int32_t& batch_size() const = 0;
  virtual int32_t* mutable_batch_size() = 0;
  virtual void set_batch_size(const int32_t& batch_size) = 0;

  virtual const std::string& data_dir() const = 0;
  virtual std::string* mutable_data_dir() = 0;
  virtual void set_data_dir(const std::string& data_dir) = 0;

  virtual const int32_t& data_part_num() const = 0;
  virtual int32_t* mutable_data_part_num() = 0;
  virtual void set_data_part_num(const int32_t& data_part_num) = 0;

  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  virtual const std::string& part_name_prefix() const = 0;
  virtual std::string* mutable_part_name_prefix() = 0;
  virtual void set_part_name_prefix(const std::string& part_name_prefix) = 0;

  virtual const int32_t& part_name_suffix_length() const = 0;
  virtual int32_t* mutable_part_name_suffix_length() = 0;
  virtual void set_part_name_suffix_length(const int32_t& part_name_suffix_length) = 0;

  virtual const bool& random_shuffle() const = 0;
  virtual bool* mutable_random_shuffle() = 0;
  virtual void set_random_shuffle(const bool& random_shuffle) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const bool& shuffle_after_epoch() const = 0;
  virtual bool* mutable_shuffle_after_epoch() = 0;
  virtual void set_shuffle_after_epoch(const bool& shuffle_after_epoch) = 0;

  virtual const int32_t& shuffle_buffer_size() const = 0;
  virtual int32_t* mutable_shuffle_buffer_size() = 0;
  virtual void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class OFRecordReaderOpInterpCtxImpl : public OFRecordReaderOpInterpCtx {
 public:
  OFRecordReaderOpInterpCtxImpl() = default;
  OFRecordReaderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& batch_size() const { return impl_.batch_size(); }
  int32_t* mutable_batch_size() { return impl_.mutable_batch_size(); }
  void set_batch_size(const int32_t& batch_size) { impl_.set_batch_size(batch_size); }
  
  const std::string& data_dir() const { return impl_.data_dir(); }
  std::string* mutable_data_dir() { return impl_.mutable_data_dir(); }
  void set_data_dir(const std::string& data_dir) { impl_.set_data_dir(data_dir); }
  
  const int32_t& data_part_num() const { return impl_.data_part_num(); }
  int32_t* mutable_data_part_num() { return impl_.mutable_data_part_num(); }
  void set_data_part_num(const int32_t& data_part_num) { impl_.set_data_part_num(data_part_num); }
  
  const std::vector<std::string>& nd_sbp() const { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { impl_.set_nd_sbp(nd_sbp); }
  
  const std::string& part_name_prefix() const { return impl_.part_name_prefix(); }
  std::string* mutable_part_name_prefix() { return impl_.mutable_part_name_prefix(); }
  void set_part_name_prefix(const std::string& part_name_prefix) { impl_.set_part_name_prefix(part_name_prefix); }
  
  const int32_t& part_name_suffix_length() const { return impl_.part_name_suffix_length(); }
  int32_t* mutable_part_name_suffix_length() { return impl_.mutable_part_name_suffix_length(); }
  void set_part_name_suffix_length(const int32_t& part_name_suffix_length) { impl_.set_part_name_suffix_length(part_name_suffix_length); }
  
  const bool& random_shuffle() const { return impl_.random_shuffle(); }
  bool* mutable_random_shuffle() { return impl_.mutable_random_shuffle(); }
  void set_random_shuffle(const bool& random_shuffle) { impl_.set_random_shuffle(random_shuffle); }
  
  const int64_t& seed() const { return impl_.seed(); }
  int64_t* mutable_seed() { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) { impl_.set_seed(seed); }
  
  const bool& shuffle_after_epoch() const { return impl_.shuffle_after_epoch(); }
  bool* mutable_shuffle_after_epoch() { return impl_.mutable_shuffle_after_epoch(); }
  void set_shuffle_after_epoch(const bool& shuffle_after_epoch) { impl_.set_shuffle_after_epoch(shuffle_after_epoch); }
  
  const int32_t& shuffle_buffer_size() const { return impl_.shuffle_buffer_size(); }
  int32_t* mutable_shuffle_buffer_size() { return impl_.mutable_shuffle_buffer_size(); }
  void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) { impl_.set_shuffle_buffer_size(shuffle_buffer_size); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OFRecordReaderOp {
 public:
  OFRecordReaderOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& batch_size() const { return internal_->batch_size; }
  int32_t* mutable_batch_size() { return &internal_->batch_size; }
  void set_batch_size(const int32_t& batch_size) { internal_->batch_size = batch_size; }
  
  const std::string& data_dir() const { return internal_->data_dir; }
  std::string* mutable_data_dir() { return &internal_->data_dir; }
  void set_data_dir(const std::string& data_dir) { internal_->data_dir = data_dir; }
  
  const int32_t& data_part_num() const { return internal_->data_part_num; }
  int32_t* mutable_data_part_num() { return &internal_->data_part_num; }
  void set_data_part_num(const int32_t& data_part_num) { internal_->data_part_num = data_part_num; }
  
  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }
  
  const std::string& part_name_prefix() const { return internal_->part_name_prefix; }
  std::string* mutable_part_name_prefix() { return &internal_->part_name_prefix; }
  void set_part_name_prefix(const std::string& part_name_prefix) { internal_->part_name_prefix = part_name_prefix; }
  
  const int32_t& part_name_suffix_length() const { return internal_->part_name_suffix_length; }
  int32_t* mutable_part_name_suffix_length() { return &internal_->part_name_suffix_length; }
  void set_part_name_suffix_length(const int32_t& part_name_suffix_length) { internal_->part_name_suffix_length = part_name_suffix_length; }
  
  const bool& random_shuffle() const { return internal_->random_shuffle; }
  bool* mutable_random_shuffle() { return &internal_->random_shuffle; }
  void set_random_shuffle(const bool& random_shuffle) { internal_->random_shuffle = random_shuffle; }
  
  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }
  
  const bool& shuffle_after_epoch() const { return internal_->shuffle_after_epoch; }
  bool* mutable_shuffle_after_epoch() { return &internal_->shuffle_after_epoch; }
  void set_shuffle_after_epoch(const bool& shuffle_after_epoch) { internal_->shuffle_after_epoch = shuffle_after_epoch; }
  
  const int32_t& shuffle_buffer_size() const { return internal_->shuffle_buffer_size; }
  int32_t* mutable_shuffle_buffer_size() { return &internal_->shuffle_buffer_size; }
  void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) { internal_->shuffle_buffer_size = shuffle_buffer_size; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t batch_size = 0;
    std::string data_dir;
    int32_t data_part_num = 0;
    std::vector<std::string> nd_sbp;
    std::string part_name_prefix = "part-";
    int32_t part_name_suffix_length = -1;
    bool random_shuffle = false;
    int64_t seed = -1;
    bool shuffle_after_epoch = false;
    int32_t shuffle_buffer_size = 1024;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ObjectBboxFlipOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ObjectBboxFlipOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ObjectBboxFlipOpInterpCtxImpl : public ObjectBboxFlipOpInterpCtx {
 public:
  ObjectBboxFlipOpInterpCtxImpl() = default;
  ObjectBboxFlipOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ObjectBboxFlipOp {
 public:
  ObjectBboxFlipOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ObjectBboxScaleOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ObjectBboxScaleOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ObjectBboxScaleOpInterpCtxImpl : public ObjectBboxScaleOpInterpCtx {
 public:
  ObjectBboxScaleOpInterpCtxImpl() = default;
  ObjectBboxScaleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ObjectBboxScaleOp {
 public:
  ObjectBboxScaleOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ObjectSegmentationPolygonFlipOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ObjectSegmentationPolygonFlipOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ObjectSegmentationPolygonFlipOpInterpCtxImpl : public ObjectSegmentationPolygonFlipOpInterpCtx {
 public:
  ObjectSegmentationPolygonFlipOpInterpCtxImpl() = default;
  ObjectSegmentationPolygonFlipOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ObjectSegmentationPolygonFlipOp {
 public:
  ObjectSegmentationPolygonFlipOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ObjectSegmentationPolygonScaleOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ObjectSegmentationPolygonScaleOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ObjectSegmentationPolygonScaleOpInterpCtxImpl : public ObjectSegmentationPolygonScaleOpInterpCtx {
 public:
  ObjectSegmentationPolygonScaleOpInterpCtxImpl() = default;
  ObjectSegmentationPolygonScaleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ObjectSegmentationPolygonScaleOp {
 public:
  ObjectSegmentationPolygonScaleOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ObjectSegmentationPolygonToMaskOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ObjectSegmentationPolygonToMaskOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ObjectSegmentationPolygonToMaskOpInterpCtxImpl : public ObjectSegmentationPolygonToMaskOpInterpCtx {
 public:
  ObjectSegmentationPolygonToMaskOpInterpCtxImpl() = default;
  ObjectSegmentationPolygonToMaskOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ObjectSegmentationPolygonToMaskOp {
 public:
  ObjectSegmentationPolygonToMaskOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class OfrecordBytesDecoderOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~OfrecordBytesDecoderOpInterpCtx() = default;

  virtual const std::string& name() const = 0;
  virtual std::string* mutable_name() = 0;
  virtual void set_name(const std::string& name) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class OfrecordBytesDecoderOpInterpCtxImpl : public OfrecordBytesDecoderOpInterpCtx {
 public:
  OfrecordBytesDecoderOpInterpCtxImpl() = default;
  OfrecordBytesDecoderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& name() const { return impl_.name(); }
  std::string* mutable_name() { return impl_.mutable_name(); }
  void set_name(const std::string& name) { impl_.set_name(name); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OfrecordBytesDecoderOp {
 public:
  OfrecordBytesDecoderOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& name() const { return internal_->name; }
  std::string* mutable_name() { return &internal_->name; }
  void set_name(const std::string& name) { internal_->name = name; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string name;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class OfrecordImageClassificationReaderOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~OfrecordImageClassificationReaderOpInterpCtx() = default;

  virtual const int32_t& batch_size() const = 0;
  virtual int32_t* mutable_batch_size() = 0;
  virtual void set_batch_size(const int32_t& batch_size) = 0;

  virtual const std::string& color_space() const = 0;
  virtual std::string* mutable_color_space() = 0;
  virtual void set_color_space(const std::string& color_space) = 0;

  virtual const std::string& data_dir() const = 0;
  virtual std::string* mutable_data_dir() = 0;
  virtual void set_data_dir(const std::string& data_dir) = 0;

  virtual const int32_t& data_part_num() const = 0;
  virtual int32_t* mutable_data_part_num() = 0;
  virtual void set_data_part_num(const int32_t& data_part_num) = 0;

  virtual const int32_t& decode_buffer_size_per_thread() const = 0;
  virtual int32_t* mutable_decode_buffer_size_per_thread() = 0;
  virtual void set_decode_buffer_size_per_thread(const int32_t& decode_buffer_size_per_thread) = 0;

  virtual const std::string& image_feature_name() const = 0;
  virtual std::string* mutable_image_feature_name() = 0;
  virtual void set_image_feature_name(const std::string& image_feature_name) = 0;

  virtual const std::string& label_feature_name() const = 0;
  virtual std::string* mutable_label_feature_name() = 0;
  virtual void set_label_feature_name(const std::string& label_feature_name) = 0;

  virtual const int32_t& num_decode_threads_per_machine() const = 0;
  virtual int32_t* mutable_num_decode_threads_per_machine() = 0;
  virtual void set_num_decode_threads_per_machine(const int32_t& num_decode_threads_per_machine) = 0;

  virtual const std::string& part_name_prefix() const = 0;
  virtual std::string* mutable_part_name_prefix() = 0;
  virtual void set_part_name_prefix(const std::string& part_name_prefix) = 0;

  virtual const int32_t& part_name_suffix_length() const = 0;
  virtual int32_t* mutable_part_name_suffix_length() = 0;
  virtual void set_part_name_suffix_length(const int32_t& part_name_suffix_length) = 0;

  virtual const bool& random_shuffle() const = 0;
  virtual bool* mutable_random_shuffle() = 0;
  virtual void set_random_shuffle(const bool& random_shuffle) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const bool& shuffle_after_epoch() const = 0;
  virtual bool* mutable_shuffle_after_epoch() = 0;
  virtual void set_shuffle_after_epoch(const bool& shuffle_after_epoch) = 0;

  virtual const int32_t& shuffle_buffer_size() const = 0;
  virtual int32_t* mutable_shuffle_buffer_size() = 0;
  virtual void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class OfrecordImageClassificationReaderOpInterpCtxImpl : public OfrecordImageClassificationReaderOpInterpCtx {
 public:
  OfrecordImageClassificationReaderOpInterpCtxImpl() = default;
  OfrecordImageClassificationReaderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& batch_size() const { return impl_.batch_size(); }
  int32_t* mutable_batch_size() { return impl_.mutable_batch_size(); }
  void set_batch_size(const int32_t& batch_size) { impl_.set_batch_size(batch_size); }
  
  const std::string& color_space() const { return impl_.color_space(); }
  std::string* mutable_color_space() { return impl_.mutable_color_space(); }
  void set_color_space(const std::string& color_space) { impl_.set_color_space(color_space); }
  
  const std::string& data_dir() const { return impl_.data_dir(); }
  std::string* mutable_data_dir() { return impl_.mutable_data_dir(); }
  void set_data_dir(const std::string& data_dir) { impl_.set_data_dir(data_dir); }
  
  const int32_t& data_part_num() const { return impl_.data_part_num(); }
  int32_t* mutable_data_part_num() { return impl_.mutable_data_part_num(); }
  void set_data_part_num(const int32_t& data_part_num) { impl_.set_data_part_num(data_part_num); }
  
  const int32_t& decode_buffer_size_per_thread() const { return impl_.decode_buffer_size_per_thread(); }
  int32_t* mutable_decode_buffer_size_per_thread() { return impl_.mutable_decode_buffer_size_per_thread(); }
  void set_decode_buffer_size_per_thread(const int32_t& decode_buffer_size_per_thread) { impl_.set_decode_buffer_size_per_thread(decode_buffer_size_per_thread); }
  
  const std::string& image_feature_name() const { return impl_.image_feature_name(); }
  std::string* mutable_image_feature_name() { return impl_.mutable_image_feature_name(); }
  void set_image_feature_name(const std::string& image_feature_name) { impl_.set_image_feature_name(image_feature_name); }
  
  const std::string& label_feature_name() const { return impl_.label_feature_name(); }
  std::string* mutable_label_feature_name() { return impl_.mutable_label_feature_name(); }
  void set_label_feature_name(const std::string& label_feature_name) { impl_.set_label_feature_name(label_feature_name); }
  
  const int32_t& num_decode_threads_per_machine() const { return impl_.num_decode_threads_per_machine(); }
  int32_t* mutable_num_decode_threads_per_machine() { return impl_.mutable_num_decode_threads_per_machine(); }
  void set_num_decode_threads_per_machine(const int32_t& num_decode_threads_per_machine) { impl_.set_num_decode_threads_per_machine(num_decode_threads_per_machine); }
  
  const std::string& part_name_prefix() const { return impl_.part_name_prefix(); }
  std::string* mutable_part_name_prefix() { return impl_.mutable_part_name_prefix(); }
  void set_part_name_prefix(const std::string& part_name_prefix) { impl_.set_part_name_prefix(part_name_prefix); }
  
  const int32_t& part_name_suffix_length() const { return impl_.part_name_suffix_length(); }
  int32_t* mutable_part_name_suffix_length() { return impl_.mutable_part_name_suffix_length(); }
  void set_part_name_suffix_length(const int32_t& part_name_suffix_length) { impl_.set_part_name_suffix_length(part_name_suffix_length); }
  
  const bool& random_shuffle() const { return impl_.random_shuffle(); }
  bool* mutable_random_shuffle() { return impl_.mutable_random_shuffle(); }
  void set_random_shuffle(const bool& random_shuffle) { impl_.set_random_shuffle(random_shuffle); }
  
  const int64_t& seed() const { return impl_.seed(); }
  int64_t* mutable_seed() { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) { impl_.set_seed(seed); }
  
  const bool& shuffle_after_epoch() const { return impl_.shuffle_after_epoch(); }
  bool* mutable_shuffle_after_epoch() { return impl_.mutable_shuffle_after_epoch(); }
  void set_shuffle_after_epoch(const bool& shuffle_after_epoch) { impl_.set_shuffle_after_epoch(shuffle_after_epoch); }
  
  const int32_t& shuffle_buffer_size() const { return impl_.shuffle_buffer_size(); }
  int32_t* mutable_shuffle_buffer_size() { return impl_.mutable_shuffle_buffer_size(); }
  void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) { impl_.set_shuffle_buffer_size(shuffle_buffer_size); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OfrecordImageClassificationReaderOp {
 public:
  OfrecordImageClassificationReaderOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& batch_size() const { return internal_->batch_size; }
  int32_t* mutable_batch_size() { return &internal_->batch_size; }
  void set_batch_size(const int32_t& batch_size) { internal_->batch_size = batch_size; }
  
  const std::string& color_space() const { return internal_->color_space; }
  std::string* mutable_color_space() { return &internal_->color_space; }
  void set_color_space(const std::string& color_space) { internal_->color_space = color_space; }
  
  const std::string& data_dir() const { return internal_->data_dir; }
  std::string* mutable_data_dir() { return &internal_->data_dir; }
  void set_data_dir(const std::string& data_dir) { internal_->data_dir = data_dir; }
  
  const int32_t& data_part_num() const { return internal_->data_part_num; }
  int32_t* mutable_data_part_num() { return &internal_->data_part_num; }
  void set_data_part_num(const int32_t& data_part_num) { internal_->data_part_num = data_part_num; }
  
  const int32_t& decode_buffer_size_per_thread() const { return internal_->decode_buffer_size_per_thread; }
  int32_t* mutable_decode_buffer_size_per_thread() { return &internal_->decode_buffer_size_per_thread; }
  void set_decode_buffer_size_per_thread(const int32_t& decode_buffer_size_per_thread) { internal_->decode_buffer_size_per_thread = decode_buffer_size_per_thread; }
  
  const std::string& image_feature_name() const { return internal_->image_feature_name; }
  std::string* mutable_image_feature_name() { return &internal_->image_feature_name; }
  void set_image_feature_name(const std::string& image_feature_name) { internal_->image_feature_name = image_feature_name; }
  
  const std::string& label_feature_name() const { return internal_->label_feature_name; }
  std::string* mutable_label_feature_name() { return &internal_->label_feature_name; }
  void set_label_feature_name(const std::string& label_feature_name) { internal_->label_feature_name = label_feature_name; }
  
  const int32_t& num_decode_threads_per_machine() const { return internal_->num_decode_threads_per_machine; }
  int32_t* mutable_num_decode_threads_per_machine() { return &internal_->num_decode_threads_per_machine; }
  void set_num_decode_threads_per_machine(const int32_t& num_decode_threads_per_machine) { internal_->num_decode_threads_per_machine = num_decode_threads_per_machine; }
  
  const std::string& part_name_prefix() const { return internal_->part_name_prefix; }
  std::string* mutable_part_name_prefix() { return &internal_->part_name_prefix; }
  void set_part_name_prefix(const std::string& part_name_prefix) { internal_->part_name_prefix = part_name_prefix; }
  
  const int32_t& part_name_suffix_length() const { return internal_->part_name_suffix_length; }
  int32_t* mutable_part_name_suffix_length() { return &internal_->part_name_suffix_length; }
  void set_part_name_suffix_length(const int32_t& part_name_suffix_length) { internal_->part_name_suffix_length = part_name_suffix_length; }
  
  const bool& random_shuffle() const { return internal_->random_shuffle; }
  bool* mutable_random_shuffle() { return &internal_->random_shuffle; }
  void set_random_shuffle(const bool& random_shuffle) { internal_->random_shuffle = random_shuffle; }
  
  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }
  
  const bool& shuffle_after_epoch() const { return internal_->shuffle_after_epoch; }
  bool* mutable_shuffle_after_epoch() { return &internal_->shuffle_after_epoch; }
  void set_shuffle_after_epoch(const bool& shuffle_after_epoch) { internal_->shuffle_after_epoch = shuffle_after_epoch; }
  
  const int32_t& shuffle_buffer_size() const { return internal_->shuffle_buffer_size; }
  int32_t* mutable_shuffle_buffer_size() { return &internal_->shuffle_buffer_size; }
  void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) { internal_->shuffle_buffer_size = shuffle_buffer_size; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t batch_size = 0;
    std::string color_space = "BGR";
    std::string data_dir;
    int32_t data_part_num = 0;
    int32_t decode_buffer_size_per_thread = 8;
    std::string image_feature_name = "encoded";
    std::string label_feature_name = "class/label";
    int32_t num_decode_threads_per_machine = 0;
    std::string part_name_prefix = "part-";
    int32_t part_name_suffix_length = -1;
    bool random_shuffle = false;
    int64_t seed = -1;
    bool shuffle_after_epoch = false;
    int32_t shuffle_buffer_size = 1024;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class OfrecordImageDecoderOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~OfrecordImageDecoderOpInterpCtx() = default;

  virtual const std::string& color_space() const = 0;
  virtual std::string* mutable_color_space() = 0;
  virtual void set_color_space(const std::string& color_space) = 0;

  virtual const std::string& name() const = 0;
  virtual std::string* mutable_name() = 0;
  virtual void set_name(const std::string& name) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class OfrecordImageDecoderOpInterpCtxImpl : public OfrecordImageDecoderOpInterpCtx {
 public:
  OfrecordImageDecoderOpInterpCtxImpl() = default;
  OfrecordImageDecoderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& color_space() const { return impl_.color_space(); }
  std::string* mutable_color_space() { return impl_.mutable_color_space(); }
  void set_color_space(const std::string& color_space) { impl_.set_color_space(color_space); }
  
  const std::string& name() const { return impl_.name(); }
  std::string* mutable_name() { return impl_.mutable_name(); }
  void set_name(const std::string& name) { impl_.set_name(name); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OfrecordImageDecoderOp {
 public:
  OfrecordImageDecoderOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& color_space() const { return internal_->color_space; }
  std::string* mutable_color_space() { return &internal_->color_space; }
  void set_color_space(const std::string& color_space) { internal_->color_space = color_space; }
  
  const std::string& name() const { return internal_->name; }
  std::string* mutable_name() { return &internal_->name; }
  void set_name(const std::string& name) { internal_->name = name; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string color_space = "BGR";
    std::string name;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class OfrecordImageDecoderRandomCropOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~OfrecordImageDecoderRandomCropOpInterpCtx() = default;

  virtual const std::string& color_space() const = 0;
  virtual std::string* mutable_color_space() = 0;
  virtual void set_color_space(const std::string& color_space) = 0;

  virtual const bool& has_seed() const = 0;
  virtual bool* mutable_has_seed() = 0;
  virtual void set_has_seed(const bool& has_seed) = 0;

  virtual const std::string& name() const = 0;
  virtual std::string* mutable_name() = 0;
  virtual void set_name(const std::string& name) = 0;

  virtual const int32_t& num_attempts() const = 0;
  virtual int32_t* mutable_num_attempts() = 0;
  virtual void set_num_attempts(const int32_t& num_attempts) = 0;

  virtual const std::vector<float>& random_area() const = 0;
  virtual std::vector<float>* mutable_random_area() = 0;
  virtual void set_random_area(const std::vector<float>& random_area) = 0;

  virtual const std::vector<float>& random_aspect_ratio() const = 0;
  virtual std::vector<float>* mutable_random_aspect_ratio() = 0;
  virtual void set_random_aspect_ratio(const std::vector<float>& random_aspect_ratio) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class OfrecordImageDecoderRandomCropOpInterpCtxImpl : public OfrecordImageDecoderRandomCropOpInterpCtx {
 public:
  OfrecordImageDecoderRandomCropOpInterpCtxImpl() = default;
  OfrecordImageDecoderRandomCropOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& color_space() const { return impl_.color_space(); }
  std::string* mutable_color_space() { return impl_.mutable_color_space(); }
  void set_color_space(const std::string& color_space) { impl_.set_color_space(color_space); }
  
  const bool& has_seed() const { return impl_.has_seed(); }
  bool* mutable_has_seed() { return impl_.mutable_has_seed(); }
  void set_has_seed(const bool& has_seed) { impl_.set_has_seed(has_seed); }
  
  const std::string& name() const { return impl_.name(); }
  std::string* mutable_name() { return impl_.mutable_name(); }
  void set_name(const std::string& name) { impl_.set_name(name); }
  
  const int32_t& num_attempts() const { return impl_.num_attempts(); }
  int32_t* mutable_num_attempts() { return impl_.mutable_num_attempts(); }
  void set_num_attempts(const int32_t& num_attempts) { impl_.set_num_attempts(num_attempts); }
  
  const std::vector<float>& random_area() const { return impl_.random_area(); }
  std::vector<float>* mutable_random_area() { return impl_.mutable_random_area(); }
  void set_random_area(const std::vector<float>& random_area) { impl_.set_random_area(random_area); }
  
  const std::vector<float>& random_aspect_ratio() const { return impl_.random_aspect_ratio(); }
  std::vector<float>* mutable_random_aspect_ratio() { return impl_.mutable_random_aspect_ratio(); }
  void set_random_aspect_ratio(const std::vector<float>& random_aspect_ratio) { impl_.set_random_aspect_ratio(random_aspect_ratio); }
  
  const int64_t& seed() const { return impl_.seed(); }
  int64_t* mutable_seed() { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) { impl_.set_seed(seed); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OfrecordImageDecoderRandomCropOp {
 public:
  OfrecordImageDecoderRandomCropOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& color_space() const { return internal_->color_space; }
  std::string* mutable_color_space() { return &internal_->color_space; }
  void set_color_space(const std::string& color_space) { internal_->color_space = color_space; }
  
  const bool& has_seed() const { return internal_->has_seed; }
  bool* mutable_has_seed() { return &internal_->has_seed; }
  void set_has_seed(const bool& has_seed) { internal_->has_seed = has_seed; }
  
  const std::string& name() const { return internal_->name; }
  std::string* mutable_name() { return &internal_->name; }
  void set_name(const std::string& name) { internal_->name = name; }
  
  const int32_t& num_attempts() const { return internal_->num_attempts; }
  int32_t* mutable_num_attempts() { return &internal_->num_attempts; }
  void set_num_attempts(const int32_t& num_attempts) { internal_->num_attempts = num_attempts; }
  
  const std::vector<float>& random_area() const { return internal_->random_area; }
  std::vector<float>* mutable_random_area() { return &internal_->random_area; }
  void set_random_area(const std::vector<float>& random_area) { internal_->random_area = random_area; }
  
  const std::vector<float>& random_aspect_ratio() const { return internal_->random_aspect_ratio; }
  std::vector<float>* mutable_random_aspect_ratio() { return &internal_->random_aspect_ratio; }
  void set_random_aspect_ratio(const std::vector<float>& random_aspect_ratio) { internal_->random_aspect_ratio = random_aspect_ratio; }
  
  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string color_space = "BGR";
    bool has_seed = false;
    std::string name;
    int32_t num_attempts = 10;
    std::vector<float> random_area;
    std::vector<float> random_aspect_ratio;
    int64_t seed = -1;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class OfrecordRawDecoderOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~OfrecordRawDecoderOpInterpCtx() = default;

  virtual const DataType& data_type() const = 0;
  virtual DataType* mutable_data_type() = 0;
  virtual void set_data_type(const DataType& data_type) = 0;

  virtual const bool& dim1_varying_length() const = 0;
  virtual bool* mutable_dim1_varying_length() = 0;
  virtual void set_dim1_varying_length(const bool& dim1_varying_length) = 0;

  virtual const std::string& name() const = 0;
  virtual std::string* mutable_name() = 0;
  virtual void set_name(const std::string& name) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  virtual const bool& truncate() const = 0;
  virtual bool* mutable_truncate() = 0;
  virtual void set_truncate(const bool& truncate) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class OfrecordRawDecoderOpInterpCtxImpl : public OfrecordRawDecoderOpInterpCtx {
 public:
  OfrecordRawDecoderOpInterpCtxImpl() = default;
  OfrecordRawDecoderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const DataType& data_type() const { return impl_.data_type(); }
  DataType* mutable_data_type() { return impl_.mutable_data_type(); }
  void set_data_type(const DataType& data_type) { impl_.set_data_type(data_type); }
  
  const bool& dim1_varying_length() const { return impl_.dim1_varying_length(); }
  bool* mutable_dim1_varying_length() { return impl_.mutable_dim1_varying_length(); }
  void set_dim1_varying_length(const bool& dim1_varying_length) { impl_.set_dim1_varying_length(dim1_varying_length); }
  
  const std::string& name() const { return impl_.name(); }
  std::string* mutable_name() { return impl_.mutable_name(); }
  void set_name(const std::string& name) { impl_.set_name(name); }
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  const bool& truncate() const { return impl_.truncate(); }
  bool* mutable_truncate() { return impl_.mutable_truncate(); }
  void set_truncate(const bool& truncate) { impl_.set_truncate(truncate); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OfrecordRawDecoderOp {
 public:
  OfrecordRawDecoderOp() : internal_(std::make_shared<Internal>()) {}
  
  const DataType& data_type() const { return internal_->data_type; }
  DataType* mutable_data_type() { return &internal_->data_type; }
  void set_data_type(const DataType& data_type) { internal_->data_type = data_type; }
  
  const bool& dim1_varying_length() const { return internal_->dim1_varying_length; }
  bool* mutable_dim1_varying_length() { return &internal_->dim1_varying_length; }
  void set_dim1_varying_length(const bool& dim1_varying_length) { internal_->dim1_varying_length = dim1_varying_length; }
  
  const std::string& name() const { return internal_->name; }
  std::string* mutable_name() { return &internal_->name; }
  void set_name(const std::string& name) { internal_->name = name; }
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  const bool& truncate() const { return internal_->truncate; }
  bool* mutable_truncate() { return &internal_->truncate; }
  void set_truncate(const bool& truncate) { internal_->truncate = truncate; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    DataType data_type;
    bool dim1_varying_length = false;
    std::string name;
    Shape shape;
    bool truncate = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class OneHotOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~OneHotOpInterpCtx() = default;

  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const double& floating_off_value() const = 0;
  virtual double* mutable_floating_off_value() = 0;
  virtual void set_floating_off_value(const double& floating_off_value) = 0;

  virtual const double& floating_on_value() const = 0;
  virtual double* mutable_floating_on_value() = 0;
  virtual void set_floating_on_value(const double& floating_on_value) = 0;

  virtual const int64_t& integer_off_value() const = 0;
  virtual int64_t* mutable_integer_off_value() = 0;
  virtual void set_integer_off_value(const int64_t& integer_off_value) = 0;

  virtual const int64_t& integer_on_value() const = 0;
  virtual int64_t* mutable_integer_on_value() = 0;
  virtual void set_integer_on_value(const int64_t& integer_on_value) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class OneHotOpInterpCtxImpl : public OneHotOpInterpCtx {
 public:
  OneHotOpInterpCtxImpl() = default;
  OneHotOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& depth() const { return impl_.depth(); }
  int64_t* mutable_depth() { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) { impl_.set_depth(depth); }
  
  const DataType& dtype() const { return impl_.dtype(); }
  DataType* mutable_dtype() { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) { impl_.set_dtype(dtype); }
  
  const double& floating_off_value() const { return impl_.floating_off_value(); }
  double* mutable_floating_off_value() { return impl_.mutable_floating_off_value(); }
  void set_floating_off_value(const double& floating_off_value) { impl_.set_floating_off_value(floating_off_value); }
  
  const double& floating_on_value() const { return impl_.floating_on_value(); }
  double* mutable_floating_on_value() { return impl_.mutable_floating_on_value(); }
  void set_floating_on_value(const double& floating_on_value) { impl_.set_floating_on_value(floating_on_value); }
  
  const int64_t& integer_off_value() const { return impl_.integer_off_value(); }
  int64_t* mutable_integer_off_value() { return impl_.mutable_integer_off_value(); }
  void set_integer_off_value(const int64_t& integer_off_value) { impl_.set_integer_off_value(integer_off_value); }
  
  const int64_t& integer_on_value() const { return impl_.integer_on_value(); }
  int64_t* mutable_integer_on_value() { return impl_.mutable_integer_on_value(); }
  void set_integer_on_value(const int64_t& integer_on_value) { impl_.set_integer_on_value(integer_on_value); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OneHotOp {
 public:
  OneHotOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }
  
  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }
  
  const double& floating_off_value() const { return internal_->floating_off_value; }
  double* mutable_floating_off_value() { return &internal_->floating_off_value; }
  void set_floating_off_value(const double& floating_off_value) { internal_->floating_off_value = floating_off_value; }
  
  const double& floating_on_value() const { return internal_->floating_on_value; }
  double* mutable_floating_on_value() { return &internal_->floating_on_value; }
  void set_floating_on_value(const double& floating_on_value) { internal_->floating_on_value = floating_on_value; }
  
  const int64_t& integer_off_value() const { return internal_->integer_off_value; }
  int64_t* mutable_integer_off_value() { return &internal_->integer_off_value; }
  void set_integer_off_value(const int64_t& integer_off_value) { internal_->integer_off_value = integer_off_value; }
  
  const int64_t& integer_on_value() const { return internal_->integer_on_value; }
  int64_t* mutable_integer_on_value() { return &internal_->integer_on_value; }
  void set_integer_on_value(const int64_t& integer_on_value) { internal_->integer_on_value = integer_on_value; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t depth = 0;
    DataType dtype;
    double floating_off_value = 0.;
    double floating_on_value = 0.;
    int64_t integer_off_value = 0;
    int64_t integer_on_value = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class OneRecReaderOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~OneRecReaderOpInterpCtx() = default;

  virtual const int32_t& batch_size() const = 0;
  virtual int32_t* mutable_batch_size() = 0;
  virtual void set_batch_size(const int32_t& batch_size) = 0;

  virtual const std::vector<std::string>& files() const = 0;
  virtual std::vector<std::string>* mutable_files() = 0;
  virtual void set_files(const std::vector<std::string>& files) = 0;

  virtual const bool& random_shuffle() const = 0;
  virtual bool* mutable_random_shuffle() = 0;
  virtual void set_random_shuffle(const bool& random_shuffle) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const bool& shuffle_after_epoch() const = 0;
  virtual bool* mutable_shuffle_after_epoch() = 0;
  virtual void set_shuffle_after_epoch(const bool& shuffle_after_epoch) = 0;

  virtual const int32_t& shuffle_buffer_size() const = 0;
  virtual int32_t* mutable_shuffle_buffer_size() = 0;
  virtual void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) = 0;

  virtual const std::string& shuffle_mode() const = 0;
  virtual std::string* mutable_shuffle_mode() = 0;
  virtual void set_shuffle_mode(const std::string& shuffle_mode) = 0;

  virtual const bool& verify_example() const = 0;
  virtual bool* mutable_verify_example() = 0;
  virtual void set_verify_example(const bool& verify_example) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class OneRecReaderOpInterpCtxImpl : public OneRecReaderOpInterpCtx {
 public:
  OneRecReaderOpInterpCtxImpl() = default;
  OneRecReaderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& batch_size() const { return impl_.batch_size(); }
  int32_t* mutable_batch_size() { return impl_.mutable_batch_size(); }
  void set_batch_size(const int32_t& batch_size) { impl_.set_batch_size(batch_size); }
  
  const std::vector<std::string>& files() const { return impl_.files(); }
  std::vector<std::string>* mutable_files() { return impl_.mutable_files(); }
  void set_files(const std::vector<std::string>& files) { impl_.set_files(files); }
  
  const bool& random_shuffle() const { return impl_.random_shuffle(); }
  bool* mutable_random_shuffle() { return impl_.mutable_random_shuffle(); }
  void set_random_shuffle(const bool& random_shuffle) { impl_.set_random_shuffle(random_shuffle); }
  
  const int64_t& seed() const { return impl_.seed(); }
  int64_t* mutable_seed() { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) { impl_.set_seed(seed); }
  
  const bool& shuffle_after_epoch() const { return impl_.shuffle_after_epoch(); }
  bool* mutable_shuffle_after_epoch() { return impl_.mutable_shuffle_after_epoch(); }
  void set_shuffle_after_epoch(const bool& shuffle_after_epoch) { impl_.set_shuffle_after_epoch(shuffle_after_epoch); }
  
  const int32_t& shuffle_buffer_size() const { return impl_.shuffle_buffer_size(); }
  int32_t* mutable_shuffle_buffer_size() { return impl_.mutable_shuffle_buffer_size(); }
  void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) { impl_.set_shuffle_buffer_size(shuffle_buffer_size); }
  
  const std::string& shuffle_mode() const { return impl_.shuffle_mode(); }
  std::string* mutable_shuffle_mode() { return impl_.mutable_shuffle_mode(); }
  void set_shuffle_mode(const std::string& shuffle_mode) { impl_.set_shuffle_mode(shuffle_mode); }
  
  const bool& verify_example() const { return impl_.verify_example(); }
  bool* mutable_verify_example() { return impl_.mutable_verify_example(); }
  void set_verify_example(const bool& verify_example) { impl_.set_verify_example(verify_example); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OneRecReaderOp {
 public:
  OneRecReaderOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& batch_size() const { return internal_->batch_size; }
  int32_t* mutable_batch_size() { return &internal_->batch_size; }
  void set_batch_size(const int32_t& batch_size) { internal_->batch_size = batch_size; }
  
  const std::vector<std::string>& files() const { return internal_->files; }
  std::vector<std::string>* mutable_files() { return &internal_->files; }
  void set_files(const std::vector<std::string>& files) { internal_->files = files; }
  
  const bool& random_shuffle() const { return internal_->random_shuffle; }
  bool* mutable_random_shuffle() { return &internal_->random_shuffle; }
  void set_random_shuffle(const bool& random_shuffle) { internal_->random_shuffle = random_shuffle; }
  
  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }
  
  const bool& shuffle_after_epoch() const { return internal_->shuffle_after_epoch; }
  bool* mutable_shuffle_after_epoch() { return &internal_->shuffle_after_epoch; }
  void set_shuffle_after_epoch(const bool& shuffle_after_epoch) { internal_->shuffle_after_epoch = shuffle_after_epoch; }
  
  const int32_t& shuffle_buffer_size() const { return internal_->shuffle_buffer_size; }
  int32_t* mutable_shuffle_buffer_size() { return &internal_->shuffle_buffer_size; }
  void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) { internal_->shuffle_buffer_size = shuffle_buffer_size; }
  
  const std::string& shuffle_mode() const { return internal_->shuffle_mode; }
  std::string* mutable_shuffle_mode() { return &internal_->shuffle_mode; }
  void set_shuffle_mode(const std::string& shuffle_mode) { internal_->shuffle_mode = shuffle_mode; }
  
  const bool& verify_example() const { return internal_->verify_example; }
  bool* mutable_verify_example() { return &internal_->verify_example; }
  void set_verify_example(const bool& verify_example) { internal_->verify_example = verify_example; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t batch_size = 0;
    std::vector<std::string> files;
    bool random_shuffle = false;
    int64_t seed = -1;
    bool shuffle_after_epoch = false;
    int32_t shuffle_buffer_size = 1024;
    std::string shuffle_mode = "instance";
    bool verify_example = true;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class OnerecDecoderOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~OnerecDecoderOpInterpCtx() = default;

  virtual const Shape& batch_padding() const = 0;
  virtual Shape* mutable_batch_padding() = 0;
  virtual void set_batch_padding(const Shape& batch_padding) = 0;

  virtual const DataType& data_type() const = 0;
  virtual DataType* mutable_data_type() = 0;
  virtual void set_data_type(const DataType& data_type) = 0;

  virtual const bool& has_batch_padding() const = 0;
  virtual bool* mutable_has_batch_padding() = 0;
  virtual void set_has_batch_padding(const bool& has_batch_padding) = 0;

  virtual const bool& has_reshape() const = 0;
  virtual bool* mutable_has_reshape() = 0;
  virtual void set_has_reshape(const bool& has_reshape) = 0;

  virtual const bool& is_dynamic() const = 0;
  virtual bool* mutable_is_dynamic() = 0;
  virtual void set_is_dynamic(const bool& is_dynamic) = 0;

  virtual const std::string& key() const = 0;
  virtual std::string* mutable_key() = 0;
  virtual void set_key(const std::string& key) = 0;

  virtual const Shape& reshape() const = 0;
  virtual Shape* mutable_reshape() = 0;
  virtual void set_reshape(const Shape& reshape) = 0;

  virtual const Shape& static_shape() const = 0;
  virtual Shape* mutable_static_shape() = 0;
  virtual void set_static_shape(const Shape& static_shape) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class OnerecDecoderOpInterpCtxImpl : public OnerecDecoderOpInterpCtx {
 public:
  OnerecDecoderOpInterpCtxImpl() = default;
  OnerecDecoderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const Shape& batch_padding() const { return impl_.batch_padding(); }
  Shape* mutable_batch_padding() { return impl_.mutable_batch_padding(); }
  void set_batch_padding(const Shape& batch_padding) { impl_.set_batch_padding(batch_padding); }
  
  const DataType& data_type() const { return impl_.data_type(); }
  DataType* mutable_data_type() { return impl_.mutable_data_type(); }
  void set_data_type(const DataType& data_type) { impl_.set_data_type(data_type); }
  
  const bool& has_batch_padding() const { return impl_.has_batch_padding(); }
  bool* mutable_has_batch_padding() { return impl_.mutable_has_batch_padding(); }
  void set_has_batch_padding(const bool& has_batch_padding) { impl_.set_has_batch_padding(has_batch_padding); }
  
  const bool& has_reshape() const { return impl_.has_reshape(); }
  bool* mutable_has_reshape() { return impl_.mutable_has_reshape(); }
  void set_has_reshape(const bool& has_reshape) { impl_.set_has_reshape(has_reshape); }
  
  const bool& is_dynamic() const { return impl_.is_dynamic(); }
  bool* mutable_is_dynamic() { return impl_.mutable_is_dynamic(); }
  void set_is_dynamic(const bool& is_dynamic) { impl_.set_is_dynamic(is_dynamic); }
  
  const std::string& key() const { return impl_.key(); }
  std::string* mutable_key() { return impl_.mutable_key(); }
  void set_key(const std::string& key) { impl_.set_key(key); }
  
  const Shape& reshape() const { return impl_.reshape(); }
  Shape* mutable_reshape() { return impl_.mutable_reshape(); }
  void set_reshape(const Shape& reshape) { impl_.set_reshape(reshape); }
  
  const Shape& static_shape() const { return impl_.static_shape(); }
  Shape* mutable_static_shape() { return impl_.mutable_static_shape(); }
  void set_static_shape(const Shape& static_shape) { impl_.set_static_shape(static_shape); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OnerecDecoderOp {
 public:
  OnerecDecoderOp() : internal_(std::make_shared<Internal>()) {}
  
  const Shape& batch_padding() const { return internal_->batch_padding; }
  Shape* mutable_batch_padding() { return &internal_->batch_padding; }
  void set_batch_padding(const Shape& batch_padding) { internal_->batch_padding = batch_padding; }
  
  const DataType& data_type() const { return internal_->data_type; }
  DataType* mutable_data_type() { return &internal_->data_type; }
  void set_data_type(const DataType& data_type) { internal_->data_type = data_type; }
  
  const bool& has_batch_padding() const { return internal_->has_batch_padding; }
  bool* mutable_has_batch_padding() { return &internal_->has_batch_padding; }
  void set_has_batch_padding(const bool& has_batch_padding) { internal_->has_batch_padding = has_batch_padding; }
  
  const bool& has_reshape() const { return internal_->has_reshape; }
  bool* mutable_has_reshape() { return &internal_->has_reshape; }
  void set_has_reshape(const bool& has_reshape) { internal_->has_reshape = has_reshape; }
  
  const bool& is_dynamic() const { return internal_->is_dynamic; }
  bool* mutable_is_dynamic() { return &internal_->is_dynamic; }
  void set_is_dynamic(const bool& is_dynamic) { internal_->is_dynamic = is_dynamic; }
  
  const std::string& key() const { return internal_->key; }
  std::string* mutable_key() { return &internal_->key; }
  void set_key(const std::string& key) { internal_->key = key; }
  
  const Shape& reshape() const { return internal_->reshape; }
  Shape* mutable_reshape() { return &internal_->reshape; }
  void set_reshape(const Shape& reshape) { internal_->reshape = reshape; }
  
  const Shape& static_shape() const { return internal_->static_shape; }
  Shape* mutable_static_shape() { return &internal_->static_shape; }
  void set_static_shape(const Shape& static_shape) { internal_->static_shape = static_shape; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    Shape batch_padding;
    DataType data_type;
    bool has_batch_padding = false;
    bool has_reshape = false;
    bool is_dynamic = false;
    std::string key;
    Shape reshape;
    Shape static_shape;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class OnesLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~OnesLikeOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class OnesLikeOpInterpCtxImpl : public OnesLikeOpInterpCtx {
 public:
  OnesLikeOpInterpCtxImpl() = default;
  OnesLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OnesLikeOp {
 public:
  OnesLikeOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class PackOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~PackOpInterpCtx() = default;

  virtual const int32_t& pack_num() const = 0;
  virtual int32_t* mutable_pack_num() = 0;
  virtual void set_pack_num(const int32_t& pack_num) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class PackOpInterpCtxImpl : public PackOpInterpCtx {
 public:
  PackOpInterpCtxImpl() = default;
  PackOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& pack_num() const { return impl_.pack_num(); }
  int32_t* mutable_pack_num() { return impl_.mutable_pack_num(); }
  void set_pack_num(const int32_t& pack_num) { impl_.set_pack_num(pack_num); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class PackOp {
 public:
  PackOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& pack_num() const { return internal_->pack_num; }
  int32_t* mutable_pack_num() { return &internal_->pack_num; }
  void set_pack_num(const int32_t& pack_num) { internal_->pack_num = pack_num; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t pack_num = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class PadGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~PadGradOpInterpCtx() = default;

  virtual const double& floating_constant_value() const = 0;
  virtual double* mutable_floating_constant_value() = 0;
  virtual void set_floating_constant_value(const double& floating_constant_value) = 0;

  virtual const int64_t& integral_constant_value() const = 0;
  virtual int64_t* mutable_integral_constant_value() = 0;
  virtual void set_integral_constant_value(const int64_t& integral_constant_value) = 0;

  virtual const std::vector<std::int64_t>& padding_after() const = 0;
  virtual std::vector<std::int64_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<std::int64_t>& padding_after) = 0;

  virtual const std::vector<std::int64_t>& padding_before() const = 0;
  virtual std::vector<std::int64_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int64_t>& padding_before) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class PadGradOpInterpCtxImpl : public PadGradOpInterpCtx {
 public:
  PadGradOpInterpCtxImpl() = default;
  PadGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& floating_constant_value() const { return impl_.floating_constant_value(); }
  double* mutable_floating_constant_value() { return impl_.mutable_floating_constant_value(); }
  void set_floating_constant_value(const double& floating_constant_value) { impl_.set_floating_constant_value(floating_constant_value); }
  
  const int64_t& integral_constant_value() const { return impl_.integral_constant_value(); }
  int64_t* mutable_integral_constant_value() { return impl_.mutable_integral_constant_value(); }
  void set_integral_constant_value(const int64_t& integral_constant_value) { impl_.set_integral_constant_value(integral_constant_value); }
  
  const std::vector<std::int64_t>& padding_after() const { return impl_.padding_after(); }
  std::vector<std::int64_t>* mutable_padding_after() { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<std::int64_t>& padding_after) { impl_.set_padding_after(padding_after); }
  
  const std::vector<std::int64_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int64_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int64_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class PadGradOp {
 public:
  PadGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& floating_constant_value() const { return internal_->floating_constant_value; }
  double* mutable_floating_constant_value() { return &internal_->floating_constant_value; }
  void set_floating_constant_value(const double& floating_constant_value) { internal_->floating_constant_value = floating_constant_value; }
  
  const int64_t& integral_constant_value() const { return internal_->integral_constant_value; }
  int64_t* mutable_integral_constant_value() { return &internal_->integral_constant_value; }
  void set_integral_constant_value(const int64_t& integral_constant_value) { internal_->integral_constant_value = integral_constant_value; }
  
  const std::vector<std::int64_t>& padding_after() const { return internal_->padding_after; }
  std::vector<std::int64_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<std::int64_t>& padding_after) { internal_->padding_after = padding_after; }
  
  const std::vector<std::int64_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int64_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int64_t>& padding_before) { internal_->padding_before = padding_before; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double floating_constant_value = 0.;
    int64_t integral_constant_value = 0;
    std::vector<std::int64_t> padding_after;
    std::vector<std::int64_t> padding_before;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class PadOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~PadOpInterpCtx() = default;

  virtual const double& floating_constant_value() const = 0;
  virtual double* mutable_floating_constant_value() = 0;
  virtual void set_floating_constant_value(const double& floating_constant_value) = 0;

  virtual const int64_t& integral_constant_value() const = 0;
  virtual int64_t* mutable_integral_constant_value() = 0;
  virtual void set_integral_constant_value(const int64_t& integral_constant_value) = 0;

  virtual const std::vector<std::int64_t>& padding_after() const = 0;
  virtual std::vector<std::int64_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<std::int64_t>& padding_after) = 0;

  virtual const std::vector<std::int64_t>& padding_before() const = 0;
  virtual std::vector<std::int64_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int64_t>& padding_before) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class PadOpInterpCtxImpl : public PadOpInterpCtx {
 public:
  PadOpInterpCtxImpl() = default;
  PadOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& floating_constant_value() const { return impl_.floating_constant_value(); }
  double* mutable_floating_constant_value() { return impl_.mutable_floating_constant_value(); }
  void set_floating_constant_value(const double& floating_constant_value) { impl_.set_floating_constant_value(floating_constant_value); }
  
  const int64_t& integral_constant_value() const { return impl_.integral_constant_value(); }
  int64_t* mutable_integral_constant_value() { return impl_.mutable_integral_constant_value(); }
  void set_integral_constant_value(const int64_t& integral_constant_value) { impl_.set_integral_constant_value(integral_constant_value); }
  
  const std::vector<std::int64_t>& padding_after() const { return impl_.padding_after(); }
  std::vector<std::int64_t>* mutable_padding_after() { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<std::int64_t>& padding_after) { impl_.set_padding_after(padding_after); }
  
  const std::vector<std::int64_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int64_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int64_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class PadOp {
 public:
  PadOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& floating_constant_value() const { return internal_->floating_constant_value; }
  double* mutable_floating_constant_value() { return &internal_->floating_constant_value; }
  void set_floating_constant_value(const double& floating_constant_value) { internal_->floating_constant_value = floating_constant_value; }
  
  const int64_t& integral_constant_value() const { return internal_->integral_constant_value; }
  int64_t* mutable_integral_constant_value() { return &internal_->integral_constant_value; }
  void set_integral_constant_value(const int64_t& integral_constant_value) { internal_->integral_constant_value = integral_constant_value; }
  
  const std::vector<std::int64_t>& padding_after() const { return internal_->padding_after; }
  std::vector<std::int64_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<std::int64_t>& padding_after) { internal_->padding_after = padding_after; }
  
  const std::vector<std::int64_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int64_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int64_t>& padding_before) { internal_->padding_before = padding_before; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double floating_constant_value = 0.;
    int64_t integral_constant_value = 0;
    std::vector<std::int64_t> padding_after;
    std::vector<std::int64_t> padding_before;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ParallelCastOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ParallelCastOpInterpCtx() = default;

  virtual const std::string& grad_sbp_parallel() const = 0;
  virtual std::string* mutable_grad_sbp_parallel() = 0;
  virtual void set_grad_sbp_parallel(const std::string& grad_sbp_parallel) = 0;

  virtual const std::string& sbp_parallel() const = 0;
  virtual std::string* mutable_sbp_parallel() = 0;
  virtual void set_sbp_parallel(const std::string& sbp_parallel) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ParallelCastOpInterpCtxImpl : public ParallelCastOpInterpCtx {
 public:
  ParallelCastOpInterpCtxImpl() = default;
  ParallelCastOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& grad_sbp_parallel() const { return impl_.grad_sbp_parallel(); }
  std::string* mutable_grad_sbp_parallel() { return impl_.mutable_grad_sbp_parallel(); }
  void set_grad_sbp_parallel(const std::string& grad_sbp_parallel) { impl_.set_grad_sbp_parallel(grad_sbp_parallel); }
  
  const std::string& sbp_parallel() const { return impl_.sbp_parallel(); }
  std::string* mutable_sbp_parallel() { return impl_.mutable_sbp_parallel(); }
  void set_sbp_parallel(const std::string& sbp_parallel) { impl_.set_sbp_parallel(sbp_parallel); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ParallelCastOp {
 public:
  ParallelCastOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& grad_sbp_parallel() const { return internal_->grad_sbp_parallel; }
  std::string* mutable_grad_sbp_parallel() { return &internal_->grad_sbp_parallel; }
  void set_grad_sbp_parallel(const std::string& grad_sbp_parallel) { internal_->grad_sbp_parallel = grad_sbp_parallel; }
  
  const std::string& sbp_parallel() const { return internal_->sbp_parallel; }
  std::string* mutable_sbp_parallel() { return &internal_->sbp_parallel; }
  void set_sbp_parallel(const std::string& sbp_parallel) { internal_->sbp_parallel = sbp_parallel; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string grad_sbp_parallel;
    std::string sbp_parallel;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class PowOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~PowOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class PowOpInterpCtxImpl : public PowOpInterpCtx {
 public:
  PowOpInterpCtxImpl() = default;
  PowOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class PowOp {
 public:
  PowOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class PowXGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~PowXGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class PowXGradOpInterpCtxImpl : public PowXGradOpInterpCtx {
 public:
  PowXGradOpInterpCtxImpl() = default;
  PowXGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class PowXGradOp {
 public:
  PowXGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class PowYGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~PowYGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class PowYGradOpInterpCtxImpl : public PowYGradOpInterpCtx {
 public:
  PowYGradOpInterpCtxImpl() = default;
  PowYGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class PowYGradOp {
 public:
  PowYGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class PreluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~PreluGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class PreluGradOpInterpCtxImpl : public PreluGradOpInterpCtx {
 public:
  PreluGradOpInterpCtxImpl() = default;
  PreluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class PreluGradOp {
 public:
  PreluGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class PreluOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~PreluOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class PreluOpInterpCtxImpl : public PreluOpInterpCtx {
 public:
  PreluOpInterpCtxImpl() = default;
  PreluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class PreluOp {
 public:
  PreluOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class QuantizationOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~QuantizationOpInterpCtx() = default;

  virtual const int32_t& quantization_bit() const = 0;
  virtual int32_t* mutable_quantization_bit() = 0;
  virtual void set_quantization_bit(const int32_t& quantization_bit) = 0;

  virtual const std::string& quantization_formula() const = 0;
  virtual std::string* mutable_quantization_formula() = 0;
  virtual void set_quantization_formula(const std::string& quantization_formula) = 0;

  virtual const std::string& quantization_scheme() const = 0;
  virtual std::string* mutable_quantization_scheme() = 0;
  virtual void set_quantization_scheme(const std::string& quantization_scheme) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class QuantizationOpInterpCtxImpl : public QuantizationOpInterpCtx {
 public:
  QuantizationOpInterpCtxImpl() = default;
  QuantizationOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& quantization_bit() const { return impl_.quantization_bit(); }
  int32_t* mutable_quantization_bit() { return impl_.mutable_quantization_bit(); }
  void set_quantization_bit(const int32_t& quantization_bit) { impl_.set_quantization_bit(quantization_bit); }
  
  const std::string& quantization_formula() const { return impl_.quantization_formula(); }
  std::string* mutable_quantization_formula() { return impl_.mutable_quantization_formula(); }
  void set_quantization_formula(const std::string& quantization_formula) { impl_.set_quantization_formula(quantization_formula); }
  
  const std::string& quantization_scheme() const { return impl_.quantization_scheme(); }
  std::string* mutable_quantization_scheme() { return impl_.mutable_quantization_scheme(); }
  void set_quantization_scheme(const std::string& quantization_scheme) { impl_.set_quantization_scheme(quantization_scheme); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class QuantizationOp {
 public:
  QuantizationOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& quantization_bit() const { return internal_->quantization_bit; }
  int32_t* mutable_quantization_bit() { return &internal_->quantization_bit; }
  void set_quantization_bit(const int32_t& quantization_bit) { internal_->quantization_bit = quantization_bit; }
  
  const std::string& quantization_formula() const { return internal_->quantization_formula; }
  std::string* mutable_quantization_formula() { return &internal_->quantization_formula; }
  void set_quantization_formula(const std::string& quantization_formula) { internal_->quantization_formula = quantization_formula; }
  
  const std::string& quantization_scheme() const { return internal_->quantization_scheme; }
  std::string* mutable_quantization_scheme() { return &internal_->quantization_scheme; }
  void set_quantization_scheme(const std::string& quantization_scheme) { internal_->quantization_scheme = quantization_scheme; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t quantization_bit = 8;
    std::string quantization_formula = "google";
    std::string quantization_scheme = "symmetric";
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class RandomMaskLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~RandomMaskLikeOpInterpCtx() = default;

  virtual const float& rate() const = 0;
  virtual float* mutable_rate() = 0;
  virtual void set_rate(const float& rate) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class RandomMaskLikeOpInterpCtxImpl : public RandomMaskLikeOpInterpCtx {
 public:
  RandomMaskLikeOpInterpCtxImpl() = default;
  RandomMaskLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& rate() const { return impl_.rate(); }
  float* mutable_rate() { return impl_.mutable_rate(); }
  void set_rate(const float& rate) { impl_.set_rate(rate); }
  
  const int64_t& seed() const { return impl_.seed(); }
  int64_t* mutable_seed() { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) { impl_.set_seed(seed); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RandomMaskLikeOp {
 public:
  RandomMaskLikeOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& rate() const { return internal_->rate; }
  float* mutable_rate() { return &internal_->rate; }
  void set_rate(const float& rate) { internal_->rate = rate; }
  
  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float rate = 0.;
    int64_t seed = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class RandpermOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~RandpermOpInterpCtx() = default;

  virtual const int32_t& n() const = 0;
  virtual int32_t* mutable_n() = 0;
  virtual void set_n(const int32_t& n) = 0;

  virtual const std::string& nd_sbp() const = 0;
  virtual std::string* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::string& nd_sbp) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class RandpermOpInterpCtxImpl : public RandpermOpInterpCtx {
 public:
  RandpermOpInterpCtxImpl() = default;
  RandpermOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& n() const { return impl_.n(); }
  int32_t* mutable_n() { return impl_.mutable_n(); }
  void set_n(const int32_t& n) { impl_.set_n(n); }
  
  const std::string& nd_sbp() const { return impl_.nd_sbp(); }
  std::string* mutable_nd_sbp() { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::string& nd_sbp) { impl_.set_nd_sbp(nd_sbp); }
  
  const int64_t& seed() const { return impl_.seed(); }
  int64_t* mutable_seed() { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) { impl_.set_seed(seed); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RandpermOp {
 public:
  RandpermOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& n() const { return internal_->n; }
  int32_t* mutable_n() { return &internal_->n; }
  void set_n(const int32_t& n) { internal_->n = n; }
  
  const std::string& nd_sbp() const { return internal_->nd_sbp; }
  std::string* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::string& nd_sbp) { internal_->nd_sbp = nd_sbp; }
  
  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t n = 0;
    std::string nd_sbp;
    int64_t seed = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReciprocalGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReciprocalGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReciprocalGradOpInterpCtxImpl : public ReciprocalGradOpInterpCtx {
 public:
  ReciprocalGradOpInterpCtxImpl() = default;
  ReciprocalGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReciprocalGradOp {
 public:
  ReciprocalGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReciprocalNoNanGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReciprocalNoNanGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReciprocalNoNanGradOpInterpCtxImpl : public ReciprocalNoNanGradOpInterpCtx {
 public:
  ReciprocalNoNanGradOpInterpCtxImpl() = default;
  ReciprocalNoNanGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReciprocalNoNanGradOp {
 public:
  ReciprocalNoNanGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReciprocalNoNanOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReciprocalNoNanOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReciprocalNoNanOpInterpCtxImpl : public ReciprocalNoNanOpInterpCtx {
 public:
  ReciprocalNoNanOpInterpCtxImpl() = default;
  ReciprocalNoNanOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReciprocalNoNanOp {
 public:
  ReciprocalNoNanOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReciprocalOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReciprocalOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReciprocalOpInterpCtxImpl : public ReciprocalOpInterpCtx {
 public:
  ReciprocalOpInterpCtxImpl() = default;
  ReciprocalOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReciprocalOp {
 public:
  ReciprocalOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class RecvOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~RecvOpInterpCtx() = default;

  virtual const int64_t& device_id() const = 0;
  virtual int64_t* mutable_device_id() = 0;
  virtual void set_device_id(const int64_t& device_id) = 0;

  virtual const std::string& device_type() const = 0;
  virtual std::string* mutable_device_type() = 0;
  virtual void set_device_type(const std::string& device_type) = 0;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  virtual const int64_t& src_process_id() const = 0;
  virtual int64_t* mutable_src_process_id() = 0;
  virtual void set_src_process_id(const int64_t& src_process_id) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class RecvOpInterpCtxImpl : public RecvOpInterpCtx {
 public:
  RecvOpInterpCtxImpl() = default;
  RecvOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& device_id() const { return impl_.device_id(); }
  int64_t* mutable_device_id() { return impl_.mutable_device_id(); }
  void set_device_id(const int64_t& device_id) { impl_.set_device_id(device_id); }
  
  const std::string& device_type() const { return impl_.device_type(); }
  std::string* mutable_device_type() { return impl_.mutable_device_type(); }
  void set_device_type(const std::string& device_type) { impl_.set_device_type(device_type); }
  
  const DataType& dtype() const { return impl_.dtype(); }
  DataType* mutable_dtype() { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) { impl_.set_dtype(dtype); }
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  const int64_t& src_process_id() const { return impl_.src_process_id(); }
  int64_t* mutable_src_process_id() { return impl_.mutable_src_process_id(); }
  void set_src_process_id(const int64_t& src_process_id) { impl_.set_src_process_id(src_process_id); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RecvOp {
 public:
  RecvOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& device_id() const { return internal_->device_id; }
  int64_t* mutable_device_id() { return &internal_->device_id; }
  void set_device_id(const int64_t& device_id) { internal_->device_id = device_id; }
  
  const std::string& device_type() const { return internal_->device_type; }
  std::string* mutable_device_type() { return &internal_->device_type; }
  void set_device_type(const std::string& device_type) { internal_->device_type = device_type; }
  
  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  const int64_t& src_process_id() const { return internal_->src_process_id; }
  int64_t* mutable_src_process_id() { return &internal_->src_process_id; }
  void set_src_process_id(const int64_t& src_process_id) { internal_->src_process_id = src_process_id; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t device_id = 0;
    std::string device_type;
    DataType dtype;
    Shape shape;
    int64_t src_process_id = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReduceAllOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReduceAllOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& axis() const = 0;
  virtual std::vector<std::int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<std::int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReduceAllOpInterpCtxImpl : public ReduceAllOpInterpCtx {
 public:
  ReduceAllOpInterpCtxImpl() = default;
  ReduceAllOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& axis() const { return impl_.axis(); }
  std::vector<std::int32_t>* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const std::vector<std::int32_t>& axis) { impl_.set_axis(axis); }
  
  const bool& keepdims() const { return impl_.keepdims(); }
  bool* mutable_keepdims() { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) { impl_.set_keepdims(keepdims); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceAllOp {
 public:
  ReduceAllOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& axis() const { return internal_->axis; }
  std::vector<std::int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<std::int32_t>& axis) { internal_->axis = axis; }
  
  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> axis;
    bool keepdims = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReduceAnyOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReduceAnyOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& axis() const = 0;
  virtual std::vector<std::int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<std::int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReduceAnyOpInterpCtxImpl : public ReduceAnyOpInterpCtx {
 public:
  ReduceAnyOpInterpCtxImpl() = default;
  ReduceAnyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& axis() const { return impl_.axis(); }
  std::vector<std::int32_t>* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const std::vector<std::int32_t>& axis) { impl_.set_axis(axis); }
  
  const bool& keepdims() const { return impl_.keepdims(); }
  bool* mutable_keepdims() { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) { impl_.set_keepdims(keepdims); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceAnyOp {
 public:
  ReduceAnyOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& axis() const { return internal_->axis; }
  std::vector<std::int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<std::int32_t>& axis) { internal_->axis = axis; }
  
  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> axis;
    bool keepdims = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReduceMaxDeviceStageGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReduceMaxDeviceStageGradOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& axis() const = 0;
  virtual std::vector<std::int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<std::int32_t>& axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReduceMaxDeviceStageGradOpInterpCtxImpl : public ReduceMaxDeviceStageGradOpInterpCtx {
 public:
  ReduceMaxDeviceStageGradOpInterpCtxImpl() = default;
  ReduceMaxDeviceStageGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& axis() const { return impl_.axis(); }
  std::vector<std::int32_t>* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const std::vector<std::int32_t>& axis) { impl_.set_axis(axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMaxDeviceStageGradOp {
 public:
  ReduceMaxDeviceStageGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& axis() const { return internal_->axis; }
  std::vector<std::int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<std::int32_t>& axis) { internal_->axis = axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> axis;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReduceMaxDeviceStageOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReduceMaxDeviceStageOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& axis() const = 0;
  virtual std::vector<std::int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<std::int32_t>& axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReduceMaxDeviceStageOpInterpCtxImpl : public ReduceMaxDeviceStageOpInterpCtx {
 public:
  ReduceMaxDeviceStageOpInterpCtxImpl() = default;
  ReduceMaxDeviceStageOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& axis() const { return impl_.axis(); }
  std::vector<std::int32_t>* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const std::vector<std::int32_t>& axis) { impl_.set_axis(axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMaxDeviceStageOp {
 public:
  ReduceMaxDeviceStageOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& axis() const { return internal_->axis; }
  std::vector<std::int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<std::int32_t>& axis) { internal_->axis = axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> axis;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReduceMaxGlobalStageGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReduceMaxGlobalStageGradOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& axis() const = 0;
  virtual std::vector<std::int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<std::int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReduceMaxGlobalStageGradOpInterpCtxImpl : public ReduceMaxGlobalStageGradOpInterpCtx {
 public:
  ReduceMaxGlobalStageGradOpInterpCtxImpl() = default;
  ReduceMaxGlobalStageGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& axis() const { return impl_.axis(); }
  std::vector<std::int32_t>* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const std::vector<std::int32_t>& axis) { impl_.set_axis(axis); }
  
  const bool& keepdims() const { return impl_.keepdims(); }
  bool* mutable_keepdims() { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) { impl_.set_keepdims(keepdims); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMaxGlobalStageGradOp {
 public:
  ReduceMaxGlobalStageGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& axis() const { return internal_->axis; }
  std::vector<std::int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<std::int32_t>& axis) { internal_->axis = axis; }
  
  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> axis;
    bool keepdims = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReduceMaxGlobalStageOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReduceMaxGlobalStageOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& axis() const = 0;
  virtual std::vector<std::int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<std::int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReduceMaxGlobalStageOpInterpCtxImpl : public ReduceMaxGlobalStageOpInterpCtx {
 public:
  ReduceMaxGlobalStageOpInterpCtxImpl() = default;
  ReduceMaxGlobalStageOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& axis() const { return impl_.axis(); }
  std::vector<std::int32_t>* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const std::vector<std::int32_t>& axis) { impl_.set_axis(axis); }
  
  const bool& keepdims() const { return impl_.keepdims(); }
  bool* mutable_keepdims() { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) { impl_.set_keepdims(keepdims); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMaxGlobalStageOp {
 public:
  ReduceMaxGlobalStageOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& axis() const { return internal_->axis; }
  std::vector<std::int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<std::int32_t>& axis) { internal_->axis = axis; }
  
  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> axis;
    bool keepdims = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReduceMaxOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReduceMaxOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& axis() const = 0;
  virtual std::vector<std::int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<std::int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReduceMaxOpInterpCtxImpl : public ReduceMaxOpInterpCtx {
 public:
  ReduceMaxOpInterpCtxImpl() = default;
  ReduceMaxOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& axis() const { return impl_.axis(); }
  std::vector<std::int32_t>* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const std::vector<std::int32_t>& axis) { impl_.set_axis(axis); }
  
  const bool& keepdims() const { return impl_.keepdims(); }
  bool* mutable_keepdims() { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) { impl_.set_keepdims(keepdims); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMaxOp {
 public:
  ReduceMaxOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& axis() const { return internal_->axis; }
  std::vector<std::int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<std::int32_t>& axis) { internal_->axis = axis; }
  
  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> axis;
    bool keepdims = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReduceMinDeviceStageGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReduceMinDeviceStageGradOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& axis() const = 0;
  virtual std::vector<std::int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<std::int32_t>& axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReduceMinDeviceStageGradOpInterpCtxImpl : public ReduceMinDeviceStageGradOpInterpCtx {
 public:
  ReduceMinDeviceStageGradOpInterpCtxImpl() = default;
  ReduceMinDeviceStageGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& axis() const { return impl_.axis(); }
  std::vector<std::int32_t>* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const std::vector<std::int32_t>& axis) { impl_.set_axis(axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMinDeviceStageGradOp {
 public:
  ReduceMinDeviceStageGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& axis() const { return internal_->axis; }
  std::vector<std::int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<std::int32_t>& axis) { internal_->axis = axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> axis;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReduceMinDeviceStageOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReduceMinDeviceStageOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& axis() const = 0;
  virtual std::vector<std::int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<std::int32_t>& axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReduceMinDeviceStageOpInterpCtxImpl : public ReduceMinDeviceStageOpInterpCtx {
 public:
  ReduceMinDeviceStageOpInterpCtxImpl() = default;
  ReduceMinDeviceStageOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& axis() const { return impl_.axis(); }
  std::vector<std::int32_t>* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const std::vector<std::int32_t>& axis) { impl_.set_axis(axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMinDeviceStageOp {
 public:
  ReduceMinDeviceStageOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& axis() const { return internal_->axis; }
  std::vector<std::int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<std::int32_t>& axis) { internal_->axis = axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> axis;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReduceMinGlobalStageGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReduceMinGlobalStageGradOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& axis() const = 0;
  virtual std::vector<std::int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<std::int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReduceMinGlobalStageGradOpInterpCtxImpl : public ReduceMinGlobalStageGradOpInterpCtx {
 public:
  ReduceMinGlobalStageGradOpInterpCtxImpl() = default;
  ReduceMinGlobalStageGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& axis() const { return impl_.axis(); }
  std::vector<std::int32_t>* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const std::vector<std::int32_t>& axis) { impl_.set_axis(axis); }
  
  const bool& keepdims() const { return impl_.keepdims(); }
  bool* mutable_keepdims() { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) { impl_.set_keepdims(keepdims); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMinGlobalStageGradOp {
 public:
  ReduceMinGlobalStageGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& axis() const { return internal_->axis; }
  std::vector<std::int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<std::int32_t>& axis) { internal_->axis = axis; }
  
  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> axis;
    bool keepdims = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReduceMinGlobalStageOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReduceMinGlobalStageOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& axis() const = 0;
  virtual std::vector<std::int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<std::int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReduceMinGlobalStageOpInterpCtxImpl : public ReduceMinGlobalStageOpInterpCtx {
 public:
  ReduceMinGlobalStageOpInterpCtxImpl() = default;
  ReduceMinGlobalStageOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& axis() const { return impl_.axis(); }
  std::vector<std::int32_t>* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const std::vector<std::int32_t>& axis) { impl_.set_axis(axis); }
  
  const bool& keepdims() const { return impl_.keepdims(); }
  bool* mutable_keepdims() { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) { impl_.set_keepdims(keepdims); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMinGlobalStageOp {
 public:
  ReduceMinGlobalStageOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& axis() const { return internal_->axis; }
  std::vector<std::int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<std::int32_t>& axis) { internal_->axis = axis; }
  
  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> axis;
    bool keepdims = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReduceMinOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReduceMinOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& axis() const = 0;
  virtual std::vector<std::int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<std::int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReduceMinOpInterpCtxImpl : public ReduceMinOpInterpCtx {
 public:
  ReduceMinOpInterpCtxImpl() = default;
  ReduceMinOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& axis() const { return impl_.axis(); }
  std::vector<std::int32_t>* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const std::vector<std::int32_t>& axis) { impl_.set_axis(axis); }
  
  const bool& keepdims() const { return impl_.keepdims(); }
  bool* mutable_keepdims() { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) { impl_.set_keepdims(keepdims); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMinOp {
 public:
  ReduceMinOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& axis() const { return internal_->axis; }
  std::vector<std::int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<std::int32_t>& axis) { internal_->axis = axis; }
  
  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> axis;
    bool keepdims = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReduceProdOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReduceProdOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& axis() const = 0;
  virtual std::vector<std::int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<std::int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReduceProdOpInterpCtxImpl : public ReduceProdOpInterpCtx {
 public:
  ReduceProdOpInterpCtxImpl() = default;
  ReduceProdOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& axis() const { return impl_.axis(); }
  std::vector<std::int32_t>* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const std::vector<std::int32_t>& axis) { impl_.set_axis(axis); }
  
  const bool& keepdims() const { return impl_.keepdims(); }
  bool* mutable_keepdims() { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) { impl_.set_keepdims(keepdims); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceProdOp {
 public:
  ReduceProdOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& axis() const { return internal_->axis; }
  std::vector<std::int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<std::int32_t>& axis) { internal_->axis = axis; }
  
  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> axis;
    bool keepdims = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReduceSumLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReduceSumLikeOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& axis() const = 0;
  virtual std::vector<std::int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<std::int32_t>& axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReduceSumLikeOpInterpCtxImpl : public ReduceSumLikeOpInterpCtx {
 public:
  ReduceSumLikeOpInterpCtxImpl() = default;
  ReduceSumLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& axis() const { return impl_.axis(); }
  std::vector<std::int32_t>* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const std::vector<std::int32_t>& axis) { impl_.set_axis(axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceSumLikeOp {
 public:
  ReduceSumLikeOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& axis() const { return internal_->axis; }
  std::vector<std::int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<std::int32_t>& axis) { internal_->axis = axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> axis;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReduceSumOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReduceSumOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& axis() const = 0;
  virtual std::vector<std::int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<std::int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReduceSumOpInterpCtxImpl : public ReduceSumOpInterpCtx {
 public:
  ReduceSumOpInterpCtxImpl() = default;
  ReduceSumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& axis() const { return impl_.axis(); }
  std::vector<std::int32_t>* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const std::vector<std::int32_t>& axis) { impl_.set_axis(axis); }
  
  const bool& keepdims() const { return impl_.keepdims(); }
  bool* mutable_keepdims() { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) { impl_.set_keepdims(keepdims); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceSumOp {
 public:
  ReduceSumOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& axis() const { return internal_->axis; }
  std::vector<std::int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<std::int32_t>& axis) { internal_->axis = axis; }
  
  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> axis;
    bool keepdims = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReflectionPad2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReflectionPad2DGradOpInterpCtx() = default;

  virtual const std::vector<std::int64_t>& padding() const = 0;
  virtual std::vector<std::int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int64_t>& padding) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReflectionPad2DGradOpInterpCtxImpl : public ReflectionPad2DGradOpInterpCtx {
 public:
  ReflectionPad2DGradOpInterpCtxImpl() = default;
  ReflectionPad2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int64_t>& padding() const { return impl_.padding(); }
  std::vector<std::int64_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int64_t>& padding) { impl_.set_padding(padding); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReflectionPad2DGradOp {
 public:
  ReflectionPad2DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int64_t>& padding() const { return internal_->padding; }
  std::vector<std::int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int64_t>& padding) { internal_->padding = padding; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int64_t> padding;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReflectionPad2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReflectionPad2DOpInterpCtx() = default;

  virtual const std::vector<std::int64_t>& padding() const = 0;
  virtual std::vector<std::int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int64_t>& padding) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReflectionPad2DOpInterpCtxImpl : public ReflectionPad2DOpInterpCtx {
 public:
  ReflectionPad2DOpInterpCtxImpl() = default;
  ReflectionPad2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int64_t>& padding() const { return impl_.padding(); }
  std::vector<std::int64_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int64_t>& padding) { impl_.set_padding(padding); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReflectionPad2DOp {
 public:
  ReflectionPad2DOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int64_t>& padding() const { return internal_->padding; }
  std::vector<std::int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int64_t>& padding) { internal_->padding = padding; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int64_t> padding;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReluGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReluGradOpInterpCtxImpl : public ReluGradOpInterpCtx {
 public:
  ReluGradOpInterpCtxImpl() = default;
  ReluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReluGradOp {
 public:
  ReluGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReluOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReluOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReluOpInterpCtxImpl : public ReluOpInterpCtx {
 public:
  ReluOpInterpCtxImpl() = default;
  ReluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReluOp {
 public:
  ReluOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class RepeatOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~RepeatOpInterpCtx() = default;

  virtual const int32_t& repeat_num() const = 0;
  virtual int32_t* mutable_repeat_num() = 0;
  virtual void set_repeat_num(const int32_t& repeat_num) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class RepeatOpInterpCtxImpl : public RepeatOpInterpCtx {
 public:
  RepeatOpInterpCtxImpl() = default;
  RepeatOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& repeat_num() const { return impl_.repeat_num(); }
  int32_t* mutable_repeat_num() { return impl_.mutable_repeat_num(); }
  void set_repeat_num(const int32_t& repeat_num) { impl_.set_repeat_num(repeat_num); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RepeatOp {
 public:
  RepeatOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& repeat_num() const { return internal_->repeat_num; }
  int32_t* mutable_repeat_num() { return &internal_->repeat_num; }
  void set_repeat_num(const int32_t& repeat_num) { internal_->repeat_num = repeat_num; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t repeat_num = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReplicationPad2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReplicationPad2DGradOpInterpCtx() = default;

  virtual const std::vector<std::int64_t>& padding() const = 0;
  virtual std::vector<std::int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int64_t>& padding) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReplicationPad2DGradOpInterpCtxImpl : public ReplicationPad2DGradOpInterpCtx {
 public:
  ReplicationPad2DGradOpInterpCtxImpl() = default;
  ReplicationPad2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int64_t>& padding() const { return impl_.padding(); }
  std::vector<std::int64_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int64_t>& padding) { impl_.set_padding(padding); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReplicationPad2DGradOp {
 public:
  ReplicationPad2DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int64_t>& padding() const { return internal_->padding; }
  std::vector<std::int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int64_t>& padding) { internal_->padding = padding; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int64_t> padding;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReplicationPad2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReplicationPad2DOpInterpCtx() = default;

  virtual const std::vector<std::int64_t>& padding() const = 0;
  virtual std::vector<std::int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int64_t>& padding) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReplicationPad2DOpInterpCtxImpl : public ReplicationPad2DOpInterpCtx {
 public:
  ReplicationPad2DOpInterpCtxImpl() = default;
  ReplicationPad2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int64_t>& padding() const { return impl_.padding(); }
  std::vector<std::int64_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int64_t>& padding) { impl_.set_padding(padding); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReplicationPad2DOp {
 public:
  ReplicationPad2DOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int64_t>& padding() const { return internal_->padding; }
  std::vector<std::int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int64_t>& padding) { internal_->padding = padding; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int64_t> padding;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReshapeLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReshapeLikeOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReshapeLikeOpInterpCtxImpl : public ReshapeLikeOpInterpCtx {
 public:
  ReshapeLikeOpInterpCtxImpl() = default;
  ReshapeLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReshapeLikeOp {
 public:
  ReshapeLikeOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ReshapeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ReshapeOpInterpCtx() = default;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ReshapeOpInterpCtxImpl : public ReshapeOpInterpCtx {
 public:
  ReshapeOpInterpCtxImpl() = default;
  ReshapeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReshapeOp {
 public:
  ReshapeOp() : internal_(std::make_shared<Internal>()) {}
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    Shape shape;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class RintGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~RintGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class RintGradOpInterpCtxImpl : public RintGradOpInterpCtx {
 public:
  RintGradOpInterpCtxImpl() = default;
  RintGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RintGradOp {
 public:
  RintGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class RintOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~RintOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class RintOpInterpCtxImpl : public RintOpInterpCtx {
 public:
  RintOpInterpCtxImpl() = default;
  RintOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RintOp {
 public:
  RintOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class RmspropUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~RmspropUpdateOpInterpCtx() = default;

  virtual const bool& centered() const = 0;
  virtual bool* mutable_centered() = 0;
  virtual void set_centered(const bool& centered) = 0;

  virtual const float& decay_rate() const = 0;
  virtual float* mutable_decay_rate() = 0;
  virtual void set_decay_rate(const float& decay_rate) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  virtual const float& l1() const = 0;
  virtual float* mutable_l1() = 0;
  virtual void set_l1(const float& l1) = 0;

  virtual const float& l2() const = 0;
  virtual float* mutable_l2() = 0;
  virtual void set_l2(const float& l2) = 0;

  virtual const float& learning_rate_val() const = 0;
  virtual float* mutable_learning_rate_val() = 0;
  virtual void set_learning_rate_val(const float& learning_rate_val) = 0;

  virtual const double& scale() const = 0;
  virtual double* mutable_scale() = 0;
  virtual void set_scale(const double& scale) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class RmspropUpdateOpInterpCtxImpl : public RmspropUpdateOpInterpCtx {
 public:
  RmspropUpdateOpInterpCtxImpl() = default;
  RmspropUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& centered() const { return impl_.centered(); }
  bool* mutable_centered() { return impl_.mutable_centered(); }
  void set_centered(const bool& centered) { impl_.set_centered(centered); }
  
  const float& decay_rate() const { return impl_.decay_rate(); }
  float* mutable_decay_rate() { return impl_.mutable_decay_rate(); }
  void set_decay_rate(const float& decay_rate) { impl_.set_decay_rate(decay_rate); }
  
  const float& epsilon() const { return impl_.epsilon(); }
  float* mutable_epsilon() { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) { impl_.set_epsilon(epsilon); }
  
  const float& l1() const { return impl_.l1(); }
  float* mutable_l1() { return impl_.mutable_l1(); }
  void set_l1(const float& l1) { impl_.set_l1(l1); }
  
  const float& l2() const { return impl_.l2(); }
  float* mutable_l2() { return impl_.mutable_l2(); }
  void set_l2(const float& l2) { impl_.set_l2(l2); }
  
  const float& learning_rate_val() const { return impl_.learning_rate_val(); }
  float* mutable_learning_rate_val() { return impl_.mutable_learning_rate_val(); }
  void set_learning_rate_val(const float& learning_rate_val) { impl_.set_learning_rate_val(learning_rate_val); }
  
  const double& scale() const { return impl_.scale(); }
  double* mutable_scale() { return impl_.mutable_scale(); }
  void set_scale(const double& scale) { impl_.set_scale(scale); }
  
  const float& weight_decay() const { return impl_.weight_decay(); }
  float* mutable_weight_decay() { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) { impl_.set_weight_decay(weight_decay); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RmspropUpdateOp {
 public:
  RmspropUpdateOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& centered() const { return internal_->centered; }
  bool* mutable_centered() { return &internal_->centered; }
  void set_centered(const bool& centered) { internal_->centered = centered; }
  
  const float& decay_rate() const { return internal_->decay_rate; }
  float* mutable_decay_rate() { return &internal_->decay_rate; }
  void set_decay_rate(const float& decay_rate) { internal_->decay_rate = decay_rate; }
  
  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }
  
  const float& l1() const { return internal_->l1; }
  float* mutable_l1() { return &internal_->l1; }
  void set_l1(const float& l1) { internal_->l1 = l1; }
  
  const float& l2() const { return internal_->l2; }
  float* mutable_l2() { return &internal_->l2; }
  void set_l2(const float& l2) { internal_->l2 = l2; }
  
  const float& learning_rate_val() const { return internal_->learning_rate_val; }
  float* mutable_learning_rate_val() { return &internal_->learning_rate_val; }
  void set_learning_rate_val(const float& learning_rate_val) { internal_->learning_rate_val = learning_rate_val; }
  
  const double& scale() const { return internal_->scale; }
  double* mutable_scale() { return &internal_->scale; }
  void set_scale(const double& scale) { internal_->scale = scale; }
  
  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool centered = false;
    float decay_rate = 0.99;
    float epsilon = 0.;
    float l1 = 0.;
    float l2 = 0.;
    float learning_rate_val = 0.;
    double scale = 1.;
    float weight_decay = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class RoiAlignGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~RoiAlignGradOpInterpCtx() = default;

  virtual const bool& aligned() const = 0;
  virtual bool* mutable_aligned() = 0;
  virtual void set_aligned(const bool& aligned) = 0;

  virtual const int32_t& pooled_h() const = 0;
  virtual int32_t* mutable_pooled_h() = 0;
  virtual void set_pooled_h(const int32_t& pooled_h) = 0;

  virtual const int32_t& pooled_w() const = 0;
  virtual int32_t* mutable_pooled_w() = 0;
  virtual void set_pooled_w(const int32_t& pooled_w) = 0;

  virtual const int32_t& sampling_ratio() const = 0;
  virtual int32_t* mutable_sampling_ratio() = 0;
  virtual void set_sampling_ratio(const int32_t& sampling_ratio) = 0;

  virtual const float& spatial_scale() const = 0;
  virtual float* mutable_spatial_scale() = 0;
  virtual void set_spatial_scale(const float& spatial_scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class RoiAlignGradOpInterpCtxImpl : public RoiAlignGradOpInterpCtx {
 public:
  RoiAlignGradOpInterpCtxImpl() = default;
  RoiAlignGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& aligned() const { return impl_.aligned(); }
  bool* mutable_aligned() { return impl_.mutable_aligned(); }
  void set_aligned(const bool& aligned) { impl_.set_aligned(aligned); }
  
  const int32_t& pooled_h() const { return impl_.pooled_h(); }
  int32_t* mutable_pooled_h() { return impl_.mutable_pooled_h(); }
  void set_pooled_h(const int32_t& pooled_h) { impl_.set_pooled_h(pooled_h); }
  
  const int32_t& pooled_w() const { return impl_.pooled_w(); }
  int32_t* mutable_pooled_w() { return impl_.mutable_pooled_w(); }
  void set_pooled_w(const int32_t& pooled_w) { impl_.set_pooled_w(pooled_w); }
  
  const int32_t& sampling_ratio() const { return impl_.sampling_ratio(); }
  int32_t* mutable_sampling_ratio() { return impl_.mutable_sampling_ratio(); }
  void set_sampling_ratio(const int32_t& sampling_ratio) { impl_.set_sampling_ratio(sampling_ratio); }
  
  const float& spatial_scale() const { return impl_.spatial_scale(); }
  float* mutable_spatial_scale() { return impl_.mutable_spatial_scale(); }
  void set_spatial_scale(const float& spatial_scale) { impl_.set_spatial_scale(spatial_scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RoiAlignGradOp {
 public:
  RoiAlignGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& aligned() const { return internal_->aligned; }
  bool* mutable_aligned() { return &internal_->aligned; }
  void set_aligned(const bool& aligned) { internal_->aligned = aligned; }
  
  const int32_t& pooled_h() const { return internal_->pooled_h; }
  int32_t* mutable_pooled_h() { return &internal_->pooled_h; }
  void set_pooled_h(const int32_t& pooled_h) { internal_->pooled_h = pooled_h; }
  
  const int32_t& pooled_w() const { return internal_->pooled_w; }
  int32_t* mutable_pooled_w() { return &internal_->pooled_w; }
  void set_pooled_w(const int32_t& pooled_w) { internal_->pooled_w = pooled_w; }
  
  const int32_t& sampling_ratio() const { return internal_->sampling_ratio; }
  int32_t* mutable_sampling_ratio() { return &internal_->sampling_ratio; }
  void set_sampling_ratio(const int32_t& sampling_ratio) { internal_->sampling_ratio = sampling_ratio; }
  
  const float& spatial_scale() const { return internal_->spatial_scale; }
  float* mutable_spatial_scale() { return &internal_->spatial_scale; }
  void set_spatial_scale(const float& spatial_scale) { internal_->spatial_scale = spatial_scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool aligned = false;
    int32_t pooled_h = 0;
    int32_t pooled_w = 0;
    int32_t sampling_ratio = 0;
    float spatial_scale = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class RoiAlignOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~RoiAlignOpInterpCtx() = default;

  virtual const bool& aligned() const = 0;
  virtual bool* mutable_aligned() = 0;
  virtual void set_aligned(const bool& aligned) = 0;

  virtual const int32_t& pooled_h() const = 0;
  virtual int32_t* mutable_pooled_h() = 0;
  virtual void set_pooled_h(const int32_t& pooled_h) = 0;

  virtual const int32_t& pooled_w() const = 0;
  virtual int32_t* mutable_pooled_w() = 0;
  virtual void set_pooled_w(const int32_t& pooled_w) = 0;

  virtual const int32_t& sampling_ratio() const = 0;
  virtual int32_t* mutable_sampling_ratio() = 0;
  virtual void set_sampling_ratio(const int32_t& sampling_ratio) = 0;

  virtual const float& spatial_scale() const = 0;
  virtual float* mutable_spatial_scale() = 0;
  virtual void set_spatial_scale(const float& spatial_scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class RoiAlignOpInterpCtxImpl : public RoiAlignOpInterpCtx {
 public:
  RoiAlignOpInterpCtxImpl() = default;
  RoiAlignOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& aligned() const { return impl_.aligned(); }
  bool* mutable_aligned() { return impl_.mutable_aligned(); }
  void set_aligned(const bool& aligned) { impl_.set_aligned(aligned); }
  
  const int32_t& pooled_h() const { return impl_.pooled_h(); }
  int32_t* mutable_pooled_h() { return impl_.mutable_pooled_h(); }
  void set_pooled_h(const int32_t& pooled_h) { impl_.set_pooled_h(pooled_h); }
  
  const int32_t& pooled_w() const { return impl_.pooled_w(); }
  int32_t* mutable_pooled_w() { return impl_.mutable_pooled_w(); }
  void set_pooled_w(const int32_t& pooled_w) { impl_.set_pooled_w(pooled_w); }
  
  const int32_t& sampling_ratio() const { return impl_.sampling_ratio(); }
  int32_t* mutable_sampling_ratio() { return impl_.mutable_sampling_ratio(); }
  void set_sampling_ratio(const int32_t& sampling_ratio) { impl_.set_sampling_ratio(sampling_ratio); }
  
  const float& spatial_scale() const { return impl_.spatial_scale(); }
  float* mutable_spatial_scale() { return impl_.mutable_spatial_scale(); }
  void set_spatial_scale(const float& spatial_scale) { impl_.set_spatial_scale(spatial_scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RoiAlignOp {
 public:
  RoiAlignOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& aligned() const { return internal_->aligned; }
  bool* mutable_aligned() { return &internal_->aligned; }
  void set_aligned(const bool& aligned) { internal_->aligned = aligned; }
  
  const int32_t& pooled_h() const { return internal_->pooled_h; }
  int32_t* mutable_pooled_h() { return &internal_->pooled_h; }
  void set_pooled_h(const int32_t& pooled_h) { internal_->pooled_h = pooled_h; }
  
  const int32_t& pooled_w() const { return internal_->pooled_w; }
  int32_t* mutable_pooled_w() { return &internal_->pooled_w; }
  void set_pooled_w(const int32_t& pooled_w) { internal_->pooled_w = pooled_w; }
  
  const int32_t& sampling_ratio() const { return internal_->sampling_ratio; }
  int32_t* mutable_sampling_ratio() { return &internal_->sampling_ratio; }
  void set_sampling_ratio(const int32_t& sampling_ratio) { internal_->sampling_ratio = sampling_ratio; }
  
  const float& spatial_scale() const { return internal_->spatial_scale; }
  float* mutable_spatial_scale() { return &internal_->spatial_scale; }
  void set_spatial_scale(const float& spatial_scale) { internal_->spatial_scale = spatial_scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool aligned = false;
    int32_t pooled_h = 0;
    int32_t pooled_w = 0;
    int32_t sampling_ratio = 0;
    float spatial_scale = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class RollOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~RollOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& dims() const = 0;
  virtual std::vector<std::int32_t>* mutable_dims() = 0;
  virtual void set_dims(const std::vector<std::int32_t>& dims) = 0;

  virtual const std::vector<std::int32_t>& shifts() const = 0;
  virtual std::vector<std::int32_t>* mutable_shifts() = 0;
  virtual void set_shifts(const std::vector<std::int32_t>& shifts) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class RollOpInterpCtxImpl : public RollOpInterpCtx {
 public:
  RollOpInterpCtxImpl() = default;
  RollOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& dims() const { return impl_.dims(); }
  std::vector<std::int32_t>* mutable_dims() { return impl_.mutable_dims(); }
  void set_dims(const std::vector<std::int32_t>& dims) { impl_.set_dims(dims); }
  
  const std::vector<std::int32_t>& shifts() const { return impl_.shifts(); }
  std::vector<std::int32_t>* mutable_shifts() { return impl_.mutable_shifts(); }
  void set_shifts(const std::vector<std::int32_t>& shifts) { impl_.set_shifts(shifts); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RollOp {
 public:
  RollOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& dims() const { return internal_->dims; }
  std::vector<std::int32_t>* mutable_dims() { return &internal_->dims; }
  void set_dims(const std::vector<std::int32_t>& dims) { internal_->dims = dims; }
  
  const std::vector<std::int32_t>& shifts() const { return internal_->shifts; }
  std::vector<std::int32_t>* mutable_shifts() { return &internal_->shifts; }
  void set_shifts(const std::vector<std::int32_t>& shifts) { internal_->shifts = shifts; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> dims;
    std::vector<std::int32_t> shifts;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class RoundGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~RoundGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class RoundGradOpInterpCtxImpl : public RoundGradOpInterpCtx {
 public:
  RoundGradOpInterpCtxImpl() = default;
  RoundGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RoundGradOp {
 public:
  RoundGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class RoundOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~RoundOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class RoundOpInterpCtxImpl : public RoundOpInterpCtx {
 public:
  RoundOpInterpCtxImpl() = default;
  RoundOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RoundOp {
 public:
  RoundOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class RsqrtGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~RsqrtGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class RsqrtGradOpInterpCtxImpl : public RsqrtGradOpInterpCtx {
 public:
  RsqrtGradOpInterpCtxImpl() = default;
  RsqrtGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RsqrtGradOp {
 public:
  RsqrtGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class RsqrtOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~RsqrtOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class RsqrtOpInterpCtxImpl : public RsqrtOpInterpCtx {
 public:
  RsqrtOpInterpCtxImpl() = default;
  RsqrtOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RsqrtOp {
 public:
  RsqrtOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SamePaddingGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SamePaddingGradOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<std::int32_t>& dilation_rate() const = 0;
  virtual std::vector<std::int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SamePaddingGradOpInterpCtxImpl : public SamePaddingGradOpInterpCtx {
 public:
  SamePaddingGradOpInterpCtxImpl() = default;
  SamePaddingGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::vector<std::int32_t>& dilation_rate() const { return impl_.dilation_rate(); }
  std::vector<std::int32_t>* mutable_dilation_rate() { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { impl_.set_dilation_rate(dilation_rate); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::string& padding() const { return impl_.padding(); }
  std::string* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SamePaddingGradOp {
 public:
  SamePaddingGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::vector<std::int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<std::int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { internal_->dilation_rate = dilation_rate; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    std::vector<std::int32_t> dilation_rate;
    std::vector<std::int32_t> kernel_size;
    std::string padding;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SamePaddingOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SamePaddingOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<std::int32_t>& dilation_rate() const = 0;
  virtual std::vector<std::int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SamePaddingOpInterpCtxImpl : public SamePaddingOpInterpCtx {
 public:
  SamePaddingOpInterpCtxImpl() = default;
  SamePaddingOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::vector<std::int32_t>& dilation_rate() const { return impl_.dilation_rate(); }
  std::vector<std::int32_t>* mutable_dilation_rate() { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { impl_.set_dilation_rate(dilation_rate); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::string& padding() const { return impl_.padding(); }
  std::string* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SamePaddingOp {
 public:
  SamePaddingOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::vector<std::int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<std::int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { internal_->dilation_rate = dilation_rate; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    std::vector<std::int32_t> dilation_rate;
    std::vector<std::int32_t> kernel_size;
    std::string padding;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarAddByTensorOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarAddByTensorOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarAddByTensorOpInterpCtxImpl : public ScalarAddByTensorOpInterpCtx {
 public:
  ScalarAddByTensorOpInterpCtxImpl() = default;
  ScalarAddByTensorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarAddByTensorOp {
 public:
  ScalarAddByTensorOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarAddOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarAddOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarAddOpInterpCtxImpl : public ScalarAddOpInterpCtx {
 public:
  ScalarAddOpInterpCtxImpl() = default;
  ScalarAddOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarAddOp {
 public:
  ScalarAddOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarDivByTensorOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarDivByTensorOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarDivByTensorOpInterpCtxImpl : public ScalarDivByTensorOpInterpCtx {
 public:
  ScalarDivByTensorOpInterpCtxImpl() = default;
  ScalarDivByTensorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarDivByTensorOp {
 public:
  ScalarDivByTensorOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarFloordivOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarFloordivOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarFloordivOpInterpCtxImpl : public ScalarFloordivOpInterpCtx {
 public:
  ScalarFloordivOpInterpCtxImpl() = default;
  ScalarFloordivOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarFloordivOp {
 public:
  ScalarFloordivOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarFmodOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarFmodOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarFmodOpInterpCtxImpl : public ScalarFmodOpInterpCtx {
 public:
  ScalarFmodOpInterpCtxImpl() = default;
  ScalarFmodOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarFmodOp {
 public:
  ScalarFmodOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarLogicalAndOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarLogicalAndOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarLogicalAndOpInterpCtxImpl : public ScalarLogicalAndOpInterpCtx {
 public:
  ScalarLogicalAndOpInterpCtxImpl() = default;
  ScalarLogicalAndOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalAndOp {
 public:
  ScalarLogicalAndOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarLogicalEqualOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarLogicalEqualOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarLogicalEqualOpInterpCtxImpl : public ScalarLogicalEqualOpInterpCtx {
 public:
  ScalarLogicalEqualOpInterpCtxImpl() = default;
  ScalarLogicalEqualOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalEqualOp {
 public:
  ScalarLogicalEqualOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarLogicalGreaterEqualOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarLogicalGreaterEqualOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarLogicalGreaterEqualOpInterpCtxImpl : public ScalarLogicalGreaterEqualOpInterpCtx {
 public:
  ScalarLogicalGreaterEqualOpInterpCtxImpl() = default;
  ScalarLogicalGreaterEqualOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalGreaterEqualOp {
 public:
  ScalarLogicalGreaterEqualOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarLogicalGreaterOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarLogicalGreaterOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarLogicalGreaterOpInterpCtxImpl : public ScalarLogicalGreaterOpInterpCtx {
 public:
  ScalarLogicalGreaterOpInterpCtxImpl() = default;
  ScalarLogicalGreaterOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalGreaterOp {
 public:
  ScalarLogicalGreaterOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarLogicalLessEqualOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarLogicalLessEqualOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarLogicalLessEqualOpInterpCtxImpl : public ScalarLogicalLessEqualOpInterpCtx {
 public:
  ScalarLogicalLessEqualOpInterpCtxImpl() = default;
  ScalarLogicalLessEqualOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalLessEqualOp {
 public:
  ScalarLogicalLessEqualOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarLogicalLessOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarLogicalLessOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarLogicalLessOpInterpCtxImpl : public ScalarLogicalLessOpInterpCtx {
 public:
  ScalarLogicalLessOpInterpCtxImpl() = default;
  ScalarLogicalLessOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalLessOp {
 public:
  ScalarLogicalLessOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarLogicalNotEqualOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarLogicalNotEqualOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarLogicalNotEqualOpInterpCtxImpl : public ScalarLogicalNotEqualOpInterpCtx {
 public:
  ScalarLogicalNotEqualOpInterpCtxImpl() = default;
  ScalarLogicalNotEqualOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalNotEqualOp {
 public:
  ScalarLogicalNotEqualOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarLogicalOrOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarLogicalOrOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarLogicalOrOpInterpCtxImpl : public ScalarLogicalOrOpInterpCtx {
 public:
  ScalarLogicalOrOpInterpCtxImpl() = default;
  ScalarLogicalOrOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalOrOp {
 public:
  ScalarLogicalOrOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarLogicalXorOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarLogicalXorOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarLogicalXorOpInterpCtxImpl : public ScalarLogicalXorOpInterpCtx {
 public:
  ScalarLogicalXorOpInterpCtxImpl() = default;
  ScalarLogicalXorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalXorOp {
 public:
  ScalarLogicalXorOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarMulByTensorOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarMulByTensorOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarMulByTensorOpInterpCtxImpl : public ScalarMulByTensorOpInterpCtx {
 public:
  ScalarMulByTensorOpInterpCtxImpl() = default;
  ScalarMulByTensorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarMulByTensorOp {
 public:
  ScalarMulByTensorOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarMulOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarMulOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarMulOpInterpCtxImpl : public ScalarMulOpInterpCtx {
 public:
  ScalarMulOpInterpCtxImpl() = default;
  ScalarMulOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarMulOp {
 public:
  ScalarMulOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarPowGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarPowGradOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarPowGradOpInterpCtxImpl : public ScalarPowGradOpInterpCtx {
 public:
  ScalarPowGradOpInterpCtxImpl() = default;
  ScalarPowGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarPowGradOp {
 public:
  ScalarPowGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarPowOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarPowOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarPowOpInterpCtxImpl : public ScalarPowOpInterpCtx {
 public:
  ScalarPowOpInterpCtxImpl() = default;
  ScalarPowOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarPowOp {
 public:
  ScalarPowOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScalarSubByTensorOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScalarSubByTensorOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScalarSubByTensorOpInterpCtxImpl : public ScalarSubByTensorOpInterpCtx {
 public:
  ScalarSubByTensorOpInterpCtxImpl() = default;
  ScalarSubByTensorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarSubByTensorOp {
 public:
  ScalarSubByTensorOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScatterNdLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScatterNdLikeOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScatterNdLikeOpInterpCtxImpl : public ScatterNdLikeOpInterpCtx {
 public:
  ScatterNdLikeOpInterpCtxImpl() = default;
  ScatterNdLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScatterNdLikeOp {
 public:
  ScatterNdLikeOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ScatterNdOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ScatterNdOpInterpCtx() = default;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ScatterNdOpInterpCtxImpl : public ScatterNdOpInterpCtx {
 public:
  ScatterNdOpInterpCtxImpl() = default;
  ScatterNdOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScatterNdOp {
 public:
  ScatterNdOp() : internal_(std::make_shared<Internal>()) {}
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    Shape shape;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SeluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SeluGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SeluGradOpInterpCtxImpl : public SeluGradOpInterpCtx {
 public:
  SeluGradOpInterpCtxImpl() = default;
  SeluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SeluGradOp {
 public:
  SeluGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SeluOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SeluOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SeluOpInterpCtxImpl : public SeluOpInterpCtx {
 public:
  SeluOpInterpCtxImpl() = default;
  SeluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SeluOp {
 public:
  SeluOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SendOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SendOpInterpCtx() = default;

  virtual const int64_t& dst_process_id() const = 0;
  virtual int64_t* mutable_dst_process_id() = 0;
  virtual void set_dst_process_id(const int64_t& dst_process_id) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SendOpInterpCtxImpl : public SendOpInterpCtx {
 public:
  SendOpInterpCtxImpl() = default;
  SendOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& dst_process_id() const { return impl_.dst_process_id(); }
  int64_t* mutable_dst_process_id() { return impl_.mutable_dst_process_id(); }
  void set_dst_process_id(const int64_t& dst_process_id) { impl_.set_dst_process_id(dst_process_id); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SendOp {
 public:
  SendOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& dst_process_id() const { return internal_->dst_process_id; }
  int64_t* mutable_dst_process_id() { return &internal_->dst_process_id; }
  void set_dst_process_id(const int64_t& dst_process_id) { internal_->dst_process_id = dst_process_id; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t dst_process_id = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SgdUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SgdUpdateOpInterpCtx() = default;

  virtual const float& l1() const = 0;
  virtual float* mutable_l1() = 0;
  virtual void set_l1(const float& l1) = 0;

  virtual const float& l2() const = 0;
  virtual float* mutable_l2() = 0;
  virtual void set_l2(const float& l2) = 0;

  virtual const float& learning_rate_val() const = 0;
  virtual float* mutable_learning_rate_val() = 0;
  virtual void set_learning_rate_val(const float& learning_rate_val) = 0;

  virtual const double& scale() const = 0;
  virtual double* mutable_scale() = 0;
  virtual void set_scale(const double& scale) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SgdUpdateOpInterpCtxImpl : public SgdUpdateOpInterpCtx {
 public:
  SgdUpdateOpInterpCtxImpl() = default;
  SgdUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& l1() const { return impl_.l1(); }
  float* mutable_l1() { return impl_.mutable_l1(); }
  void set_l1(const float& l1) { impl_.set_l1(l1); }
  
  const float& l2() const { return impl_.l2(); }
  float* mutable_l2() { return impl_.mutable_l2(); }
  void set_l2(const float& l2) { impl_.set_l2(l2); }
  
  const float& learning_rate_val() const { return impl_.learning_rate_val(); }
  float* mutable_learning_rate_val() { return impl_.mutable_learning_rate_val(); }
  void set_learning_rate_val(const float& learning_rate_val) { impl_.set_learning_rate_val(learning_rate_val); }
  
  const double& scale() const { return impl_.scale(); }
  double* mutable_scale() { return impl_.mutable_scale(); }
  void set_scale(const double& scale) { impl_.set_scale(scale); }
  
  const float& weight_decay() const { return impl_.weight_decay(); }
  float* mutable_weight_decay() { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) { impl_.set_weight_decay(weight_decay); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SgdUpdateOp {
 public:
  SgdUpdateOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& l1() const { return internal_->l1; }
  float* mutable_l1() { return &internal_->l1; }
  void set_l1(const float& l1) { internal_->l1 = l1; }
  
  const float& l2() const { return internal_->l2; }
  float* mutable_l2() { return &internal_->l2; }
  void set_l2(const float& l2) { internal_->l2 = l2; }
  
  const float& learning_rate_val() const { return internal_->learning_rate_val; }
  float* mutable_learning_rate_val() { return &internal_->learning_rate_val; }
  void set_learning_rate_val(const float& learning_rate_val) { internal_->learning_rate_val = learning_rate_val; }
  
  const double& scale() const { return internal_->scale; }
  double* mutable_scale() { return &internal_->scale; }
  void set_scale(const double& scale) { internal_->scale = scale; }
  
  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float l1 = 0.;
    float l2 = 0.;
    float learning_rate_val = 0.;
    double scale = 1.;
    float weight_decay = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SigmoidCrossEntropyGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SigmoidCrossEntropyGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SigmoidCrossEntropyGradOpInterpCtxImpl : public SigmoidCrossEntropyGradOpInterpCtx {
 public:
  SigmoidCrossEntropyGradOpInterpCtxImpl() = default;
  SigmoidCrossEntropyGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SigmoidCrossEntropyGradOp {
 public:
  SigmoidCrossEntropyGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SigmoidCrossEntropyOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SigmoidCrossEntropyOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SigmoidCrossEntropyOpInterpCtxImpl : public SigmoidCrossEntropyOpInterpCtx {
 public:
  SigmoidCrossEntropyOpInterpCtxImpl() = default;
  SigmoidCrossEntropyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SigmoidCrossEntropyOp {
 public:
  SigmoidCrossEntropyOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SigmoidGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SigmoidGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SigmoidGradOpInterpCtxImpl : public SigmoidGradOpInterpCtx {
 public:
  SigmoidGradOpInterpCtxImpl() = default;
  SigmoidGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SigmoidGradOp {
 public:
  SigmoidGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SigmoidOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SigmoidOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SigmoidOpInterpCtxImpl : public SigmoidOpInterpCtx {
 public:
  SigmoidOpInterpCtxImpl() = default;
  SigmoidOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SigmoidOp {
 public:
  SigmoidOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SigmoidV2GradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SigmoidV2GradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SigmoidV2GradOpInterpCtxImpl : public SigmoidV2GradOpInterpCtx {
 public:
  SigmoidV2GradOpInterpCtxImpl() = default;
  SigmoidV2GradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SigmoidV2GradOp {
 public:
  SigmoidV2GradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SigmoidV2OpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SigmoidV2OpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SigmoidV2OpInterpCtxImpl : public SigmoidV2OpInterpCtx {
 public:
  SigmoidV2OpInterpCtxImpl() = default;
  SigmoidV2OpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SigmoidV2Op {
 public:
  SigmoidV2Op() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SignGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SignGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SignGradOpInterpCtxImpl : public SignGradOpInterpCtx {
 public:
  SignGradOpInterpCtxImpl() = default;
  SignGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SignGradOp {
 public:
  SignGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SignOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SignOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SignOpInterpCtxImpl : public SignOpInterpCtx {
 public:
  SignOpInterpCtxImpl() = default;
  SignOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SignOp {
 public:
  SignOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SiluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SiluGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SiluGradOpInterpCtxImpl : public SiluGradOpInterpCtx {
 public:
  SiluGradOpInterpCtxImpl() = default;
  SiluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SiluGradOp {
 public:
  SiluGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SiluOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SiluOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SiluOpInterpCtxImpl : public SiluOpInterpCtx {
 public:
  SiluOpInterpCtxImpl() = default;
  SiluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SiluOp {
 public:
  SiluOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SinGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SinGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SinGradOpInterpCtxImpl : public SinGradOpInterpCtx {
 public:
  SinGradOpInterpCtxImpl() = default;
  SinGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SinGradOp {
 public:
  SinGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SinOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SinOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SinOpInterpCtxImpl : public SinOpInterpCtx {
 public:
  SinOpInterpCtxImpl() = default;
  SinOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SinOp {
 public:
  SinOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SinhGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SinhGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SinhGradOpInterpCtxImpl : public SinhGradOpInterpCtx {
 public:
  SinhGradOpInterpCtxImpl() = default;
  SinhGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SinhGradOp {
 public:
  SinhGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SinhOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SinhOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SinhOpInterpCtxImpl : public SinhOpInterpCtx {
 public:
  SinhOpInterpCtxImpl() = default;
  SinhOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SinhOp {
 public:
  SinhOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SliceGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SliceGradOpInterpCtx() = default;

  virtual const std::vector<std::int64_t>& start() const = 0;
  virtual std::vector<std::int64_t>* mutable_start() = 0;
  virtual void set_start(const std::vector<std::int64_t>& start) = 0;

  virtual const std::vector<std::int64_t>& step() const = 0;
  virtual std::vector<std::int64_t>* mutable_step() = 0;
  virtual void set_step(const std::vector<std::int64_t>& step) = 0;

  virtual const std::vector<std::int64_t>& stop() const = 0;
  virtual std::vector<std::int64_t>* mutable_stop() = 0;
  virtual void set_stop(const std::vector<std::int64_t>& stop) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SliceGradOpInterpCtxImpl : public SliceGradOpInterpCtx {
 public:
  SliceGradOpInterpCtxImpl() = default;
  SliceGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int64_t>& start() const { return impl_.start(); }
  std::vector<std::int64_t>* mutable_start() { return impl_.mutable_start(); }
  void set_start(const std::vector<std::int64_t>& start) { impl_.set_start(start); }
  
  const std::vector<std::int64_t>& step() const { return impl_.step(); }
  std::vector<std::int64_t>* mutable_step() { return impl_.mutable_step(); }
  void set_step(const std::vector<std::int64_t>& step) { impl_.set_step(step); }
  
  const std::vector<std::int64_t>& stop() const { return impl_.stop(); }
  std::vector<std::int64_t>* mutable_stop() { return impl_.mutable_stop(); }
  void set_stop(const std::vector<std::int64_t>& stop) { impl_.set_stop(stop); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SliceGradOp {
 public:
  SliceGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int64_t>& start() const { return internal_->start; }
  std::vector<std::int64_t>* mutable_start() { return &internal_->start; }
  void set_start(const std::vector<std::int64_t>& start) { internal_->start = start; }
  
  const std::vector<std::int64_t>& step() const { return internal_->step; }
  std::vector<std::int64_t>* mutable_step() { return &internal_->step; }
  void set_step(const std::vector<std::int64_t>& step) { internal_->step = step; }
  
  const std::vector<std::int64_t>& stop() const { return internal_->stop; }
  std::vector<std::int64_t>* mutable_stop() { return &internal_->stop; }
  void set_stop(const std::vector<std::int64_t>& stop) { internal_->stop = stop; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int64_t> start;
    std::vector<std::int64_t> step;
    std::vector<std::int64_t> stop;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SliceOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SliceOpInterpCtx() = default;

  virtual const std::vector<std::int64_t>& start() const = 0;
  virtual std::vector<std::int64_t>* mutable_start() = 0;
  virtual void set_start(const std::vector<std::int64_t>& start) = 0;

  virtual const std::vector<std::int64_t>& step() const = 0;
  virtual std::vector<std::int64_t>* mutable_step() = 0;
  virtual void set_step(const std::vector<std::int64_t>& step) = 0;

  virtual const std::vector<std::int64_t>& stop() const = 0;
  virtual std::vector<std::int64_t>* mutable_stop() = 0;
  virtual void set_stop(const std::vector<std::int64_t>& stop) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SliceOpInterpCtxImpl : public SliceOpInterpCtx {
 public:
  SliceOpInterpCtxImpl() = default;
  SliceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int64_t>& start() const { return impl_.start(); }
  std::vector<std::int64_t>* mutable_start() { return impl_.mutable_start(); }
  void set_start(const std::vector<std::int64_t>& start) { impl_.set_start(start); }
  
  const std::vector<std::int64_t>& step() const { return impl_.step(); }
  std::vector<std::int64_t>* mutable_step() { return impl_.mutable_step(); }
  void set_step(const std::vector<std::int64_t>& step) { impl_.set_step(step); }
  
  const std::vector<std::int64_t>& stop() const { return impl_.stop(); }
  std::vector<std::int64_t>* mutable_stop() { return impl_.mutable_stop(); }
  void set_stop(const std::vector<std::int64_t>& stop) { impl_.set_stop(stop); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SliceOp {
 public:
  SliceOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int64_t>& start() const { return internal_->start; }
  std::vector<std::int64_t>* mutable_start() { return &internal_->start; }
  void set_start(const std::vector<std::int64_t>& start) { internal_->start = start; }
  
  const std::vector<std::int64_t>& step() const { return internal_->step; }
  std::vector<std::int64_t>* mutable_step() { return &internal_->step; }
  void set_step(const std::vector<std::int64_t>& step) { internal_->step = step; }
  
  const std::vector<std::int64_t>& stop() const { return internal_->stop; }
  std::vector<std::int64_t>* mutable_stop() { return &internal_->stop; }
  void set_stop(const std::vector<std::int64_t>& stop) { internal_->stop = stop; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int64_t> start;
    std::vector<std::int64_t> step;
    std::vector<std::int64_t> stop;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SliceUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SliceUpdateOpInterpCtx() = default;

  virtual const std::vector<std::int64_t>& start() const = 0;
  virtual std::vector<std::int64_t>* mutable_start() = 0;
  virtual void set_start(const std::vector<std::int64_t>& start) = 0;

  virtual const std::vector<std::int64_t>& step() const = 0;
  virtual std::vector<std::int64_t>* mutable_step() = 0;
  virtual void set_step(const std::vector<std::int64_t>& step) = 0;

  virtual const std::vector<std::int64_t>& stop() const = 0;
  virtual std::vector<std::int64_t>* mutable_stop() = 0;
  virtual void set_stop(const std::vector<std::int64_t>& stop) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SliceUpdateOpInterpCtxImpl : public SliceUpdateOpInterpCtx {
 public:
  SliceUpdateOpInterpCtxImpl() = default;
  SliceUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int64_t>& start() const { return impl_.start(); }
  std::vector<std::int64_t>* mutable_start() { return impl_.mutable_start(); }
  void set_start(const std::vector<std::int64_t>& start) { impl_.set_start(start); }
  
  const std::vector<std::int64_t>& step() const { return impl_.step(); }
  std::vector<std::int64_t>* mutable_step() { return impl_.mutable_step(); }
  void set_step(const std::vector<std::int64_t>& step) { impl_.set_step(step); }
  
  const std::vector<std::int64_t>& stop() const { return impl_.stop(); }
  std::vector<std::int64_t>* mutable_stop() { return impl_.mutable_stop(); }
  void set_stop(const std::vector<std::int64_t>& stop) { impl_.set_stop(stop); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SliceUpdateOp {
 public:
  SliceUpdateOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int64_t>& start() const { return internal_->start; }
  std::vector<std::int64_t>* mutable_start() { return &internal_->start; }
  void set_start(const std::vector<std::int64_t>& start) { internal_->start = start; }
  
  const std::vector<std::int64_t>& step() const { return internal_->step; }
  std::vector<std::int64_t>* mutable_step() { return &internal_->step; }
  void set_step(const std::vector<std::int64_t>& step) { internal_->step = step; }
  
  const std::vector<std::int64_t>& stop() const { return internal_->stop; }
  std::vector<std::int64_t>* mutable_stop() { return &internal_->stop; }
  void set_stop(const std::vector<std::int64_t>& stop) { internal_->stop = stop; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int64_t> start;
    std::vector<std::int64_t> step;
    std::vector<std::int64_t> stop;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SmoothL1LossGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SmoothL1LossGradOpInterpCtx() = default;

  virtual const float& beta() const = 0;
  virtual float* mutable_beta() = 0;
  virtual void set_beta(const float& beta) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SmoothL1LossGradOpInterpCtxImpl : public SmoothL1LossGradOpInterpCtx {
 public:
  SmoothL1LossGradOpInterpCtxImpl() = default;
  SmoothL1LossGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& beta() const { return impl_.beta(); }
  float* mutable_beta() { return impl_.mutable_beta(); }
  void set_beta(const float& beta) { impl_.set_beta(beta); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SmoothL1LossGradOp {
 public:
  SmoothL1LossGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& beta() const { return internal_->beta; }
  float* mutable_beta() { return &internal_->beta; }
  void set_beta(const float& beta) { internal_->beta = beta; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float beta = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SmoothL1LossOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SmoothL1LossOpInterpCtx() = default;

  virtual const float& beta() const = 0;
  virtual float* mutable_beta() = 0;
  virtual void set_beta(const float& beta) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SmoothL1LossOpInterpCtxImpl : public SmoothL1LossOpInterpCtx {
 public:
  SmoothL1LossOpInterpCtxImpl() = default;
  SmoothL1LossOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const float& beta() const { return impl_.beta(); }
  float* mutable_beta() { return impl_.mutable_beta(); }
  void set_beta(const float& beta) { impl_.set_beta(beta); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SmoothL1LossOp {
 public:
  SmoothL1LossOp() : internal_(std::make_shared<Internal>()) {}
  
  const float& beta() const { return internal_->beta; }
  float* mutable_beta() { return &internal_->beta; }
  void set_beta(const float& beta) { internal_->beta = beta; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    float beta = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SoftmaxCrossEntropyGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SoftmaxCrossEntropyGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SoftmaxCrossEntropyGradOpInterpCtxImpl : public SoftmaxCrossEntropyGradOpInterpCtx {
 public:
  SoftmaxCrossEntropyGradOpInterpCtxImpl() = default;
  SoftmaxCrossEntropyGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SoftmaxCrossEntropyGradOp {
 public:
  SoftmaxCrossEntropyGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SoftmaxCrossEntropyOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SoftmaxCrossEntropyOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SoftmaxCrossEntropyOpInterpCtxImpl : public SoftmaxCrossEntropyOpInterpCtx {
 public:
  SoftmaxCrossEntropyOpInterpCtxImpl() = default;
  SoftmaxCrossEntropyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SoftmaxCrossEntropyOp {
 public:
  SoftmaxCrossEntropyOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SoftmaxGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SoftmaxGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SoftmaxGradOpInterpCtxImpl : public SoftmaxGradOpInterpCtx {
 public:
  SoftmaxGradOpInterpCtxImpl() = default;
  SoftmaxGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SoftmaxGradOp {
 public:
  SoftmaxGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SoftmaxOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SoftmaxOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SoftmaxOpInterpCtxImpl : public SoftmaxOpInterpCtx {
 public:
  SoftmaxOpInterpCtxImpl() = default;
  SoftmaxOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SoftmaxOp {
 public:
  SoftmaxOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SoftplusGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SoftplusGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SoftplusGradOpInterpCtxImpl : public SoftplusGradOpInterpCtx {
 public:
  SoftplusGradOpInterpCtxImpl() = default;
  SoftplusGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SoftplusGradOp {
 public:
  SoftplusGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SoftplusOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SoftplusOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SoftplusOpInterpCtxImpl : public SoftplusOpInterpCtx {
 public:
  SoftplusOpInterpCtxImpl() = default;
  SoftplusOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SoftplusOp {
 public:
  SoftplusOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SoftsignGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SoftsignGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SoftsignGradOpInterpCtxImpl : public SoftsignGradOpInterpCtx {
 public:
  SoftsignGradOpInterpCtxImpl() = default;
  SoftsignGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SoftsignGradOp {
 public:
  SoftsignGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SoftsignOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SoftsignOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SoftsignOpInterpCtxImpl : public SoftsignOpInterpCtx {
 public:
  SoftsignOpInterpCtxImpl() = default;
  SoftsignOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SoftsignOp {
 public:
  SoftsignOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SortOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SortOpInterpCtx() = default;

  virtual const std::string& direction() const = 0;
  virtual std::string* mutable_direction() = 0;
  virtual void set_direction(const std::string& direction) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SortOpInterpCtxImpl : public SortOpInterpCtx {
 public:
  SortOpInterpCtxImpl() = default;
  SortOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& direction() const { return impl_.direction(); }
  std::string* mutable_direction() { return impl_.mutable_direction(); }
  void set_direction(const std::string& direction) { impl_.set_direction(direction); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SortOp {
 public:
  SortOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& direction() const { return internal_->direction; }
  std::string* mutable_direction() { return &internal_->direction; }
  void set_direction(const std::string& direction) { internal_->direction = direction; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string direction;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SparseCrossEntropyGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SparseCrossEntropyGradOpInterpCtx() = default;

  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SparseCrossEntropyGradOpInterpCtxImpl : public SparseCrossEntropyGradOpInterpCtx {
 public:
  SparseCrossEntropyGradOpInterpCtxImpl() = default;
  SparseCrossEntropyGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& depth() const { return impl_.depth(); }
  int64_t* mutable_depth() { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) { impl_.set_depth(depth); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SparseCrossEntropyGradOp {
 public:
  SparseCrossEntropyGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t depth = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SparseCrossEntropyMsGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SparseCrossEntropyMsGradOpInterpCtx() = default;

  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SparseCrossEntropyMsGradOpInterpCtxImpl : public SparseCrossEntropyMsGradOpInterpCtx {
 public:
  SparseCrossEntropyMsGradOpInterpCtxImpl() = default;
  SparseCrossEntropyMsGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& depth() const { return impl_.depth(); }
  int64_t* mutable_depth() { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) { impl_.set_depth(depth); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SparseCrossEntropyMsGradOp {
 public:
  SparseCrossEntropyMsGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t depth = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SparseCrossEntropyMsOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SparseCrossEntropyMsOpInterpCtx() = default;

  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SparseCrossEntropyMsOpInterpCtxImpl : public SparseCrossEntropyMsOpInterpCtx {
 public:
  SparseCrossEntropyMsOpInterpCtxImpl() = default;
  SparseCrossEntropyMsOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& depth() const { return impl_.depth(); }
  int64_t* mutable_depth() { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) { impl_.set_depth(depth); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SparseCrossEntropyMsOp {
 public:
  SparseCrossEntropyMsOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t depth = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SparseCrossEntropyOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SparseCrossEntropyOpInterpCtx() = default;

  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SparseCrossEntropyOpInterpCtxImpl : public SparseCrossEntropyOpInterpCtx {
 public:
  SparseCrossEntropyOpInterpCtxImpl() = default;
  SparseCrossEntropyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& depth() const { return impl_.depth(); }
  int64_t* mutable_depth() { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) { impl_.set_depth(depth); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SparseCrossEntropyOp {
 public:
  SparseCrossEntropyOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t depth = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SparseSoftmaxCrossEntropyGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SparseSoftmaxCrossEntropyGradOpInterpCtx() = default;

  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SparseSoftmaxCrossEntropyGradOpInterpCtxImpl : public SparseSoftmaxCrossEntropyGradOpInterpCtx {
 public:
  SparseSoftmaxCrossEntropyGradOpInterpCtxImpl() = default;
  SparseSoftmaxCrossEntropyGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& depth() const { return impl_.depth(); }
  int64_t* mutable_depth() { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) { impl_.set_depth(depth); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SparseSoftmaxCrossEntropyGradOp {
 public:
  SparseSoftmaxCrossEntropyGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t depth = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SparseSoftmaxCrossEntropyMsGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SparseSoftmaxCrossEntropyMsGradOpInterpCtx() = default;

  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SparseSoftmaxCrossEntropyMsGradOpInterpCtxImpl : public SparseSoftmaxCrossEntropyMsGradOpInterpCtx {
 public:
  SparseSoftmaxCrossEntropyMsGradOpInterpCtxImpl() = default;
  SparseSoftmaxCrossEntropyMsGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& depth() const { return impl_.depth(); }
  int64_t* mutable_depth() { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) { impl_.set_depth(depth); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SparseSoftmaxCrossEntropyMsGradOp {
 public:
  SparseSoftmaxCrossEntropyMsGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t depth = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SparseSoftmaxCrossEntropyMsOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SparseSoftmaxCrossEntropyMsOpInterpCtx() = default;

  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SparseSoftmaxCrossEntropyMsOpInterpCtxImpl : public SparseSoftmaxCrossEntropyMsOpInterpCtx {
 public:
  SparseSoftmaxCrossEntropyMsOpInterpCtxImpl() = default;
  SparseSoftmaxCrossEntropyMsOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& depth() const { return impl_.depth(); }
  int64_t* mutable_depth() { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) { impl_.set_depth(depth); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SparseSoftmaxCrossEntropyMsOp {
 public:
  SparseSoftmaxCrossEntropyMsOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t depth = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SparseSoftmaxCrossEntropyOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SparseSoftmaxCrossEntropyOpInterpCtx() = default;

  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SparseSoftmaxCrossEntropyOpInterpCtxImpl : public SparseSoftmaxCrossEntropyOpInterpCtx {
 public:
  SparseSoftmaxCrossEntropyOpInterpCtxImpl() = default;
  SparseSoftmaxCrossEntropyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& depth() const { return impl_.depth(); }
  int64_t* mutable_depth() { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) { impl_.set_depth(depth); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SparseSoftmaxCrossEntropyOp {
 public:
  SparseSoftmaxCrossEntropyOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t depth = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SplitLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SplitLikeOpInterpCtx() = default;

  virtual const int64_t& axis() const = 0;
  virtual int64_t* mutable_axis() = 0;
  virtual void set_axis(const int64_t& axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SplitLikeOpInterpCtxImpl : public SplitLikeOpInterpCtx {
 public:
  SplitLikeOpInterpCtxImpl() = default;
  SplitLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& axis() const { return impl_.axis(); }
  int64_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int64_t& axis) { impl_.set_axis(axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SplitLikeOp {
 public:
  SplitLikeOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& axis() const { return internal_->axis; }
  int64_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int64_t& axis) { internal_->axis = axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t axis = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SqrtGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SqrtGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SqrtGradOpInterpCtxImpl : public SqrtGradOpInterpCtx {
 public:
  SqrtGradOpInterpCtxImpl() = default;
  SqrtGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SqrtGradOp {
 public:
  SqrtGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SqrtOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SqrtOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SqrtOpInterpCtxImpl : public SqrtOpInterpCtx {
 public:
  SqrtOpInterpCtxImpl() = default;
  SqrtOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SqrtOp {
 public:
  SqrtOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SquareGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SquareGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SquareGradOpInterpCtxImpl : public SquareGradOpInterpCtx {
 public:
  SquareGradOpInterpCtxImpl() = default;
  SquareGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SquareGradOp {
 public:
  SquareGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SquareOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SquareOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SquareOpInterpCtxImpl : public SquareOpInterpCtx {
 public:
  SquareOpInterpCtxImpl() = default;
  SquareOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SquareOp {
 public:
  SquareOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SquareSumOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SquareSumOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SquareSumOpInterpCtxImpl : public SquareSumOpInterpCtx {
 public:
  SquareSumOpInterpCtxImpl() = default;
  SquareSumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SquareSumOp {
 public:
  SquareSumOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SqueezeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SqueezeOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& axes() const = 0;
  virtual std::vector<std::int32_t>* mutable_axes() = 0;
  virtual void set_axes(const std::vector<std::int32_t>& axes) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SqueezeOpInterpCtxImpl : public SqueezeOpInterpCtx {
 public:
  SqueezeOpInterpCtxImpl() = default;
  SqueezeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& axes() const { return impl_.axes(); }
  std::vector<std::int32_t>* mutable_axes() { return impl_.mutable_axes(); }
  void set_axes(const std::vector<std::int32_t>& axes) { impl_.set_axes(axes); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SqueezeOp {
 public:
  SqueezeOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& axes() const { return internal_->axes; }
  std::vector<std::int32_t>* mutable_axes() { return &internal_->axes; }
  void set_axes(const std::vector<std::int32_t>& axes) { internal_->axes = axes; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> axes;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SspVariableProxyOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SspVariableProxyOpInterpCtx() = default;

  virtual const int64_t& buffer_size() const = 0;
  virtual int64_t* mutable_buffer_size() = 0;
  virtual void set_buffer_size(const int64_t& buffer_size) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SspVariableProxyOpInterpCtxImpl : public SspVariableProxyOpInterpCtx {
 public:
  SspVariableProxyOpInterpCtxImpl() = default;
  SspVariableProxyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& buffer_size() const { return impl_.buffer_size(); }
  int64_t* mutable_buffer_size() { return impl_.mutable_buffer_size(); }
  void set_buffer_size(const int64_t& buffer_size) { impl_.set_buffer_size(buffer_size); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SspVariableProxyOp {
 public:
  SspVariableProxyOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& buffer_size() const { return internal_->buffer_size; }
  int64_t* mutable_buffer_size() { return &internal_->buffer_size; }
  void set_buffer_size(const int64_t& buffer_size) { internal_->buffer_size = buffer_size; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t buffer_size = 1;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SummaryWriteHistogramOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SummaryWriteHistogramOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SummaryWriteHistogramOpInterpCtxImpl : public SummaryWriteHistogramOpInterpCtx {
 public:
  SummaryWriteHistogramOpInterpCtxImpl() = default;
  SummaryWriteHistogramOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SummaryWriteHistogramOp {
 public:
  SummaryWriteHistogramOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SummaryWriteImageOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SummaryWriteImageOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SummaryWriteImageOpInterpCtxImpl : public SummaryWriteImageOpInterpCtx {
 public:
  SummaryWriteImageOpInterpCtxImpl() = default;
  SummaryWriteImageOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SummaryWriteImageOp {
 public:
  SummaryWriteImageOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SummaryWritePbOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SummaryWritePbOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SummaryWritePbOpInterpCtxImpl : public SummaryWritePbOpInterpCtx {
 public:
  SummaryWritePbOpInterpCtxImpl() = default;
  SummaryWritePbOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SummaryWritePbOp {
 public:
  SummaryWritePbOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class SummaryWriteScalarOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~SummaryWriteScalarOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class SummaryWriteScalarOpInterpCtxImpl : public SummaryWriteScalarOpInterpCtx {
 public:
  SummaryWriteScalarOpInterpCtxImpl() = default;
  SummaryWriteScalarOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SummaryWriteScalarOp {
 public:
  SummaryWriteScalarOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TanGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TanGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TanGradOpInterpCtxImpl : public TanGradOpInterpCtx {
 public:
  TanGradOpInterpCtxImpl() = default;
  TanGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TanGradOp {
 public:
  TanGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TanOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TanOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TanOpInterpCtxImpl : public TanOpInterpCtx {
 public:
  TanOpInterpCtxImpl() = default;
  TanOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TanOp {
 public:
  TanOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TanhGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TanhGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TanhGradOpInterpCtxImpl : public TanhGradOpInterpCtx {
 public:
  TanhGradOpInterpCtxImpl() = default;
  TanhGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TanhGradOp {
 public:
  TanhGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TanhOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TanhOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TanhOpInterpCtxImpl : public TanhOpInterpCtx {
 public:
  TanhOpInterpCtxImpl() = default;
  TanhOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TanhOp {
 public:
  TanhOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TensorBufferToListOfTensorsOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TensorBufferToListOfTensorsOpInterpCtx() = default;

  virtual const bool& dynamic_out() const = 0;
  virtual bool* mutable_dynamic_out() = 0;
  virtual void set_dynamic_out(const bool& dynamic_out) = 0;

  virtual const DataType& out_dtype() const = 0;
  virtual DataType* mutable_out_dtype() = 0;
  virtual void set_out_dtype(const DataType& out_dtype) = 0;

  virtual const Shape& out_shape() const = 0;
  virtual Shape* mutable_out_shape() = 0;
  virtual void set_out_shape(const Shape& out_shape) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TensorBufferToListOfTensorsOpInterpCtxImpl : public TensorBufferToListOfTensorsOpInterpCtx {
 public:
  TensorBufferToListOfTensorsOpInterpCtxImpl() = default;
  TensorBufferToListOfTensorsOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& dynamic_out() const { return impl_.dynamic_out(); }
  bool* mutable_dynamic_out() { return impl_.mutable_dynamic_out(); }
  void set_dynamic_out(const bool& dynamic_out) { impl_.set_dynamic_out(dynamic_out); }
  
  const DataType& out_dtype() const { return impl_.out_dtype(); }
  DataType* mutable_out_dtype() { return impl_.mutable_out_dtype(); }
  void set_out_dtype(const DataType& out_dtype) { impl_.set_out_dtype(out_dtype); }
  
  const Shape& out_shape() const { return impl_.out_shape(); }
  Shape* mutable_out_shape() { return impl_.mutable_out_shape(); }
  void set_out_shape(const Shape& out_shape) { impl_.set_out_shape(out_shape); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TensorBufferToListOfTensorsOp {
 public:
  TensorBufferToListOfTensorsOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& dynamic_out() const { return internal_->dynamic_out; }
  bool* mutable_dynamic_out() { return &internal_->dynamic_out; }
  void set_dynamic_out(const bool& dynamic_out) { internal_->dynamic_out = dynamic_out; }
  
  const DataType& out_dtype() const { return internal_->out_dtype; }
  DataType* mutable_out_dtype() { return &internal_->out_dtype; }
  void set_out_dtype(const DataType& out_dtype) { internal_->out_dtype = out_dtype; }
  
  const Shape& out_shape() const { return internal_->out_shape; }
  Shape* mutable_out_shape() { return &internal_->out_shape; }
  void set_out_shape(const Shape& out_shape) { internal_->out_shape = out_shape; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool dynamic_out = false;
    DataType out_dtype;
    Shape out_shape;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TensorBufferToListOfTensorsV2OpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TensorBufferToListOfTensorsV2OpInterpCtx() = default;

  virtual const bool& dynamic_out() const = 0;
  virtual bool* mutable_dynamic_out() = 0;
  virtual void set_dynamic_out(const bool& dynamic_out) = 0;

  virtual const std::vector<DataType>& out_dtypes() const = 0;
  virtual std::vector<DataType>* mutable_out_dtypes() = 0;
  virtual void set_out_dtypes(const std::vector<DataType>& out_dtypes) = 0;

  virtual const std::vector<Shape>& out_shapes() const = 0;
  virtual std::vector<Shape>* mutable_out_shapes() = 0;
  virtual void set_out_shapes(const std::vector<Shape>& out_shapes) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TensorBufferToListOfTensorsV2OpInterpCtxImpl : public TensorBufferToListOfTensorsV2OpInterpCtx {
 public:
  TensorBufferToListOfTensorsV2OpInterpCtxImpl() = default;
  TensorBufferToListOfTensorsV2OpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& dynamic_out() const { return impl_.dynamic_out(); }
  bool* mutable_dynamic_out() { return impl_.mutable_dynamic_out(); }
  void set_dynamic_out(const bool& dynamic_out) { impl_.set_dynamic_out(dynamic_out); }
  
  const std::vector<DataType>& out_dtypes() const { return impl_.out_dtypes(); }
  std::vector<DataType>* mutable_out_dtypes() { return impl_.mutable_out_dtypes(); }
  void set_out_dtypes(const std::vector<DataType>& out_dtypes) { impl_.set_out_dtypes(out_dtypes); }
  
  const std::vector<Shape>& out_shapes() const { return impl_.out_shapes(); }
  std::vector<Shape>* mutable_out_shapes() { return impl_.mutable_out_shapes(); }
  void set_out_shapes(const std::vector<Shape>& out_shapes) { impl_.set_out_shapes(out_shapes); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TensorBufferToListOfTensorsV2Op {
 public:
  TensorBufferToListOfTensorsV2Op() : internal_(std::make_shared<Internal>()) {}
  
  const bool& dynamic_out() const { return internal_->dynamic_out; }
  bool* mutable_dynamic_out() { return &internal_->dynamic_out; }
  void set_dynamic_out(const bool& dynamic_out) { internal_->dynamic_out = dynamic_out; }
  
  const std::vector<DataType>& out_dtypes() const { return internal_->out_dtypes; }
  std::vector<DataType>* mutable_out_dtypes() { return &internal_->out_dtypes; }
  void set_out_dtypes(const std::vector<DataType>& out_dtypes) { internal_->out_dtypes = out_dtypes; }
  
  const std::vector<Shape>& out_shapes() const { return internal_->out_shapes; }
  std::vector<Shape>* mutable_out_shapes() { return &internal_->out_shapes; }
  void set_out_shapes(const std::vector<Shape>& out_shapes) { internal_->out_shapes = out_shapes; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool dynamic_out = false;
    std::vector<DataType> out_dtypes;
    std::vector<Shape> out_shapes;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TensorBufferToTensorOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TensorBufferToTensorOpInterpCtx() = default;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const Shape& instance_shape() const = 0;
  virtual Shape* mutable_instance_shape() = 0;
  virtual void set_instance_shape(const Shape& instance_shape) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TensorBufferToTensorOpInterpCtxImpl : public TensorBufferToTensorOpInterpCtx {
 public:
  TensorBufferToTensorOpInterpCtxImpl() = default;
  TensorBufferToTensorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const DataType& dtype() const { return impl_.dtype(); }
  DataType* mutable_dtype() { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) { impl_.set_dtype(dtype); }
  
  const Shape& instance_shape() const { return impl_.instance_shape(); }
  Shape* mutable_instance_shape() { return impl_.mutable_instance_shape(); }
  void set_instance_shape(const Shape& instance_shape) { impl_.set_instance_shape(instance_shape); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TensorBufferToTensorOp {
 public:
  TensorBufferToTensorOp() : internal_(std::make_shared<Internal>()) {}
  
  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }
  
  const Shape& instance_shape() const { return internal_->instance_shape; }
  Shape* mutable_instance_shape() { return &internal_->instance_shape; }
  void set_instance_shape(const Shape& instance_shape) { internal_->instance_shape = instance_shape; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    DataType dtype;
    Shape instance_shape;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TensorScatterNdAddOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TensorScatterNdAddOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TensorScatterNdAddOpInterpCtxImpl : public TensorScatterNdAddOpInterpCtx {
 public:
  TensorScatterNdAddOpInterpCtxImpl() = default;
  TensorScatterNdAddOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TensorScatterNdAddOp {
 public:
  TensorScatterNdAddOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TensorScatterNdUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TensorScatterNdUpdateOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TensorScatterNdUpdateOpInterpCtxImpl : public TensorScatterNdUpdateOpInterpCtx {
 public:
  TensorScatterNdUpdateOpInterpCtxImpl() = default;
  TensorScatterNdUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TensorScatterNdUpdateOp {
 public:
  TensorScatterNdUpdateOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TensorToTensorBufferOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TensorToTensorBufferOpInterpCtx() = default;

  virtual const int32_t& instance_dims() const = 0;
  virtual int32_t* mutable_instance_dims() = 0;
  virtual void set_instance_dims(const int32_t& instance_dims) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TensorToTensorBufferOpInterpCtxImpl : public TensorToTensorBufferOpInterpCtx {
 public:
  TensorToTensorBufferOpInterpCtxImpl() = default;
  TensorToTensorBufferOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& instance_dims() const { return impl_.instance_dims(); }
  int32_t* mutable_instance_dims() { return impl_.mutable_instance_dims(); }
  void set_instance_dims(const int32_t& instance_dims) { impl_.set_instance_dims(instance_dims); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TensorToTensorBufferOp {
 public:
  TensorToTensorBufferOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& instance_dims() const { return internal_->instance_dims; }
  int32_t* mutable_instance_dims() { return &internal_->instance_dims; }
  void set_instance_dims(const int32_t& instance_dims) { internal_->instance_dims = instance_dims; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t instance_dims = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TestDataTypeAttrOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TestDataTypeAttrOpInterpCtx() = default;

  virtual const DataType& output_type() const = 0;
  virtual DataType* mutable_output_type() = 0;
  virtual void set_output_type(const DataType& output_type) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TestDataTypeAttrOpInterpCtxImpl : public TestDataTypeAttrOpInterpCtx {
 public:
  TestDataTypeAttrOpInterpCtxImpl() = default;
  TestDataTypeAttrOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const DataType& output_type() const { return impl_.output_type(); }
  DataType* mutable_output_type() { return impl_.mutable_output_type(); }
  void set_output_type(const DataType& output_type) { impl_.set_output_type(output_type); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestDataTypeAttrOp {
 public:
  TestDataTypeAttrOp() : internal_(std::make_shared<Internal>()) {}
  
  const DataType& output_type() const { return internal_->output_type; }
  DataType* mutable_output_type() { return &internal_->output_type; }
  void set_output_type(const DataType& output_type) { internal_->output_type = output_type; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    DataType output_type;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TestDynamicSourceOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TestDynamicSourceOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TestDynamicSourceOpInterpCtxImpl : public TestDynamicSourceOpInterpCtx {
 public:
  TestDynamicSourceOpInterpCtxImpl() = default;
  TestDynamicSourceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestDynamicSourceOp {
 public:
  TestDynamicSourceOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TestListDataTypeAndListShapeAndListStringAttrOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TestListDataTypeAndListShapeAndListStringAttrOpInterpCtx() = default;

  virtual const std::vector<Shape>& out_shapes() const = 0;
  virtual std::vector<Shape>* mutable_out_shapes() = 0;
  virtual void set_out_shapes(const std::vector<Shape>& out_shapes) = 0;

  virtual const std::vector<DataType>& out_types() const = 0;
  virtual std::vector<DataType>* mutable_out_types() = 0;
  virtual void set_out_types(const std::vector<DataType>& out_types) = 0;

  virtual const std::vector<std::string>& string_list() const = 0;
  virtual std::vector<std::string>* mutable_string_list() = 0;
  virtual void set_string_list(const std::vector<std::string>& string_list) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TestListDataTypeAndListShapeAndListStringAttrOpInterpCtxImpl : public TestListDataTypeAndListShapeAndListStringAttrOpInterpCtx {
 public:
  TestListDataTypeAndListShapeAndListStringAttrOpInterpCtxImpl() = default;
  TestListDataTypeAndListShapeAndListStringAttrOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<Shape>& out_shapes() const { return impl_.out_shapes(); }
  std::vector<Shape>* mutable_out_shapes() { return impl_.mutable_out_shapes(); }
  void set_out_shapes(const std::vector<Shape>& out_shapes) { impl_.set_out_shapes(out_shapes); }
  
  const std::vector<DataType>& out_types() const { return impl_.out_types(); }
  std::vector<DataType>* mutable_out_types() { return impl_.mutable_out_types(); }
  void set_out_types(const std::vector<DataType>& out_types) { impl_.set_out_types(out_types); }
  
  const std::vector<std::string>& string_list() const { return impl_.string_list(); }
  std::vector<std::string>* mutable_string_list() { return impl_.mutable_string_list(); }
  void set_string_list(const std::vector<std::string>& string_list) { impl_.set_string_list(string_list); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestListDataTypeAndListShapeAndListStringAttrOp {
 public:
  TestListDataTypeAndListShapeAndListStringAttrOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<Shape>& out_shapes() const { return internal_->out_shapes; }
  std::vector<Shape>* mutable_out_shapes() { return &internal_->out_shapes; }
  void set_out_shapes(const std::vector<Shape>& out_shapes) { internal_->out_shapes = out_shapes; }
  
  const std::vector<DataType>& out_types() const { return internal_->out_types; }
  std::vector<DataType>* mutable_out_types() { return &internal_->out_types; }
  void set_out_types(const std::vector<DataType>& out_types) { internal_->out_types = out_types; }
  
  const std::vector<std::string>& string_list() const { return internal_->string_list; }
  std::vector<std::string>* mutable_string_list() { return &internal_->string_list; }
  void set_string_list(const std::vector<std::string>& string_list) { internal_->string_list = string_list; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<Shape> out_shapes;
    std::vector<DataType> out_types;
    std::vector<std::string> string_list;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TestMultiInputGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TestMultiInputGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TestMultiInputGradOpInterpCtxImpl : public TestMultiInputGradOpInterpCtx {
 public:
  TestMultiInputGradOpInterpCtxImpl() = default;
  TestMultiInputGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestMultiInputGradOp {
 public:
  TestMultiInputGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TestMultiInputOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TestMultiInputOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TestMultiInputOpInterpCtxImpl : public TestMultiInputOpInterpCtx {
 public:
  TestMultiInputOpInterpCtxImpl() = default;
  TestMultiInputOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestMultiInputOp {
 public:
  TestMultiInputOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TestMultiOutputOrderOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TestMultiOutputOrderOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TestMultiOutputOrderOpInterpCtxImpl : public TestMultiOutputOrderOpInterpCtx {
 public:
  TestMultiOutputOrderOpInterpCtxImpl() = default;
  TestMultiOutputOrderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestMultiOutputOrderOp {
 public:
  TestMultiOutputOrderOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TestRandomSourceOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TestRandomSourceOpInterpCtx() = default;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TestRandomSourceOpInterpCtxImpl : public TestRandomSourceOpInterpCtx {
 public:
  TestRandomSourceOpInterpCtxImpl() = default;
  TestRandomSourceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& seed() const { return impl_.seed(); }
  int64_t* mutable_seed() { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) { impl_.set_seed(seed); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestRandomSourceOp {
 public:
  TestRandomSourceOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t seed = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TestReshapeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TestReshapeOpInterpCtx() = default;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TestReshapeOpInterpCtxImpl : public TestReshapeOpInterpCtx {
 public:
  TestReshapeOpInterpCtxImpl() = default;
  TestReshapeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestReshapeOp {
 public:
  TestReshapeOp() : internal_(std::make_shared<Internal>()) {}
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    Shape shape;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TestSourceMultiGpuFixedOutNumOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TestSourceMultiGpuFixedOutNumOpInterpCtx() = default;

  virtual const int64_t& out_num() const = 0;
  virtual int64_t* mutable_out_num() = 0;
  virtual void set_out_num(const int64_t& out_num) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TestSourceMultiGpuFixedOutNumOpInterpCtxImpl : public TestSourceMultiGpuFixedOutNumOpInterpCtx {
 public:
  TestSourceMultiGpuFixedOutNumOpInterpCtxImpl() = default;
  TestSourceMultiGpuFixedOutNumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& out_num() const { return impl_.out_num(); }
  int64_t* mutable_out_num() { return impl_.mutable_out_num(); }
  void set_out_num(const int64_t& out_num) { impl_.set_out_num(out_num); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestSourceMultiGpuFixedOutNumOp {
 public:
  TestSourceMultiGpuFixedOutNumOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& out_num() const { return internal_->out_num; }
  int64_t* mutable_out_num() { return &internal_->out_num; }
  void set_out_num(const int64_t& out_num) { internal_->out_num = out_num; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t out_num = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TestSourceOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TestSourceOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TestSourceOpInterpCtxImpl : public TestSourceOpInterpCtx {
 public:
  TestSourceOpInterpCtxImpl() = default;
  TestSourceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestSourceOp {
 public:
  TestSourceOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TestUserOpAttrAutoTypeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TestUserOpAttrAutoTypeOpInterpCtx() = default;

  virtual const int32_t& int1() const = 0;
  virtual int32_t* mutable_int1() = 0;
  virtual void set_int1(const int32_t& int1) = 0;

  virtual const int32_t& int2() const = 0;
  virtual int32_t* mutable_int2() = 0;
  virtual void set_int2(const int32_t& int2) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TestUserOpAttrAutoTypeOpInterpCtxImpl : public TestUserOpAttrAutoTypeOpInterpCtx {
 public:
  TestUserOpAttrAutoTypeOpInterpCtxImpl() = default;
  TestUserOpAttrAutoTypeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& int1() const { return impl_.int1(); }
  int32_t* mutable_int1() { return impl_.mutable_int1(); }
  void set_int1(const int32_t& int1) { impl_.set_int1(int1); }
  
  const int32_t& int2() const { return impl_.int2(); }
  int32_t* mutable_int2() { return impl_.mutable_int2(); }
  void set_int2(const int32_t& int2) { impl_.set_int2(int2); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestUserOpAttrAutoTypeOp {
 public:
  TestUserOpAttrAutoTypeOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& int1() const { return internal_->int1; }
  int32_t* mutable_int1() { return &internal_->int1; }
  void set_int1(const int32_t& int1) { internal_->int1 = int1; }
  
  const int32_t& int2() const { return internal_->int2; }
  int32_t* mutable_int2() { return &internal_->int2; }
  void set_int2(const int32_t& int2) { internal_->int2 = int2; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t int1 = 0;
    int32_t int2 = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TfAvgPool1DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TfAvgPool1DGradOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<std::int32_t>& padding_after() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<std::int32_t>& padding_after) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& pool_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<std::int32_t>& pool_size) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TfAvgPool1DGradOpInterpCtxImpl : public TfAvgPool1DGradOpInterpCtx {
 public:
  TfAvgPool1DGradOpInterpCtxImpl() = default;
  TfAvgPool1DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::string& padding() const { return impl_.padding(); }
  std::string* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& padding_after() const { return impl_.padding_after(); }
  std::vector<std::int32_t>* mutable_padding_after() { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { impl_.set_padding_after(padding_after); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& pool_size() const { return impl_.pool_size(); }
  std::vector<std::int32_t>* mutable_pool_size() { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { impl_.set_pool_size(pool_size); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfAvgPool1DGradOp {
 public:
  TfAvgPool1DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<std::int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { internal_->padding_after = padding_after; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<std::int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { internal_->pool_size = pool_size; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    std::string data_format;
    std::string padding;
    std::vector<std::int32_t> padding_after;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> pool_size;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TfAvgPool1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TfAvgPool1DOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<std::int32_t>& padding_after() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<std::int32_t>& padding_after) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& pool_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<std::int32_t>& pool_size) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TfAvgPool1DOpInterpCtxImpl : public TfAvgPool1DOpInterpCtx {
 public:
  TfAvgPool1DOpInterpCtxImpl() = default;
  TfAvgPool1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::string& padding() const { return impl_.padding(); }
  std::string* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& padding_after() const { return impl_.padding_after(); }
  std::vector<std::int32_t>* mutable_padding_after() { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { impl_.set_padding_after(padding_after); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& pool_size() const { return impl_.pool_size(); }
  std::vector<std::int32_t>* mutable_pool_size() { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { impl_.set_pool_size(pool_size); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfAvgPool1DOp {
 public:
  TfAvgPool1DOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<std::int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { internal_->padding_after = padding_after; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<std::int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { internal_->pool_size = pool_size; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    std::string data_format;
    std::string padding;
    std::vector<std::int32_t> padding_after;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> pool_size;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TfAvgPool2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TfAvgPool2DGradOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<std::int32_t>& padding_after() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<std::int32_t>& padding_after) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& pool_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<std::int32_t>& pool_size) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TfAvgPool2DGradOpInterpCtxImpl : public TfAvgPool2DGradOpInterpCtx {
 public:
  TfAvgPool2DGradOpInterpCtxImpl() = default;
  TfAvgPool2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::string& padding() const { return impl_.padding(); }
  std::string* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& padding_after() const { return impl_.padding_after(); }
  std::vector<std::int32_t>* mutable_padding_after() { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { impl_.set_padding_after(padding_after); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& pool_size() const { return impl_.pool_size(); }
  std::vector<std::int32_t>* mutable_pool_size() { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { impl_.set_pool_size(pool_size); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfAvgPool2DGradOp {
 public:
  TfAvgPool2DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<std::int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { internal_->padding_after = padding_after; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<std::int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { internal_->pool_size = pool_size; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    std::string data_format;
    std::string padding;
    std::vector<std::int32_t> padding_after;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> pool_size;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TfAvgPool2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TfAvgPool2DOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<std::int32_t>& padding_after() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<std::int32_t>& padding_after) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& pool_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<std::int32_t>& pool_size) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TfAvgPool2DOpInterpCtxImpl : public TfAvgPool2DOpInterpCtx {
 public:
  TfAvgPool2DOpInterpCtxImpl() = default;
  TfAvgPool2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::string& padding() const { return impl_.padding(); }
  std::string* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& padding_after() const { return impl_.padding_after(); }
  std::vector<std::int32_t>* mutable_padding_after() { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { impl_.set_padding_after(padding_after); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& pool_size() const { return impl_.pool_size(); }
  std::vector<std::int32_t>* mutable_pool_size() { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { impl_.set_pool_size(pool_size); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfAvgPool2DOp {
 public:
  TfAvgPool2DOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<std::int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { internal_->padding_after = padding_after; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<std::int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { internal_->pool_size = pool_size; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    std::string data_format;
    std::string padding;
    std::vector<std::int32_t> padding_after;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> pool_size;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TfAvgPool3DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TfAvgPool3DGradOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<std::int32_t>& padding_after() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<std::int32_t>& padding_after) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& pool_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<std::int32_t>& pool_size) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TfAvgPool3DGradOpInterpCtxImpl : public TfAvgPool3DGradOpInterpCtx {
 public:
  TfAvgPool3DGradOpInterpCtxImpl() = default;
  TfAvgPool3DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::string& padding() const { return impl_.padding(); }
  std::string* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& padding_after() const { return impl_.padding_after(); }
  std::vector<std::int32_t>* mutable_padding_after() { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { impl_.set_padding_after(padding_after); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& pool_size() const { return impl_.pool_size(); }
  std::vector<std::int32_t>* mutable_pool_size() { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { impl_.set_pool_size(pool_size); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfAvgPool3DGradOp {
 public:
  TfAvgPool3DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<std::int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { internal_->padding_after = padding_after; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<std::int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { internal_->pool_size = pool_size; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    std::string data_format;
    std::string padding;
    std::vector<std::int32_t> padding_after;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> pool_size;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TfAvgPool3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TfAvgPool3DOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<std::int32_t>& padding_after() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<std::int32_t>& padding_after) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& pool_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<std::int32_t>& pool_size) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TfAvgPool3DOpInterpCtxImpl : public TfAvgPool3DOpInterpCtx {
 public:
  TfAvgPool3DOpInterpCtxImpl() = default;
  TfAvgPool3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::string& padding() const { return impl_.padding(); }
  std::string* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& padding_after() const { return impl_.padding_after(); }
  std::vector<std::int32_t>* mutable_padding_after() { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { impl_.set_padding_after(padding_after); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& pool_size() const { return impl_.pool_size(); }
  std::vector<std::int32_t>* mutable_pool_size() { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { impl_.set_pool_size(pool_size); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfAvgPool3DOp {
 public:
  TfAvgPool3DOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<std::int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { internal_->padding_after = padding_after; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<std::int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { internal_->pool_size = pool_size; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    std::string data_format;
    std::string padding;
    std::vector<std::int32_t> padding_after;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> pool_size;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TfMaxPool1DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TfMaxPool1DGradOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<std::int32_t>& padding_after() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<std::int32_t>& padding_after) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& pool_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<std::int32_t>& pool_size) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TfMaxPool1DGradOpInterpCtxImpl : public TfMaxPool1DGradOpInterpCtx {
 public:
  TfMaxPool1DGradOpInterpCtxImpl() = default;
  TfMaxPool1DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::string& padding() const { return impl_.padding(); }
  std::string* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& padding_after() const { return impl_.padding_after(); }
  std::vector<std::int32_t>* mutable_padding_after() { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { impl_.set_padding_after(padding_after); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& pool_size() const { return impl_.pool_size(); }
  std::vector<std::int32_t>* mutable_pool_size() { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { impl_.set_pool_size(pool_size); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfMaxPool1DGradOp {
 public:
  TfMaxPool1DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<std::int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { internal_->padding_after = padding_after; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<std::int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { internal_->pool_size = pool_size; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    std::string data_format;
    std::string padding;
    std::vector<std::int32_t> padding_after;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> pool_size;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TfMaxPool1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TfMaxPool1DOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<std::int32_t>& padding_after() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<std::int32_t>& padding_after) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& pool_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<std::int32_t>& pool_size) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TfMaxPool1DOpInterpCtxImpl : public TfMaxPool1DOpInterpCtx {
 public:
  TfMaxPool1DOpInterpCtxImpl() = default;
  TfMaxPool1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::string& padding() const { return impl_.padding(); }
  std::string* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& padding_after() const { return impl_.padding_after(); }
  std::vector<std::int32_t>* mutable_padding_after() { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { impl_.set_padding_after(padding_after); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& pool_size() const { return impl_.pool_size(); }
  std::vector<std::int32_t>* mutable_pool_size() { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { impl_.set_pool_size(pool_size); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfMaxPool1DOp {
 public:
  TfMaxPool1DOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<std::int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { internal_->padding_after = padding_after; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<std::int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { internal_->pool_size = pool_size; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    std::string data_format;
    std::string padding;
    std::vector<std::int32_t> padding_after;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> pool_size;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TfMaxPool2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TfMaxPool2DGradOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<std::int32_t>& padding_after() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<std::int32_t>& padding_after) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& pool_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<std::int32_t>& pool_size) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TfMaxPool2DGradOpInterpCtxImpl : public TfMaxPool2DGradOpInterpCtx {
 public:
  TfMaxPool2DGradOpInterpCtxImpl() = default;
  TfMaxPool2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::string& padding() const { return impl_.padding(); }
  std::string* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& padding_after() const { return impl_.padding_after(); }
  std::vector<std::int32_t>* mutable_padding_after() { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { impl_.set_padding_after(padding_after); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& pool_size() const { return impl_.pool_size(); }
  std::vector<std::int32_t>* mutable_pool_size() { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { impl_.set_pool_size(pool_size); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfMaxPool2DGradOp {
 public:
  TfMaxPool2DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<std::int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { internal_->padding_after = padding_after; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<std::int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { internal_->pool_size = pool_size; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    std::string data_format;
    std::string padding;
    std::vector<std::int32_t> padding_after;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> pool_size;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TfMaxPool2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TfMaxPool2DOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<std::int32_t>& padding_after() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<std::int32_t>& padding_after) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& pool_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<std::int32_t>& pool_size) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TfMaxPool2DOpInterpCtxImpl : public TfMaxPool2DOpInterpCtx {
 public:
  TfMaxPool2DOpInterpCtxImpl() = default;
  TfMaxPool2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::string& padding() const { return impl_.padding(); }
  std::string* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& padding_after() const { return impl_.padding_after(); }
  std::vector<std::int32_t>* mutable_padding_after() { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { impl_.set_padding_after(padding_after); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& pool_size() const { return impl_.pool_size(); }
  std::vector<std::int32_t>* mutable_pool_size() { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { impl_.set_pool_size(pool_size); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfMaxPool2DOp {
 public:
  TfMaxPool2DOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<std::int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { internal_->padding_after = padding_after; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<std::int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { internal_->pool_size = pool_size; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    std::string data_format;
    std::string padding;
    std::vector<std::int32_t> padding_after;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> pool_size;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TfMaxPool3DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TfMaxPool3DGradOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<std::int32_t>& padding_after() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<std::int32_t>& padding_after) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& pool_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<std::int32_t>& pool_size) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TfMaxPool3DGradOpInterpCtxImpl : public TfMaxPool3DGradOpInterpCtx {
 public:
  TfMaxPool3DGradOpInterpCtxImpl() = default;
  TfMaxPool3DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::string& padding() const { return impl_.padding(); }
  std::string* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& padding_after() const { return impl_.padding_after(); }
  std::vector<std::int32_t>* mutable_padding_after() { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { impl_.set_padding_after(padding_after); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& pool_size() const { return impl_.pool_size(); }
  std::vector<std::int32_t>* mutable_pool_size() { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { impl_.set_pool_size(pool_size); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfMaxPool3DGradOp {
 public:
  TfMaxPool3DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<std::int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { internal_->padding_after = padding_after; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<std::int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { internal_->pool_size = pool_size; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    std::string data_format;
    std::string padding;
    std::vector<std::int32_t> padding_after;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> pool_size;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TfMaxPool3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TfMaxPool3DOpInterpCtx() = default;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<std::int32_t>& padding_after() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<std::int32_t>& padding_after) = 0;

  virtual const std::vector<std::int32_t>& padding_before() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<std::int32_t>& padding_before) = 0;

  virtual const std::vector<std::int32_t>& pool_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<std::int32_t>& pool_size) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TfMaxPool3DOpInterpCtxImpl : public TfMaxPool3DOpInterpCtx {
 public:
  TfMaxPool3DOpInterpCtxImpl() = default;
  TfMaxPool3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& ceil_mode() const { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) { impl_.set_ceil_mode(ceil_mode); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::string& padding() const { return impl_.padding(); }
  std::string* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& padding_after() const { return impl_.padding_after(); }
  std::vector<std::int32_t>* mutable_padding_after() { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { impl_.set_padding_after(padding_after); }
  
  const std::vector<std::int32_t>& padding_before() const { return impl_.padding_before(); }
  std::vector<std::int32_t>* mutable_padding_before() { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { impl_.set_padding_before(padding_before); }
  
  const std::vector<std::int32_t>& pool_size() const { return impl_.pool_size(); }
  std::vector<std::int32_t>* mutable_pool_size() { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { impl_.set_pool_size(pool_size); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfMaxPool3DOp {
 public:
  TfMaxPool3DOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<std::int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<std::int32_t>& padding_after) { internal_->padding_after = padding_after; }
  
  const std::vector<std::int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<std::int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<std::int32_t>& padding_before) { internal_->padding_before = padding_before; }
  
  const std::vector<std::int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<std::int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<std::int32_t>& pool_size) { internal_->pool_size = pool_size; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool ceil_mode;
    std::string data_format;
    std::string padding;
    std::vector<std::int32_t> padding_after;
    std::vector<std::int32_t> padding_before;
    std::vector<std::int32_t> pool_size;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TfPreluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TfPreluGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TfPreluGradOpInterpCtxImpl : public TfPreluGradOpInterpCtx {
 public:
  TfPreluGradOpInterpCtxImpl() = default;
  TfPreluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfPreluGradOp {
 public:
  TfPreluGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TfPreluOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TfPreluOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TfPreluOpInterpCtxImpl : public TfPreluOpInterpCtx {
 public:
  TfPreluOpInterpCtxImpl() = default;
  TfPreluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfPreluOp {
 public:
  TfPreluOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TopKOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TopKOpInterpCtx() = default;

  virtual const int32_t& k() const = 0;
  virtual int32_t* mutable_k() = 0;
  virtual void set_k(const int32_t& k) = 0;

  virtual const bool& sorted() const = 0;
  virtual bool* mutable_sorted() = 0;
  virtual void set_sorted(const bool& sorted) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TopKOpInterpCtxImpl : public TopKOpInterpCtx {
 public:
  TopKOpInterpCtxImpl() = default;
  TopKOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& k() const { return impl_.k(); }
  int32_t* mutable_k() { return impl_.mutable_k(); }
  void set_k(const int32_t& k) { impl_.set_k(k); }
  
  const bool& sorted() const { return impl_.sorted(); }
  bool* mutable_sorted() { return impl_.mutable_sorted(); }
  void set_sorted(const bool& sorted) { impl_.set_sorted(sorted); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TopKOp {
 public:
  TopKOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& k() const { return internal_->k; }
  int32_t* mutable_k() { return &internal_->k; }
  void set_k(const int32_t& k) { internal_->k = k; }
  
  const bool& sorted() const { return internal_->sorted; }
  bool* mutable_sorted() { return &internal_->sorted; }
  void set_sorted(const bool& sorted) { internal_->sorted = sorted; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t k = 0;
    bool sorted = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TransposeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TransposeOpInterpCtx() = default;

  virtual const std::vector<std::int32_t>& perm() const = 0;
  virtual std::vector<std::int32_t>* mutable_perm() = 0;
  virtual void set_perm(const std::vector<std::int32_t>& perm) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TransposeOpInterpCtxImpl : public TransposeOpInterpCtx {
 public:
  TransposeOpInterpCtxImpl() = default;
  TransposeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::vector<std::int32_t>& perm() const { return impl_.perm(); }
  std::vector<std::int32_t>* mutable_perm() { return impl_.mutable_perm(); }
  void set_perm(const std::vector<std::int32_t>& perm) { impl_.set_perm(perm); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TransposeOp {
 public:
  TransposeOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::vector<std::int32_t>& perm() const { return internal_->perm; }
  std::vector<std::int32_t>* mutable_perm() { return &internal_->perm; }
  void set_perm(const std::vector<std::int32_t>& perm) { internal_->perm = perm; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::vector<std::int32_t> perm;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TrilOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TrilOpInterpCtx() = default;

  virtual const int64_t& diagonal() const = 0;
  virtual int64_t* mutable_diagonal() = 0;
  virtual void set_diagonal(const int64_t& diagonal) = 0;

  virtual const double& floating_fill_value() const = 0;
  virtual double* mutable_floating_fill_value() = 0;
  virtual void set_floating_fill_value(const double& floating_fill_value) = 0;

  virtual const int64_t& integer_fill_value() const = 0;
  virtual int64_t* mutable_integer_fill_value() = 0;
  virtual void set_integer_fill_value(const int64_t& integer_fill_value) = 0;

  virtual const bool& is_floating_fill_value() const = 0;
  virtual bool* mutable_is_floating_fill_value() = 0;
  virtual void set_is_floating_fill_value(const bool& is_floating_fill_value) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TrilOpInterpCtxImpl : public TrilOpInterpCtx {
 public:
  TrilOpInterpCtxImpl() = default;
  TrilOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& diagonal() const { return impl_.diagonal(); }
  int64_t* mutable_diagonal() { return impl_.mutable_diagonal(); }
  void set_diagonal(const int64_t& diagonal) { impl_.set_diagonal(diagonal); }
  
  const double& floating_fill_value() const { return impl_.floating_fill_value(); }
  double* mutable_floating_fill_value() { return impl_.mutable_floating_fill_value(); }
  void set_floating_fill_value(const double& floating_fill_value) { impl_.set_floating_fill_value(floating_fill_value); }
  
  const int64_t& integer_fill_value() const { return impl_.integer_fill_value(); }
  int64_t* mutable_integer_fill_value() { return impl_.mutable_integer_fill_value(); }
  void set_integer_fill_value(const int64_t& integer_fill_value) { impl_.set_integer_fill_value(integer_fill_value); }
  
  const bool& is_floating_fill_value() const { return impl_.is_floating_fill_value(); }
  bool* mutable_is_floating_fill_value() { return impl_.mutable_is_floating_fill_value(); }
  void set_is_floating_fill_value(const bool& is_floating_fill_value) { impl_.set_is_floating_fill_value(is_floating_fill_value); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TrilOp {
 public:
  TrilOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& diagonal() const { return internal_->diagonal; }
  int64_t* mutable_diagonal() { return &internal_->diagonal; }
  void set_diagonal(const int64_t& diagonal) { internal_->diagonal = diagonal; }
  
  const double& floating_fill_value() const { return internal_->floating_fill_value; }
  double* mutable_floating_fill_value() { return &internal_->floating_fill_value; }
  void set_floating_fill_value(const double& floating_fill_value) { internal_->floating_fill_value = floating_fill_value; }
  
  const int64_t& integer_fill_value() const { return internal_->integer_fill_value; }
  int64_t* mutable_integer_fill_value() { return &internal_->integer_fill_value; }
  void set_integer_fill_value(const int64_t& integer_fill_value) { internal_->integer_fill_value = integer_fill_value; }
  
  const bool& is_floating_fill_value() const { return internal_->is_floating_fill_value; }
  bool* mutable_is_floating_fill_value() { return &internal_->is_floating_fill_value; }
  void set_is_floating_fill_value(const bool& is_floating_fill_value) { internal_->is_floating_fill_value = is_floating_fill_value; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t diagonal = 0;
    double floating_fill_value = 0.;
    int64_t integer_fill_value = 0;
    bool is_floating_fill_value = false;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TriuOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TriuOpInterpCtx() = default;

  virtual const int64_t& diagonal() const = 0;
  virtual int64_t* mutable_diagonal() = 0;
  virtual void set_diagonal(const int64_t& diagonal) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TriuOpInterpCtxImpl : public TriuOpInterpCtx {
 public:
  TriuOpInterpCtxImpl() = default;
  TriuOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& diagonal() const { return impl_.diagonal(); }
  int64_t* mutable_diagonal() { return impl_.mutable_diagonal(); }
  void set_diagonal(const int64_t& diagonal) { impl_.set_diagonal(diagonal); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TriuOp {
 public:
  TriuOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& diagonal() const { return internal_->diagonal; }
  int64_t* mutable_diagonal() { return &internal_->diagonal; }
  void set_diagonal(const int64_t& diagonal) { internal_->diagonal = diagonal; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t diagonal = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class TupleIdentityOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~TupleIdentityOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class TupleIdentityOpInterpCtxImpl : public TupleIdentityOpInterpCtx {
 public:
  TupleIdentityOpInterpCtxImpl() = default;
  TupleIdentityOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TupleIdentityOp {
 public:
  TupleIdentityOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UnfoldOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UnfoldOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<std::int32_t>& dilation_rate() const = 0;
  virtual std::vector<std::int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) = 0;

  virtual const std::vector<std::int32_t>& kernel_size() const = 0;
  virtual std::vector<std::int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<std::int32_t>& kernel_size) = 0;

  virtual const std::vector<std::int32_t>& padding() const = 0;
  virtual std::vector<std::int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<std::int32_t>& padding) = 0;

  virtual const std::vector<std::int32_t>& strides() const = 0;
  virtual std::vector<std::int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<std::int32_t>& strides) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UnfoldOpInterpCtxImpl : public UnfoldOpInterpCtx {
 public:
  UnfoldOpInterpCtxImpl() = default;
  UnfoldOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const std::vector<std::int32_t>& dilation_rate() const { return impl_.dilation_rate(); }
  std::vector<std::int32_t>* mutable_dilation_rate() { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { impl_.set_dilation_rate(dilation_rate); }
  
  const std::vector<std::int32_t>& kernel_size() const { return impl_.kernel_size(); }
  std::vector<std::int32_t>* mutable_kernel_size() { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { impl_.set_kernel_size(kernel_size); }
  
  const std::vector<std::int32_t>& padding() const { return impl_.padding(); }
  std::vector<std::int32_t>* mutable_padding() { return impl_.mutable_padding(); }
  void set_padding(const std::vector<std::int32_t>& padding) { impl_.set_padding(padding); }
  
  const std::vector<std::int32_t>& strides() const { return impl_.strides(); }
  std::vector<std::int32_t>* mutable_strides() { return impl_.mutable_strides(); }
  void set_strides(const std::vector<std::int32_t>& strides) { impl_.set_strides(strides); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UnfoldOp {
 public:
  UnfoldOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const std::vector<std::int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<std::int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<std::int32_t>& dilation_rate) { internal_->dilation_rate = dilation_rate; }
  
  const std::vector<std::int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<std::int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<std::int32_t>& kernel_size) { internal_->kernel_size = kernel_size; }
  
  const std::vector<std::int32_t>& padding() const { return internal_->padding; }
  std::vector<std::int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<std::int32_t>& padding) { internal_->padding = padding; }
  
  const std::vector<std::int32_t>& strides() const { return internal_->strides; }
  std::vector<std::int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<std::int32_t>& strides) { internal_->strides = strides; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    std::vector<std::int32_t> dilation_rate;
    std::vector<std::int32_t> kernel_size;
    std::vector<std::int32_t> padding;
    std::vector<std::int32_t> strides;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UnfoldTensorGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UnfoldTensorGradOpInterpCtx() = default;

  virtual const int32_t& dimension() const = 0;
  virtual int32_t* mutable_dimension() = 0;
  virtual void set_dimension(const int32_t& dimension) = 0;

  virtual const int32_t& size() const = 0;
  virtual int32_t* mutable_size() = 0;
  virtual void set_size(const int32_t& size) = 0;

  virtual const int32_t& step() const = 0;
  virtual int32_t* mutable_step() = 0;
  virtual void set_step(const int32_t& step) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UnfoldTensorGradOpInterpCtxImpl : public UnfoldTensorGradOpInterpCtx {
 public:
  UnfoldTensorGradOpInterpCtxImpl() = default;
  UnfoldTensorGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& dimension() const { return impl_.dimension(); }
  int32_t* mutable_dimension() { return impl_.mutable_dimension(); }
  void set_dimension(const int32_t& dimension) { impl_.set_dimension(dimension); }
  
  const int32_t& size() const { return impl_.size(); }
  int32_t* mutable_size() { return impl_.mutable_size(); }
  void set_size(const int32_t& size) { impl_.set_size(size); }
  
  const int32_t& step() const { return impl_.step(); }
  int32_t* mutable_step() { return impl_.mutable_step(); }
  void set_step(const int32_t& step) { impl_.set_step(step); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UnfoldTensorGradOp {
 public:
  UnfoldTensorGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& dimension() const { return internal_->dimension; }
  int32_t* mutable_dimension() { return &internal_->dimension; }
  void set_dimension(const int32_t& dimension) { internal_->dimension = dimension; }
  
  const int32_t& size() const { return internal_->size; }
  int32_t* mutable_size() { return &internal_->size; }
  void set_size(const int32_t& size) { internal_->size = size; }
  
  const int32_t& step() const { return internal_->step; }
  int32_t* mutable_step() { return &internal_->step; }
  void set_step(const int32_t& step) { internal_->step = step; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t dimension = 0;
    int32_t size = 0;
    int32_t step = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UnfoldTensorOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UnfoldTensorOpInterpCtx() = default;

  virtual const int32_t& dimension() const = 0;
  virtual int32_t* mutable_dimension() = 0;
  virtual void set_dimension(const int32_t& dimension) = 0;

  virtual const int32_t& size() const = 0;
  virtual int32_t* mutable_size() = 0;
  virtual void set_size(const int32_t& size) = 0;

  virtual const int32_t& step() const = 0;
  virtual int32_t* mutable_step() = 0;
  virtual void set_step(const int32_t& step) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UnfoldTensorOpInterpCtxImpl : public UnfoldTensorOpInterpCtx {
 public:
  UnfoldTensorOpInterpCtxImpl() = default;
  UnfoldTensorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& dimension() const { return impl_.dimension(); }
  int32_t* mutable_dimension() { return impl_.mutable_dimension(); }
  void set_dimension(const int32_t& dimension) { impl_.set_dimension(dimension); }
  
  const int32_t& size() const { return impl_.size(); }
  int32_t* mutable_size() { return impl_.mutable_size(); }
  void set_size(const int32_t& size) { impl_.set_size(size); }
  
  const int32_t& step() const { return impl_.step(); }
  int32_t* mutable_step() { return impl_.mutable_step(); }
  void set_step(const int32_t& step) { impl_.set_step(step); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UnfoldTensorOp {
 public:
  UnfoldTensorOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& dimension() const { return internal_->dimension; }
  int32_t* mutable_dimension() { return &internal_->dimension; }
  void set_dimension(const int32_t& dimension) { internal_->dimension = dimension; }
  
  const int32_t& size() const { return internal_->size; }
  int32_t* mutable_size() { return &internal_->size; }
  void set_size(const int32_t& size) { internal_->size = size; }
  
  const int32_t& step() const { return internal_->step; }
  int32_t* mutable_step() { return &internal_->step; }
  void set_step(const int32_t& step) { internal_->step = step; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t dimension = 0;
    int32_t size = 0;
    int32_t step = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UniformIntOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UniformIntOpInterpCtx() = default;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const int64_t& from() const = 0;
  virtual int64_t* mutable_from() = 0;
  virtual void set_from(const int64_t& from) = 0;

  virtual const std::string& nd_sbp() const = 0;
  virtual std::string* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::string& nd_sbp) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  virtual const int64_t& to() const = 0;
  virtual int64_t* mutable_to() = 0;
  virtual void set_to(const int64_t& to) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UniformIntOpInterpCtxImpl : public UniformIntOpInterpCtx {
 public:
  UniformIntOpInterpCtxImpl() = default;
  UniformIntOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const DataType& dtype() const { return impl_.dtype(); }
  DataType* mutable_dtype() { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) { impl_.set_dtype(dtype); }
  
  const int64_t& from() const { return impl_.from(); }
  int64_t* mutable_from() { return impl_.mutable_from(); }
  void set_from(const int64_t& from) { impl_.set_from(from); }
  
  const std::string& nd_sbp() const { return impl_.nd_sbp(); }
  std::string* mutable_nd_sbp() { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::string& nd_sbp) { impl_.set_nd_sbp(nd_sbp); }
  
  const int64_t& seed() const { return impl_.seed(); }
  int64_t* mutable_seed() { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) { impl_.set_seed(seed); }
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  const int64_t& to() const { return impl_.to(); }
  int64_t* mutable_to() { return impl_.mutable_to(); }
  void set_to(const int64_t& to) { impl_.set_to(to); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UniformIntOp {
 public:
  UniformIntOp() : internal_(std::make_shared<Internal>()) {}
  
  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }
  
  const int64_t& from() const { return internal_->from; }
  int64_t* mutable_from() { return &internal_->from; }
  void set_from(const int64_t& from) { internal_->from = from; }
  
  const std::string& nd_sbp() const { return internal_->nd_sbp; }
  std::string* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::string& nd_sbp) { internal_->nd_sbp = nd_sbp; }
  
  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  const int64_t& to() const { return internal_->to; }
  int64_t* mutable_to() { return &internal_->to; }
  void set_to(const int64_t& to) { internal_->to = to; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    DataType dtype;
    int64_t from = 0;
    std::string nd_sbp;
    int64_t seed = 0;
    Shape shape;
    int64_t to = 1;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UniformOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UniformOpInterpCtx() = default;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const double& from() const = 0;
  virtual double* mutable_from() = 0;
  virtual void set_from(const double& from) = 0;

  virtual const std::string& nd_sbp() const = 0;
  virtual std::string* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::string& nd_sbp) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  virtual const double& to() const = 0;
  virtual double* mutable_to() = 0;
  virtual void set_to(const double& to) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UniformOpInterpCtxImpl : public UniformOpInterpCtx {
 public:
  UniformOpInterpCtxImpl() = default;
  UniformOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const DataType& dtype() const { return impl_.dtype(); }
  DataType* mutable_dtype() { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) { impl_.set_dtype(dtype); }
  
  const double& from() const { return impl_.from(); }
  double* mutable_from() { return impl_.mutable_from(); }
  void set_from(const double& from) { impl_.set_from(from); }
  
  const std::string& nd_sbp() const { return impl_.nd_sbp(); }
  std::string* mutable_nd_sbp() { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::string& nd_sbp) { impl_.set_nd_sbp(nd_sbp); }
  
  const int64_t& seed() const { return impl_.seed(); }
  int64_t* mutable_seed() { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) { impl_.set_seed(seed); }
  
  const Shape& shape() const { return impl_.shape(); }
  Shape* mutable_shape() { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) { impl_.set_shape(shape); }
  
  const double& to() const { return impl_.to(); }
  double* mutable_to() { return impl_.mutable_to(); }
  void set_to(const double& to) { impl_.set_to(to); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UniformOp {
 public:
  UniformOp() : internal_(std::make_shared<Internal>()) {}
  
  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }
  
  const double& from() const { return internal_->from; }
  double* mutable_from() { return &internal_->from; }
  void set_from(const double& from) { internal_->from = from; }
  
  const std::string& nd_sbp() const { return internal_->nd_sbp; }
  std::string* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::string& nd_sbp) { internal_->nd_sbp = nd_sbp; }
  
  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }
  
  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }
  
  const double& to() const { return internal_->to; }
  double* mutable_to() { return &internal_->to; }
  void set_to(const double& to) { internal_->to = to; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    DataType dtype;
    double from = 0.;
    std::string nd_sbp;
    int64_t seed = 0;
    Shape shape;
    double to = 1.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UniqueWithCountsOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UniqueWithCountsOpInterpCtx() = default;

  virtual const DataType& out_idx() const = 0;
  virtual DataType* mutable_out_idx() = 0;
  virtual void set_out_idx(const DataType& out_idx) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UniqueWithCountsOpInterpCtxImpl : public UniqueWithCountsOpInterpCtx {
 public:
  UniqueWithCountsOpInterpCtxImpl() = default;
  UniqueWithCountsOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const DataType& out_idx() const { return impl_.out_idx(); }
  DataType* mutable_out_idx() { return impl_.mutable_out_idx(); }
  void set_out_idx(const DataType& out_idx) { impl_.set_out_idx(out_idx); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UniqueWithCountsOp {
 public:
  UniqueWithCountsOp() : internal_(std::make_shared<Internal>()) {}
  
  const DataType& out_idx() const { return internal_->out_idx; }
  DataType* mutable_out_idx() { return &internal_->out_idx; }
  void set_out_idx(const DataType& out_idx) { internal_->out_idx = out_idx; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    DataType out_idx;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UnpackOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UnpackOpInterpCtx() = default;

  virtual const int32_t& unpack_num() const = 0;
  virtual int32_t* mutable_unpack_num() = 0;
  virtual void set_unpack_num(const int32_t& unpack_num) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UnpackOpInterpCtxImpl : public UnpackOpInterpCtx {
 public:
  UnpackOpInterpCtxImpl() = default;
  UnpackOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int32_t& unpack_num() const { return impl_.unpack_num(); }
  int32_t* mutable_unpack_num() { return impl_.mutable_unpack_num(); }
  void set_unpack_num(const int32_t& unpack_num) { impl_.set_unpack_num(unpack_num); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UnpackOp {
 public:
  UnpackOp() : internal_(std::make_shared<Internal>()) {}
  
  const int32_t& unpack_num() const { return internal_->unpack_num; }
  int32_t* mutable_unpack_num() { return &internal_->unpack_num; }
  void set_unpack_num(const int32_t& unpack_num) { internal_->unpack_num = unpack_num; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int32_t unpack_num = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UnsortedBatchSegmentSumOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UnsortedBatchSegmentSumOpInterpCtx() = default;

  virtual const int64_t& num_segments() const = 0;
  virtual int64_t* mutable_num_segments() = 0;
  virtual void set_num_segments(const int64_t& num_segments) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UnsortedBatchSegmentSumOpInterpCtxImpl : public UnsortedBatchSegmentSumOpInterpCtx {
 public:
  UnsortedBatchSegmentSumOpInterpCtxImpl() = default;
  UnsortedBatchSegmentSumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& num_segments() const { return impl_.num_segments(); }
  int64_t* mutable_num_segments() { return impl_.mutable_num_segments(); }
  void set_num_segments(const int64_t& num_segments) { impl_.set_num_segments(num_segments); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UnsortedBatchSegmentSumOp {
 public:
  UnsortedBatchSegmentSumOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& num_segments() const { return internal_->num_segments; }
  int64_t* mutable_num_segments() { return &internal_->num_segments; }
  void set_num_segments(const int64_t& num_segments) { internal_->num_segments = num_segments; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t num_segments = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UnsortedSegmentSumLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UnsortedSegmentSumLikeOpInterpCtx() = default;

  virtual const int64_t& axis() const = 0;
  virtual int64_t* mutable_axis() = 0;
  virtual void set_axis(const int64_t& axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UnsortedSegmentSumLikeOpInterpCtxImpl : public UnsortedSegmentSumLikeOpInterpCtx {
 public:
  UnsortedSegmentSumLikeOpInterpCtxImpl() = default;
  UnsortedSegmentSumLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& axis() const { return impl_.axis(); }
  int64_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int64_t& axis) { impl_.set_axis(axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UnsortedSegmentSumLikeOp {
 public:
  UnsortedSegmentSumLikeOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& axis() const { return internal_->axis; }
  int64_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int64_t& axis) { internal_->axis = axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t axis = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UnsortedSegmentSumOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UnsortedSegmentSumOpInterpCtx() = default;

  virtual const int64_t& axis() const = 0;
  virtual int64_t* mutable_axis() = 0;
  virtual void set_axis(const int64_t& axis) = 0;

  virtual const int64_t& num_segments() const = 0;
  virtual int64_t* mutable_num_segments() = 0;
  virtual void set_num_segments(const int64_t& num_segments) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UnsortedSegmentSumOpInterpCtxImpl : public UnsortedSegmentSumOpInterpCtx {
 public:
  UnsortedSegmentSumOpInterpCtxImpl() = default;
  UnsortedSegmentSumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& axis() const { return impl_.axis(); }
  int64_t* mutable_axis() { return impl_.mutable_axis(); }
  void set_axis(const int64_t& axis) { impl_.set_axis(axis); }
  
  const int64_t& num_segments() const { return impl_.num_segments(); }
  int64_t* mutable_num_segments() { return impl_.mutable_num_segments(); }
  void set_num_segments(const int64_t& num_segments) { impl_.set_num_segments(num_segments); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UnsortedSegmentSumOp {
 public:
  UnsortedSegmentSumOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& axis() const { return internal_->axis; }
  int64_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int64_t& axis) { internal_->axis = axis; }
  
  const int64_t& num_segments() const { return internal_->num_segments; }
  int64_t* mutable_num_segments() { return &internal_->num_segments; }
  void set_num_segments(const int64_t& num_segments) { internal_->num_segments = num_segments; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t axis = 0;
    int64_t num_segments = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UpsampleBicubic2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UpsampleBicubic2DGradOpInterpCtx() = default;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UpsampleBicubic2DGradOpInterpCtxImpl : public UpsampleBicubic2DGradOpInterpCtx {
 public:
  UpsampleBicubic2DGradOpInterpCtxImpl() = default;
  UpsampleBicubic2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& align_corners() const { return impl_.align_corners(); }
  bool* mutable_align_corners() { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) { impl_.set_align_corners(align_corners); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const float& height_scale() const { return impl_.height_scale(); }
  float* mutable_height_scale() { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) { impl_.set_height_scale(height_scale); }
  
  const float& width_scale() const { return impl_.width_scale(); }
  float* mutable_width_scale() { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) { impl_.set_width_scale(width_scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleBicubic2DGradOp {
 public:
  UpsampleBicubic2DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }
  
  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool align_corners = false;
    std::string data_format;
    float height_scale = 0.;
    float width_scale = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UpsampleBicubic2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UpsampleBicubic2DOpInterpCtx() = default;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UpsampleBicubic2DOpInterpCtxImpl : public UpsampleBicubic2DOpInterpCtx {
 public:
  UpsampleBicubic2DOpInterpCtxImpl() = default;
  UpsampleBicubic2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& align_corners() const { return impl_.align_corners(); }
  bool* mutable_align_corners() { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) { impl_.set_align_corners(align_corners); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const float& height_scale() const { return impl_.height_scale(); }
  float* mutable_height_scale() { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) { impl_.set_height_scale(height_scale); }
  
  const float& width_scale() const { return impl_.width_scale(); }
  float* mutable_width_scale() { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) { impl_.set_width_scale(width_scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleBicubic2DOp {
 public:
  UpsampleBicubic2DOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }
  
  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool align_corners = false;
    std::string data_format;
    float height_scale = 0.;
    float width_scale = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UpsampleBilinear2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UpsampleBilinear2DGradOpInterpCtx() = default;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UpsampleBilinear2DGradOpInterpCtxImpl : public UpsampleBilinear2DGradOpInterpCtx {
 public:
  UpsampleBilinear2DGradOpInterpCtxImpl() = default;
  UpsampleBilinear2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& align_corners() const { return impl_.align_corners(); }
  bool* mutable_align_corners() { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) { impl_.set_align_corners(align_corners); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const float& height_scale() const { return impl_.height_scale(); }
  float* mutable_height_scale() { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) { impl_.set_height_scale(height_scale); }
  
  const float& width_scale() const { return impl_.width_scale(); }
  float* mutable_width_scale() { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) { impl_.set_width_scale(width_scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleBilinear2DGradOp {
 public:
  UpsampleBilinear2DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }
  
  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool align_corners = false;
    std::string data_format;
    float height_scale = 0.;
    float width_scale = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UpsampleBilinear2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UpsampleBilinear2DOpInterpCtx() = default;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UpsampleBilinear2DOpInterpCtxImpl : public UpsampleBilinear2DOpInterpCtx {
 public:
  UpsampleBilinear2DOpInterpCtxImpl() = default;
  UpsampleBilinear2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& align_corners() const { return impl_.align_corners(); }
  bool* mutable_align_corners() { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) { impl_.set_align_corners(align_corners); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const float& height_scale() const { return impl_.height_scale(); }
  float* mutable_height_scale() { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) { impl_.set_height_scale(height_scale); }
  
  const float& width_scale() const { return impl_.width_scale(); }
  float* mutable_width_scale() { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) { impl_.set_width_scale(width_scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleBilinear2DOp {
 public:
  UpsampleBilinear2DOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }
  
  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool align_corners = false;
    std::string data_format;
    float height_scale = 0.;
    float width_scale = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UpsampleGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UpsampleGradOpInterpCtx() = default;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const std::string& interpolation() const = 0;
  virtual std::string* mutable_interpolation() = 0;
  virtual void set_interpolation(const std::string& interpolation) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UpsampleGradOpInterpCtxImpl : public UpsampleGradOpInterpCtx {
 public:
  UpsampleGradOpInterpCtxImpl() = default;
  UpsampleGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& align_corners() const { return impl_.align_corners(); }
  bool* mutable_align_corners() { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) { impl_.set_align_corners(align_corners); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const float& height_scale() const { return impl_.height_scale(); }
  float* mutable_height_scale() { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) { impl_.set_height_scale(height_scale); }
  
  const std::string& interpolation() const { return impl_.interpolation(); }
  std::string* mutable_interpolation() { return impl_.mutable_interpolation(); }
  void set_interpolation(const std::string& interpolation) { impl_.set_interpolation(interpolation); }
  
  const float& width_scale() const { return impl_.width_scale(); }
  float* mutable_width_scale() { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) { impl_.set_width_scale(width_scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleGradOp {
 public:
  UpsampleGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }
  
  const std::string& interpolation() const { return internal_->interpolation; }
  std::string* mutable_interpolation() { return &internal_->interpolation; }
  void set_interpolation(const std::string& interpolation) { internal_->interpolation = interpolation; }
  
  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool align_corners = false;
    std::string data_format;
    float height_scale = 0.;
    std::string interpolation;
    float width_scale = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UpsampleLinear1DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UpsampleLinear1DGradOpInterpCtx() = default;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const float& scale_factor() const = 0;
  virtual float* mutable_scale_factor() = 0;
  virtual void set_scale_factor(const float& scale_factor) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UpsampleLinear1DGradOpInterpCtxImpl : public UpsampleLinear1DGradOpInterpCtx {
 public:
  UpsampleLinear1DGradOpInterpCtxImpl() = default;
  UpsampleLinear1DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& align_corners() const { return impl_.align_corners(); }
  bool* mutable_align_corners() { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) { impl_.set_align_corners(align_corners); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const float& scale_factor() const { return impl_.scale_factor(); }
  float* mutable_scale_factor() { return impl_.mutable_scale_factor(); }
  void set_scale_factor(const float& scale_factor) { impl_.set_scale_factor(scale_factor); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleLinear1DGradOp {
 public:
  UpsampleLinear1DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const float& scale_factor() const { return internal_->scale_factor; }
  float* mutable_scale_factor() { return &internal_->scale_factor; }
  void set_scale_factor(const float& scale_factor) { internal_->scale_factor = scale_factor; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool align_corners = false;
    std::string data_format;
    float scale_factor = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UpsampleLinear1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UpsampleLinear1DOpInterpCtx() = default;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const float& scale_factor() const = 0;
  virtual float* mutable_scale_factor() = 0;
  virtual void set_scale_factor(const float& scale_factor) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UpsampleLinear1DOpInterpCtxImpl : public UpsampleLinear1DOpInterpCtx {
 public:
  UpsampleLinear1DOpInterpCtxImpl() = default;
  UpsampleLinear1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& align_corners() const { return impl_.align_corners(); }
  bool* mutable_align_corners() { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) { impl_.set_align_corners(align_corners); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const float& scale_factor() const { return impl_.scale_factor(); }
  float* mutable_scale_factor() { return impl_.mutable_scale_factor(); }
  void set_scale_factor(const float& scale_factor) { impl_.set_scale_factor(scale_factor); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleLinear1DOp {
 public:
  UpsampleLinear1DOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const float& scale_factor() const { return internal_->scale_factor; }
  float* mutable_scale_factor() { return &internal_->scale_factor; }
  void set_scale_factor(const float& scale_factor) { internal_->scale_factor = scale_factor; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool align_corners = false;
    std::string data_format;
    float scale_factor = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UpsampleNearest1DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UpsampleNearest1DGradOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const float& scale_factor() const = 0;
  virtual float* mutable_scale_factor() = 0;
  virtual void set_scale_factor(const float& scale_factor) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UpsampleNearest1DGradOpInterpCtxImpl : public UpsampleNearest1DGradOpInterpCtx {
 public:
  UpsampleNearest1DGradOpInterpCtxImpl() = default;
  UpsampleNearest1DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const float& scale_factor() const { return impl_.scale_factor(); }
  float* mutable_scale_factor() { return impl_.mutable_scale_factor(); }
  void set_scale_factor(const float& scale_factor) { impl_.set_scale_factor(scale_factor); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleNearest1DGradOp {
 public:
  UpsampleNearest1DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const float& scale_factor() const { return internal_->scale_factor; }
  float* mutable_scale_factor() { return &internal_->scale_factor; }
  void set_scale_factor(const float& scale_factor) { internal_->scale_factor = scale_factor; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    float scale_factor = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UpsampleNearest1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UpsampleNearest1DOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const float& scale_factor() const = 0;
  virtual float* mutable_scale_factor() = 0;
  virtual void set_scale_factor(const float& scale_factor) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UpsampleNearest1DOpInterpCtxImpl : public UpsampleNearest1DOpInterpCtx {
 public:
  UpsampleNearest1DOpInterpCtxImpl() = default;
  UpsampleNearest1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const float& scale_factor() const { return impl_.scale_factor(); }
  float* mutable_scale_factor() { return impl_.mutable_scale_factor(); }
  void set_scale_factor(const float& scale_factor) { impl_.set_scale_factor(scale_factor); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleNearest1DOp {
 public:
  UpsampleNearest1DOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const float& scale_factor() const { return internal_->scale_factor; }
  float* mutable_scale_factor() { return &internal_->scale_factor; }
  void set_scale_factor(const float& scale_factor) { internal_->scale_factor = scale_factor; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    float scale_factor = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UpsampleNearest2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UpsampleNearest2DGradOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UpsampleNearest2DGradOpInterpCtxImpl : public UpsampleNearest2DGradOpInterpCtx {
 public:
  UpsampleNearest2DGradOpInterpCtxImpl() = default;
  UpsampleNearest2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const float& height_scale() const { return impl_.height_scale(); }
  float* mutable_height_scale() { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) { impl_.set_height_scale(height_scale); }
  
  const float& width_scale() const { return impl_.width_scale(); }
  float* mutable_width_scale() { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) { impl_.set_width_scale(width_scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleNearest2DGradOp {
 public:
  UpsampleNearest2DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }
  
  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    float height_scale = 0.;
    float width_scale = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UpsampleNearest2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UpsampleNearest2DOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UpsampleNearest2DOpInterpCtxImpl : public UpsampleNearest2DOpInterpCtx {
 public:
  UpsampleNearest2DOpInterpCtxImpl() = default;
  UpsampleNearest2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const float& height_scale() const { return impl_.height_scale(); }
  float* mutable_height_scale() { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) { impl_.set_height_scale(height_scale); }
  
  const float& width_scale() const { return impl_.width_scale(); }
  float* mutable_width_scale() { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) { impl_.set_width_scale(width_scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleNearest2DOp {
 public:
  UpsampleNearest2DOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }
  
  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    float height_scale = 0.;
    float width_scale = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UpsampleNearest3DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UpsampleNearest3DGradOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const float& depth_scale() const = 0;
  virtual float* mutable_depth_scale() = 0;
  virtual void set_depth_scale(const float& depth_scale) = 0;

  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UpsampleNearest3DGradOpInterpCtxImpl : public UpsampleNearest3DGradOpInterpCtx {
 public:
  UpsampleNearest3DGradOpInterpCtxImpl() = default;
  UpsampleNearest3DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const float& depth_scale() const { return impl_.depth_scale(); }
  float* mutable_depth_scale() { return impl_.mutable_depth_scale(); }
  void set_depth_scale(const float& depth_scale) { impl_.set_depth_scale(depth_scale); }
  
  const float& height_scale() const { return impl_.height_scale(); }
  float* mutable_height_scale() { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) { impl_.set_height_scale(height_scale); }
  
  const float& width_scale() const { return impl_.width_scale(); }
  float* mutable_width_scale() { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) { impl_.set_width_scale(width_scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleNearest3DGradOp {
 public:
  UpsampleNearest3DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const float& depth_scale() const { return internal_->depth_scale; }
  float* mutable_depth_scale() { return &internal_->depth_scale; }
  void set_depth_scale(const float& depth_scale) { internal_->depth_scale = depth_scale; }
  
  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }
  
  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    float depth_scale = 0.;
    float height_scale = 0.;
    float width_scale = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UpsampleNearest3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UpsampleNearest3DOpInterpCtx() = default;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const float& depth_scale() const = 0;
  virtual float* mutable_depth_scale() = 0;
  virtual void set_depth_scale(const float& depth_scale) = 0;

  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UpsampleNearest3DOpInterpCtxImpl : public UpsampleNearest3DOpInterpCtx {
 public:
  UpsampleNearest3DOpInterpCtxImpl() = default;
  UpsampleNearest3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const float& depth_scale() const { return impl_.depth_scale(); }
  float* mutable_depth_scale() { return impl_.mutable_depth_scale(); }
  void set_depth_scale(const float& depth_scale) { impl_.set_depth_scale(depth_scale); }
  
  const float& height_scale() const { return impl_.height_scale(); }
  float* mutable_height_scale() { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) { impl_.set_height_scale(height_scale); }
  
  const float& width_scale() const { return impl_.width_scale(); }
  float* mutable_width_scale() { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) { impl_.set_width_scale(width_scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleNearest3DOp {
 public:
  UpsampleNearest3DOp() : internal_(std::make_shared<Internal>()) {}
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const float& depth_scale() const { return internal_->depth_scale; }
  float* mutable_depth_scale() { return &internal_->depth_scale; }
  void set_depth_scale(const float& depth_scale) { internal_->depth_scale = depth_scale; }
  
  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }
  
  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    std::string data_format;
    float depth_scale = 0.;
    float height_scale = 0.;
    float width_scale = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UpsampleOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UpsampleOpInterpCtx() = default;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const std::string& interpolation() const = 0;
  virtual std::string* mutable_interpolation() = 0;
  virtual void set_interpolation(const std::string& interpolation) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UpsampleOpInterpCtxImpl : public UpsampleOpInterpCtx {
 public:
  UpsampleOpInterpCtxImpl() = default;
  UpsampleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& align_corners() const { return impl_.align_corners(); }
  bool* mutable_align_corners() { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) { impl_.set_align_corners(align_corners); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const float& height_scale() const { return impl_.height_scale(); }
  float* mutable_height_scale() { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) { impl_.set_height_scale(height_scale); }
  
  const std::string& interpolation() const { return impl_.interpolation(); }
  std::string* mutable_interpolation() { return impl_.mutable_interpolation(); }
  void set_interpolation(const std::string& interpolation) { impl_.set_interpolation(interpolation); }
  
  const float& width_scale() const { return impl_.width_scale(); }
  float* mutable_width_scale() { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) { impl_.set_width_scale(width_scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleOp {
 public:
  UpsampleOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }
  
  const std::string& interpolation() const { return internal_->interpolation; }
  std::string* mutable_interpolation() { return &internal_->interpolation; }
  void set_interpolation(const std::string& interpolation) { internal_->interpolation = interpolation; }
  
  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool align_corners = false;
    std::string data_format;
    float height_scale = 0.;
    std::string interpolation;
    float width_scale = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UpsampleTrilinear3DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UpsampleTrilinear3DGradOpInterpCtx() = default;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const float& depth_scale() const = 0;
  virtual float* mutable_depth_scale() = 0;
  virtual void set_depth_scale(const float& depth_scale) = 0;

  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UpsampleTrilinear3DGradOpInterpCtxImpl : public UpsampleTrilinear3DGradOpInterpCtx {
 public:
  UpsampleTrilinear3DGradOpInterpCtxImpl() = default;
  UpsampleTrilinear3DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& align_corners() const { return impl_.align_corners(); }
  bool* mutable_align_corners() { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) { impl_.set_align_corners(align_corners); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const float& depth_scale() const { return impl_.depth_scale(); }
  float* mutable_depth_scale() { return impl_.mutable_depth_scale(); }
  void set_depth_scale(const float& depth_scale) { impl_.set_depth_scale(depth_scale); }
  
  const float& height_scale() const { return impl_.height_scale(); }
  float* mutable_height_scale() { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) { impl_.set_height_scale(height_scale); }
  
  const float& width_scale() const { return impl_.width_scale(); }
  float* mutable_width_scale() { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) { impl_.set_width_scale(width_scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleTrilinear3DGradOp {
 public:
  UpsampleTrilinear3DGradOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const float& depth_scale() const { return internal_->depth_scale; }
  float* mutable_depth_scale() { return &internal_->depth_scale; }
  void set_depth_scale(const float& depth_scale) { internal_->depth_scale = depth_scale; }
  
  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }
  
  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool align_corners = false;
    std::string data_format;
    float depth_scale = 0.;
    float height_scale = 0.;
    float width_scale = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class UpsampleTrilinear3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~UpsampleTrilinear3DOpInterpCtx() = default;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const float& depth_scale() const = 0;
  virtual float* mutable_depth_scale() = 0;
  virtual void set_depth_scale(const float& depth_scale) = 0;

  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class UpsampleTrilinear3DOpInterpCtxImpl : public UpsampleTrilinear3DOpInterpCtx {
 public:
  UpsampleTrilinear3DOpInterpCtxImpl() = default;
  UpsampleTrilinear3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& align_corners() const { return impl_.align_corners(); }
  bool* mutable_align_corners() { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) { impl_.set_align_corners(align_corners); }
  
  const std::string& data_format() const { return impl_.data_format(); }
  std::string* mutable_data_format() { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) { impl_.set_data_format(data_format); }
  
  const float& depth_scale() const { return impl_.depth_scale(); }
  float* mutable_depth_scale() { return impl_.mutable_depth_scale(); }
  void set_depth_scale(const float& depth_scale) { impl_.set_depth_scale(depth_scale); }
  
  const float& height_scale() const { return impl_.height_scale(); }
  float* mutable_height_scale() { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) { impl_.set_height_scale(height_scale); }
  
  const float& width_scale() const { return impl_.width_scale(); }
  float* mutable_width_scale() { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) { impl_.set_width_scale(width_scale); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleTrilinear3DOp {
 public:
  UpsampleTrilinear3DOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }
  
  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }
  
  const float& depth_scale() const { return internal_->depth_scale; }
  float* mutable_depth_scale() { return &internal_->depth_scale; }
  void set_depth_scale(const float& depth_scale) { internal_->depth_scale = depth_scale; }
  
  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }
  
  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool align_corners = false;
    std::string data_format;
    float depth_scale = 0.;
    float height_scale = 0.;
    float width_scale = 0.;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class WhereOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~WhereOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class WhereOpInterpCtxImpl : public WhereOpInterpCtx {
 public:
  WhereOpInterpCtxImpl() = default;
  WhereOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class WhereOp {
 public:
  WhereOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class WhereScalarXOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~WhereScalarXOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class WhereScalarXOpInterpCtxImpl : public WhereScalarXOpInterpCtx {
 public:
  WhereScalarXOpInterpCtxImpl() = default;
  WhereScalarXOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class WhereScalarXOp {
 public:
  WhereScalarXOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class WhereScalarXyOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~WhereScalarXyOpInterpCtx() = default;

  virtual const bool& has_x_float_operand() const = 0;
  virtual bool* mutable_has_x_float_operand() = 0;
  virtual void set_has_x_float_operand(const bool& has_x_float_operand) = 0;

  virtual const bool& has_x_int_operand() const = 0;
  virtual bool* mutable_has_x_int_operand() = 0;
  virtual void set_has_x_int_operand(const bool& has_x_int_operand) = 0;

  virtual const bool& has_y_float_operand() const = 0;
  virtual bool* mutable_has_y_float_operand() = 0;
  virtual void set_has_y_float_operand(const bool& has_y_float_operand) = 0;

  virtual const bool& has_y_int_operand() const = 0;
  virtual bool* mutable_has_y_int_operand() = 0;
  virtual void set_has_y_int_operand(const bool& has_y_int_operand) = 0;

  virtual const double& x_float_operand() const = 0;
  virtual double* mutable_x_float_operand() = 0;
  virtual void set_x_float_operand(const double& x_float_operand) = 0;

  virtual const int64_t& x_int_operand() const = 0;
  virtual int64_t* mutable_x_int_operand() = 0;
  virtual void set_x_int_operand(const int64_t& x_int_operand) = 0;

  virtual const double& y_float_operand() const = 0;
  virtual double* mutable_y_float_operand() = 0;
  virtual void set_y_float_operand(const double& y_float_operand) = 0;

  virtual const int64_t& y_int_operand() const = 0;
  virtual int64_t* mutable_y_int_operand() = 0;
  virtual void set_y_int_operand(const int64_t& y_int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class WhereScalarXyOpInterpCtxImpl : public WhereScalarXyOpInterpCtx {
 public:
  WhereScalarXyOpInterpCtxImpl() = default;
  WhereScalarXyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const bool& has_x_float_operand() const { return impl_.has_x_float_operand(); }
  bool* mutable_has_x_float_operand() { return impl_.mutable_has_x_float_operand(); }
  void set_has_x_float_operand(const bool& has_x_float_operand) { impl_.set_has_x_float_operand(has_x_float_operand); }
  
  const bool& has_x_int_operand() const { return impl_.has_x_int_operand(); }
  bool* mutable_has_x_int_operand() { return impl_.mutable_has_x_int_operand(); }
  void set_has_x_int_operand(const bool& has_x_int_operand) { impl_.set_has_x_int_operand(has_x_int_operand); }
  
  const bool& has_y_float_operand() const { return impl_.has_y_float_operand(); }
  bool* mutable_has_y_float_operand() { return impl_.mutable_has_y_float_operand(); }
  void set_has_y_float_operand(const bool& has_y_float_operand) { impl_.set_has_y_float_operand(has_y_float_operand); }
  
  const bool& has_y_int_operand() const { return impl_.has_y_int_operand(); }
  bool* mutable_has_y_int_operand() { return impl_.mutable_has_y_int_operand(); }
  void set_has_y_int_operand(const bool& has_y_int_operand) { impl_.set_has_y_int_operand(has_y_int_operand); }
  
  const double& x_float_operand() const { return impl_.x_float_operand(); }
  double* mutable_x_float_operand() { return impl_.mutable_x_float_operand(); }
  void set_x_float_operand(const double& x_float_operand) { impl_.set_x_float_operand(x_float_operand); }
  
  const int64_t& x_int_operand() const { return impl_.x_int_operand(); }
  int64_t* mutable_x_int_operand() { return impl_.mutable_x_int_operand(); }
  void set_x_int_operand(const int64_t& x_int_operand) { impl_.set_x_int_operand(x_int_operand); }
  
  const double& y_float_operand() const { return impl_.y_float_operand(); }
  double* mutable_y_float_operand() { return impl_.mutable_y_float_operand(); }
  void set_y_float_operand(const double& y_float_operand) { impl_.set_y_float_operand(y_float_operand); }
  
  const int64_t& y_int_operand() const { return impl_.y_int_operand(); }
  int64_t* mutable_y_int_operand() { return impl_.mutable_y_int_operand(); }
  void set_y_int_operand(const int64_t& y_int_operand) { impl_.set_y_int_operand(y_int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class WhereScalarXyOp {
 public:
  WhereScalarXyOp() : internal_(std::make_shared<Internal>()) {}
  
  const bool& has_x_float_operand() const { return internal_->has_x_float_operand; }
  bool* mutable_has_x_float_operand() { return &internal_->has_x_float_operand; }
  void set_has_x_float_operand(const bool& has_x_float_operand) { internal_->has_x_float_operand = has_x_float_operand; }
  
  const bool& has_x_int_operand() const { return internal_->has_x_int_operand; }
  bool* mutable_has_x_int_operand() { return &internal_->has_x_int_operand; }
  void set_has_x_int_operand(const bool& has_x_int_operand) { internal_->has_x_int_operand = has_x_int_operand; }
  
  const bool& has_y_float_operand() const { return internal_->has_y_float_operand; }
  bool* mutable_has_y_float_operand() { return &internal_->has_y_float_operand; }
  void set_has_y_float_operand(const bool& has_y_float_operand) { internal_->has_y_float_operand = has_y_float_operand; }
  
  const bool& has_y_int_operand() const { return internal_->has_y_int_operand; }
  bool* mutable_has_y_int_operand() { return &internal_->has_y_int_operand; }
  void set_has_y_int_operand(const bool& has_y_int_operand) { internal_->has_y_int_operand = has_y_int_operand; }
  
  const double& x_float_operand() const { return internal_->x_float_operand; }
  double* mutable_x_float_operand() { return &internal_->x_float_operand; }
  void set_x_float_operand(const double& x_float_operand) { internal_->x_float_operand = x_float_operand; }
  
  const int64_t& x_int_operand() const { return internal_->x_int_operand; }
  int64_t* mutable_x_int_operand() { return &internal_->x_int_operand; }
  void set_x_int_operand(const int64_t& x_int_operand) { internal_->x_int_operand = x_int_operand; }
  
  const double& y_float_operand() const { return internal_->y_float_operand; }
  double* mutable_y_float_operand() { return &internal_->y_float_operand; }
  void set_y_float_operand(const double& y_float_operand) { internal_->y_float_operand = y_float_operand; }
  
  const int64_t& y_int_operand() const { return internal_->y_int_operand; }
  int64_t* mutable_y_int_operand() { return &internal_->y_int_operand; }
  void set_y_int_operand(const int64_t& y_int_operand) { internal_->y_int_operand = y_int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    bool has_x_float_operand = false;
    bool has_x_int_operand = false;
    bool has_y_float_operand = false;
    bool has_y_int_operand = false;
    double x_float_operand = 0.;
    int64_t x_int_operand = 0;
    double y_float_operand = 0.;
    int64_t y_int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class WhereScalarYOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~WhereScalarYOpInterpCtx() = default;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class WhereScalarYOpInterpCtxImpl : public WhereScalarYOpInterpCtx {
 public:
  WhereScalarYOpInterpCtxImpl() = default;
  WhereScalarYOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const double& float_operand() const { return impl_.float_operand(); }
  double* mutable_float_operand() { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) { impl_.set_float_operand(float_operand); }
  
  const bool& has_float_operand() const { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) { impl_.set_has_float_operand(has_float_operand); }
  
  const bool& has_int_operand() const { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) { impl_.set_has_int_operand(has_int_operand); }
  
  const int64_t& int_operand() const { return impl_.int_operand(); }
  int64_t* mutable_int_operand() { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) { impl_.set_int_operand(int_operand); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class WhereScalarYOp {
 public:
  WhereScalarYOp() : internal_(std::make_shared<Internal>()) {}
  
  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }
  
  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) { internal_->has_float_operand = has_float_operand; }
  
  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) { internal_->has_int_operand = has_int_operand; }
  
  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    double float_operand = 0.;
    bool has_float_operand = false;
    bool has_int_operand = false;
    int64_t int_operand = 0;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class XdivyOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~XdivyOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class XdivyOpInterpCtxImpl : public XdivyOpInterpCtx {
 public:
  XdivyOpInterpCtxImpl() = default;
  XdivyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class XdivyOp {
 public:
  XdivyOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class XdivyXGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~XdivyXGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class XdivyXGradOpInterpCtxImpl : public XdivyXGradOpInterpCtx {
 public:
  XdivyXGradOpInterpCtxImpl() = default;
  XdivyXGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class XdivyXGradOp {
 public:
  XdivyXGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class XdivyYGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~XdivyYGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class XdivyYGradOpInterpCtxImpl : public XdivyYGradOpInterpCtx {
 public:
  XdivyYGradOpInterpCtxImpl() = default;
  XdivyYGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class XdivyYGradOp {
 public:
  XdivyYGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class XlogyOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~XlogyOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class XlogyOpInterpCtxImpl : public XlogyOpInterpCtx {
 public:
  XlogyOpInterpCtxImpl() = default;
  XlogyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class XlogyOp {
 public:
  XlogyOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class XlogyXGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~XlogyXGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class XlogyXGradOpInterpCtxImpl : public XlogyXGradOpInterpCtx {
 public:
  XlogyXGradOpInterpCtxImpl() = default;
  XlogyXGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class XlogyXGradOp {
 public:
  XlogyXGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class XlogyYGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~XlogyYGradOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class XlogyYGradOpInterpCtxImpl : public XlogyYGradOpInterpCtx {
 public:
  XlogyYGradOpInterpCtxImpl() = default;
  XlogyYGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class XlogyYGradOp {
 public:
  XlogyYGradOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class ZeroLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~ZeroLikeOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class ZeroLikeOpInterpCtxImpl : public ZeroLikeOpInterpCtx {
 public:
  ZeroLikeOpInterpCtxImpl() = default;
  ZeroLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ZeroLikeOp {
 public:
  ZeroLikeOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class _ncclLogicalAllGatherNoncontinuousOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~_ncclLogicalAllGatherNoncontinuousOpInterpCtx() = default;

  virtual const int64_t& in_split_axis() const = 0;
  virtual int64_t* mutable_in_split_axis() = 0;
  virtual void set_in_split_axis(const int64_t& in_split_axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class _ncclLogicalAllGatherNoncontinuousOpInterpCtxImpl : public _ncclLogicalAllGatherNoncontinuousOpInterpCtx {
 public:
  _ncclLogicalAllGatherNoncontinuousOpInterpCtxImpl() = default;
  _ncclLogicalAllGatherNoncontinuousOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& in_split_axis() const { return impl_.in_split_axis(); }
  int64_t* mutable_in_split_axis() { return impl_.mutable_in_split_axis(); }
  void set_in_split_axis(const int64_t& in_split_axis) { impl_.set_in_split_axis(in_split_axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogicalAllGatherNoncontinuousOp {
 public:
  _ncclLogicalAllGatherNoncontinuousOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& in_split_axis() const { return internal_->in_split_axis; }
  int64_t* mutable_in_split_axis() { return &internal_->in_split_axis; }
  void set_in_split_axis(const int64_t& in_split_axis) { internal_->in_split_axis = in_split_axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t in_split_axis = -1;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class _ncclLogicalAllGatherOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~_ncclLogicalAllGatherOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class _ncclLogicalAllGatherOpInterpCtxImpl : public _ncclLogicalAllGatherOpInterpCtx {
 public:
  _ncclLogicalAllGatherOpInterpCtxImpl() = default;
  _ncclLogicalAllGatherOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogicalAllGatherOp {
 public:
  _ncclLogicalAllGatherOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class _ncclLogicalAllReduceOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~_ncclLogicalAllReduceOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class _ncclLogicalAllReduceOpInterpCtxImpl : public _ncclLogicalAllReduceOpInterpCtx {
 public:
  _ncclLogicalAllReduceOpInterpCtxImpl() = default;
  _ncclLogicalAllReduceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogicalAllReduceOp {
 public:
  _ncclLogicalAllReduceOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class _ncclLogicalReduceScatterOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~_ncclLogicalReduceScatterOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class _ncclLogicalReduceScatterOpInterpCtxImpl : public _ncclLogicalReduceScatterOpInterpCtx {
 public:
  _ncclLogicalReduceScatterOpInterpCtxImpl() = default;
  _ncclLogicalReduceScatterOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogicalReduceScatterOp {
 public:
  _ncclLogicalReduceScatterOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class _ncclLogicalS2sOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~_ncclLogicalS2sOpInterpCtx() = default;

  virtual const int64_t& in_split_axis() const = 0;
  virtual int64_t* mutable_in_split_axis() = 0;
  virtual void set_in_split_axis(const int64_t& in_split_axis) = 0;

  virtual const int64_t& out_split_axis() const = 0;
  virtual int64_t* mutable_out_split_axis() = 0;
  virtual void set_out_split_axis(const int64_t& out_split_axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class _ncclLogicalS2sOpInterpCtxImpl : public _ncclLogicalS2sOpInterpCtx {
 public:
  _ncclLogicalS2sOpInterpCtxImpl() = default;
  _ncclLogicalS2sOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& in_split_axis() const { return impl_.in_split_axis(); }
  int64_t* mutable_in_split_axis() { return impl_.mutable_in_split_axis(); }
  void set_in_split_axis(const int64_t& in_split_axis) { impl_.set_in_split_axis(in_split_axis); }
  
  const int64_t& out_split_axis() const { return impl_.out_split_axis(); }
  int64_t* mutable_out_split_axis() { return impl_.mutable_out_split_axis(); }
  void set_out_split_axis(const int64_t& out_split_axis) { impl_.set_out_split_axis(out_split_axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogicalS2sOp {
 public:
  _ncclLogicalS2sOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& in_split_axis() const { return internal_->in_split_axis; }
  int64_t* mutable_in_split_axis() { return &internal_->in_split_axis; }
  void set_in_split_axis(const int64_t& in_split_axis) { internal_->in_split_axis = in_split_axis; }
  
  const int64_t& out_split_axis() const { return internal_->out_split_axis; }
  int64_t* mutable_out_split_axis() { return &internal_->out_split_axis; }
  void set_out_split_axis(const int64_t& out_split_axis) { internal_->out_split_axis = out_split_axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t in_split_axis = -1;
    int64_t out_split_axis = -1;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class _ncclLogical_2DSameDim0All2allOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~_ncclLogical_2DSameDim0All2allOpInterpCtx() = default;

  virtual const int64_t& in_dim1_split_axis() const = 0;
  virtual int64_t* mutable_in_dim1_split_axis() = 0;
  virtual void set_in_dim1_split_axis(const int64_t& in_dim1_split_axis) = 0;

  virtual const int64_t& out_dim1_split_axis() const = 0;
  virtual int64_t* mutable_out_dim1_split_axis() = 0;
  virtual void set_out_dim1_split_axis(const int64_t& out_dim1_split_axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class _ncclLogical_2DSameDim0All2allOpInterpCtxImpl : public _ncclLogical_2DSameDim0All2allOpInterpCtx {
 public:
  _ncclLogical_2DSameDim0All2allOpInterpCtxImpl() = default;
  _ncclLogical_2DSameDim0All2allOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& in_dim1_split_axis() const { return impl_.in_dim1_split_axis(); }
  int64_t* mutable_in_dim1_split_axis() { return impl_.mutable_in_dim1_split_axis(); }
  void set_in_dim1_split_axis(const int64_t& in_dim1_split_axis) { impl_.set_in_dim1_split_axis(in_dim1_split_axis); }
  
  const int64_t& out_dim1_split_axis() const { return impl_.out_dim1_split_axis(); }
  int64_t* mutable_out_dim1_split_axis() { return impl_.mutable_out_dim1_split_axis(); }
  void set_out_dim1_split_axis(const int64_t& out_dim1_split_axis) { impl_.set_out_dim1_split_axis(out_dim1_split_axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogical_2DSameDim0All2allOp {
 public:
  _ncclLogical_2DSameDim0All2allOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& in_dim1_split_axis() const { return internal_->in_dim1_split_axis; }
  int64_t* mutable_in_dim1_split_axis() { return &internal_->in_dim1_split_axis; }
  void set_in_dim1_split_axis(const int64_t& in_dim1_split_axis) { internal_->in_dim1_split_axis = in_dim1_split_axis; }
  
  const int64_t& out_dim1_split_axis() const { return internal_->out_dim1_split_axis; }
  int64_t* mutable_out_dim1_split_axis() { return &internal_->out_dim1_split_axis; }
  void set_out_dim1_split_axis(const int64_t& out_dim1_split_axis) { internal_->out_dim1_split_axis = out_dim1_split_axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t in_dim1_split_axis = -1;
    int64_t out_dim1_split_axis = -1;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class _ncclLogical_2DSameDim0AllGatherNoncontinuousOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~_ncclLogical_2DSameDim0AllGatherNoncontinuousOpInterpCtx() = default;

  virtual const int64_t& in_dim1_split_axis() const = 0;
  virtual int64_t* mutable_in_dim1_split_axis() = 0;
  virtual void set_in_dim1_split_axis(const int64_t& in_dim1_split_axis) = 0;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class _ncclLogical_2DSameDim0AllGatherNoncontinuousOpInterpCtxImpl : public _ncclLogical_2DSameDim0AllGatherNoncontinuousOpInterpCtx {
 public:
  _ncclLogical_2DSameDim0AllGatherNoncontinuousOpInterpCtxImpl() = default;
  _ncclLogical_2DSameDim0AllGatherNoncontinuousOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  const int64_t& in_dim1_split_axis() const { return impl_.in_dim1_split_axis(); }
  int64_t* mutable_in_dim1_split_axis() { return impl_.mutable_in_dim1_split_axis(); }
  void set_in_dim1_split_axis(const int64_t& in_dim1_split_axis) { impl_.set_in_dim1_split_axis(in_dim1_split_axis); }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogical_2DSameDim0AllGatherNoncontinuousOp {
 public:
  _ncclLogical_2DSameDim0AllGatherNoncontinuousOp() : internal_(std::make_shared<Internal>()) {}
  
  const int64_t& in_dim1_split_axis() const { return internal_->in_dim1_split_axis; }
  int64_t* mutable_in_dim1_split_axis() { return &internal_->in_dim1_split_axis; }
  void set_in_dim1_split_axis(const int64_t& in_dim1_split_axis) { internal_->in_dim1_split_axis = in_dim1_split_axis; }
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal { 
    int64_t in_dim1_split_axis = -1;
  };

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class _ncclLogical_2DSameDim0AllGatherOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~_ncclLogical_2DSameDim0AllGatherOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class _ncclLogical_2DSameDim0AllGatherOpInterpCtxImpl : public _ncclLogical_2DSameDim0AllGatherOpInterpCtx {
 public:
  _ncclLogical_2DSameDim0AllGatherOpInterpCtxImpl() = default;
  _ncclLogical_2DSameDim0AllGatherOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogical_2DSameDim0AllGatherOp {
 public:
  _ncclLogical_2DSameDim0AllGatherOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class _ncclLogical_2DSameDim0AllReduceOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~_ncclLogical_2DSameDim0AllReduceOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class _ncclLogical_2DSameDim0AllReduceOpInterpCtxImpl : public _ncclLogical_2DSameDim0AllReduceOpInterpCtx {
 public:
  _ncclLogical_2DSameDim0AllReduceOpInterpCtxImpl() = default;
  _ncclLogical_2DSameDim0AllReduceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogical_2DSameDim0AllReduceOp {
 public:
  _ncclLogical_2DSameDim0AllReduceOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

class _ncclLogical_2DSameDim1AllReduceOpInterpCtx : public OpInterpCtx {
 public:
  virtual ~_ncclLogical_2DSameDim1AllReduceOpInterpCtx() = default;

  const HashSet<std::string>& AttrNames() const override;
};

template <typename Provider>
class _ncclLogical_2DSameDim1AllReduceOpInterpCtxImpl : public _ncclLogical_2DSameDim1AllReduceOpInterpCtx {
 public:
  _ncclLogical_2DSameDim1AllReduceOpInterpCtxImpl() = default;
  _ncclLogical_2DSameDim1AllReduceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogical_2DSameDim1AllReduceOp {
 public:
  _ncclLogical_2DSameDim1AllReduceOp() : internal_(std::make_shared<Internal>()) {}
  
  Maybe<AttrVal> GetAttr(const std::string& attr_name) const;

 private:
  struct Internal {};

  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

} // namespace oneflow
