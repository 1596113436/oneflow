/*
Copyright 2020 The OneFlow Authors. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// This file is generated automatically. Please DO NOT EDIT!

#ifndef ONEFLOW_CORE_FRAMEWORK_OP_INTERP_CTX_GENERATED_H_
#define ONEFLOW_CORE_FRAMEWORK_OP_INTERP_CTX_GENERATED_H_

#include "oneflow/core/framework/op_interp_ctx.h"

namespace oneflow {

class COCOReaderOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& session_id() const = 0;
  virtual int64_t* mutable_session_id() = 0;
  virtual void set_session_id(const int64_t& session_id) = 0;

  virtual const std::string& annotation_file() const = 0;
  virtual std::string* mutable_annotation_file() = 0;
  virtual void set_annotation_file(const std::string& annotation_file) = 0;

  virtual const std::string& image_dir() const = 0;
  virtual std::string* mutable_image_dir() = 0;
  virtual void set_image_dir(const std::string& image_dir) = 0;

  virtual const int64_t& batch_size() const = 0;
  virtual int64_t* mutable_batch_size() = 0;
  virtual void set_batch_size(const int64_t& batch_size) = 0;

  virtual const bool& shuffle_after_epoch() const = 0;
  virtual bool* mutable_shuffle_after_epoch() = 0;
  virtual void set_shuffle_after_epoch(const bool& shuffle_after_epoch) = 0;

  virtual const int64_t& random_seed() const = 0;
  virtual int64_t* mutable_random_seed() = 0;
  virtual void set_random_seed(const int64_t& random_seed) = 0;

  virtual const bool& group_by_ratio() const = 0;
  virtual bool* mutable_group_by_ratio() = 0;
  virtual void set_group_by_ratio(const bool& group_by_ratio) = 0;

  virtual const bool& remove_images_without_annotations() const = 0;
  virtual bool* mutable_remove_images_without_annotations() = 0;
  virtual void set_remove_images_without_annotations(
      const bool& remove_images_without_annotations) = 0;

  virtual const bool& stride_partition() const = 0;
  virtual bool* mutable_stride_partition() = 0;
  virtual void set_stride_partition(const bool& stride_partition) = 0;

  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{
        "session_id",          "annotation_file",
        "image_dir",           "batch_size",
        "shuffle_after_epoch", "random_seed",
        "group_by_ratio",      "remove_images_without_annotations",
        "stride_partition",    "nd_sbp"};
    return attr_names;
  }
};
template<typename Provider>
class COCOReaderOpInterpCtxImpl : public COCOReaderOpInterpCtx {
 public:
  COCOReaderOpInterpCtxImpl() = default;
  COCOReaderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& session_id() const override { return impl_.session_id(); }
  int64_t* mutable_session_id() override { return impl_.mutable_session_id(); }
  void set_session_id(const int64_t& session_id) override { impl_.set_session_id(session_id); }

  const std::string& annotation_file() const override { return impl_.annotation_file(); }
  std::string* mutable_annotation_file() override { return impl_.mutable_annotation_file(); }
  void set_annotation_file(const std::string& annotation_file) override {
    impl_.set_annotation_file(annotation_file);
  }

  const std::string& image_dir() const override { return impl_.image_dir(); }
  std::string* mutable_image_dir() override { return impl_.mutable_image_dir(); }
  void set_image_dir(const std::string& image_dir) override { impl_.set_image_dir(image_dir); }

  const int64_t& batch_size() const override { return impl_.batch_size(); }
  int64_t* mutable_batch_size() override { return impl_.mutable_batch_size(); }
  void set_batch_size(const int64_t& batch_size) override { impl_.set_batch_size(batch_size); }

  const bool& shuffle_after_epoch() const override { return impl_.shuffle_after_epoch(); }
  bool* mutable_shuffle_after_epoch() override { return impl_.mutable_shuffle_after_epoch(); }
  void set_shuffle_after_epoch(const bool& shuffle_after_epoch) override {
    impl_.set_shuffle_after_epoch(shuffle_after_epoch);
  }

  const int64_t& random_seed() const override { return impl_.random_seed(); }
  int64_t* mutable_random_seed() override { return impl_.mutable_random_seed(); }
  void set_random_seed(const int64_t& random_seed) override { impl_.set_random_seed(random_seed); }

  const bool& group_by_ratio() const override { return impl_.group_by_ratio(); }
  bool* mutable_group_by_ratio() override { return impl_.mutable_group_by_ratio(); }
  void set_group_by_ratio(const bool& group_by_ratio) override {
    impl_.set_group_by_ratio(group_by_ratio);
  }

  const bool& remove_images_without_annotations() const override {
    return impl_.remove_images_without_annotations();
  }
  bool* mutable_remove_images_without_annotations() override {
    return impl_.mutable_remove_images_without_annotations();
  }
  void set_remove_images_without_annotations(
      const bool& remove_images_without_annotations) override {
    impl_.set_remove_images_without_annotations(remove_images_without_annotations);
  }

  const bool& stride_partition() const override { return impl_.stride_partition(); }
  bool* mutable_stride_partition() override { return impl_.mutable_stride_partition(); }
  void set_stride_partition(const bool& stride_partition) override {
    impl_.set_stride_partition(stride_partition);
  }

  const std::vector<std::string>& nd_sbp() const override { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() override { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) override { impl_.set_nd_sbp(nd_sbp); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class COCOReaderOp {
 public:
  COCOReaderOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "session_id") {
      return CastAttr(&internal_->session_id);
    } else if (attr_name == "annotation_file") {
      return CastAttr(&internal_->annotation_file);
    } else if (attr_name == "image_dir") {
      return CastAttr(&internal_->image_dir);
    } else if (attr_name == "batch_size") {
      return CastAttr(&internal_->batch_size);
    } else if (attr_name == "shuffle_after_epoch") {
      return CastAttr(&internal_->shuffle_after_epoch);
    } else if (attr_name == "random_seed") {
      return CastAttr(&internal_->random_seed);
    } else if (attr_name == "group_by_ratio") {
      return CastAttr(&internal_->group_by_ratio);
    } else if (attr_name == "remove_images_without_annotations") {
      return CastAttr(&internal_->remove_images_without_annotations);
    } else if (attr_name == "stride_partition") {
      return CastAttr(&internal_->stride_partition);
    } else if (attr_name == "nd_sbp") {
      return CastAttr(&internal_->nd_sbp);
    } else {
      return Error::RuntimeError() << "COCOReader op has no attribute named " << attr_name;
    }
  }

  const int64_t& session_id() const { return internal_->session_id; }
  int64_t* mutable_session_id() { return &internal_->session_id; }
  void set_session_id(const int64_t& session_id) { internal_->session_id = session_id; }

  const std::string& annotation_file() const { return internal_->annotation_file; }
  std::string* mutable_annotation_file() { return &internal_->annotation_file; }
  void set_annotation_file(const std::string& annotation_file) {
    internal_->annotation_file = annotation_file;
  }

  const std::string& image_dir() const { return internal_->image_dir; }
  std::string* mutable_image_dir() { return &internal_->image_dir; }
  void set_image_dir(const std::string& image_dir) { internal_->image_dir = image_dir; }

  const int64_t& batch_size() const { return internal_->batch_size; }
  int64_t* mutable_batch_size() { return &internal_->batch_size; }
  void set_batch_size(const int64_t& batch_size) { internal_->batch_size = batch_size; }

  const bool& shuffle_after_epoch() const { return internal_->shuffle_after_epoch; }
  bool* mutable_shuffle_after_epoch() { return &internal_->shuffle_after_epoch; }
  void set_shuffle_after_epoch(const bool& shuffle_after_epoch) {
    internal_->shuffle_after_epoch = shuffle_after_epoch;
  }

  const int64_t& random_seed() const { return internal_->random_seed; }
  int64_t* mutable_random_seed() { return &internal_->random_seed; }
  void set_random_seed(const int64_t& random_seed) { internal_->random_seed = random_seed; }

  const bool& group_by_ratio() const { return internal_->group_by_ratio; }
  bool* mutable_group_by_ratio() { return &internal_->group_by_ratio; }
  void set_group_by_ratio(const bool& group_by_ratio) {
    internal_->group_by_ratio = group_by_ratio;
  }

  const bool& remove_images_without_annotations() const {
    return internal_->remove_images_without_annotations;
  }
  bool* mutable_remove_images_without_annotations() {
    return &internal_->remove_images_without_annotations;
  }
  void set_remove_images_without_annotations(const bool& remove_images_without_annotations) {
    internal_->remove_images_without_annotations = remove_images_without_annotations;
  }

  const bool& stride_partition() const { return internal_->stride_partition; }
  bool* mutable_stride_partition() { return &internal_->stride_partition; }
  void set_stride_partition(const bool& stride_partition) {
    internal_->stride_partition = stride_partition;
  }

  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }

 private:
  struct Internal {
    int64_t session_id;
    std::string annotation_file;
    std::string image_dir;
    int64_t batch_size;
    bool shuffle_after_epoch;
    int64_t random_seed;
    bool group_by_ratio;
    bool remove_images_without_annotations;
    bool stride_partition;
    std::vector<std::string> nd_sbp;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.COCOReader", COCOReaderOpInterpCtxImpl<schema::COCOReaderOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CategoricalOrdinalEncodeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& hash_precomputed() const = 0;
  virtual bool* mutable_hash_precomputed() = 0;
  virtual void set_hash_precomputed(const bool& hash_precomputed) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"hash_precomputed"};
    return attr_names;
  }
};
template<typename Provider>
class CategoricalOrdinalEncodeOpInterpCtxImpl : public CategoricalOrdinalEncodeOpInterpCtx {
 public:
  CategoricalOrdinalEncodeOpInterpCtxImpl() = default;
  CategoricalOrdinalEncodeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& hash_precomputed() const override { return impl_.hash_precomputed(); }
  bool* mutable_hash_precomputed() override { return impl_.mutable_hash_precomputed(); }
  void set_hash_precomputed(const bool& hash_precomputed) override {
    impl_.set_hash_precomputed(hash_precomputed);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CategoricalOrdinalEncodeOp {
 public:
  CategoricalOrdinalEncodeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "hash_precomputed") {
      return CastAttr(&internal_->hash_precomputed);
    } else {
      return Error::RuntimeError()
             << "CategoricalOrdinalEncode op has no attribute named " << attr_name;
    }
  }

  const bool& hash_precomputed() const { return internal_->hash_precomputed; }
  bool* mutable_hash_precomputed() { return &internal_->hash_precomputed; }
  void set_hash_precomputed(const bool& hash_precomputed) {
    internal_->hash_precomputed = hash_precomputed;
  }

 private:
  struct Internal {
    bool hash_precomputed;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.CategoricalOrdinalEncode",
                       CategoricalOrdinalEncodeOpInterpCtxImpl<schema::CategoricalOrdinalEncodeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class OFRecordReaderOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& data_dir() const = 0;
  virtual std::string* mutable_data_dir() = 0;
  virtual void set_data_dir(const std::string& data_dir) = 0;

  virtual const int32_t& data_part_num() const = 0;
  virtual int32_t* mutable_data_part_num() = 0;
  virtual void set_data_part_num(const int32_t& data_part_num) = 0;

  virtual const int32_t& batch_size() const = 0;
  virtual int32_t* mutable_batch_size() = 0;
  virtual void set_batch_size(const int32_t& batch_size) = 0;

  virtual const std::string& part_name_prefix() const = 0;
  virtual std::string* mutable_part_name_prefix() = 0;
  virtual void set_part_name_prefix(const std::string& part_name_prefix) = 0;

  virtual const int32_t& part_name_suffix_length() const = 0;
  virtual int32_t* mutable_part_name_suffix_length() = 0;
  virtual void set_part_name_suffix_length(const int32_t& part_name_suffix_length) = 0;

  virtual const bool& random_shuffle() const = 0;
  virtual bool* mutable_random_shuffle() = 0;
  virtual void set_random_shuffle(const bool& random_shuffle) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const int32_t& shuffle_buffer_size() const = 0;
  virtual int32_t* mutable_shuffle_buffer_size() = 0;
  virtual void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) = 0;

  virtual const bool& shuffle_after_epoch() const = 0;
  virtual bool* mutable_shuffle_after_epoch() = 0;
  virtual void set_shuffle_after_epoch(const bool& shuffle_after_epoch) = 0;

  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"data_dir",
                                           "data_part_num",
                                           "batch_size",
                                           "part_name_prefix",
                                           "part_name_suffix_length",
                                           "random_shuffle",
                                           "seed",
                                           "shuffle_buffer_size",
                                           "shuffle_after_epoch",
                                           "nd_sbp"};
    return attr_names;
  }
};
template<typename Provider>
class OFRecordReaderOpInterpCtxImpl : public OFRecordReaderOpInterpCtx {
 public:
  OFRecordReaderOpInterpCtxImpl() = default;
  OFRecordReaderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& data_dir() const override { return impl_.data_dir(); }
  std::string* mutable_data_dir() override { return impl_.mutable_data_dir(); }
  void set_data_dir(const std::string& data_dir) override { impl_.set_data_dir(data_dir); }

  const int32_t& data_part_num() const override { return impl_.data_part_num(); }
  int32_t* mutable_data_part_num() override { return impl_.mutable_data_part_num(); }
  void set_data_part_num(const int32_t& data_part_num) override {
    impl_.set_data_part_num(data_part_num);
  }

  const int32_t& batch_size() const override { return impl_.batch_size(); }
  int32_t* mutable_batch_size() override { return impl_.mutable_batch_size(); }
  void set_batch_size(const int32_t& batch_size) override { impl_.set_batch_size(batch_size); }

  const std::string& part_name_prefix() const override { return impl_.part_name_prefix(); }
  std::string* mutable_part_name_prefix() override { return impl_.mutable_part_name_prefix(); }
  void set_part_name_prefix(const std::string& part_name_prefix) override {
    impl_.set_part_name_prefix(part_name_prefix);
  }

  const int32_t& part_name_suffix_length() const override {
    return impl_.part_name_suffix_length();
  }
  int32_t* mutable_part_name_suffix_length() override {
    return impl_.mutable_part_name_suffix_length();
  }
  void set_part_name_suffix_length(const int32_t& part_name_suffix_length) override {
    impl_.set_part_name_suffix_length(part_name_suffix_length);
  }

  const bool& random_shuffle() const override { return impl_.random_shuffle(); }
  bool* mutable_random_shuffle() override { return impl_.mutable_random_shuffle(); }
  void set_random_shuffle(const bool& random_shuffle) override {
    impl_.set_random_shuffle(random_shuffle);
  }

  const int64_t& seed() const override { return impl_.seed(); }
  int64_t* mutable_seed() override { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) override { impl_.set_seed(seed); }

  const int32_t& shuffle_buffer_size() const override { return impl_.shuffle_buffer_size(); }
  int32_t* mutable_shuffle_buffer_size() override { return impl_.mutable_shuffle_buffer_size(); }
  void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) override {
    impl_.set_shuffle_buffer_size(shuffle_buffer_size);
  }

  const bool& shuffle_after_epoch() const override { return impl_.shuffle_after_epoch(); }
  bool* mutable_shuffle_after_epoch() override { return impl_.mutable_shuffle_after_epoch(); }
  void set_shuffle_after_epoch(const bool& shuffle_after_epoch) override {
    impl_.set_shuffle_after_epoch(shuffle_after_epoch);
  }

  const std::vector<std::string>& nd_sbp() const override { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() override { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) override { impl_.set_nd_sbp(nd_sbp); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OFRecordReaderOp {
 public:
  OFRecordReaderOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "data_dir") {
      return CastAttr(&internal_->data_dir);
    } else if (attr_name == "data_part_num") {
      return CastAttr(&internal_->data_part_num);
    } else if (attr_name == "batch_size") {
      return CastAttr(&internal_->batch_size);
    } else if (attr_name == "part_name_prefix") {
      return CastAttr(&internal_->part_name_prefix);
    } else if (attr_name == "part_name_suffix_length") {
      return CastAttr(&internal_->part_name_suffix_length);
    } else if (attr_name == "random_shuffle") {
      return CastAttr(&internal_->random_shuffle);
    } else if (attr_name == "seed") {
      return CastAttr(&internal_->seed);
    } else if (attr_name == "shuffle_buffer_size") {
      return CastAttr(&internal_->shuffle_buffer_size);
    } else if (attr_name == "shuffle_after_epoch") {
      return CastAttr(&internal_->shuffle_after_epoch);
    } else if (attr_name == "nd_sbp") {
      return CastAttr(&internal_->nd_sbp);
    } else {
      return Error::RuntimeError() << "OFRecordReader op has no attribute named " << attr_name;
    }
  }

  const std::string& data_dir() const { return internal_->data_dir; }
  std::string* mutable_data_dir() { return &internal_->data_dir; }
  void set_data_dir(const std::string& data_dir) { internal_->data_dir = data_dir; }

  const int32_t& data_part_num() const { return internal_->data_part_num; }
  int32_t* mutable_data_part_num() { return &internal_->data_part_num; }
  void set_data_part_num(const int32_t& data_part_num) { internal_->data_part_num = data_part_num; }

  const int32_t& batch_size() const { return internal_->batch_size; }
  int32_t* mutable_batch_size() { return &internal_->batch_size; }
  void set_batch_size(const int32_t& batch_size) { internal_->batch_size = batch_size; }

  const std::string& part_name_prefix() const { return internal_->part_name_prefix; }
  std::string* mutable_part_name_prefix() { return &internal_->part_name_prefix; }
  void set_part_name_prefix(const std::string& part_name_prefix) {
    internal_->part_name_prefix = part_name_prefix;
  }

  const int32_t& part_name_suffix_length() const { return internal_->part_name_suffix_length; }
  int32_t* mutable_part_name_suffix_length() { return &internal_->part_name_suffix_length; }
  void set_part_name_suffix_length(const int32_t& part_name_suffix_length) {
    internal_->part_name_suffix_length = part_name_suffix_length;
  }

  const bool& random_shuffle() const { return internal_->random_shuffle; }
  bool* mutable_random_shuffle() { return &internal_->random_shuffle; }
  void set_random_shuffle(const bool& random_shuffle) {
    internal_->random_shuffle = random_shuffle;
  }

  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }

  const int32_t& shuffle_buffer_size() const { return internal_->shuffle_buffer_size; }
  int32_t* mutable_shuffle_buffer_size() { return &internal_->shuffle_buffer_size; }
  void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) {
    internal_->shuffle_buffer_size = shuffle_buffer_size;
  }

  const bool& shuffle_after_epoch() const { return internal_->shuffle_after_epoch; }
  bool* mutable_shuffle_after_epoch() { return &internal_->shuffle_after_epoch; }
  void set_shuffle_after_epoch(const bool& shuffle_after_epoch) {
    internal_->shuffle_after_epoch = shuffle_after_epoch;
  }

  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }

 private:
  struct Internal {
    std::string data_dir;
    int32_t data_part_num;
    int32_t batch_size;
    std::string part_name_prefix;
    int32_t part_name_suffix_length;
    bool random_shuffle;
    int64_t seed;
    int32_t shuffle_buffer_size;
    bool shuffle_after_epoch;
    std::vector<std::string> nd_sbp;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.OFRecordReader",
                       OFRecordReaderOpInterpCtxImpl<schema::OFRecordReaderOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class OneRecReaderOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<std::string>& files() const = 0;
  virtual std::vector<std::string>* mutable_files() = 0;
  virtual void set_files(const std::vector<std::string>& files) = 0;

  virtual const int32_t& batch_size() const = 0;
  virtual int32_t* mutable_batch_size() = 0;
  virtual void set_batch_size(const int32_t& batch_size) = 0;

  virtual const bool& random_shuffle() const = 0;
  virtual bool* mutable_random_shuffle() = 0;
  virtual void set_random_shuffle(const bool& random_shuffle) = 0;

  virtual const std::string& shuffle_mode() const = 0;
  virtual std::string* mutable_shuffle_mode() = 0;
  virtual void set_shuffle_mode(const std::string& shuffle_mode) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const int32_t& shuffle_buffer_size() const = 0;
  virtual int32_t* mutable_shuffle_buffer_size() = 0;
  virtual void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) = 0;

  virtual const bool& shuffle_after_epoch() const = 0;
  virtual bool* mutable_shuffle_after_epoch() = 0;
  virtual void set_shuffle_after_epoch(const bool& shuffle_after_epoch) = 0;

  virtual const bool& verify_example() const = 0;
  virtual bool* mutable_verify_example() = 0;
  virtual void set_verify_example(const bool& verify_example) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{
        "files", "batch_size",          "random_shuffle",      "shuffle_mode",
        "seed",  "shuffle_buffer_size", "shuffle_after_epoch", "verify_example"};
    return attr_names;
  }
};
template<typename Provider>
class OneRecReaderOpInterpCtxImpl : public OneRecReaderOpInterpCtx {
 public:
  OneRecReaderOpInterpCtxImpl() = default;
  OneRecReaderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<std::string>& files() const override { return impl_.files(); }
  std::vector<std::string>* mutable_files() override { return impl_.mutable_files(); }
  void set_files(const std::vector<std::string>& files) override { impl_.set_files(files); }

  const int32_t& batch_size() const override { return impl_.batch_size(); }
  int32_t* mutable_batch_size() override { return impl_.mutable_batch_size(); }
  void set_batch_size(const int32_t& batch_size) override { impl_.set_batch_size(batch_size); }

  const bool& random_shuffle() const override { return impl_.random_shuffle(); }
  bool* mutable_random_shuffle() override { return impl_.mutable_random_shuffle(); }
  void set_random_shuffle(const bool& random_shuffle) override {
    impl_.set_random_shuffle(random_shuffle);
  }

  const std::string& shuffle_mode() const override { return impl_.shuffle_mode(); }
  std::string* mutable_shuffle_mode() override { return impl_.mutable_shuffle_mode(); }
  void set_shuffle_mode(const std::string& shuffle_mode) override {
    impl_.set_shuffle_mode(shuffle_mode);
  }

  const int64_t& seed() const override { return impl_.seed(); }
  int64_t* mutable_seed() override { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) override { impl_.set_seed(seed); }

  const int32_t& shuffle_buffer_size() const override { return impl_.shuffle_buffer_size(); }
  int32_t* mutable_shuffle_buffer_size() override { return impl_.mutable_shuffle_buffer_size(); }
  void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) override {
    impl_.set_shuffle_buffer_size(shuffle_buffer_size);
  }

  const bool& shuffle_after_epoch() const override { return impl_.shuffle_after_epoch(); }
  bool* mutable_shuffle_after_epoch() override { return impl_.mutable_shuffle_after_epoch(); }
  void set_shuffle_after_epoch(const bool& shuffle_after_epoch) override {
    impl_.set_shuffle_after_epoch(shuffle_after_epoch);
  }

  const bool& verify_example() const override { return impl_.verify_example(); }
  bool* mutable_verify_example() override { return impl_.mutable_verify_example(); }
  void set_verify_example(const bool& verify_example) override {
    impl_.set_verify_example(verify_example);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OneRecReaderOp {
 public:
  OneRecReaderOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "files") {
      return CastAttr(&internal_->files);
    } else if (attr_name == "batch_size") {
      return CastAttr(&internal_->batch_size);
    } else if (attr_name == "random_shuffle") {
      return CastAttr(&internal_->random_shuffle);
    } else if (attr_name == "shuffle_mode") {
      return CastAttr(&internal_->shuffle_mode);
    } else if (attr_name == "seed") {
      return CastAttr(&internal_->seed);
    } else if (attr_name == "shuffle_buffer_size") {
      return CastAttr(&internal_->shuffle_buffer_size);
    } else if (attr_name == "shuffle_after_epoch") {
      return CastAttr(&internal_->shuffle_after_epoch);
    } else if (attr_name == "verify_example") {
      return CastAttr(&internal_->verify_example);
    } else {
      return Error::RuntimeError() << "OneRecReader op has no attribute named " << attr_name;
    }
  }

  const std::vector<std::string>& files() const { return internal_->files; }
  std::vector<std::string>* mutable_files() { return &internal_->files; }
  void set_files(const std::vector<std::string>& files) { internal_->files = files; }

  const int32_t& batch_size() const { return internal_->batch_size; }
  int32_t* mutable_batch_size() { return &internal_->batch_size; }
  void set_batch_size(const int32_t& batch_size) { internal_->batch_size = batch_size; }

  const bool& random_shuffle() const { return internal_->random_shuffle; }
  bool* mutable_random_shuffle() { return &internal_->random_shuffle; }
  void set_random_shuffle(const bool& random_shuffle) {
    internal_->random_shuffle = random_shuffle;
  }

  const std::string& shuffle_mode() const { return internal_->shuffle_mode; }
  std::string* mutable_shuffle_mode() { return &internal_->shuffle_mode; }
  void set_shuffle_mode(const std::string& shuffle_mode) { internal_->shuffle_mode = shuffle_mode; }

  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }

  const int32_t& shuffle_buffer_size() const { return internal_->shuffle_buffer_size; }
  int32_t* mutable_shuffle_buffer_size() { return &internal_->shuffle_buffer_size; }
  void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) {
    internal_->shuffle_buffer_size = shuffle_buffer_size;
  }

  const bool& shuffle_after_epoch() const { return internal_->shuffle_after_epoch; }
  bool* mutable_shuffle_after_epoch() { return &internal_->shuffle_after_epoch; }
  void set_shuffle_after_epoch(const bool& shuffle_after_epoch) {
    internal_->shuffle_after_epoch = shuffle_after_epoch;
  }

  const bool& verify_example() const { return internal_->verify_example; }
  bool* mutable_verify_example() { return &internal_->verify_example; }
  void set_verify_example(const bool& verify_example) {
    internal_->verify_example = verify_example;
  }

 private:
  struct Internal {
    std::vector<std::string> files;
    int32_t batch_size;
    bool random_shuffle;
    std::string shuffle_mode;
    int64_t seed;
    int32_t shuffle_buffer_size;
    bool shuffle_after_epoch;
    bool verify_example;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.OneRecReader", OneRecReaderOpInterpCtxImpl<schema::OneRecReaderOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TestDataTypeAttrOpInterpCtx : public OpInterpCtx {
 public:
  virtual const DataType& output_type() const = 0;
  virtual DataType* mutable_output_type() = 0;
  virtual void set_output_type(const DataType& output_type) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"output_type"};
    return attr_names;
  }
};
template<typename Provider>
class TestDataTypeAttrOpInterpCtxImpl : public TestDataTypeAttrOpInterpCtx {
 public:
  TestDataTypeAttrOpInterpCtxImpl() = default;
  TestDataTypeAttrOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const DataType& output_type() const override { return impl_.output_type(); }
  DataType* mutable_output_type() override { return impl_.mutable_output_type(); }
  void set_output_type(const DataType& output_type) override { impl_.set_output_type(output_type); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestDataTypeAttrOp {
 public:
  TestDataTypeAttrOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "output_type") {
      return CastAttr(&internal_->output_type);
    } else {
      return Error::RuntimeError() << "TestDataTypeAttr op has no attribute named " << attr_name;
    }
  }

  const DataType& output_type() const { return internal_->output_type; }
  DataType* mutable_output_type() { return &internal_->output_type; }
  void set_output_type(const DataType& output_type) { internal_->output_type = output_type; }

 private:
  struct Internal {
    DataType output_type;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.TestDataTypeAttr",
                       TestDataTypeAttrOpInterpCtxImpl<schema::TestDataTypeAttrOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TestDynamicSourceOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class TestDynamicSourceOpInterpCtxImpl : public TestDynamicSourceOpInterpCtx {
 public:
  TestDynamicSourceOpInterpCtxImpl() = default;
  TestDynamicSourceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestDynamicSourceOp {
 public:
  TestDynamicSourceOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "TestDynamicSource op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.TestDynamicSource",
                       TestDynamicSourceOpInterpCtxImpl<schema::TestDynamicSourceOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TestListDataTypeAndListShapeAndListStringAttrOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<Shape>& out_shapes() const = 0;
  virtual std::vector<Shape>* mutable_out_shapes() = 0;
  virtual void set_out_shapes(const std::vector<Shape>& out_shapes) = 0;

  virtual const std::vector<DataType>& out_types() const = 0;
  virtual std::vector<DataType>* mutable_out_types() = 0;
  virtual void set_out_types(const std::vector<DataType>& out_types) = 0;

  virtual const std::vector<std::string>& string_list() const = 0;
  virtual std::vector<std::string>* mutable_string_list() = 0;
  virtual void set_string_list(const std::vector<std::string>& string_list) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"out_shapes", "out_types", "string_list"};
    return attr_names;
  }
};
template<typename Provider>
class TestListDataTypeAndListShapeAndListStringAttrOpInterpCtxImpl
    : public TestListDataTypeAndListShapeAndListStringAttrOpInterpCtx {
 public:
  TestListDataTypeAndListShapeAndListStringAttrOpInterpCtxImpl() = default;
  TestListDataTypeAndListShapeAndListStringAttrOpInterpCtxImpl(const Provider& impl)
      : impl_(impl) {}

  const std::vector<Shape>& out_shapes() const override { return impl_.out_shapes(); }
  std::vector<Shape>* mutable_out_shapes() override { return impl_.mutable_out_shapes(); }
  void set_out_shapes(const std::vector<Shape>& out_shapes) override {
    impl_.set_out_shapes(out_shapes);
  }

  const std::vector<DataType>& out_types() const override { return impl_.out_types(); }
  std::vector<DataType>* mutable_out_types() override { return impl_.mutable_out_types(); }
  void set_out_types(const std::vector<DataType>& out_types) override {
    impl_.set_out_types(out_types);
  }

  const std::vector<std::string>& string_list() const override { return impl_.string_list(); }
  std::vector<std::string>* mutable_string_list() override { return impl_.mutable_string_list(); }
  void set_string_list(const std::vector<std::string>& string_list) override {
    impl_.set_string_list(string_list);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestListDataTypeAndListShapeAndListStringAttrOp {
 public:
  TestListDataTypeAndListShapeAndListStringAttrOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "out_shapes") {
      return CastAttr(&internal_->out_shapes);
    } else if (attr_name == "out_types") {
      return CastAttr(&internal_->out_types);
    } else if (attr_name == "string_list") {
      return CastAttr(&internal_->string_list);
    } else {
      return Error::RuntimeError()
             << "TestListDataTypeAndListShapeAndListStringAttr op has no attribute named "
             << attr_name;
    }
  }

  const std::vector<Shape>& out_shapes() const { return internal_->out_shapes; }
  std::vector<Shape>* mutable_out_shapes() { return &internal_->out_shapes; }
  void set_out_shapes(const std::vector<Shape>& out_shapes) { internal_->out_shapes = out_shapes; }

  const std::vector<DataType>& out_types() const { return internal_->out_types; }
  std::vector<DataType>* mutable_out_types() { return &internal_->out_types; }
  void set_out_types(const std::vector<DataType>& out_types) { internal_->out_types = out_types; }

  const std::vector<std::string>& string_list() const { return internal_->string_list; }
  std::vector<std::string>* mutable_string_list() { return &internal_->string_list; }
  void set_string_list(const std::vector<std::string>& string_list) {
    internal_->string_list = string_list;
  }

 private:
  struct Internal {
    std::vector<Shape> out_shapes;
    std::vector<DataType> out_types;
    std::vector<std::string> string_list;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.TestListDataTypeAndListShapeAndListStringAttr",
                       TestListDataTypeAndListShapeAndListStringAttrOpInterpCtxImpl<
                           schema::TestListDataTypeAndListShapeAndListStringAttrOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TestMultiInputOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class TestMultiInputOpInterpCtxImpl : public TestMultiInputOpInterpCtx {
 public:
  TestMultiInputOpInterpCtxImpl() = default;
  TestMultiInputOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestMultiInputOp {
 public:
  TestMultiInputOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "TestMultiInput op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.TestMultiInput",
                       TestMultiInputOpInterpCtxImpl<schema::TestMultiInputOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TestMultiInputGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class TestMultiInputGradOpInterpCtxImpl : public TestMultiInputGradOpInterpCtx {
 public:
  TestMultiInputGradOpInterpCtxImpl() = default;
  TestMultiInputGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestMultiInputGradOp {
 public:
  TestMultiInputGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "TestMultiInputGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.TestMultiInputGrad",
                       TestMultiInputGradOpInterpCtxImpl<schema::TestMultiInputGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TestMultiOutputOrderOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class TestMultiOutputOrderOpInterpCtxImpl : public TestMultiOutputOrderOpInterpCtx {
 public:
  TestMultiOutputOrderOpInterpCtxImpl() = default;
  TestMultiOutputOrderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestMultiOutputOrderOp {
 public:
  TestMultiOutputOrderOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "TestMultiOutputOrder op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.TestMultiOutputOrder",
                       TestMultiOutputOrderOpInterpCtxImpl<schema::TestMultiOutputOrderOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TestRandomSourceOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"seed"};
    return attr_names;
  }
};
template<typename Provider>
class TestRandomSourceOpInterpCtxImpl : public TestRandomSourceOpInterpCtx {
 public:
  TestRandomSourceOpInterpCtxImpl() = default;
  TestRandomSourceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& seed() const override { return impl_.seed(); }
  int64_t* mutable_seed() override { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) override { impl_.set_seed(seed); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestRandomSourceOp {
 public:
  TestRandomSourceOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "seed") {
      return CastAttr(&internal_->seed);
    } else {
      return Error::RuntimeError() << "TestRandomSource op has no attribute named " << attr_name;
    }
  }

  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }

 private:
  struct Internal {
    int64_t seed;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.TestRandomSource",
                       TestRandomSourceOpInterpCtxImpl<schema::TestRandomSourceOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TestReshapeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"shape"};
    return attr_names;
  }
};
template<typename Provider>
class TestReshapeOpInterpCtxImpl : public TestReshapeOpInterpCtx {
 public:
  TestReshapeOpInterpCtxImpl() = default;
  TestReshapeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestReshapeOp {
 public:
  TestReshapeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else {
      return Error::RuntimeError() << "TestReshape op has no attribute named " << attr_name;
    }
  }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

 private:
  struct Internal {
    Shape shape;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.TestReshape", TestReshapeOpInterpCtxImpl<schema::TestReshapeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TestSourceOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class TestSourceOpInterpCtxImpl : public TestSourceOpInterpCtx {
 public:
  TestSourceOpInterpCtxImpl() = default;
  TestSourceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestSourceOp {
 public:
  TestSourceOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "TestSource op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.TestSource", TestSourceOpInterpCtxImpl<schema::TestSourceOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TestSourceMultiGpuFixedOutNumOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& out_num() const = 0;
  virtual int64_t* mutable_out_num() = 0;
  virtual void set_out_num(const int64_t& out_num) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"out_num"};
    return attr_names;
  }
};
template<typename Provider>
class TestSourceMultiGpuFixedOutNumOpInterpCtxImpl
    : public TestSourceMultiGpuFixedOutNumOpInterpCtx {
 public:
  TestSourceMultiGpuFixedOutNumOpInterpCtxImpl() = default;
  TestSourceMultiGpuFixedOutNumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& out_num() const override { return impl_.out_num(); }
  int64_t* mutable_out_num() override { return impl_.mutable_out_num(); }
  void set_out_num(const int64_t& out_num) override { impl_.set_out_num(out_num); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestSourceMultiGpuFixedOutNumOp {
 public:
  TestSourceMultiGpuFixedOutNumOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "out_num") {
      return CastAttr(&internal_->out_num);
    } else {
      return Error::RuntimeError()
             << "TestSourceMultiGpuFixedOutNum op has no attribute named " << attr_name;
    }
  }

  const int64_t& out_num() const { return internal_->out_num; }
  int64_t* mutable_out_num() { return &internal_->out_num; }
  void set_out_num(const int64_t& out_num) { internal_->out_num = out_num; }

 private:
  struct Internal {
    int64_t out_num;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.TestSourceMultiGpuFixedOutNum",
    TestSourceMultiGpuFixedOutNumOpInterpCtxImpl<schema::TestSourceMultiGpuFixedOutNumOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class _ncclLogical_2DSameDim0All2allOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& in_dim1_split_axis() const = 0;
  virtual int64_t* mutable_in_dim1_split_axis() = 0;
  virtual void set_in_dim1_split_axis(const int64_t& in_dim1_split_axis) = 0;

  virtual const int64_t& out_dim1_split_axis() const = 0;
  virtual int64_t* mutable_out_dim1_split_axis() = 0;
  virtual void set_out_dim1_split_axis(const int64_t& out_dim1_split_axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"in_dim1_split_axis", "out_dim1_split_axis"};
    return attr_names;
  }
};
template<typename Provider>
class _ncclLogical_2DSameDim0All2allOpInterpCtxImpl
    : public _ncclLogical_2DSameDim0All2allOpInterpCtx {
 public:
  _ncclLogical_2DSameDim0All2allOpInterpCtxImpl() = default;
  _ncclLogical_2DSameDim0All2allOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& in_dim1_split_axis() const override { return impl_.in_dim1_split_axis(); }
  int64_t* mutable_in_dim1_split_axis() override { return impl_.mutable_in_dim1_split_axis(); }
  void set_in_dim1_split_axis(const int64_t& in_dim1_split_axis) override {
    impl_.set_in_dim1_split_axis(in_dim1_split_axis);
  }

  const int64_t& out_dim1_split_axis() const override { return impl_.out_dim1_split_axis(); }
  int64_t* mutable_out_dim1_split_axis() override { return impl_.mutable_out_dim1_split_axis(); }
  void set_out_dim1_split_axis(const int64_t& out_dim1_split_axis) override {
    impl_.set_out_dim1_split_axis(out_dim1_split_axis);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogical_2DSameDim0All2allOp {
 public:
  _ncclLogical_2DSameDim0All2allOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "in_dim1_split_axis") {
      return CastAttr(&internal_->in_dim1_split_axis);
    } else if (attr_name == "out_dim1_split_axis") {
      return CastAttr(&internal_->out_dim1_split_axis);
    } else {
      return Error::RuntimeError()
             << "_ncclLogical_2DSameDim0All2all op has no attribute named " << attr_name;
    }
  }

  const int64_t& in_dim1_split_axis() const { return internal_->in_dim1_split_axis; }
  int64_t* mutable_in_dim1_split_axis() { return &internal_->in_dim1_split_axis; }
  void set_in_dim1_split_axis(const int64_t& in_dim1_split_axis) {
    internal_->in_dim1_split_axis = in_dim1_split_axis;
  }

  const int64_t& out_dim1_split_axis() const { return internal_->out_dim1_split_axis; }
  int64_t* mutable_out_dim1_split_axis() { return &internal_->out_dim1_split_axis; }
  void set_out_dim1_split_axis(const int64_t& out_dim1_split_axis) {
    internal_->out_dim1_split_axis = out_dim1_split_axis;
  }

 private:
  struct Internal {
    int64_t in_dim1_split_axis;
    int64_t out_dim1_split_axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user._nccl_logical_2D_same_dim0_all2all",
    _ncclLogical_2DSameDim0All2allOpInterpCtxImpl<schema::_ncclLogical_2DSameDim0All2allOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class _ncclLogical_2DSameDim0AllGatherOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class _ncclLogical_2DSameDim0AllGatherOpInterpCtxImpl
    : public _ncclLogical_2DSameDim0AllGatherOpInterpCtx {
 public:
  _ncclLogical_2DSameDim0AllGatherOpInterpCtxImpl() = default;
  _ncclLogical_2DSameDim0AllGatherOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogical_2DSameDim0AllGatherOp {
 public:
  _ncclLogical_2DSameDim0AllGatherOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "_ncclLogical_2DSameDim0AllGather op has no attribute named "
                                 << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user._nccl_logical_2D_same_dim0_all_gather",
    _ncclLogical_2DSameDim0AllGatherOpInterpCtxImpl<schema::_ncclLogical_2DSameDim0AllGatherOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class _ncclLogical_2DSameDim0AllGatherNoncontinuousOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& in_dim1_split_axis() const = 0;
  virtual int64_t* mutable_in_dim1_split_axis() = 0;
  virtual void set_in_dim1_split_axis(const int64_t& in_dim1_split_axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"in_dim1_split_axis"};
    return attr_names;
  }
};
template<typename Provider>
class _ncclLogical_2DSameDim0AllGatherNoncontinuousOpInterpCtxImpl
    : public _ncclLogical_2DSameDim0AllGatherNoncontinuousOpInterpCtx {
 public:
  _ncclLogical_2DSameDim0AllGatherNoncontinuousOpInterpCtxImpl() = default;
  _ncclLogical_2DSameDim0AllGatherNoncontinuousOpInterpCtxImpl(const Provider& impl)
      : impl_(impl) {}

  const int64_t& in_dim1_split_axis() const override { return impl_.in_dim1_split_axis(); }
  int64_t* mutable_in_dim1_split_axis() override { return impl_.mutable_in_dim1_split_axis(); }
  void set_in_dim1_split_axis(const int64_t& in_dim1_split_axis) override {
    impl_.set_in_dim1_split_axis(in_dim1_split_axis);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogical_2DSameDim0AllGatherNoncontinuousOp {
 public:
  _ncclLogical_2DSameDim0AllGatherNoncontinuousOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "in_dim1_split_axis") {
      return CastAttr(&internal_->in_dim1_split_axis);
    } else {
      return Error::RuntimeError()
             << "_ncclLogical_2DSameDim0AllGatherNoncontinuous op has no attribute named "
             << attr_name;
    }
  }

  const int64_t& in_dim1_split_axis() const { return internal_->in_dim1_split_axis; }
  int64_t* mutable_in_dim1_split_axis() { return &internal_->in_dim1_split_axis; }
  void set_in_dim1_split_axis(const int64_t& in_dim1_split_axis) {
    internal_->in_dim1_split_axis = in_dim1_split_axis;
  }

 private:
  struct Internal {
    int64_t in_dim1_split_axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user._nccl_logical_2D_same_dim0_all_gather_noncontinuous",
                       _ncclLogical_2DSameDim0AllGatherNoncontinuousOpInterpCtxImpl<
                           schema::_ncclLogical_2DSameDim0AllGatherNoncontinuousOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class _ncclLogical_2DSameDim0AllReduceOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class _ncclLogical_2DSameDim0AllReduceOpInterpCtxImpl
    : public _ncclLogical_2DSameDim0AllReduceOpInterpCtx {
 public:
  _ncclLogical_2DSameDim0AllReduceOpInterpCtxImpl() = default;
  _ncclLogical_2DSameDim0AllReduceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogical_2DSameDim0AllReduceOp {
 public:
  _ncclLogical_2DSameDim0AllReduceOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "_ncclLogical_2DSameDim0AllReduce op has no attribute named "
                                 << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user._nccl_logical_2D_same_dim0_all_reduce",
    _ncclLogical_2DSameDim0AllReduceOpInterpCtxImpl<schema::_ncclLogical_2DSameDim0AllReduceOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class _ncclLogical_2DSameDim1AllReduceOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class _ncclLogical_2DSameDim1AllReduceOpInterpCtxImpl
    : public _ncclLogical_2DSameDim1AllReduceOpInterpCtx {
 public:
  _ncclLogical_2DSameDim1AllReduceOpInterpCtxImpl() = default;
  _ncclLogical_2DSameDim1AllReduceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogical_2DSameDim1AllReduceOp {
 public:
  _ncclLogical_2DSameDim1AllReduceOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "_ncclLogical_2DSameDim1AllReduce op has no attribute named "
                                 << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user._nccl_logical_2D_same_dim1_all_reduce",
    _ncclLogical_2DSameDim1AllReduceOpInterpCtxImpl<schema::_ncclLogical_2DSameDim1AllReduceOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class _ncclLogicalAllGatherOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class _ncclLogicalAllGatherOpInterpCtxImpl : public _ncclLogicalAllGatherOpInterpCtx {
 public:
  _ncclLogicalAllGatherOpInterpCtxImpl() = default;
  _ncclLogicalAllGatherOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogicalAllGatherOp {
 public:
  _ncclLogicalAllGatherOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "_ncclLogicalAllGather op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user._nccl_logical_all_gather",
                       _ncclLogicalAllGatherOpInterpCtxImpl<schema::_ncclLogicalAllGatherOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class _ncclLogicalAllGatherNoncontinuousOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& in_split_axis() const = 0;
  virtual int64_t* mutable_in_split_axis() = 0;
  virtual void set_in_split_axis(const int64_t& in_split_axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"in_split_axis"};
    return attr_names;
  }
};
template<typename Provider>
class _ncclLogicalAllGatherNoncontinuousOpInterpCtxImpl
    : public _ncclLogicalAllGatherNoncontinuousOpInterpCtx {
 public:
  _ncclLogicalAllGatherNoncontinuousOpInterpCtxImpl() = default;
  _ncclLogicalAllGatherNoncontinuousOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& in_split_axis() const override { return impl_.in_split_axis(); }
  int64_t* mutable_in_split_axis() override { return impl_.mutable_in_split_axis(); }
  void set_in_split_axis(const int64_t& in_split_axis) override {
    impl_.set_in_split_axis(in_split_axis);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogicalAllGatherNoncontinuousOp {
 public:
  _ncclLogicalAllGatherNoncontinuousOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "in_split_axis") {
      return CastAttr(&internal_->in_split_axis);
    } else {
      return Error::RuntimeError()
             << "_ncclLogicalAllGatherNoncontinuous op has no attribute named " << attr_name;
    }
  }

  const int64_t& in_split_axis() const { return internal_->in_split_axis; }
  int64_t* mutable_in_split_axis() { return &internal_->in_split_axis; }
  void set_in_split_axis(const int64_t& in_split_axis) { internal_->in_split_axis = in_split_axis; }

 private:
  struct Internal {
    int64_t in_split_axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user._nccl_logical_all_gather_noncontinuous",
                       _ncclLogicalAllGatherNoncontinuousOpInterpCtxImpl<
                           schema::_ncclLogicalAllGatherNoncontinuousOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class _ncclLogicalAllReduceOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class _ncclLogicalAllReduceOpInterpCtxImpl : public _ncclLogicalAllReduceOpInterpCtx {
 public:
  _ncclLogicalAllReduceOpInterpCtxImpl() = default;
  _ncclLogicalAllReduceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogicalAllReduceOp {
 public:
  _ncclLogicalAllReduceOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "_ncclLogicalAllReduce op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user._nccl_logical_all_reduce",
                       _ncclLogicalAllReduceOpInterpCtxImpl<schema::_ncclLogicalAllReduceOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class _ncclLogicalReduceScatterOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class _ncclLogicalReduceScatterOpInterpCtxImpl : public _ncclLogicalReduceScatterOpInterpCtx {
 public:
  _ncclLogicalReduceScatterOpInterpCtxImpl() = default;
  _ncclLogicalReduceScatterOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogicalReduceScatterOp {
 public:
  _ncclLogicalReduceScatterOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "_ncclLogicalReduceScatter op has no attribute named "
                                 << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user._nccl_logical_reduce_scatter",
    _ncclLogicalReduceScatterOpInterpCtxImpl<schema::_ncclLogicalReduceScatterOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class _ncclLogicalS2sOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& in_split_axis() const = 0;
  virtual int64_t* mutable_in_split_axis() = 0;
  virtual void set_in_split_axis(const int64_t& in_split_axis) = 0;

  virtual const int64_t& out_split_axis() const = 0;
  virtual int64_t* mutable_out_split_axis() = 0;
  virtual void set_out_split_axis(const int64_t& out_split_axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"in_split_axis", "out_split_axis"};
    return attr_names;
  }
};
template<typename Provider>
class _ncclLogicalS2sOpInterpCtxImpl : public _ncclLogicalS2sOpInterpCtx {
 public:
  _ncclLogicalS2sOpInterpCtxImpl() = default;
  _ncclLogicalS2sOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& in_split_axis() const override { return impl_.in_split_axis(); }
  int64_t* mutable_in_split_axis() override { return impl_.mutable_in_split_axis(); }
  void set_in_split_axis(const int64_t& in_split_axis) override {
    impl_.set_in_split_axis(in_split_axis);
  }

  const int64_t& out_split_axis() const override { return impl_.out_split_axis(); }
  int64_t* mutable_out_split_axis() override { return impl_.mutable_out_split_axis(); }
  void set_out_split_axis(const int64_t& out_split_axis) override {
    impl_.set_out_split_axis(out_split_axis);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class _ncclLogicalS2sOp {
 public:
  _ncclLogicalS2sOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "in_split_axis") {
      return CastAttr(&internal_->in_split_axis);
    } else if (attr_name == "out_split_axis") {
      return CastAttr(&internal_->out_split_axis);
    } else {
      return Error::RuntimeError() << "_ncclLogicalS2s op has no attribute named " << attr_name;
    }
  }

  const int64_t& in_split_axis() const { return internal_->in_split_axis; }
  int64_t* mutable_in_split_axis() { return &internal_->in_split_axis; }
  void set_in_split_axis(const int64_t& in_split_axis) { internal_->in_split_axis = in_split_axis; }

  const int64_t& out_split_axis() const { return internal_->out_split_axis; }
  int64_t* mutable_out_split_axis() { return &internal_->out_split_axis; }
  void set_out_split_axis(const int64_t& out_split_axis) {
    internal_->out_split_axis = out_split_axis;
  }

 private:
  struct Internal {
    int64_t in_split_axis;
    int64_t out_split_axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user._nccl_logical_s2s",
                       _ncclLogicalS2sOpInterpCtxImpl<schema::_ncclLogicalS2sOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AbsOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AbsOpInterpCtxImpl : public AbsOpInterpCtx {
 public:
  AbsOpInterpCtxImpl() = default;
  AbsOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AbsOp {
 public:
  AbsOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Abs op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.abs", AbsOpInterpCtxImpl<schema::AbsOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AbsGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AbsGradOpInterpCtxImpl : public AbsGradOpInterpCtx {
 public:
  AbsGradOpInterpCtxImpl() = default;
  AbsGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AbsGradOp {
 public:
  AbsGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "AbsGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.abs_grad", AbsGradOpInterpCtxImpl<schema::AbsGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AccOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& max_acc_num() const = 0;
  virtual int32_t* mutable_max_acc_num() = 0;
  virtual void set_max_acc_num(const int32_t& max_acc_num) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"max_acc_num"};
    return attr_names;
  }
};
template<typename Provider>
class AccOpInterpCtxImpl : public AccOpInterpCtx {
 public:
  AccOpInterpCtxImpl() = default;
  AccOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& max_acc_num() const override { return impl_.max_acc_num(); }
  int32_t* mutable_max_acc_num() override { return impl_.mutable_max_acc_num(); }
  void set_max_acc_num(const int32_t& max_acc_num) override { impl_.set_max_acc_num(max_acc_num); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AccOp {
 public:
  AccOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "max_acc_num") {
      return CastAttr(&internal_->max_acc_num);
    } else {
      return Error::RuntimeError() << "Acc op has no attribute named " << attr_name;
    }
  }

  const int32_t& max_acc_num() const { return internal_->max_acc_num; }
  int32_t* mutable_max_acc_num() { return &internal_->max_acc_num; }
  void set_max_acc_num(const int32_t& max_acc_num) { internal_->max_acc_num = max_acc_num; }

 private:
  struct Internal {
    int32_t max_acc_num;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.acc", AccOpInterpCtxImpl<schema::AccOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AcosOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AcosOpInterpCtxImpl : public AcosOpInterpCtx {
 public:
  AcosOpInterpCtxImpl() = default;
  AcosOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AcosOp {
 public:
  AcosOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Acos op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.acos", AcosOpInterpCtxImpl<schema::AcosOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AcosGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AcosGradOpInterpCtxImpl : public AcosGradOpInterpCtx {
 public:
  AcosGradOpInterpCtxImpl() = default;
  AcosGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AcosGradOp {
 public:
  AcosGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "AcosGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.acos_grad", AcosGradOpInterpCtxImpl<schema::AcosGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AcoshOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AcoshOpInterpCtxImpl : public AcoshOpInterpCtx {
 public:
  AcoshOpInterpCtxImpl() = default;
  AcoshOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AcoshOp {
 public:
  AcoshOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Acosh op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.acosh", AcoshOpInterpCtxImpl<schema::AcoshOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AcoshGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AcoshGradOpInterpCtxImpl : public AcoshGradOpInterpCtx {
 public:
  AcoshGradOpInterpCtxImpl() = default;
  AcoshGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AcoshGradOp {
 public:
  AcoshGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "AcoshGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.acosh_grad", AcoshGradOpInterpCtxImpl<schema::AcoshGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AdagradUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& train_step_val() const = 0;
  virtual int32_t* mutable_train_step_val() = 0;
  virtual void set_train_step_val(const int32_t& train_step_val) = 0;

  virtual const float& learning_rate_val() const = 0;
  virtual float* mutable_learning_rate_val() = 0;
  virtual void set_learning_rate_val(const float& learning_rate_val) = 0;

  virtual const double& scale() const = 0;
  virtual double* mutable_scale() = 0;
  virtual void set_scale(const double& scale) = 0;

  virtual const float& l1() const = 0;
  virtual float* mutable_l1() = 0;
  virtual void set_l1(const float& l1) = 0;

  virtual const float& l2() const = 0;
  virtual float* mutable_l2() = 0;
  virtual void set_l2(const float& l2) = 0;

  virtual const float& lr_decay() const = 0;
  virtual float* mutable_lr_decay() = 0;
  virtual void set_lr_decay(const float& lr_decay) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{
        "train_step_val", "learning_rate_val", "scale",  "l1", "l2",
        "lr_decay",       "weight_decay",      "epsilon"};
    return attr_names;
  }
};
template<typename Provider>
class AdagradUpdateOpInterpCtxImpl : public AdagradUpdateOpInterpCtx {
 public:
  AdagradUpdateOpInterpCtxImpl() = default;
  AdagradUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& train_step_val() const override { return impl_.train_step_val(); }
  int32_t* mutable_train_step_val() override { return impl_.mutable_train_step_val(); }
  void set_train_step_val(const int32_t& train_step_val) override {
    impl_.set_train_step_val(train_step_val);
  }

  const float& learning_rate_val() const override { return impl_.learning_rate_val(); }
  float* mutable_learning_rate_val() override { return impl_.mutable_learning_rate_val(); }
  void set_learning_rate_val(const float& learning_rate_val) override {
    impl_.set_learning_rate_val(learning_rate_val);
  }

  const double& scale() const override { return impl_.scale(); }
  double* mutable_scale() override { return impl_.mutable_scale(); }
  void set_scale(const double& scale) override { impl_.set_scale(scale); }

  const float& l1() const override { return impl_.l1(); }
  float* mutable_l1() override { return impl_.mutable_l1(); }
  void set_l1(const float& l1) override { impl_.set_l1(l1); }

  const float& l2() const override { return impl_.l2(); }
  float* mutable_l2() override { return impl_.mutable_l2(); }
  void set_l2(const float& l2) override { impl_.set_l2(l2); }

  const float& lr_decay() const override { return impl_.lr_decay(); }
  float* mutable_lr_decay() override { return impl_.mutable_lr_decay(); }
  void set_lr_decay(const float& lr_decay) override { impl_.set_lr_decay(lr_decay); }

  const float& weight_decay() const override { return impl_.weight_decay(); }
  float* mutable_weight_decay() override { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) override {
    impl_.set_weight_decay(weight_decay);
  }

  const float& epsilon() const override { return impl_.epsilon(); }
  float* mutable_epsilon() override { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) override { impl_.set_epsilon(epsilon); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdagradUpdateOp {
 public:
  AdagradUpdateOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "train_step_val") {
      return CastAttr(&internal_->train_step_val);
    } else if (attr_name == "learning_rate_val") {
      return CastAttr(&internal_->learning_rate_val);
    } else if (attr_name == "scale") {
      return CastAttr(&internal_->scale);
    } else if (attr_name == "l1") {
      return CastAttr(&internal_->l1);
    } else if (attr_name == "l2") {
      return CastAttr(&internal_->l2);
    } else if (attr_name == "lr_decay") {
      return CastAttr(&internal_->lr_decay);
    } else if (attr_name == "weight_decay") {
      return CastAttr(&internal_->weight_decay);
    } else if (attr_name == "epsilon") {
      return CastAttr(&internal_->epsilon);
    } else {
      return Error::RuntimeError() << "AdagradUpdate op has no attribute named " << attr_name;
    }
  }

  const int32_t& train_step_val() const { return internal_->train_step_val; }
  int32_t* mutable_train_step_val() { return &internal_->train_step_val; }
  void set_train_step_val(const int32_t& train_step_val) {
    internal_->train_step_val = train_step_val;
  }

  const float& learning_rate_val() const { return internal_->learning_rate_val; }
  float* mutable_learning_rate_val() { return &internal_->learning_rate_val; }
  void set_learning_rate_val(const float& learning_rate_val) {
    internal_->learning_rate_val = learning_rate_val;
  }

  const double& scale() const { return internal_->scale; }
  double* mutable_scale() { return &internal_->scale; }
  void set_scale(const double& scale) { internal_->scale = scale; }

  const float& l1() const { return internal_->l1; }
  float* mutable_l1() { return &internal_->l1; }
  void set_l1(const float& l1) { internal_->l1 = l1; }

  const float& l2() const { return internal_->l2; }
  float* mutable_l2() { return &internal_->l2; }
  void set_l2(const float& l2) { internal_->l2 = l2; }

  const float& lr_decay() const { return internal_->lr_decay; }
  float* mutable_lr_decay() { return &internal_->lr_decay; }
  void set_lr_decay(const float& lr_decay) { internal_->lr_decay = lr_decay; }

  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }

  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }

 private:
  struct Internal {
    int32_t train_step_val;
    float learning_rate_val;
    double scale;
    float l1;
    float l2;
    float lr_decay;
    float weight_decay;
    float epsilon;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.adagrad_update",
                       AdagradUpdateOpInterpCtxImpl<schema::AdagradUpdateOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AdamBiasCorrectionFactorOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& beta() const = 0;
  virtual float* mutable_beta() = 0;
  virtual void set_beta(const float& beta) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"beta"};
    return attr_names;
  }
};
template<typename Provider>
class AdamBiasCorrectionFactorOpInterpCtxImpl : public AdamBiasCorrectionFactorOpInterpCtx {
 public:
  AdamBiasCorrectionFactorOpInterpCtxImpl() = default;
  AdamBiasCorrectionFactorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& beta() const override { return impl_.beta(); }
  float* mutable_beta() override { return impl_.mutable_beta(); }
  void set_beta(const float& beta) override { impl_.set_beta(beta); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdamBiasCorrectionFactorOp {
 public:
  AdamBiasCorrectionFactorOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "beta") {
      return CastAttr(&internal_->beta);
    } else {
      return Error::RuntimeError()
             << "AdamBiasCorrectionFactor op has no attribute named " << attr_name;
    }
  }

  const float& beta() const { return internal_->beta; }
  float* mutable_beta() { return &internal_->beta; }
  void set_beta(const float& beta) { internal_->beta = beta; }

 private:
  struct Internal {
    float beta;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.adam_bias_correction_factor",
                       AdamBiasCorrectionFactorOpInterpCtxImpl<schema::AdamBiasCorrectionFactorOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AdamUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& learning_rate_val() const = 0;
  virtual float* mutable_learning_rate_val() = 0;
  virtual void set_learning_rate_val(const float& learning_rate_val) = 0;

  virtual const float& bias_correction1_val() const = 0;
  virtual float* mutable_bias_correction1_val() = 0;
  virtual void set_bias_correction1_val(const float& bias_correction1_val) = 0;

  virtual const float& bias_correction2_val() const = 0;
  virtual float* mutable_bias_correction2_val() = 0;
  virtual void set_bias_correction2_val(const float& bias_correction2_val) = 0;

  virtual const double& scale() const = 0;
  virtual double* mutable_scale() = 0;
  virtual void set_scale(const double& scale) = 0;

  virtual const float& l1() const = 0;
  virtual float* mutable_l1() = 0;
  virtual void set_l1(const float& l1) = 0;

  virtual const float& l2() const = 0;
  virtual float* mutable_l2() = 0;
  virtual void set_l2(const float& l2) = 0;

  virtual const float& beta1() const = 0;
  virtual float* mutable_beta1() = 0;
  virtual void set_beta1(const float& beta1) = 0;

  virtual const float& beta2() const = 0;
  virtual float* mutable_beta2() = 0;
  virtual void set_beta2(const float& beta2) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  virtual const bool& amsgrad() const = 0;
  virtual bool* mutable_amsgrad() = 0;
  virtual void set_amsgrad(const bool& amsgrad) = 0;

  virtual const bool& do_bias_correction() const = 0;
  virtual bool* mutable_do_bias_correction() = 0;
  virtual void set_do_bias_correction(const bool& do_bias_correction) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"learning_rate_val",
                                           "bias_correction1_val",
                                           "bias_correction2_val",
                                           "scale",
                                           "l1",
                                           "l2",
                                           "beta1",
                                           "beta2",
                                           "epsilon",
                                           "weight_decay",
                                           "amsgrad",
                                           "do_bias_correction"};
    return attr_names;
  }
};
template<typename Provider>
class AdamUpdateOpInterpCtxImpl : public AdamUpdateOpInterpCtx {
 public:
  AdamUpdateOpInterpCtxImpl() = default;
  AdamUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& learning_rate_val() const override { return impl_.learning_rate_val(); }
  float* mutable_learning_rate_val() override { return impl_.mutable_learning_rate_val(); }
  void set_learning_rate_val(const float& learning_rate_val) override {
    impl_.set_learning_rate_val(learning_rate_val);
  }

  const float& bias_correction1_val() const override { return impl_.bias_correction1_val(); }
  float* mutable_bias_correction1_val() override { return impl_.mutable_bias_correction1_val(); }
  void set_bias_correction1_val(const float& bias_correction1_val) override {
    impl_.set_bias_correction1_val(bias_correction1_val);
  }

  const float& bias_correction2_val() const override { return impl_.bias_correction2_val(); }
  float* mutable_bias_correction2_val() override { return impl_.mutable_bias_correction2_val(); }
  void set_bias_correction2_val(const float& bias_correction2_val) override {
    impl_.set_bias_correction2_val(bias_correction2_val);
  }

  const double& scale() const override { return impl_.scale(); }
  double* mutable_scale() override { return impl_.mutable_scale(); }
  void set_scale(const double& scale) override { impl_.set_scale(scale); }

  const float& l1() const override { return impl_.l1(); }
  float* mutable_l1() override { return impl_.mutable_l1(); }
  void set_l1(const float& l1) override { impl_.set_l1(l1); }

  const float& l2() const override { return impl_.l2(); }
  float* mutable_l2() override { return impl_.mutable_l2(); }
  void set_l2(const float& l2) override { impl_.set_l2(l2); }

  const float& beta1() const override { return impl_.beta1(); }
  float* mutable_beta1() override { return impl_.mutable_beta1(); }
  void set_beta1(const float& beta1) override { impl_.set_beta1(beta1); }

  const float& beta2() const override { return impl_.beta2(); }
  float* mutable_beta2() override { return impl_.mutable_beta2(); }
  void set_beta2(const float& beta2) override { impl_.set_beta2(beta2); }

  const float& epsilon() const override { return impl_.epsilon(); }
  float* mutable_epsilon() override { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) override { impl_.set_epsilon(epsilon); }

  const float& weight_decay() const override { return impl_.weight_decay(); }
  float* mutable_weight_decay() override { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) override {
    impl_.set_weight_decay(weight_decay);
  }

  const bool& amsgrad() const override { return impl_.amsgrad(); }
  bool* mutable_amsgrad() override { return impl_.mutable_amsgrad(); }
  void set_amsgrad(const bool& amsgrad) override { impl_.set_amsgrad(amsgrad); }

  const bool& do_bias_correction() const override { return impl_.do_bias_correction(); }
  bool* mutable_do_bias_correction() override { return impl_.mutable_do_bias_correction(); }
  void set_do_bias_correction(const bool& do_bias_correction) override {
    impl_.set_do_bias_correction(do_bias_correction);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdamUpdateOp {
 public:
  AdamUpdateOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "learning_rate_val") {
      return CastAttr(&internal_->learning_rate_val);
    } else if (attr_name == "bias_correction1_val") {
      return CastAttr(&internal_->bias_correction1_val);
    } else if (attr_name == "bias_correction2_val") {
      return CastAttr(&internal_->bias_correction2_val);
    } else if (attr_name == "scale") {
      return CastAttr(&internal_->scale);
    } else if (attr_name == "l1") {
      return CastAttr(&internal_->l1);
    } else if (attr_name == "l2") {
      return CastAttr(&internal_->l2);
    } else if (attr_name == "beta1") {
      return CastAttr(&internal_->beta1);
    } else if (attr_name == "beta2") {
      return CastAttr(&internal_->beta2);
    } else if (attr_name == "epsilon") {
      return CastAttr(&internal_->epsilon);
    } else if (attr_name == "weight_decay") {
      return CastAttr(&internal_->weight_decay);
    } else if (attr_name == "amsgrad") {
      return CastAttr(&internal_->amsgrad);
    } else if (attr_name == "do_bias_correction") {
      return CastAttr(&internal_->do_bias_correction);
    } else {
      return Error::RuntimeError() << "AdamUpdate op has no attribute named " << attr_name;
    }
  }

  const float& learning_rate_val() const { return internal_->learning_rate_val; }
  float* mutable_learning_rate_val() { return &internal_->learning_rate_val; }
  void set_learning_rate_val(const float& learning_rate_val) {
    internal_->learning_rate_val = learning_rate_val;
  }

  const float& bias_correction1_val() const { return internal_->bias_correction1_val; }
  float* mutable_bias_correction1_val() { return &internal_->bias_correction1_val; }
  void set_bias_correction1_val(const float& bias_correction1_val) {
    internal_->bias_correction1_val = bias_correction1_val;
  }

  const float& bias_correction2_val() const { return internal_->bias_correction2_val; }
  float* mutable_bias_correction2_val() { return &internal_->bias_correction2_val; }
  void set_bias_correction2_val(const float& bias_correction2_val) {
    internal_->bias_correction2_val = bias_correction2_val;
  }

  const double& scale() const { return internal_->scale; }
  double* mutable_scale() { return &internal_->scale; }
  void set_scale(const double& scale) { internal_->scale = scale; }

  const float& l1() const { return internal_->l1; }
  float* mutable_l1() { return &internal_->l1; }
  void set_l1(const float& l1) { internal_->l1 = l1; }

  const float& l2() const { return internal_->l2; }
  float* mutable_l2() { return &internal_->l2; }
  void set_l2(const float& l2) { internal_->l2 = l2; }

  const float& beta1() const { return internal_->beta1; }
  float* mutable_beta1() { return &internal_->beta1; }
  void set_beta1(const float& beta1) { internal_->beta1 = beta1; }

  const float& beta2() const { return internal_->beta2; }
  float* mutable_beta2() { return &internal_->beta2; }
  void set_beta2(const float& beta2) { internal_->beta2 = beta2; }

  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }

  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }

  const bool& amsgrad() const { return internal_->amsgrad; }
  bool* mutable_amsgrad() { return &internal_->amsgrad; }
  void set_amsgrad(const bool& amsgrad) { internal_->amsgrad = amsgrad; }

  const bool& do_bias_correction() const { return internal_->do_bias_correction; }
  bool* mutable_do_bias_correction() { return &internal_->do_bias_correction; }
  void set_do_bias_correction(const bool& do_bias_correction) {
    internal_->do_bias_correction = do_bias_correction;
  }

 private:
  struct Internal {
    float learning_rate_val;
    float bias_correction1_val;
    float bias_correction2_val;
    double scale;
    float l1;
    float l2;
    float beta1;
    float beta2;
    float epsilon;
    float weight_decay;
    bool amsgrad;
    bool do_bias_correction;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.adam_update", AdamUpdateOpInterpCtxImpl<schema::AdamUpdateOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AdaptiveAvgPool1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& output_size() const = 0;
  virtual std::vector<int64_t>* mutable_output_size() = 0;
  virtual void set_output_size(const std::vector<int64_t>& output_size) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"output_size"};
    return attr_names;
  }
};
template<typename Provider>
class AdaptiveAvgPool1DOpInterpCtxImpl : public AdaptiveAvgPool1DOpInterpCtx {
 public:
  AdaptiveAvgPool1DOpInterpCtxImpl() = default;
  AdaptiveAvgPool1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& output_size() const override { return impl_.output_size(); }
  std::vector<int64_t>* mutable_output_size() override { return impl_.mutable_output_size(); }
  void set_output_size(const std::vector<int64_t>& output_size) override {
    impl_.set_output_size(output_size);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdaptiveAvgPool1DOp {
 public:
  AdaptiveAvgPool1DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "output_size") {
      return CastAttr(&internal_->output_size);
    } else {
      return Error::RuntimeError() << "AdaptiveAvgPool1D op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& output_size() const { return internal_->output_size; }
  std::vector<int64_t>* mutable_output_size() { return &internal_->output_size; }
  void set_output_size(const std::vector<int64_t>& output_size) {
    internal_->output_size = output_size;
  }

 private:
  struct Internal {
    std::vector<int64_t> output_size;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.adaptive_avg_pool1d",
                       AdaptiveAvgPool1DOpInterpCtxImpl<schema::AdaptiveAvgPool1DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AdaptiveAvgPool1DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& output_size() const = 0;
  virtual std::vector<int64_t>* mutable_output_size() = 0;
  virtual void set_output_size(const std::vector<int64_t>& output_size) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"output_size"};
    return attr_names;
  }
};
template<typename Provider>
class AdaptiveAvgPool1DGradOpInterpCtxImpl : public AdaptiveAvgPool1DGradOpInterpCtx {
 public:
  AdaptiveAvgPool1DGradOpInterpCtxImpl() = default;
  AdaptiveAvgPool1DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& output_size() const override { return impl_.output_size(); }
  std::vector<int64_t>* mutable_output_size() override { return impl_.mutable_output_size(); }
  void set_output_size(const std::vector<int64_t>& output_size) override {
    impl_.set_output_size(output_size);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdaptiveAvgPool1DGradOp {
 public:
  AdaptiveAvgPool1DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "output_size") {
      return CastAttr(&internal_->output_size);
    } else {
      return Error::RuntimeError()
             << "AdaptiveAvgPool1DGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& output_size() const { return internal_->output_size; }
  std::vector<int64_t>* mutable_output_size() { return &internal_->output_size; }
  void set_output_size(const std::vector<int64_t>& output_size) {
    internal_->output_size = output_size;
  }

 private:
  struct Internal {
    std::vector<int64_t> output_size;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.adaptive_avg_pool1d_grad",
                       AdaptiveAvgPool1DGradOpInterpCtxImpl<schema::AdaptiveAvgPool1DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AdaptiveAvgPool2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& output_size() const = 0;
  virtual std::vector<int64_t>* mutable_output_size() = 0;
  virtual void set_output_size(const std::vector<int64_t>& output_size) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"output_size"};
    return attr_names;
  }
};
template<typename Provider>
class AdaptiveAvgPool2DOpInterpCtxImpl : public AdaptiveAvgPool2DOpInterpCtx {
 public:
  AdaptiveAvgPool2DOpInterpCtxImpl() = default;
  AdaptiveAvgPool2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& output_size() const override { return impl_.output_size(); }
  std::vector<int64_t>* mutable_output_size() override { return impl_.mutable_output_size(); }
  void set_output_size(const std::vector<int64_t>& output_size) override {
    impl_.set_output_size(output_size);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdaptiveAvgPool2DOp {
 public:
  AdaptiveAvgPool2DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "output_size") {
      return CastAttr(&internal_->output_size);
    } else {
      return Error::RuntimeError() << "AdaptiveAvgPool2D op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& output_size() const { return internal_->output_size; }
  std::vector<int64_t>* mutable_output_size() { return &internal_->output_size; }
  void set_output_size(const std::vector<int64_t>& output_size) {
    internal_->output_size = output_size;
  }

 private:
  struct Internal {
    std::vector<int64_t> output_size;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.adaptive_avg_pool2d",
                       AdaptiveAvgPool2DOpInterpCtxImpl<schema::AdaptiveAvgPool2DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AdaptiveAvgPool2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& output_size() const = 0;
  virtual std::vector<int64_t>* mutable_output_size() = 0;
  virtual void set_output_size(const std::vector<int64_t>& output_size) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"output_size"};
    return attr_names;
  }
};
template<typename Provider>
class AdaptiveAvgPool2DGradOpInterpCtxImpl : public AdaptiveAvgPool2DGradOpInterpCtx {
 public:
  AdaptiveAvgPool2DGradOpInterpCtxImpl() = default;
  AdaptiveAvgPool2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& output_size() const override { return impl_.output_size(); }
  std::vector<int64_t>* mutable_output_size() override { return impl_.mutable_output_size(); }
  void set_output_size(const std::vector<int64_t>& output_size) override {
    impl_.set_output_size(output_size);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdaptiveAvgPool2DGradOp {
 public:
  AdaptiveAvgPool2DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "output_size") {
      return CastAttr(&internal_->output_size);
    } else {
      return Error::RuntimeError()
             << "AdaptiveAvgPool2DGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& output_size() const { return internal_->output_size; }
  std::vector<int64_t>* mutable_output_size() { return &internal_->output_size; }
  void set_output_size(const std::vector<int64_t>& output_size) {
    internal_->output_size = output_size;
  }

 private:
  struct Internal {
    std::vector<int64_t> output_size;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.adaptive_avg_pool2d_grad",
                       AdaptiveAvgPool2DGradOpInterpCtxImpl<schema::AdaptiveAvgPool2DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AdaptiveAvgPool3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& output_size() const = 0;
  virtual std::vector<int64_t>* mutable_output_size() = 0;
  virtual void set_output_size(const std::vector<int64_t>& output_size) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"output_size"};
    return attr_names;
  }
};
template<typename Provider>
class AdaptiveAvgPool3DOpInterpCtxImpl : public AdaptiveAvgPool3DOpInterpCtx {
 public:
  AdaptiveAvgPool3DOpInterpCtxImpl() = default;
  AdaptiveAvgPool3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& output_size() const override { return impl_.output_size(); }
  std::vector<int64_t>* mutable_output_size() override { return impl_.mutable_output_size(); }
  void set_output_size(const std::vector<int64_t>& output_size) override {
    impl_.set_output_size(output_size);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdaptiveAvgPool3DOp {
 public:
  AdaptiveAvgPool3DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "output_size") {
      return CastAttr(&internal_->output_size);
    } else {
      return Error::RuntimeError() << "AdaptiveAvgPool3D op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& output_size() const { return internal_->output_size; }
  std::vector<int64_t>* mutable_output_size() { return &internal_->output_size; }
  void set_output_size(const std::vector<int64_t>& output_size) {
    internal_->output_size = output_size;
  }

 private:
  struct Internal {
    std::vector<int64_t> output_size;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.adaptive_avg_pool3d",
                       AdaptiveAvgPool3DOpInterpCtxImpl<schema::AdaptiveAvgPool3DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AdaptiveAvgPool3DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& output_size() const = 0;
  virtual std::vector<int64_t>* mutable_output_size() = 0;
  virtual void set_output_size(const std::vector<int64_t>& output_size) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"output_size"};
    return attr_names;
  }
};
template<typename Provider>
class AdaptiveAvgPool3DGradOpInterpCtxImpl : public AdaptiveAvgPool3DGradOpInterpCtx {
 public:
  AdaptiveAvgPool3DGradOpInterpCtxImpl() = default;
  AdaptiveAvgPool3DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& output_size() const override { return impl_.output_size(); }
  std::vector<int64_t>* mutable_output_size() override { return impl_.mutable_output_size(); }
  void set_output_size(const std::vector<int64_t>& output_size) override {
    impl_.set_output_size(output_size);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AdaptiveAvgPool3DGradOp {
 public:
  AdaptiveAvgPool3DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "output_size") {
      return CastAttr(&internal_->output_size);
    } else {
      return Error::RuntimeError()
             << "AdaptiveAvgPool3DGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& output_size() const { return internal_->output_size; }
  std::vector<int64_t>* mutable_output_size() { return &internal_->output_size; }
  void set_output_size(const std::vector<int64_t>& output_size) {
    internal_->output_size = output_size;
  }

 private:
  struct Internal {
    std::vector<int64_t> output_size;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.adaptive_avg_pool3d_grad",
                       AdaptiveAvgPool3DGradOpInterpCtxImpl<schema::AdaptiveAvgPool3DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AddNOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AddNOpInterpCtxImpl : public AddNOpInterpCtx {
 public:
  AddNOpInterpCtxImpl() = default;
  AddNOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AddNOp {
 public:
  AddNOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "AddN op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.add_n", AddNOpInterpCtxImpl<schema::AddNOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AffineGridOpInterpCtx : public OpInterpCtx {
 public:
  virtual const Shape& size() const = 0;
  virtual Shape* mutable_size() = 0;
  virtual void set_size(const Shape& size) = 0;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"size", "align_corners"};
    return attr_names;
  }
};
template<typename Provider>
class AffineGridOpInterpCtxImpl : public AffineGridOpInterpCtx {
 public:
  AffineGridOpInterpCtxImpl() = default;
  AffineGridOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const Shape& size() const override { return impl_.size(); }
  Shape* mutable_size() override { return impl_.mutable_size(); }
  void set_size(const Shape& size) override { impl_.set_size(size); }

  const bool& align_corners() const override { return impl_.align_corners(); }
  bool* mutable_align_corners() override { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) override {
    impl_.set_align_corners(align_corners);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AffineGridOp {
 public:
  AffineGridOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "size") {
      return CastAttr(&internal_->size);
    } else if (attr_name == "align_corners") {
      return CastAttr(&internal_->align_corners);
    } else {
      return Error::RuntimeError() << "AffineGrid op has no attribute named " << attr_name;
    }
  }

  const Shape& size() const { return internal_->size; }
  Shape* mutable_size() { return &internal_->size; }
  void set_size(const Shape& size) { internal_->size = size; }

  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }

 private:
  struct Internal {
    Shape size;
    bool align_corners;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.affine_grid", AffineGridOpInterpCtxImpl<schema::AffineGridOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AffineGridGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const Shape& size() const = 0;
  virtual Shape* mutable_size() = 0;
  virtual void set_size(const Shape& size) = 0;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"size", "align_corners"};
    return attr_names;
  }
};
template<typename Provider>
class AffineGridGradOpInterpCtxImpl : public AffineGridGradOpInterpCtx {
 public:
  AffineGridGradOpInterpCtxImpl() = default;
  AffineGridGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const Shape& size() const override { return impl_.size(); }
  Shape* mutable_size() override { return impl_.mutable_size(); }
  void set_size(const Shape& size) override { impl_.set_size(size); }

  const bool& align_corners() const override { return impl_.align_corners(); }
  bool* mutable_align_corners() override { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) override {
    impl_.set_align_corners(align_corners);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AffineGridGradOp {
 public:
  AffineGridGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "size") {
      return CastAttr(&internal_->size);
    } else if (attr_name == "align_corners") {
      return CastAttr(&internal_->align_corners);
    } else {
      return Error::RuntimeError() << "AffineGridGrad op has no attribute named " << attr_name;
    }
  }

  const Shape& size() const { return internal_->size; }
  Shape* mutable_size() { return &internal_->size; }
  void set_size(const Shape& size) { internal_->size = size; }

  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }

 private:
  struct Internal {
    Shape size;
    bool align_corners;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.affine_grid_grad",
                       AffineGridGradOpInterpCtxImpl<schema::AffineGridGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AmpWhiteIdentityOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AmpWhiteIdentityOpInterpCtxImpl : public AmpWhiteIdentityOpInterpCtx {
 public:
  AmpWhiteIdentityOpInterpCtxImpl() = default;
  AmpWhiteIdentityOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AmpWhiteIdentityOp {
 public:
  AmpWhiteIdentityOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "AmpWhiteIdentity op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.amp_white_identity",
                       AmpWhiteIdentityOpInterpCtxImpl<schema::AmpWhiteIdentityOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ArangeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& integer_start() const = 0;
  virtual int64_t* mutable_integer_start() = 0;
  virtual void set_integer_start(const int64_t& integer_start) = 0;

  virtual const int64_t& integer_delta() const = 0;
  virtual int64_t* mutable_integer_delta() = 0;
  virtual void set_integer_delta(const int64_t& integer_delta) = 0;

  virtual const int64_t& integer_limit() const = 0;
  virtual int64_t* mutable_integer_limit() = 0;
  virtual void set_integer_limit(const int64_t& integer_limit) = 0;

  virtual const double& float_start() const = 0;
  virtual double* mutable_float_start() = 0;
  virtual void set_float_start(const double& float_start) = 0;

  virtual const double& float_delta() const = 0;
  virtual double* mutable_float_delta() = 0;
  virtual void set_float_delta(const double& float_delta) = 0;

  virtual const double& float_limit() const = 0;
  virtual double* mutable_float_limit() = 0;
  virtual void set_float_limit(const double& float_limit) = 0;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"integer_start", "integer_delta", "integer_limit",
                                           "float_start",   "float_delta",   "float_limit",
                                           "dtype",         "nd_sbp"};
    return attr_names;
  }
};
template<typename Provider>
class ArangeOpInterpCtxImpl : public ArangeOpInterpCtx {
 public:
  ArangeOpInterpCtxImpl() = default;
  ArangeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& integer_start() const override { return impl_.integer_start(); }
  int64_t* mutable_integer_start() override { return impl_.mutable_integer_start(); }
  void set_integer_start(const int64_t& integer_start) override {
    impl_.set_integer_start(integer_start);
  }

  const int64_t& integer_delta() const override { return impl_.integer_delta(); }
  int64_t* mutable_integer_delta() override { return impl_.mutable_integer_delta(); }
  void set_integer_delta(const int64_t& integer_delta) override {
    impl_.set_integer_delta(integer_delta);
  }

  const int64_t& integer_limit() const override { return impl_.integer_limit(); }
  int64_t* mutable_integer_limit() override { return impl_.mutable_integer_limit(); }
  void set_integer_limit(const int64_t& integer_limit) override {
    impl_.set_integer_limit(integer_limit);
  }

  const double& float_start() const override { return impl_.float_start(); }
  double* mutable_float_start() override { return impl_.mutable_float_start(); }
  void set_float_start(const double& float_start) override { impl_.set_float_start(float_start); }

  const double& float_delta() const override { return impl_.float_delta(); }
  double* mutable_float_delta() override { return impl_.mutable_float_delta(); }
  void set_float_delta(const double& float_delta) override { impl_.set_float_delta(float_delta); }

  const double& float_limit() const override { return impl_.float_limit(); }
  double* mutable_float_limit() override { return impl_.mutable_float_limit(); }
  void set_float_limit(const double& float_limit) override { impl_.set_float_limit(float_limit); }

  const DataType& dtype() const override { return impl_.dtype(); }
  DataType* mutable_dtype() override { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) override { impl_.set_dtype(dtype); }

  const std::vector<std::string>& nd_sbp() const override { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() override { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) override { impl_.set_nd_sbp(nd_sbp); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ArangeOp {
 public:
  ArangeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "integer_start") {
      return CastAttr(&internal_->integer_start);
    } else if (attr_name == "integer_delta") {
      return CastAttr(&internal_->integer_delta);
    } else if (attr_name == "integer_limit") {
      return CastAttr(&internal_->integer_limit);
    } else if (attr_name == "float_start") {
      return CastAttr(&internal_->float_start);
    } else if (attr_name == "float_delta") {
      return CastAttr(&internal_->float_delta);
    } else if (attr_name == "float_limit") {
      return CastAttr(&internal_->float_limit);
    } else if (attr_name == "dtype") {
      return CastAttr(&internal_->dtype);
    } else if (attr_name == "nd_sbp") {
      return CastAttr(&internal_->nd_sbp);
    } else {
      return Error::RuntimeError() << "Arange op has no attribute named " << attr_name;
    }
  }

  const int64_t& integer_start() const { return internal_->integer_start; }
  int64_t* mutable_integer_start() { return &internal_->integer_start; }
  void set_integer_start(const int64_t& integer_start) { internal_->integer_start = integer_start; }

  const int64_t& integer_delta() const { return internal_->integer_delta; }
  int64_t* mutable_integer_delta() { return &internal_->integer_delta; }
  void set_integer_delta(const int64_t& integer_delta) { internal_->integer_delta = integer_delta; }

  const int64_t& integer_limit() const { return internal_->integer_limit; }
  int64_t* mutable_integer_limit() { return &internal_->integer_limit; }
  void set_integer_limit(const int64_t& integer_limit) { internal_->integer_limit = integer_limit; }

  const double& float_start() const { return internal_->float_start; }
  double* mutable_float_start() { return &internal_->float_start; }
  void set_float_start(const double& float_start) { internal_->float_start = float_start; }

  const double& float_delta() const { return internal_->float_delta; }
  double* mutable_float_delta() { return &internal_->float_delta; }
  void set_float_delta(const double& float_delta) { internal_->float_delta = float_delta; }

  const double& float_limit() const { return internal_->float_limit; }
  double* mutable_float_limit() { return &internal_->float_limit; }
  void set_float_limit(const double& float_limit) { internal_->float_limit = float_limit; }

  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }

  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }

 private:
  struct Internal {
    int64_t integer_start;
    int64_t integer_delta;
    int64_t integer_limit;
    double float_start;
    double float_delta;
    double float_limit;
    DataType dtype;
    std::vector<std::string> nd_sbp;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.arange", ArangeOpInterpCtxImpl<schema::ArangeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ArgSortOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& direction() const = 0;
  virtual std::string* mutable_direction() = 0;
  virtual void set_direction(const std::string& direction) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"direction"};
    return attr_names;
  }
};
template<typename Provider>
class ArgSortOpInterpCtxImpl : public ArgSortOpInterpCtx {
 public:
  ArgSortOpInterpCtxImpl() = default;
  ArgSortOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& direction() const override { return impl_.direction(); }
  std::string* mutable_direction() override { return impl_.mutable_direction(); }
  void set_direction(const std::string& direction) override { impl_.set_direction(direction); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ArgSortOp {
 public:
  ArgSortOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "direction") {
      return CastAttr(&internal_->direction);
    } else {
      return Error::RuntimeError() << "ArgSort op has no attribute named " << attr_name;
    }
  }

  const std::string& direction() const { return internal_->direction; }
  std::string* mutable_direction() { return &internal_->direction; }
  void set_direction(const std::string& direction) { internal_->direction = direction; }

 private:
  struct Internal {
    std::string direction;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.arg_sort", ArgSortOpInterpCtxImpl<schema::ArgSortOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ArgmaxOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ArgmaxOpInterpCtxImpl : public ArgmaxOpInterpCtx {
 public:
  ArgmaxOpInterpCtxImpl() = default;
  ArgmaxOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ArgmaxOp {
 public:
  ArgmaxOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Argmax op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.argmax", ArgmaxOpInterpCtxImpl<schema::ArgmaxOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ArgwhereOpInterpCtx : public OpInterpCtx {
 public:
  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"dtype"};
    return attr_names;
  }
};
template<typename Provider>
class ArgwhereOpInterpCtxImpl : public ArgwhereOpInterpCtx {
 public:
  ArgwhereOpInterpCtxImpl() = default;
  ArgwhereOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const DataType& dtype() const override { return impl_.dtype(); }
  DataType* mutable_dtype() override { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) override { impl_.set_dtype(dtype); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ArgwhereOp {
 public:
  ArgwhereOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "dtype") {
      return CastAttr(&internal_->dtype);
    } else {
      return Error::RuntimeError() << "Argwhere op has no attribute named " << attr_name;
    }
  }

  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }

 private:
  struct Internal {
    DataType dtype;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.argwhere", ArgwhereOpInterpCtxImpl<schema::ArgwhereOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AsinOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AsinOpInterpCtxImpl : public AsinOpInterpCtx {
 public:
  AsinOpInterpCtxImpl() = default;
  AsinOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AsinOp {
 public:
  AsinOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Asin op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.asin", AsinOpInterpCtxImpl<schema::AsinOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AsinGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AsinGradOpInterpCtxImpl : public AsinGradOpInterpCtx {
 public:
  AsinGradOpInterpCtxImpl() = default;
  AsinGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AsinGradOp {
 public:
  AsinGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "AsinGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.asin_grad", AsinGradOpInterpCtxImpl<schema::AsinGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AsinhOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AsinhOpInterpCtxImpl : public AsinhOpInterpCtx {
 public:
  AsinhOpInterpCtxImpl() = default;
  AsinhOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AsinhOp {
 public:
  AsinhOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Asinh op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.asinh", AsinhOpInterpCtxImpl<schema::AsinhOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AsinhGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AsinhGradOpInterpCtxImpl : public AsinhGradOpInterpCtx {
 public:
  AsinhGradOpInterpCtxImpl() = default;
  AsinhGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AsinhGradOp {
 public:
  AsinhGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "AsinhGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.asinh_grad", AsinhGradOpInterpCtxImpl<schema::AsinhGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AssignOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AssignOpInterpCtxImpl : public AssignOpInterpCtx {
 public:
  AssignOpInterpCtxImpl() = default;
  AssignOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AssignOp {
 public:
  AssignOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Assign op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.assign", AssignOpInterpCtxImpl<schema::AssignOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AssignIfOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AssignIfOpInterpCtxImpl : public AssignIfOpInterpCtx {
 public:
  AssignIfOpInterpCtxImpl() = default;
  AssignIfOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AssignIfOp {
 public:
  AssignIfOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "AssignIf op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.assign_if", AssignIfOpInterpCtxImpl<schema::AssignIfOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AssignIfNotOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AssignIfNotOpInterpCtxImpl : public AssignIfNotOpInterpCtx {
 public:
  AssignIfNotOpInterpCtxImpl() = default;
  AssignIfNotOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AssignIfNotOp {
 public:
  AssignIfNotOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "AssignIfNot op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.assign_if_not", AssignIfNotOpInterpCtxImpl<schema::AssignIfNotOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AtanOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AtanOpInterpCtxImpl : public AtanOpInterpCtx {
 public:
  AtanOpInterpCtxImpl() = default;
  AtanOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AtanOp {
 public:
  AtanOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Atan op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.atan", AtanOpInterpCtxImpl<schema::AtanOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class Atan2OpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class Atan2OpInterpCtxImpl : public Atan2OpInterpCtx {
 public:
  Atan2OpInterpCtxImpl() = default;
  Atan2OpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Atan2Op {
 public:
  Atan2Op() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Atan2 op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.atan2", Atan2OpInterpCtxImpl<schema::Atan2Op>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class Atan2XGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class Atan2XGradOpInterpCtxImpl : public Atan2XGradOpInterpCtx {
 public:
  Atan2XGradOpInterpCtxImpl() = default;
  Atan2XGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Atan2XGradOp {
 public:
  Atan2XGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Atan2XGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.atan2_x_grad", Atan2XGradOpInterpCtxImpl<schema::Atan2XGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class Atan2YGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class Atan2YGradOpInterpCtxImpl : public Atan2YGradOpInterpCtx {
 public:
  Atan2YGradOpInterpCtxImpl() = default;
  Atan2YGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Atan2YGradOp {
 public:
  Atan2YGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Atan2YGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.atan2_y_grad", Atan2YGradOpInterpCtxImpl<schema::Atan2YGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AtanGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AtanGradOpInterpCtxImpl : public AtanGradOpInterpCtx {
 public:
  AtanGradOpInterpCtxImpl() = default;
  AtanGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AtanGradOp {
 public:
  AtanGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "AtanGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.atan_grad", AtanGradOpInterpCtxImpl<schema::AtanGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AtanhOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AtanhOpInterpCtxImpl : public AtanhOpInterpCtx {
 public:
  AtanhOpInterpCtxImpl() = default;
  AtanhOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AtanhOp {
 public:
  AtanhOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Atanh op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.atanh", AtanhOpInterpCtxImpl<schema::AtanhOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AtanhGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class AtanhGradOpInterpCtxImpl : public AtanhGradOpInterpCtx {
 public:
  AtanhGradOpInterpCtxImpl() = default;
  AtanhGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AtanhGradOp {
 public:
  AtanhGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "AtanhGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.atanh_grad", AtanhGradOpInterpCtxImpl<schema::AtanhGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AvgPool1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& padding() const = 0;
  virtual std::vector<int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int32_t>& padding) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& stride() const = 0;
  virtual std::vector<int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<int32_t>& stride) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",         "data_format", "kernel_size",
                                           "stride",          "ceil_mode",   "count_include_pad",
                                           "divisor_override"};
    return attr_names;
  }
};
template<typename Provider>
class AvgPool1DOpInterpCtxImpl : public AvgPool1DOpInterpCtx {
 public:
  AvgPool1DOpInterpCtxImpl() = default;
  AvgPool1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& padding() const override { return impl_.padding(); }
  std::vector<int32_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int32_t>& padding) override { impl_.set_padding(padding); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& stride() const override { return impl_.stride(); }
  std::vector<int32_t>* mutable_stride() override { return impl_.mutable_stride(); }
  void set_stride(const std::vector<int32_t>& stride) override { impl_.set_stride(stride); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  const bool& count_include_pad() const override { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() override { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) override {
    impl_.set_count_include_pad(count_include_pad);
  }

  const int64_t& divisor_override() const override { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() override { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) override {
    impl_.set_divisor_override(divisor_override);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AvgPool1DOp {
 public:
  AvgPool1DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "stride") {
      return CastAttr(&internal_->stride);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else if (attr_name == "count_include_pad") {
      return CastAttr(&internal_->count_include_pad);
    } else if (attr_name == "divisor_override") {
      return CastAttr(&internal_->divisor_override);
    } else {
      return Error::RuntimeError() << "AvgPool1D op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& padding() const { return internal_->padding; }
  std::vector<int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int32_t>& padding) { internal_->padding = padding; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& stride() const { return internal_->stride; }
  std::vector<int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<int32_t>& stride) { internal_->stride = stride; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) {
    internal_->count_include_pad = count_include_pad;
  }

  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) {
    internal_->divisor_override = divisor_override;
  }

 private:
  struct Internal {
    std::vector<int32_t> padding;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> stride;
    bool ceil_mode;
    bool count_include_pad;
    int64_t divisor_override;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.avgpool_1d", AvgPool1DOpInterpCtxImpl<schema::AvgPool1DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AvgPool1DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& padding() const = 0;
  virtual std::vector<int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int32_t>& padding) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& stride() const = 0;
  virtual std::vector<int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<int32_t>& stride) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",         "data_format", "kernel_size",
                                           "stride",          "ceil_mode",   "count_include_pad",
                                           "divisor_override"};
    return attr_names;
  }
};
template<typename Provider>
class AvgPool1DGradOpInterpCtxImpl : public AvgPool1DGradOpInterpCtx {
 public:
  AvgPool1DGradOpInterpCtxImpl() = default;
  AvgPool1DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& padding() const override { return impl_.padding(); }
  std::vector<int32_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int32_t>& padding) override { impl_.set_padding(padding); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& stride() const override { return impl_.stride(); }
  std::vector<int32_t>* mutable_stride() override { return impl_.mutable_stride(); }
  void set_stride(const std::vector<int32_t>& stride) override { impl_.set_stride(stride); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  const bool& count_include_pad() const override { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() override { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) override {
    impl_.set_count_include_pad(count_include_pad);
  }

  const int64_t& divisor_override() const override { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() override { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) override {
    impl_.set_divisor_override(divisor_override);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AvgPool1DGradOp {
 public:
  AvgPool1DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "stride") {
      return CastAttr(&internal_->stride);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else if (attr_name == "count_include_pad") {
      return CastAttr(&internal_->count_include_pad);
    } else if (attr_name == "divisor_override") {
      return CastAttr(&internal_->divisor_override);
    } else {
      return Error::RuntimeError() << "AvgPool1DGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& padding() const { return internal_->padding; }
  std::vector<int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int32_t>& padding) { internal_->padding = padding; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& stride() const { return internal_->stride; }
  std::vector<int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<int32_t>& stride) { internal_->stride = stride; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) {
    internal_->count_include_pad = count_include_pad;
  }

  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) {
    internal_->divisor_override = divisor_override;
  }

 private:
  struct Internal {
    std::vector<int32_t> padding;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> stride;
    bool ceil_mode;
    bool count_include_pad;
    int64_t divisor_override;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.avgpool_1d_grad",
                       AvgPool1DGradOpInterpCtxImpl<schema::AvgPool1DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AvgPool2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& padding() const = 0;
  virtual std::vector<int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int32_t>& padding) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& stride() const = 0;
  virtual std::vector<int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<int32_t>& stride) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",         "data_format", "kernel_size",
                                           "stride",          "ceil_mode",   "count_include_pad",
                                           "divisor_override"};
    return attr_names;
  }
};
template<typename Provider>
class AvgPool2DOpInterpCtxImpl : public AvgPool2DOpInterpCtx {
 public:
  AvgPool2DOpInterpCtxImpl() = default;
  AvgPool2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& padding() const override { return impl_.padding(); }
  std::vector<int32_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int32_t>& padding) override { impl_.set_padding(padding); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& stride() const override { return impl_.stride(); }
  std::vector<int32_t>* mutable_stride() override { return impl_.mutable_stride(); }
  void set_stride(const std::vector<int32_t>& stride) override { impl_.set_stride(stride); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  const bool& count_include_pad() const override { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() override { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) override {
    impl_.set_count_include_pad(count_include_pad);
  }

  const int64_t& divisor_override() const override { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() override { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) override {
    impl_.set_divisor_override(divisor_override);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AvgPool2DOp {
 public:
  AvgPool2DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "stride") {
      return CastAttr(&internal_->stride);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else if (attr_name == "count_include_pad") {
      return CastAttr(&internal_->count_include_pad);
    } else if (attr_name == "divisor_override") {
      return CastAttr(&internal_->divisor_override);
    } else {
      return Error::RuntimeError() << "AvgPool2D op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& padding() const { return internal_->padding; }
  std::vector<int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int32_t>& padding) { internal_->padding = padding; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& stride() const { return internal_->stride; }
  std::vector<int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<int32_t>& stride) { internal_->stride = stride; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) {
    internal_->count_include_pad = count_include_pad;
  }

  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) {
    internal_->divisor_override = divisor_override;
  }

 private:
  struct Internal {
    std::vector<int32_t> padding;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> stride;
    bool ceil_mode;
    bool count_include_pad;
    int64_t divisor_override;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.avgpool_2d", AvgPool2DOpInterpCtxImpl<schema::AvgPool2DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AvgPool2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& padding() const = 0;
  virtual std::vector<int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int32_t>& padding) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& stride() const = 0;
  virtual std::vector<int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<int32_t>& stride) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",         "data_format", "kernel_size",
                                           "stride",          "ceil_mode",   "count_include_pad",
                                           "divisor_override"};
    return attr_names;
  }
};
template<typename Provider>
class AvgPool2DGradOpInterpCtxImpl : public AvgPool2DGradOpInterpCtx {
 public:
  AvgPool2DGradOpInterpCtxImpl() = default;
  AvgPool2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& padding() const override { return impl_.padding(); }
  std::vector<int32_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int32_t>& padding) override { impl_.set_padding(padding); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& stride() const override { return impl_.stride(); }
  std::vector<int32_t>* mutable_stride() override { return impl_.mutable_stride(); }
  void set_stride(const std::vector<int32_t>& stride) override { impl_.set_stride(stride); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  const bool& count_include_pad() const override { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() override { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) override {
    impl_.set_count_include_pad(count_include_pad);
  }

  const int64_t& divisor_override() const override { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() override { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) override {
    impl_.set_divisor_override(divisor_override);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AvgPool2DGradOp {
 public:
  AvgPool2DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "stride") {
      return CastAttr(&internal_->stride);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else if (attr_name == "count_include_pad") {
      return CastAttr(&internal_->count_include_pad);
    } else if (attr_name == "divisor_override") {
      return CastAttr(&internal_->divisor_override);
    } else {
      return Error::RuntimeError() << "AvgPool2DGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& padding() const { return internal_->padding; }
  std::vector<int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int32_t>& padding) { internal_->padding = padding; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& stride() const { return internal_->stride; }
  std::vector<int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<int32_t>& stride) { internal_->stride = stride; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) {
    internal_->count_include_pad = count_include_pad;
  }

  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) {
    internal_->divisor_override = divisor_override;
  }

 private:
  struct Internal {
    std::vector<int32_t> padding;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> stride;
    bool ceil_mode;
    bool count_include_pad;
    int64_t divisor_override;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.avgpool_2d_grad",
                       AvgPool2DGradOpInterpCtxImpl<schema::AvgPool2DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AvgPool3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& padding() const = 0;
  virtual std::vector<int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int32_t>& padding) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& stride() const = 0;
  virtual std::vector<int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<int32_t>& stride) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",         "data_format", "kernel_size",
                                           "stride",          "ceil_mode",   "count_include_pad",
                                           "divisor_override"};
    return attr_names;
  }
};
template<typename Provider>
class AvgPool3DOpInterpCtxImpl : public AvgPool3DOpInterpCtx {
 public:
  AvgPool3DOpInterpCtxImpl() = default;
  AvgPool3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& padding() const override { return impl_.padding(); }
  std::vector<int32_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int32_t>& padding) override { impl_.set_padding(padding); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& stride() const override { return impl_.stride(); }
  std::vector<int32_t>* mutable_stride() override { return impl_.mutable_stride(); }
  void set_stride(const std::vector<int32_t>& stride) override { impl_.set_stride(stride); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  const bool& count_include_pad() const override { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() override { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) override {
    impl_.set_count_include_pad(count_include_pad);
  }

  const int64_t& divisor_override() const override { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() override { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) override {
    impl_.set_divisor_override(divisor_override);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AvgPool3DOp {
 public:
  AvgPool3DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "stride") {
      return CastAttr(&internal_->stride);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else if (attr_name == "count_include_pad") {
      return CastAttr(&internal_->count_include_pad);
    } else if (attr_name == "divisor_override") {
      return CastAttr(&internal_->divisor_override);
    } else {
      return Error::RuntimeError() << "AvgPool3D op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& padding() const { return internal_->padding; }
  std::vector<int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int32_t>& padding) { internal_->padding = padding; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& stride() const { return internal_->stride; }
  std::vector<int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<int32_t>& stride) { internal_->stride = stride; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) {
    internal_->count_include_pad = count_include_pad;
  }

  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) {
    internal_->divisor_override = divisor_override;
  }

 private:
  struct Internal {
    std::vector<int32_t> padding;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> stride;
    bool ceil_mode;
    bool count_include_pad;
    int64_t divisor_override;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.avgpool_3d", AvgPool3DOpInterpCtxImpl<schema::AvgPool3DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class AvgPool3DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& padding() const = 0;
  virtual std::vector<int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int32_t>& padding) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& stride() const = 0;
  virtual std::vector<int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<int32_t>& stride) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  virtual const bool& count_include_pad() const = 0;
  virtual bool* mutable_count_include_pad() = 0;
  virtual void set_count_include_pad(const bool& count_include_pad) = 0;

  virtual const int64_t& divisor_override() const = 0;
  virtual int64_t* mutable_divisor_override() = 0;
  virtual void set_divisor_override(const int64_t& divisor_override) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",         "data_format", "kernel_size",
                                           "stride",          "ceil_mode",   "count_include_pad",
                                           "divisor_override"};
    return attr_names;
  }
};
template<typename Provider>
class AvgPool3DGradOpInterpCtxImpl : public AvgPool3DGradOpInterpCtx {
 public:
  AvgPool3DGradOpInterpCtxImpl() = default;
  AvgPool3DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& padding() const override { return impl_.padding(); }
  std::vector<int32_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int32_t>& padding) override { impl_.set_padding(padding); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& stride() const override { return impl_.stride(); }
  std::vector<int32_t>* mutable_stride() override { return impl_.mutable_stride(); }
  void set_stride(const std::vector<int32_t>& stride) override { impl_.set_stride(stride); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  const bool& count_include_pad() const override { return impl_.count_include_pad(); }
  bool* mutable_count_include_pad() override { return impl_.mutable_count_include_pad(); }
  void set_count_include_pad(const bool& count_include_pad) override {
    impl_.set_count_include_pad(count_include_pad);
  }

  const int64_t& divisor_override() const override { return impl_.divisor_override(); }
  int64_t* mutable_divisor_override() override { return impl_.mutable_divisor_override(); }
  void set_divisor_override(const int64_t& divisor_override) override {
    impl_.set_divisor_override(divisor_override);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class AvgPool3DGradOp {
 public:
  AvgPool3DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "stride") {
      return CastAttr(&internal_->stride);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else if (attr_name == "count_include_pad") {
      return CastAttr(&internal_->count_include_pad);
    } else if (attr_name == "divisor_override") {
      return CastAttr(&internal_->divisor_override);
    } else {
      return Error::RuntimeError() << "AvgPool3DGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& padding() const { return internal_->padding; }
  std::vector<int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int32_t>& padding) { internal_->padding = padding; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& stride() const { return internal_->stride; }
  std::vector<int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<int32_t>& stride) { internal_->stride = stride; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

  const bool& count_include_pad() const { return internal_->count_include_pad; }
  bool* mutable_count_include_pad() { return &internal_->count_include_pad; }
  void set_count_include_pad(const bool& count_include_pad) {
    internal_->count_include_pad = count_include_pad;
  }

  const int64_t& divisor_override() const { return internal_->divisor_override; }
  int64_t* mutable_divisor_override() { return &internal_->divisor_override; }
  void set_divisor_override(const int64_t& divisor_override) {
    internal_->divisor_override = divisor_override;
  }

 private:
  struct Internal {
    std::vector<int32_t> padding;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> stride;
    bool ceil_mode;
    bool count_include_pad;
    int64_t divisor_override;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.avgpool_3d_grad",
                       AvgPool3DGradOpInterpCtxImpl<schema::AvgPool3DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BatchGatherOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BatchGatherOpInterpCtxImpl : public BatchGatherOpInterpCtx {
 public:
  BatchGatherOpInterpCtxImpl() = default;
  BatchGatherOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BatchGatherOp {
 public:
  BatchGatherOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BatchGather op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.batch_gather", BatchGatherOpInterpCtxImpl<schema::BatchGatherOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BatchMatmulOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& transpose_a() const = 0;
  virtual bool* mutable_transpose_a() = 0;
  virtual void set_transpose_a(const bool& transpose_a) = 0;

  virtual const bool& transpose_b() const = 0;
  virtual bool* mutable_transpose_b() = 0;
  virtual void set_transpose_b(const bool& transpose_b) = 0;

  virtual const double& alpha() const = 0;
  virtual double* mutable_alpha() = 0;
  virtual void set_alpha(const double& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"transpose_a", "transpose_b", "alpha"};
    return attr_names;
  }
};
template<typename Provider>
class BatchMatmulOpInterpCtxImpl : public BatchMatmulOpInterpCtx {
 public:
  BatchMatmulOpInterpCtxImpl() = default;
  BatchMatmulOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& transpose_a() const override { return impl_.transpose_a(); }
  bool* mutable_transpose_a() override { return impl_.mutable_transpose_a(); }
  void set_transpose_a(const bool& transpose_a) override { impl_.set_transpose_a(transpose_a); }

  const bool& transpose_b() const override { return impl_.transpose_b(); }
  bool* mutable_transpose_b() override { return impl_.mutable_transpose_b(); }
  void set_transpose_b(const bool& transpose_b) override { impl_.set_transpose_b(transpose_b); }

  const double& alpha() const override { return impl_.alpha(); }
  double* mutable_alpha() override { return impl_.mutable_alpha(); }
  void set_alpha(const double& alpha) override { impl_.set_alpha(alpha); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BatchMatmulOp {
 public:
  BatchMatmulOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "transpose_a") {
      return CastAttr(&internal_->transpose_a);
    } else if (attr_name == "transpose_b") {
      return CastAttr(&internal_->transpose_b);
    } else if (attr_name == "alpha") {
      return CastAttr(&internal_->alpha);
    } else {
      return Error::RuntimeError() << "BatchMatmul op has no attribute named " << attr_name;
    }
  }

  const bool& transpose_a() const { return internal_->transpose_a; }
  bool* mutable_transpose_a() { return &internal_->transpose_a; }
  void set_transpose_a(const bool& transpose_a) { internal_->transpose_a = transpose_a; }

  const bool& transpose_b() const { return internal_->transpose_b; }
  bool* mutable_transpose_b() { return &internal_->transpose_b; }
  void set_transpose_b(const bool& transpose_b) { internal_->transpose_b = transpose_b; }

  const double& alpha() const { return internal_->alpha; }
  double* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const double& alpha) { internal_->alpha = alpha; }

 private:
  struct Internal {
    bool transpose_a;
    bool transpose_b;
    double alpha;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.batch_matmul", BatchMatmulOpInterpCtxImpl<schema::BatchMatmulOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BernoulliOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const bool& has_seed() const = 0;
  virtual bool* mutable_has_seed() = 0;
  virtual void set_has_seed(const bool& has_seed) = 0;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"seed", "has_seed", "dtype"};
    return attr_names;
  }
};
template<typename Provider>
class BernoulliOpInterpCtxImpl : public BernoulliOpInterpCtx {
 public:
  BernoulliOpInterpCtxImpl() = default;
  BernoulliOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& seed() const override { return impl_.seed(); }
  int64_t* mutable_seed() override { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) override { impl_.set_seed(seed); }

  const bool& has_seed() const override { return impl_.has_seed(); }
  bool* mutable_has_seed() override { return impl_.mutable_has_seed(); }
  void set_has_seed(const bool& has_seed) override { impl_.set_has_seed(has_seed); }

  const DataType& dtype() const override { return impl_.dtype(); }
  DataType* mutable_dtype() override { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) override { impl_.set_dtype(dtype); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BernoulliOp {
 public:
  BernoulliOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "seed") {
      return CastAttr(&internal_->seed);
    } else if (attr_name == "has_seed") {
      return CastAttr(&internal_->has_seed);
    } else if (attr_name == "dtype") {
      return CastAttr(&internal_->dtype);
    } else {
      return Error::RuntimeError() << "Bernoulli op has no attribute named " << attr_name;
    }
  }

  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }

  const bool& has_seed() const { return internal_->has_seed; }
  bool* mutable_has_seed() { return &internal_->has_seed; }
  void set_has_seed(const bool& has_seed) { internal_->has_seed = has_seed; }

  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }

 private:
  struct Internal {
    int64_t seed;
    bool has_seed;
    DataType dtype;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.bernoulli", BernoulliOpInterpCtxImpl<schema::BernoulliOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BiasAddOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis"};
    return attr_names;
  }
};
template<typename Provider>
class BiasAddOpInterpCtxImpl : public BiasAddOpInterpCtx {
 public:
  BiasAddOpInterpCtxImpl() = default;
  BiasAddOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& axis() const override { return impl_.axis(); }
  int32_t* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) override { impl_.set_axis(axis); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BiasAddOp {
 public:
  BiasAddOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else {
      return Error::RuntimeError() << "BiasAdd op has no attribute named " << attr_name;
    }
  }

  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }

 private:
  struct Internal {
    int32_t axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.bias_add", BiasAddOpInterpCtxImpl<schema::BiasAddOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BinaryCrossEntropyOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BinaryCrossEntropyOpInterpCtxImpl : public BinaryCrossEntropyOpInterpCtx {
 public:
  BinaryCrossEntropyOpInterpCtxImpl() = default;
  BinaryCrossEntropyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BinaryCrossEntropyOp {
 public:
  BinaryCrossEntropyOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BinaryCrossEntropy op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.binary_cross_entropy",
                       BinaryCrossEntropyOpInterpCtxImpl<schema::BinaryCrossEntropyOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BinaryCrossEntropyGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BinaryCrossEntropyGradOpInterpCtxImpl : public BinaryCrossEntropyGradOpInterpCtx {
 public:
  BinaryCrossEntropyGradOpInterpCtxImpl() = default;
  BinaryCrossEntropyGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BinaryCrossEntropyGradOp {
 public:
  BinaryCrossEntropyGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BinaryCrossEntropyGrad op has no attribute named "
                                 << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.binary_cross_entropy_grad",
                       BinaryCrossEntropyGradOpInterpCtxImpl<schema::BinaryCrossEntropyGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BinaryCrossEntropyWithLogitsOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_pos_weight() const = 0;
  virtual bool* mutable_has_pos_weight() = 0;
  virtual void set_has_pos_weight(const bool& has_pos_weight) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_pos_weight"};
    return attr_names;
  }
};
template<typename Provider>
class BinaryCrossEntropyWithLogitsOpInterpCtxImpl : public BinaryCrossEntropyWithLogitsOpInterpCtx {
 public:
  BinaryCrossEntropyWithLogitsOpInterpCtxImpl() = default;
  BinaryCrossEntropyWithLogitsOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_pos_weight() const override { return impl_.has_pos_weight(); }
  bool* mutable_has_pos_weight() override { return impl_.mutable_has_pos_weight(); }
  void set_has_pos_weight(const bool& has_pos_weight) override {
    impl_.set_has_pos_weight(has_pos_weight);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BinaryCrossEntropyWithLogitsOp {
 public:
  BinaryCrossEntropyWithLogitsOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_pos_weight") {
      return CastAttr(&internal_->has_pos_weight);
    } else {
      return Error::RuntimeError()
             << "BinaryCrossEntropyWithLogits op has no attribute named " << attr_name;
    }
  }

  const bool& has_pos_weight() const { return internal_->has_pos_weight; }
  bool* mutable_has_pos_weight() { return &internal_->has_pos_weight; }
  void set_has_pos_weight(const bool& has_pos_weight) {
    internal_->has_pos_weight = has_pos_weight;
  }

 private:
  struct Internal {
    bool has_pos_weight;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.binary_cross_entropy_with_logits",
    BinaryCrossEntropyWithLogitsOpInterpCtxImpl<schema::BinaryCrossEntropyWithLogitsOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BinaryCrossEntropyWithLogitsGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_pos_weight() const = 0;
  virtual bool* mutable_has_pos_weight() = 0;
  virtual void set_has_pos_weight(const bool& has_pos_weight) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_pos_weight"};
    return attr_names;
  }
};
template<typename Provider>
class BinaryCrossEntropyWithLogitsGradOpInterpCtxImpl
    : public BinaryCrossEntropyWithLogitsGradOpInterpCtx {
 public:
  BinaryCrossEntropyWithLogitsGradOpInterpCtxImpl() = default;
  BinaryCrossEntropyWithLogitsGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_pos_weight() const override { return impl_.has_pos_weight(); }
  bool* mutable_has_pos_weight() override { return impl_.mutable_has_pos_weight(); }
  void set_has_pos_weight(const bool& has_pos_weight) override {
    impl_.set_has_pos_weight(has_pos_weight);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BinaryCrossEntropyWithLogitsGradOp {
 public:
  BinaryCrossEntropyWithLogitsGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_pos_weight") {
      return CastAttr(&internal_->has_pos_weight);
    } else {
      return Error::RuntimeError()
             << "BinaryCrossEntropyWithLogitsGrad op has no attribute named " << attr_name;
    }
  }

  const bool& has_pos_weight() const { return internal_->has_pos_weight; }
  bool* mutable_has_pos_weight() { return &internal_->has_pos_weight; }
  void set_has_pos_weight(const bool& has_pos_weight) {
    internal_->has_pos_weight = has_pos_weight;
  }

 private:
  struct Internal {
    bool has_pos_weight;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.binary_cross_entropy_with_logits_grad",
    BinaryCrossEntropyWithLogitsGradOpInterpCtxImpl<schema::BinaryCrossEntropyWithLogitsGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastAddOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastAddOpInterpCtxImpl : public BroadcastAddOpInterpCtx {
 public:
  BroadcastAddOpInterpCtxImpl() = default;
  BroadcastAddOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastAddOp {
 public:
  BroadcastAddOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastAdd op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_add", BroadcastAddOpInterpCtxImpl<schema::BroadcastAddOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastDivOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastDivOpInterpCtxImpl : public BroadcastDivOpInterpCtx {
 public:
  BroadcastDivOpInterpCtxImpl() = default;
  BroadcastDivOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastDivOp {
 public:
  BroadcastDivOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastDiv op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_div", BroadcastDivOpInterpCtxImpl<schema::BroadcastDivOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastDivGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastDivGradOpInterpCtxImpl : public BroadcastDivGradOpInterpCtx {
 public:
  BroadcastDivGradOpInterpCtxImpl() = default;
  BroadcastDivGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastDivGradOp {
 public:
  BroadcastDivGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastDivGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_div_grad",
                       BroadcastDivGradOpInterpCtxImpl<schema::BroadcastDivGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastEqualOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastEqualOpInterpCtxImpl : public BroadcastEqualOpInterpCtx {
 public:
  BroadcastEqualOpInterpCtxImpl() = default;
  BroadcastEqualOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastEqualOp {
 public:
  BroadcastEqualOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastEqual op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_equal",
                       BroadcastEqualOpInterpCtxImpl<schema::BroadcastEqualOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastFloorModOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastFloorModOpInterpCtxImpl : public BroadcastFloorModOpInterpCtx {
 public:
  BroadcastFloorModOpInterpCtxImpl() = default;
  BroadcastFloorModOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastFloorModOp {
 public:
  BroadcastFloorModOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastFloorMod op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_floor_mod",
                       BroadcastFloorModOpInterpCtxImpl<schema::BroadcastFloorModOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastFmodOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastFmodOpInterpCtxImpl : public BroadcastFmodOpInterpCtx {
 public:
  BroadcastFmodOpInterpCtxImpl() = default;
  BroadcastFmodOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastFmodOp {
 public:
  BroadcastFmodOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastFmod op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_fmod",
                       BroadcastFmodOpInterpCtxImpl<schema::BroadcastFmodOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastGreaterOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastGreaterOpInterpCtxImpl : public BroadcastGreaterOpInterpCtx {
 public:
  BroadcastGreaterOpInterpCtxImpl() = default;
  BroadcastGreaterOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastGreaterOp {
 public:
  BroadcastGreaterOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastGreater op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_greater",
                       BroadcastGreaterOpInterpCtxImpl<schema::BroadcastGreaterOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastGreaterEqualOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastGreaterEqualOpInterpCtxImpl : public BroadcastGreaterEqualOpInterpCtx {
 public:
  BroadcastGreaterEqualOpInterpCtxImpl() = default;
  BroadcastGreaterEqualOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastGreaterEqualOp {
 public:
  BroadcastGreaterEqualOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastGreaterEqual op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_greater_equal",
                       BroadcastGreaterEqualOpInterpCtxImpl<schema::BroadcastGreaterEqualOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastLessOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastLessOpInterpCtxImpl : public BroadcastLessOpInterpCtx {
 public:
  BroadcastLessOpInterpCtxImpl() = default;
  BroadcastLessOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastLessOp {
 public:
  BroadcastLessOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastLess op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_less",
                       BroadcastLessOpInterpCtxImpl<schema::BroadcastLessOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastLessEqualOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastLessEqualOpInterpCtxImpl : public BroadcastLessEqualOpInterpCtx {
 public:
  BroadcastLessEqualOpInterpCtxImpl() = default;
  BroadcastLessEqualOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastLessEqualOp {
 public:
  BroadcastLessEqualOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastLessEqual op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_less_equal",
                       BroadcastLessEqualOpInterpCtxImpl<schema::BroadcastLessEqualOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& broadcast_axes() const = 0;
  virtual std::vector<int32_t>* mutable_broadcast_axes() = 0;
  virtual void set_broadcast_axes(const std::vector<int32_t>& broadcast_axes) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"broadcast_axes"};
    return attr_names;
  }
};
template<typename Provider>
class BroadcastLikeOpInterpCtxImpl : public BroadcastLikeOpInterpCtx {
 public:
  BroadcastLikeOpInterpCtxImpl() = default;
  BroadcastLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& broadcast_axes() const override { return impl_.broadcast_axes(); }
  std::vector<int32_t>* mutable_broadcast_axes() override { return impl_.mutable_broadcast_axes(); }
  void set_broadcast_axes(const std::vector<int32_t>& broadcast_axes) override {
    impl_.set_broadcast_axes(broadcast_axes);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastLikeOp {
 public:
  BroadcastLikeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "broadcast_axes") {
      return CastAttr(&internal_->broadcast_axes);
    } else {
      return Error::RuntimeError() << "BroadcastLike op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& broadcast_axes() const { return internal_->broadcast_axes; }
  std::vector<int32_t>* mutable_broadcast_axes() { return &internal_->broadcast_axes; }
  void set_broadcast_axes(const std::vector<int32_t>& broadcast_axes) {
    internal_->broadcast_axes = broadcast_axes;
  }

 private:
  struct Internal {
    std::vector<int32_t> broadcast_axes;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_like",
                       BroadcastLikeOpInterpCtxImpl<schema::BroadcastLikeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastLogicalAndOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastLogicalAndOpInterpCtxImpl : public BroadcastLogicalAndOpInterpCtx {
 public:
  BroadcastLogicalAndOpInterpCtxImpl() = default;
  BroadcastLogicalAndOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastLogicalAndOp {
 public:
  BroadcastLogicalAndOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastLogicalAnd op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_logical_and",
                       BroadcastLogicalAndOpInterpCtxImpl<schema::BroadcastLogicalAndOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastLogicalOrOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastLogicalOrOpInterpCtxImpl : public BroadcastLogicalOrOpInterpCtx {
 public:
  BroadcastLogicalOrOpInterpCtxImpl() = default;
  BroadcastLogicalOrOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastLogicalOrOp {
 public:
  BroadcastLogicalOrOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastLogicalOr op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_logical_or",
                       BroadcastLogicalOrOpInterpCtxImpl<schema::BroadcastLogicalOrOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastLogicalXorOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastLogicalXorOpInterpCtxImpl : public BroadcastLogicalXorOpInterpCtx {
 public:
  BroadcastLogicalXorOpInterpCtxImpl() = default;
  BroadcastLogicalXorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastLogicalXorOp {
 public:
  BroadcastLogicalXorOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastLogicalXor op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_logical_xor",
                       BroadcastLogicalXorOpInterpCtxImpl<schema::BroadcastLogicalXorOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastMatmulOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& transpose_a() const = 0;
  virtual bool* mutable_transpose_a() = 0;
  virtual void set_transpose_a(const bool& transpose_a) = 0;

  virtual const bool& transpose_b() const = 0;
  virtual bool* mutable_transpose_b() = 0;
  virtual void set_transpose_b(const bool& transpose_b) = 0;

  virtual const double& alpha() const = 0;
  virtual double* mutable_alpha() = 0;
  virtual void set_alpha(const double& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"transpose_a", "transpose_b", "alpha"};
    return attr_names;
  }
};
template<typename Provider>
class BroadcastMatmulOpInterpCtxImpl : public BroadcastMatmulOpInterpCtx {
 public:
  BroadcastMatmulOpInterpCtxImpl() = default;
  BroadcastMatmulOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& transpose_a() const override { return impl_.transpose_a(); }
  bool* mutable_transpose_a() override { return impl_.mutable_transpose_a(); }
  void set_transpose_a(const bool& transpose_a) override { impl_.set_transpose_a(transpose_a); }

  const bool& transpose_b() const override { return impl_.transpose_b(); }
  bool* mutable_transpose_b() override { return impl_.mutable_transpose_b(); }
  void set_transpose_b(const bool& transpose_b) override { impl_.set_transpose_b(transpose_b); }

  const double& alpha() const override { return impl_.alpha(); }
  double* mutable_alpha() override { return impl_.mutable_alpha(); }
  void set_alpha(const double& alpha) override { impl_.set_alpha(alpha); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastMatmulOp {
 public:
  BroadcastMatmulOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "transpose_a") {
      return CastAttr(&internal_->transpose_a);
    } else if (attr_name == "transpose_b") {
      return CastAttr(&internal_->transpose_b);
    } else if (attr_name == "alpha") {
      return CastAttr(&internal_->alpha);
    } else {
      return Error::RuntimeError() << "BroadcastMatmul op has no attribute named " << attr_name;
    }
  }

  const bool& transpose_a() const { return internal_->transpose_a; }
  bool* mutable_transpose_a() { return &internal_->transpose_a; }
  void set_transpose_a(const bool& transpose_a) { internal_->transpose_a = transpose_a; }

  const bool& transpose_b() const { return internal_->transpose_b; }
  bool* mutable_transpose_b() { return &internal_->transpose_b; }
  void set_transpose_b(const bool& transpose_b) { internal_->transpose_b = transpose_b; }

  const double& alpha() const { return internal_->alpha; }
  double* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const double& alpha) { internal_->alpha = alpha; }

 private:
  struct Internal {
    bool transpose_a;
    bool transpose_b;
    double alpha;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_matmul",
                       BroadcastMatmulOpInterpCtxImpl<schema::BroadcastMatmulOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastMatmulGradBOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& alpha() const = 0;
  virtual double* mutable_alpha() = 0;
  virtual void set_alpha(const double& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"alpha"};
    return attr_names;
  }
};
template<typename Provider>
class BroadcastMatmulGradBOpInterpCtxImpl : public BroadcastMatmulGradBOpInterpCtx {
 public:
  BroadcastMatmulGradBOpInterpCtxImpl() = default;
  BroadcastMatmulGradBOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& alpha() const override { return impl_.alpha(); }
  double* mutable_alpha() override { return impl_.mutable_alpha(); }
  void set_alpha(const double& alpha) override { impl_.set_alpha(alpha); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastMatmulGradBOp {
 public:
  BroadcastMatmulGradBOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "alpha") {
      return CastAttr(&internal_->alpha);
    } else {
      return Error::RuntimeError()
             << "BroadcastMatmulGradB op has no attribute named " << attr_name;
    }
  }

  const double& alpha() const { return internal_->alpha; }
  double* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const double& alpha) { internal_->alpha = alpha; }

 private:
  struct Internal {
    double alpha;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_matmul_grad_b",
                       BroadcastMatmulGradBOpInterpCtxImpl<schema::BroadcastMatmulGradBOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastMaximumOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastMaximumOpInterpCtxImpl : public BroadcastMaximumOpInterpCtx {
 public:
  BroadcastMaximumOpInterpCtxImpl() = default;
  BroadcastMaximumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastMaximumOp {
 public:
  BroadcastMaximumOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastMaximum op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_maximum",
                       BroadcastMaximumOpInterpCtxImpl<schema::BroadcastMaximumOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastMinimumOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastMinimumOpInterpCtxImpl : public BroadcastMinimumOpInterpCtx {
 public:
  BroadcastMinimumOpInterpCtxImpl() = default;
  BroadcastMinimumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastMinimumOp {
 public:
  BroadcastMinimumOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastMinimum op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_minimum",
                       BroadcastMinimumOpInterpCtxImpl<schema::BroadcastMinimumOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastMulOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastMulOpInterpCtxImpl : public BroadcastMulOpInterpCtx {
 public:
  BroadcastMulOpInterpCtxImpl() = default;
  BroadcastMulOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastMulOp {
 public:
  BroadcastMulOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastMul op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_mul", BroadcastMulOpInterpCtxImpl<schema::BroadcastMulOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastNotEqualOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastNotEqualOpInterpCtxImpl : public BroadcastNotEqualOpInterpCtx {
 public:
  BroadcastNotEqualOpInterpCtxImpl() = default;
  BroadcastNotEqualOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastNotEqualOp {
 public:
  BroadcastNotEqualOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastNotEqual op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_not_equal",
                       BroadcastNotEqualOpInterpCtxImpl<schema::BroadcastNotEqualOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastPowOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastPowOpInterpCtxImpl : public BroadcastPowOpInterpCtx {
 public:
  BroadcastPowOpInterpCtxImpl() = default;
  BroadcastPowOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastPowOp {
 public:
  BroadcastPowOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastPow op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_pow", BroadcastPowOpInterpCtxImpl<schema::BroadcastPowOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastPowXGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastPowXGradOpInterpCtxImpl : public BroadcastPowXGradOpInterpCtx {
 public:
  BroadcastPowXGradOpInterpCtxImpl() = default;
  BroadcastPowXGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastPowXGradOp {
 public:
  BroadcastPowXGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastPowXGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_pow_x_grad",
                       BroadcastPowXGradOpInterpCtxImpl<schema::BroadcastPowXGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastPowYGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastPowYGradOpInterpCtxImpl : public BroadcastPowYGradOpInterpCtx {
 public:
  BroadcastPowYGradOpInterpCtxImpl() = default;
  BroadcastPowYGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastPowYGradOp {
 public:
  BroadcastPowYGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastPowYGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_pow_y_grad",
                       BroadcastPowYGradOpInterpCtxImpl<schema::BroadcastPowYGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class BroadcastSubOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class BroadcastSubOpInterpCtxImpl : public BroadcastSubOpInterpCtx {
 public:
  BroadcastSubOpInterpCtxImpl() = default;
  BroadcastSubOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class BroadcastSubOp {
 public:
  BroadcastSubOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "BroadcastSub op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.broadcast_sub", BroadcastSubOpInterpCtxImpl<schema::BroadcastSubOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CastOpInterpCtx : public OpInterpCtx {
 public:
  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"dtype"};
    return attr_names;
  }
};
template<typename Provider>
class CastOpInterpCtxImpl : public CastOpInterpCtx {
 public:
  CastOpInterpCtxImpl() = default;
  CastOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const DataType& dtype() const override { return impl_.dtype(); }
  DataType* mutable_dtype() override { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) override { impl_.set_dtype(dtype); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CastOp {
 public:
  CastOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "dtype") {
      return CastAttr(&internal_->dtype);
    } else {
      return Error::RuntimeError() << "Cast op has no attribute named " << attr_name;
    }
  }

  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }

 private:
  struct Internal {
    DataType dtype;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.cast", CastOpInterpCtxImpl<schema::CastOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CastLikeOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class CastLikeOpInterpCtxImpl : public CastLikeOpInterpCtx {
 public:
  CastLikeOpInterpCtxImpl() = default;
  CastLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CastLikeOp {
 public:
  CastLikeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "CastLike op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.cast_like", CastLikeOpInterpCtxImpl<schema::CastLikeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CastToStaticShapeOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class CastToStaticShapeOpInterpCtxImpl : public CastToStaticShapeOpInterpCtx {
 public:
  CastToStaticShapeOpInterpCtxImpl() = default;
  CastToStaticShapeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CastToStaticShapeOp {
 public:
  CastToStaticShapeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "CastToStaticShape op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.cast_to_static_shape",
                       CastToStaticShapeOpInterpCtxImpl<schema::CastToStaticShapeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CastToTickOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class CastToTickOpInterpCtxImpl : public CastToTickOpInterpCtx {
 public:
  CastToTickOpInterpCtxImpl() = default;
  CastToTickOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CastToTickOp {
 public:
  CastToTickOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "CastToTick op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.cast_to_tick", CastToTickOpInterpCtxImpl<schema::CastToTickOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CcreluOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class CcreluOpInterpCtxImpl : public CcreluOpInterpCtx {
 public:
  CcreluOpInterpCtxImpl() = default;
  CcreluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CcreluOp {
 public:
  CcreluOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Ccrelu op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.ccrelu", CcreluOpInterpCtxImpl<schema::CcreluOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CcreluGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class CcreluGradOpInterpCtxImpl : public CcreluGradOpInterpCtx {
 public:
  CcreluGradOpInterpCtxImpl() = default;
  CcreluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CcreluGradOp {
 public:
  CcreluGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "CcreluGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.ccrelu_grad", CcreluGradOpInterpCtxImpl<schema::CcreluGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CeilOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class CeilOpInterpCtxImpl : public CeilOpInterpCtx {
 public:
  CeilOpInterpCtxImpl() = default;
  CeilOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CeilOp {
 public:
  CeilOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Ceil op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.ceil", CeilOpInterpCtxImpl<schema::CeilOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CeilGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class CeilGradOpInterpCtxImpl : public CeilGradOpInterpCtx {
 public:
  CeilGradOpInterpCtxImpl() = default;
  CeilGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CeilGradOp {
 public:
  CeilGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "CeilGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.ceil_grad", CeilGradOpInterpCtxImpl<schema::CeilGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CeluOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& alpha() const = 0;
  virtual double* mutable_alpha() = 0;
  virtual void set_alpha(const double& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"alpha"};
    return attr_names;
  }
};
template<typename Provider>
class CeluOpInterpCtxImpl : public CeluOpInterpCtx {
 public:
  CeluOpInterpCtxImpl() = default;
  CeluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& alpha() const override { return impl_.alpha(); }
  double* mutable_alpha() override { return impl_.mutable_alpha(); }
  void set_alpha(const double& alpha) override { impl_.set_alpha(alpha); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CeluOp {
 public:
  CeluOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "alpha") {
      return CastAttr(&internal_->alpha);
    } else {
      return Error::RuntimeError() << "Celu op has no attribute named " << attr_name;
    }
  }

  const double& alpha() const { return internal_->alpha; }
  double* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const double& alpha) { internal_->alpha = alpha; }

 private:
  struct Internal {
    double alpha;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.celu", CeluOpInterpCtxImpl<schema::CeluOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CeluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& alpha() const = 0;
  virtual double* mutable_alpha() = 0;
  virtual void set_alpha(const double& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"alpha"};
    return attr_names;
  }
};
template<typename Provider>
class CeluGradOpInterpCtxImpl : public CeluGradOpInterpCtx {
 public:
  CeluGradOpInterpCtxImpl() = default;
  CeluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& alpha() const override { return impl_.alpha(); }
  double* mutable_alpha() override { return impl_.mutable_alpha(); }
  void set_alpha(const double& alpha) override { impl_.set_alpha(alpha); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CeluGradOp {
 public:
  CeluGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "alpha") {
      return CastAttr(&internal_->alpha);
    } else {
      return Error::RuntimeError() << "CeluGrad op has no attribute named " << attr_name;
    }
  }

  const double& alpha() const { return internal_->alpha; }
  double* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const double& alpha) { internal_->alpha = alpha; }

 private:
  struct Internal {
    double alpha;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.celu_grad", CeluGradOpInterpCtxImpl<schema::CeluGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ClipByScalarOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& floating_min() const = 0;
  virtual double* mutable_floating_min() = 0;
  virtual void set_floating_min(const double& floating_min) = 0;

  virtual const int64_t& integral_min() const = 0;
  virtual int64_t* mutable_integral_min() = 0;
  virtual void set_integral_min(const int64_t& integral_min) = 0;

  virtual const double& floating_max() const = 0;
  virtual double* mutable_floating_max() = 0;
  virtual void set_floating_max(const double& floating_max) = 0;

  virtual const int64_t& integral_max() const = 0;
  virtual int64_t* mutable_integral_max() = 0;
  virtual void set_integral_max(const int64_t& integral_max) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"floating_min", "integral_min", "floating_max",
                                           "integral_max"};
    return attr_names;
  }
};
template<typename Provider>
class ClipByScalarOpInterpCtxImpl : public ClipByScalarOpInterpCtx {
 public:
  ClipByScalarOpInterpCtxImpl() = default;
  ClipByScalarOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& floating_min() const override { return impl_.floating_min(); }
  double* mutable_floating_min() override { return impl_.mutable_floating_min(); }
  void set_floating_min(const double& floating_min) override {
    impl_.set_floating_min(floating_min);
  }

  const int64_t& integral_min() const override { return impl_.integral_min(); }
  int64_t* mutable_integral_min() override { return impl_.mutable_integral_min(); }
  void set_integral_min(const int64_t& integral_min) override {
    impl_.set_integral_min(integral_min);
  }

  const double& floating_max() const override { return impl_.floating_max(); }
  double* mutable_floating_max() override { return impl_.mutable_floating_max(); }
  void set_floating_max(const double& floating_max) override {
    impl_.set_floating_max(floating_max);
  }

  const int64_t& integral_max() const override { return impl_.integral_max(); }
  int64_t* mutable_integral_max() override { return impl_.mutable_integral_max(); }
  void set_integral_max(const int64_t& integral_max) override {
    impl_.set_integral_max(integral_max);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ClipByScalarOp {
 public:
  ClipByScalarOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "floating_min") {
      return CastAttr(&internal_->floating_min);
    } else if (attr_name == "integral_min") {
      return CastAttr(&internal_->integral_min);
    } else if (attr_name == "floating_max") {
      return CastAttr(&internal_->floating_max);
    } else if (attr_name == "integral_max") {
      return CastAttr(&internal_->integral_max);
    } else {
      return Error::RuntimeError() << "ClipByScalar op has no attribute named " << attr_name;
    }
  }

  const double& floating_min() const { return internal_->floating_min; }
  double* mutable_floating_min() { return &internal_->floating_min; }
  void set_floating_min(const double& floating_min) { internal_->floating_min = floating_min; }

  const int64_t& integral_min() const { return internal_->integral_min; }
  int64_t* mutable_integral_min() { return &internal_->integral_min; }
  void set_integral_min(const int64_t& integral_min) { internal_->integral_min = integral_min; }

  const double& floating_max() const { return internal_->floating_max; }
  double* mutable_floating_max() { return &internal_->floating_max; }
  void set_floating_max(const double& floating_max) { internal_->floating_max = floating_max; }

  const int64_t& integral_max() const { return internal_->integral_max; }
  int64_t* mutable_integral_max() { return &internal_->integral_max; }
  void set_integral_max(const int64_t& integral_max) { internal_->integral_max = integral_max; }

 private:
  struct Internal {
    double floating_min;
    int64_t integral_min;
    double floating_max;
    int64_t integral_max;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.clip_by_scalar", ClipByScalarOpInterpCtxImpl<schema::ClipByScalarOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ClipByScalarGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& floating_min() const = 0;
  virtual double* mutable_floating_min() = 0;
  virtual void set_floating_min(const double& floating_min) = 0;

  virtual const int64_t& integral_min() const = 0;
  virtual int64_t* mutable_integral_min() = 0;
  virtual void set_integral_min(const int64_t& integral_min) = 0;

  virtual const double& floating_max() const = 0;
  virtual double* mutable_floating_max() = 0;
  virtual void set_floating_max(const double& floating_max) = 0;

  virtual const int64_t& integral_max() const = 0;
  virtual int64_t* mutable_integral_max() = 0;
  virtual void set_integral_max(const int64_t& integral_max) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"floating_min", "integral_min", "floating_max",
                                           "integral_max"};
    return attr_names;
  }
};
template<typename Provider>
class ClipByScalarGradOpInterpCtxImpl : public ClipByScalarGradOpInterpCtx {
 public:
  ClipByScalarGradOpInterpCtxImpl() = default;
  ClipByScalarGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& floating_min() const override { return impl_.floating_min(); }
  double* mutable_floating_min() override { return impl_.mutable_floating_min(); }
  void set_floating_min(const double& floating_min) override {
    impl_.set_floating_min(floating_min);
  }

  const int64_t& integral_min() const override { return impl_.integral_min(); }
  int64_t* mutable_integral_min() override { return impl_.mutable_integral_min(); }
  void set_integral_min(const int64_t& integral_min) override {
    impl_.set_integral_min(integral_min);
  }

  const double& floating_max() const override { return impl_.floating_max(); }
  double* mutable_floating_max() override { return impl_.mutable_floating_max(); }
  void set_floating_max(const double& floating_max) override {
    impl_.set_floating_max(floating_max);
  }

  const int64_t& integral_max() const override { return impl_.integral_max(); }
  int64_t* mutable_integral_max() override { return impl_.mutable_integral_max(); }
  void set_integral_max(const int64_t& integral_max) override {
    impl_.set_integral_max(integral_max);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ClipByScalarGradOp {
 public:
  ClipByScalarGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "floating_min") {
      return CastAttr(&internal_->floating_min);
    } else if (attr_name == "integral_min") {
      return CastAttr(&internal_->integral_min);
    } else if (attr_name == "floating_max") {
      return CastAttr(&internal_->floating_max);
    } else if (attr_name == "integral_max") {
      return CastAttr(&internal_->integral_max);
    } else {
      return Error::RuntimeError() << "ClipByScalarGrad op has no attribute named " << attr_name;
    }
  }

  const double& floating_min() const { return internal_->floating_min; }
  double* mutable_floating_min() { return &internal_->floating_min; }
  void set_floating_min(const double& floating_min) { internal_->floating_min = floating_min; }

  const int64_t& integral_min() const { return internal_->integral_min; }
  int64_t* mutable_integral_min() { return &internal_->integral_min; }
  void set_integral_min(const int64_t& integral_min) { internal_->integral_min = integral_min; }

  const double& floating_max() const { return internal_->floating_max; }
  double* mutable_floating_max() { return &internal_->floating_max; }
  void set_floating_max(const double& floating_max) { internal_->floating_max = floating_max; }

  const int64_t& integral_max() const { return internal_->integral_max; }
  int64_t* mutable_integral_max() { return &internal_->integral_max; }
  void set_integral_max(const int64_t& integral_max) { internal_->integral_max = integral_max; }

 private:
  struct Internal {
    double floating_min;
    int64_t integral_min;
    double floating_max;
    int64_t integral_max;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.clip_by_scalar_grad",
                       ClipByScalarGradOpInterpCtxImpl<schema::ClipByScalarGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ClipByScalarMaxOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& floating_max() const = 0;
  virtual double* mutable_floating_max() = 0;
  virtual void set_floating_max(const double& floating_max) = 0;

  virtual const int64_t& integral_max() const = 0;
  virtual int64_t* mutable_integral_max() = 0;
  virtual void set_integral_max(const int64_t& integral_max) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"floating_max", "integral_max"};
    return attr_names;
  }
};
template<typename Provider>
class ClipByScalarMaxOpInterpCtxImpl : public ClipByScalarMaxOpInterpCtx {
 public:
  ClipByScalarMaxOpInterpCtxImpl() = default;
  ClipByScalarMaxOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& floating_max() const override { return impl_.floating_max(); }
  double* mutable_floating_max() override { return impl_.mutable_floating_max(); }
  void set_floating_max(const double& floating_max) override {
    impl_.set_floating_max(floating_max);
  }

  const int64_t& integral_max() const override { return impl_.integral_max(); }
  int64_t* mutable_integral_max() override { return impl_.mutable_integral_max(); }
  void set_integral_max(const int64_t& integral_max) override {
    impl_.set_integral_max(integral_max);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ClipByScalarMaxOp {
 public:
  ClipByScalarMaxOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "floating_max") {
      return CastAttr(&internal_->floating_max);
    } else if (attr_name == "integral_max") {
      return CastAttr(&internal_->integral_max);
    } else {
      return Error::RuntimeError() << "ClipByScalarMax op has no attribute named " << attr_name;
    }
  }

  const double& floating_max() const { return internal_->floating_max; }
  double* mutable_floating_max() { return &internal_->floating_max; }
  void set_floating_max(const double& floating_max) { internal_->floating_max = floating_max; }

  const int64_t& integral_max() const { return internal_->integral_max; }
  int64_t* mutable_integral_max() { return &internal_->integral_max; }
  void set_integral_max(const int64_t& integral_max) { internal_->integral_max = integral_max; }

 private:
  struct Internal {
    double floating_max;
    int64_t integral_max;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.clip_by_scalar_max",
                       ClipByScalarMaxOpInterpCtxImpl<schema::ClipByScalarMaxOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ClipByScalarMaxGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& floating_max() const = 0;
  virtual double* mutable_floating_max() = 0;
  virtual void set_floating_max(const double& floating_max) = 0;

  virtual const int64_t& integral_max() const = 0;
  virtual int64_t* mutable_integral_max() = 0;
  virtual void set_integral_max(const int64_t& integral_max) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"floating_max", "integral_max"};
    return attr_names;
  }
};
template<typename Provider>
class ClipByScalarMaxGradOpInterpCtxImpl : public ClipByScalarMaxGradOpInterpCtx {
 public:
  ClipByScalarMaxGradOpInterpCtxImpl() = default;
  ClipByScalarMaxGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& floating_max() const override { return impl_.floating_max(); }
  double* mutable_floating_max() override { return impl_.mutable_floating_max(); }
  void set_floating_max(const double& floating_max) override {
    impl_.set_floating_max(floating_max);
  }

  const int64_t& integral_max() const override { return impl_.integral_max(); }
  int64_t* mutable_integral_max() override { return impl_.mutable_integral_max(); }
  void set_integral_max(const int64_t& integral_max) override {
    impl_.set_integral_max(integral_max);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ClipByScalarMaxGradOp {
 public:
  ClipByScalarMaxGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "floating_max") {
      return CastAttr(&internal_->floating_max);
    } else if (attr_name == "integral_max") {
      return CastAttr(&internal_->integral_max);
    } else {
      return Error::RuntimeError() << "ClipByScalarMaxGrad op has no attribute named " << attr_name;
    }
  }

  const double& floating_max() const { return internal_->floating_max; }
  double* mutable_floating_max() { return &internal_->floating_max; }
  void set_floating_max(const double& floating_max) { internal_->floating_max = floating_max; }

  const int64_t& integral_max() const { return internal_->integral_max; }
  int64_t* mutable_integral_max() { return &internal_->integral_max; }
  void set_integral_max(const int64_t& integral_max) { internal_->integral_max = integral_max; }

 private:
  struct Internal {
    double floating_max;
    int64_t integral_max;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.clip_by_scalar_max_grad",
                       ClipByScalarMaxGradOpInterpCtxImpl<schema::ClipByScalarMaxGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ClipByScalarMinOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& floating_min() const = 0;
  virtual double* mutable_floating_min() = 0;
  virtual void set_floating_min(const double& floating_min) = 0;

  virtual const int64_t& integral_min() const = 0;
  virtual int64_t* mutable_integral_min() = 0;
  virtual void set_integral_min(const int64_t& integral_min) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"floating_min", "integral_min"};
    return attr_names;
  }
};
template<typename Provider>
class ClipByScalarMinOpInterpCtxImpl : public ClipByScalarMinOpInterpCtx {
 public:
  ClipByScalarMinOpInterpCtxImpl() = default;
  ClipByScalarMinOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& floating_min() const override { return impl_.floating_min(); }
  double* mutable_floating_min() override { return impl_.mutable_floating_min(); }
  void set_floating_min(const double& floating_min) override {
    impl_.set_floating_min(floating_min);
  }

  const int64_t& integral_min() const override { return impl_.integral_min(); }
  int64_t* mutable_integral_min() override { return impl_.mutable_integral_min(); }
  void set_integral_min(const int64_t& integral_min) override {
    impl_.set_integral_min(integral_min);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ClipByScalarMinOp {
 public:
  ClipByScalarMinOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "floating_min") {
      return CastAttr(&internal_->floating_min);
    } else if (attr_name == "integral_min") {
      return CastAttr(&internal_->integral_min);
    } else {
      return Error::RuntimeError() << "ClipByScalarMin op has no attribute named " << attr_name;
    }
  }

  const double& floating_min() const { return internal_->floating_min; }
  double* mutable_floating_min() { return &internal_->floating_min; }
  void set_floating_min(const double& floating_min) { internal_->floating_min = floating_min; }

  const int64_t& integral_min() const { return internal_->integral_min; }
  int64_t* mutable_integral_min() { return &internal_->integral_min; }
  void set_integral_min(const int64_t& integral_min) { internal_->integral_min = integral_min; }

 private:
  struct Internal {
    double floating_min;
    int64_t integral_min;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.clip_by_scalar_min",
                       ClipByScalarMinOpInterpCtxImpl<schema::ClipByScalarMinOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ClipByScalarMinGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& floating_min() const = 0;
  virtual double* mutable_floating_min() = 0;
  virtual void set_floating_min(const double& floating_min) = 0;

  virtual const int64_t& integral_min() const = 0;
  virtual int64_t* mutable_integral_min() = 0;
  virtual void set_integral_min(const int64_t& integral_min) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"floating_min", "integral_min"};
    return attr_names;
  }
};
template<typename Provider>
class ClipByScalarMinGradOpInterpCtxImpl : public ClipByScalarMinGradOpInterpCtx {
 public:
  ClipByScalarMinGradOpInterpCtxImpl() = default;
  ClipByScalarMinGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& floating_min() const override { return impl_.floating_min(); }
  double* mutable_floating_min() override { return impl_.mutable_floating_min(); }
  void set_floating_min(const double& floating_min) override {
    impl_.set_floating_min(floating_min);
  }

  const int64_t& integral_min() const override { return impl_.integral_min(); }
  int64_t* mutable_integral_min() override { return impl_.mutable_integral_min(); }
  void set_integral_min(const int64_t& integral_min) override {
    impl_.set_integral_min(integral_min);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ClipByScalarMinGradOp {
 public:
  ClipByScalarMinGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "floating_min") {
      return CastAttr(&internal_->floating_min);
    } else if (attr_name == "integral_min") {
      return CastAttr(&internal_->integral_min);
    } else {
      return Error::RuntimeError() << "ClipByScalarMinGrad op has no attribute named " << attr_name;
    }
  }

  const double& floating_min() const { return internal_->floating_min; }
  double* mutable_floating_min() { return &internal_->floating_min; }
  void set_floating_min(const double& floating_min) { internal_->floating_min = floating_min; }

  const int64_t& integral_min() const { return internal_->integral_min; }
  int64_t* mutable_integral_min() { return &internal_->integral_min; }
  void set_integral_min(const int64_t& integral_min) { internal_->integral_min = integral_min; }

 private:
  struct Internal {
    double floating_min;
    int64_t integral_min;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.clip_by_scalar_min_grad",
                       ClipByScalarMinGradOpInterpCtxImpl<schema::ClipByScalarMinGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CoinFlipOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& probability() const = 0;
  virtual float* mutable_probability() = 0;
  virtual void set_probability(const float& probability) = 0;

  virtual const int64_t& batch_size() const = 0;
  virtual int64_t* mutable_batch_size() = 0;
  virtual void set_batch_size(const int64_t& batch_size) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const bool& has_seed() const = 0;
  virtual bool* mutable_has_seed() = 0;
  virtual void set_has_seed(const bool& has_seed) = 0;

  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"probability", "batch_size", "seed", "has_seed",
                                           "nd_sbp"};
    return attr_names;
  }
};
template<typename Provider>
class CoinFlipOpInterpCtxImpl : public CoinFlipOpInterpCtx {
 public:
  CoinFlipOpInterpCtxImpl() = default;
  CoinFlipOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& probability() const override { return impl_.probability(); }
  float* mutable_probability() override { return impl_.mutable_probability(); }
  void set_probability(const float& probability) override { impl_.set_probability(probability); }

  const int64_t& batch_size() const override { return impl_.batch_size(); }
  int64_t* mutable_batch_size() override { return impl_.mutable_batch_size(); }
  void set_batch_size(const int64_t& batch_size) override { impl_.set_batch_size(batch_size); }

  const int64_t& seed() const override { return impl_.seed(); }
  int64_t* mutable_seed() override { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) override { impl_.set_seed(seed); }

  const bool& has_seed() const override { return impl_.has_seed(); }
  bool* mutable_has_seed() override { return impl_.mutable_has_seed(); }
  void set_has_seed(const bool& has_seed) override { impl_.set_has_seed(has_seed); }

  const std::vector<std::string>& nd_sbp() const override { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() override { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) override { impl_.set_nd_sbp(nd_sbp); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CoinFlipOp {
 public:
  CoinFlipOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "probability") {
      return CastAttr(&internal_->probability);
    } else if (attr_name == "batch_size") {
      return CastAttr(&internal_->batch_size);
    } else if (attr_name == "seed") {
      return CastAttr(&internal_->seed);
    } else if (attr_name == "has_seed") {
      return CastAttr(&internal_->has_seed);
    } else if (attr_name == "nd_sbp") {
      return CastAttr(&internal_->nd_sbp);
    } else {
      return Error::RuntimeError() << "CoinFlip op has no attribute named " << attr_name;
    }
  }

  const float& probability() const { return internal_->probability; }
  float* mutable_probability() { return &internal_->probability; }
  void set_probability(const float& probability) { internal_->probability = probability; }

  const int64_t& batch_size() const { return internal_->batch_size; }
  int64_t* mutable_batch_size() { return &internal_->batch_size; }
  void set_batch_size(const int64_t& batch_size) { internal_->batch_size = batch_size; }

  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }

  const bool& has_seed() const { return internal_->has_seed; }
  bool* mutable_has_seed() { return &internal_->has_seed; }
  void set_has_seed(const bool& has_seed) { internal_->has_seed = has_seed; }

  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }

 private:
  struct Internal {
    float probability;
    int64_t batch_size;
    int64_t seed;
    bool has_seed;
    std::vector<std::string> nd_sbp;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.coin_flip", CoinFlipOpInterpCtxImpl<schema::CoinFlipOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CombinedMarginLossOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& m1() const = 0;
  virtual float* mutable_m1() = 0;
  virtual void set_m1(const float& m1) = 0;

  virtual const float& m2() const = 0;
  virtual float* mutable_m2() = 0;
  virtual void set_m2(const float& m2) = 0;

  virtual const float& m3() const = 0;
  virtual float* mutable_m3() = 0;
  virtual void set_m3(const float& m3) = 0;

  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"m1", "m2", "m3", "depth"};
    return attr_names;
  }
};
template<typename Provider>
class CombinedMarginLossOpInterpCtxImpl : public CombinedMarginLossOpInterpCtx {
 public:
  CombinedMarginLossOpInterpCtxImpl() = default;
  CombinedMarginLossOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& m1() const override { return impl_.m1(); }
  float* mutable_m1() override { return impl_.mutable_m1(); }
  void set_m1(const float& m1) override { impl_.set_m1(m1); }

  const float& m2() const override { return impl_.m2(); }
  float* mutable_m2() override { return impl_.mutable_m2(); }
  void set_m2(const float& m2) override { impl_.set_m2(m2); }

  const float& m3() const override { return impl_.m3(); }
  float* mutable_m3() override { return impl_.mutable_m3(); }
  void set_m3(const float& m3) override { impl_.set_m3(m3); }

  const int64_t& depth() const override { return impl_.depth(); }
  int64_t* mutable_depth() override { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) override { impl_.set_depth(depth); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CombinedMarginLossOp {
 public:
  CombinedMarginLossOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "m1") {
      return CastAttr(&internal_->m1);
    } else if (attr_name == "m2") {
      return CastAttr(&internal_->m2);
    } else if (attr_name == "m3") {
      return CastAttr(&internal_->m3);
    } else if (attr_name == "depth") {
      return CastAttr(&internal_->depth);
    } else {
      return Error::RuntimeError() << "CombinedMarginLoss op has no attribute named " << attr_name;
    }
  }

  const float& m1() const { return internal_->m1; }
  float* mutable_m1() { return &internal_->m1; }
  void set_m1(const float& m1) { internal_->m1 = m1; }

  const float& m2() const { return internal_->m2; }
  float* mutable_m2() { return &internal_->m2; }
  void set_m2(const float& m2) { internal_->m2 = m2; }

  const float& m3() const { return internal_->m3; }
  float* mutable_m3() { return &internal_->m3; }
  void set_m3(const float& m3) { internal_->m3 = m3; }

  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }

 private:
  struct Internal {
    float m1;
    float m2;
    float m3;
    int64_t depth;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.combined_margin_loss",
                       CombinedMarginLossOpInterpCtxImpl<schema::CombinedMarginLossOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CombinedMarginLossGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& m1() const = 0;
  virtual float* mutable_m1() = 0;
  virtual void set_m1(const float& m1) = 0;

  virtual const float& m2() const = 0;
  virtual float* mutable_m2() = 0;
  virtual void set_m2(const float& m2) = 0;

  virtual const float& m3() const = 0;
  virtual float* mutable_m3() = 0;
  virtual void set_m3(const float& m3) = 0;

  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"m1", "m2", "m3", "depth"};
    return attr_names;
  }
};
template<typename Provider>
class CombinedMarginLossGradOpInterpCtxImpl : public CombinedMarginLossGradOpInterpCtx {
 public:
  CombinedMarginLossGradOpInterpCtxImpl() = default;
  CombinedMarginLossGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& m1() const override { return impl_.m1(); }
  float* mutable_m1() override { return impl_.mutable_m1(); }
  void set_m1(const float& m1) override { impl_.set_m1(m1); }

  const float& m2() const override { return impl_.m2(); }
  float* mutable_m2() override { return impl_.mutable_m2(); }
  void set_m2(const float& m2) override { impl_.set_m2(m2); }

  const float& m3() const override { return impl_.m3(); }
  float* mutable_m3() override { return impl_.mutable_m3(); }
  void set_m3(const float& m3) override { impl_.set_m3(m3); }

  const int64_t& depth() const override { return impl_.depth(); }
  int64_t* mutable_depth() override { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) override { impl_.set_depth(depth); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CombinedMarginLossGradOp {
 public:
  CombinedMarginLossGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "m1") {
      return CastAttr(&internal_->m1);
    } else if (attr_name == "m2") {
      return CastAttr(&internal_->m2);
    } else if (attr_name == "m3") {
      return CastAttr(&internal_->m3);
    } else if (attr_name == "depth") {
      return CastAttr(&internal_->depth);
    } else {
      return Error::RuntimeError()
             << "CombinedMarginLossGrad op has no attribute named " << attr_name;
    }
  }

  const float& m1() const { return internal_->m1; }
  float* mutable_m1() { return &internal_->m1; }
  void set_m1(const float& m1) { internal_->m1 = m1; }

  const float& m2() const { return internal_->m2; }
  float* mutable_m2() { return &internal_->m2; }
  void set_m2(const float& m2) { internal_->m2 = m2; }

  const float& m3() const { return internal_->m3; }
  float* mutable_m3() { return &internal_->m3; }
  void set_m3(const float& m3) { internal_->m3 = m3; }

  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }

 private:
  struct Internal {
    float m1;
    float m2;
    float m3;
    int64_t depth;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.combined_margin_loss_grad",
                       CombinedMarginLossGradOpInterpCtxImpl<schema::CombinedMarginLossGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ConcatOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& axis() const = 0;
  virtual int64_t* mutable_axis() = 0;
  virtual void set_axis(const int64_t& axis) = 0;

  virtual const int64_t& max_dim_size() const = 0;
  virtual int64_t* mutable_max_dim_size() = 0;
  virtual void set_max_dim_size(const int64_t& max_dim_size) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "max_dim_size"};
    return attr_names;
  }
};
template<typename Provider>
class ConcatOpInterpCtxImpl : public ConcatOpInterpCtx {
 public:
  ConcatOpInterpCtxImpl() = default;
  ConcatOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& axis() const override { return impl_.axis(); }
  int64_t* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const int64_t& axis) override { impl_.set_axis(axis); }

  const int64_t& max_dim_size() const override { return impl_.max_dim_size(); }
  int64_t* mutable_max_dim_size() override { return impl_.mutable_max_dim_size(); }
  void set_max_dim_size(const int64_t& max_dim_size) override {
    impl_.set_max_dim_size(max_dim_size);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConcatOp {
 public:
  ConcatOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "max_dim_size") {
      return CastAttr(&internal_->max_dim_size);
    } else {
      return Error::RuntimeError() << "Concat op has no attribute named " << attr_name;
    }
  }

  const int64_t& axis() const { return internal_->axis; }
  int64_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int64_t& axis) { internal_->axis = axis; }

  const int64_t& max_dim_size() const { return internal_->max_dim_size; }
  int64_t* mutable_max_dim_size() { return &internal_->max_dim_size; }
  void set_max_dim_size(const int64_t& max_dim_size) { internal_->max_dim_size = max_dim_size; }

 private:
  struct Internal {
    int64_t axis;
    int64_t max_dim_size;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.concat", ConcatOpInterpCtxImpl<schema::ConcatOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ConstantOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& floating_value() const = 0;
  virtual double* mutable_floating_value() = 0;
  virtual void set_floating_value(const double& floating_value) = 0;

  virtual const int64_t& integer_value() const = 0;
  virtual int64_t* mutable_integer_value() = 0;
  virtual void set_integer_value(const int64_t& integer_value) = 0;

  virtual const bool& is_floating_value() const = 0;
  virtual bool* mutable_is_floating_value() = 0;
  virtual void set_is_floating_value(const bool& is_floating_value) = 0;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"floating_value", "integer_value", "is_floating_value",
                                           "dtype",          "shape",         "nd_sbp"};
    return attr_names;
  }
};
template<typename Provider>
class ConstantOpInterpCtxImpl : public ConstantOpInterpCtx {
 public:
  ConstantOpInterpCtxImpl() = default;
  ConstantOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& floating_value() const override { return impl_.floating_value(); }
  double* mutable_floating_value() override { return impl_.mutable_floating_value(); }
  void set_floating_value(const double& floating_value) override {
    impl_.set_floating_value(floating_value);
  }

  const int64_t& integer_value() const override { return impl_.integer_value(); }
  int64_t* mutable_integer_value() override { return impl_.mutable_integer_value(); }
  void set_integer_value(const int64_t& integer_value) override {
    impl_.set_integer_value(integer_value);
  }

  const bool& is_floating_value() const override { return impl_.is_floating_value(); }
  bool* mutable_is_floating_value() override { return impl_.mutable_is_floating_value(); }
  void set_is_floating_value(const bool& is_floating_value) override {
    impl_.set_is_floating_value(is_floating_value);
  }

  const DataType& dtype() const override { return impl_.dtype(); }
  DataType* mutable_dtype() override { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) override { impl_.set_dtype(dtype); }

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  const std::vector<std::string>& nd_sbp() const override { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() override { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) override { impl_.set_nd_sbp(nd_sbp); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConstantOp {
 public:
  ConstantOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "floating_value") {
      return CastAttr(&internal_->floating_value);
    } else if (attr_name == "integer_value") {
      return CastAttr(&internal_->integer_value);
    } else if (attr_name == "is_floating_value") {
      return CastAttr(&internal_->is_floating_value);
    } else if (attr_name == "dtype") {
      return CastAttr(&internal_->dtype);
    } else if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else if (attr_name == "nd_sbp") {
      return CastAttr(&internal_->nd_sbp);
    } else {
      return Error::RuntimeError() << "Constant op has no attribute named " << attr_name;
    }
  }

  const double& floating_value() const { return internal_->floating_value; }
  double* mutable_floating_value() { return &internal_->floating_value; }
  void set_floating_value(const double& floating_value) {
    internal_->floating_value = floating_value;
  }

  const int64_t& integer_value() const { return internal_->integer_value; }
  int64_t* mutable_integer_value() { return &internal_->integer_value; }
  void set_integer_value(const int64_t& integer_value) { internal_->integer_value = integer_value; }

  const bool& is_floating_value() const { return internal_->is_floating_value; }
  bool* mutable_is_floating_value() { return &internal_->is_floating_value; }
  void set_is_floating_value(const bool& is_floating_value) {
    internal_->is_floating_value = is_floating_value;
  }

  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }

 private:
  struct Internal {
    double floating_value;
    int64_t integer_value;
    bool is_floating_value;
    DataType dtype;
    Shape shape;
    std::vector<std::string> nd_sbp;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.constant", ConstantOpInterpCtxImpl<schema::ConstantOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ConstantPad1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& padding() const = 0;
  virtual std::vector<int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int64_t>& padding) = 0;

  virtual const double& floating_value() const = 0;
  virtual double* mutable_floating_value() = 0;
  virtual void set_floating_value(const double& floating_value) = 0;

  virtual const int64_t& integral_value() const = 0;
  virtual int64_t* mutable_integral_value() = 0;
  virtual void set_integral_value(const int64_t& integral_value) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding", "floating_value", "integral_value"};
    return attr_names;
  }
};
template<typename Provider>
class ConstantPad1DOpInterpCtxImpl : public ConstantPad1DOpInterpCtx {
 public:
  ConstantPad1DOpInterpCtxImpl() = default;
  ConstantPad1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& padding() const override { return impl_.padding(); }
  std::vector<int64_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int64_t>& padding) override { impl_.set_padding(padding); }

  const double& floating_value() const override { return impl_.floating_value(); }
  double* mutable_floating_value() override { return impl_.mutable_floating_value(); }
  void set_floating_value(const double& floating_value) override {
    impl_.set_floating_value(floating_value);
  }

  const int64_t& integral_value() const override { return impl_.integral_value(); }
  int64_t* mutable_integral_value() override { return impl_.mutable_integral_value(); }
  void set_integral_value(const int64_t& integral_value) override {
    impl_.set_integral_value(integral_value);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConstantPad1DOp {
 public:
  ConstantPad1DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "floating_value") {
      return CastAttr(&internal_->floating_value);
    } else if (attr_name == "integral_value") {
      return CastAttr(&internal_->integral_value);
    } else {
      return Error::RuntimeError() << "ConstantPad1D op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& padding() const { return internal_->padding; }
  std::vector<int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int64_t>& padding) { internal_->padding = padding; }

  const double& floating_value() const { return internal_->floating_value; }
  double* mutable_floating_value() { return &internal_->floating_value; }
  void set_floating_value(const double& floating_value) {
    internal_->floating_value = floating_value;
  }

  const int64_t& integral_value() const { return internal_->integral_value; }
  int64_t* mutable_integral_value() { return &internal_->integral_value; }
  void set_integral_value(const int64_t& integral_value) {
    internal_->integral_value = integral_value;
  }

 private:
  struct Internal {
    std::vector<int64_t> padding;
    double floating_value;
    int64_t integral_value;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.constant_pad1d",
                       ConstantPad1DOpInterpCtxImpl<schema::ConstantPad1DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ConstantPad1DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& padding() const = 0;
  virtual std::vector<int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int64_t>& padding) = 0;

  virtual const double& floating_value() const = 0;
  virtual double* mutable_floating_value() = 0;
  virtual void set_floating_value(const double& floating_value) = 0;

  virtual const int64_t& integral_value() const = 0;
  virtual int64_t* mutable_integral_value() = 0;
  virtual void set_integral_value(const int64_t& integral_value) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding", "floating_value", "integral_value"};
    return attr_names;
  }
};
template<typename Provider>
class ConstantPad1DGradOpInterpCtxImpl : public ConstantPad1DGradOpInterpCtx {
 public:
  ConstantPad1DGradOpInterpCtxImpl() = default;
  ConstantPad1DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& padding() const override { return impl_.padding(); }
  std::vector<int64_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int64_t>& padding) override { impl_.set_padding(padding); }

  const double& floating_value() const override { return impl_.floating_value(); }
  double* mutable_floating_value() override { return impl_.mutable_floating_value(); }
  void set_floating_value(const double& floating_value) override {
    impl_.set_floating_value(floating_value);
  }

  const int64_t& integral_value() const override { return impl_.integral_value(); }
  int64_t* mutable_integral_value() override { return impl_.mutable_integral_value(); }
  void set_integral_value(const int64_t& integral_value) override {
    impl_.set_integral_value(integral_value);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConstantPad1DGradOp {
 public:
  ConstantPad1DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "floating_value") {
      return CastAttr(&internal_->floating_value);
    } else if (attr_name == "integral_value") {
      return CastAttr(&internal_->integral_value);
    } else {
      return Error::RuntimeError() << "ConstantPad1DGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& padding() const { return internal_->padding; }
  std::vector<int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int64_t>& padding) { internal_->padding = padding; }

  const double& floating_value() const { return internal_->floating_value; }
  double* mutable_floating_value() { return &internal_->floating_value; }
  void set_floating_value(const double& floating_value) {
    internal_->floating_value = floating_value;
  }

  const int64_t& integral_value() const { return internal_->integral_value; }
  int64_t* mutable_integral_value() { return &internal_->integral_value; }
  void set_integral_value(const int64_t& integral_value) {
    internal_->integral_value = integral_value;
  }

 private:
  struct Internal {
    std::vector<int64_t> padding;
    double floating_value;
    int64_t integral_value;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.constant_pad1d_grad",
                       ConstantPad1DGradOpInterpCtxImpl<schema::ConstantPad1DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ConstantPad2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& padding() const = 0;
  virtual std::vector<int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int64_t>& padding) = 0;

  virtual const double& floating_value() const = 0;
  virtual double* mutable_floating_value() = 0;
  virtual void set_floating_value(const double& floating_value) = 0;

  virtual const int64_t& integral_value() const = 0;
  virtual int64_t* mutable_integral_value() = 0;
  virtual void set_integral_value(const int64_t& integral_value) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding", "floating_value", "integral_value"};
    return attr_names;
  }
};
template<typename Provider>
class ConstantPad2DOpInterpCtxImpl : public ConstantPad2DOpInterpCtx {
 public:
  ConstantPad2DOpInterpCtxImpl() = default;
  ConstantPad2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& padding() const override { return impl_.padding(); }
  std::vector<int64_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int64_t>& padding) override { impl_.set_padding(padding); }

  const double& floating_value() const override { return impl_.floating_value(); }
  double* mutable_floating_value() override { return impl_.mutable_floating_value(); }
  void set_floating_value(const double& floating_value) override {
    impl_.set_floating_value(floating_value);
  }

  const int64_t& integral_value() const override { return impl_.integral_value(); }
  int64_t* mutable_integral_value() override { return impl_.mutable_integral_value(); }
  void set_integral_value(const int64_t& integral_value) override {
    impl_.set_integral_value(integral_value);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConstantPad2DOp {
 public:
  ConstantPad2DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "floating_value") {
      return CastAttr(&internal_->floating_value);
    } else if (attr_name == "integral_value") {
      return CastAttr(&internal_->integral_value);
    } else {
      return Error::RuntimeError() << "ConstantPad2D op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& padding() const { return internal_->padding; }
  std::vector<int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int64_t>& padding) { internal_->padding = padding; }

  const double& floating_value() const { return internal_->floating_value; }
  double* mutable_floating_value() { return &internal_->floating_value; }
  void set_floating_value(const double& floating_value) {
    internal_->floating_value = floating_value;
  }

  const int64_t& integral_value() const { return internal_->integral_value; }
  int64_t* mutable_integral_value() { return &internal_->integral_value; }
  void set_integral_value(const int64_t& integral_value) {
    internal_->integral_value = integral_value;
  }

 private:
  struct Internal {
    std::vector<int64_t> padding;
    double floating_value;
    int64_t integral_value;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.constant_pad2d",
                       ConstantPad2DOpInterpCtxImpl<schema::ConstantPad2DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ConstantPad2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& padding() const = 0;
  virtual std::vector<int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int64_t>& padding) = 0;

  virtual const double& floating_value() const = 0;
  virtual double* mutable_floating_value() = 0;
  virtual void set_floating_value(const double& floating_value) = 0;

  virtual const int64_t& integral_value() const = 0;
  virtual int64_t* mutable_integral_value() = 0;
  virtual void set_integral_value(const int64_t& integral_value) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding", "floating_value", "integral_value"};
    return attr_names;
  }
};
template<typename Provider>
class ConstantPad2DGradOpInterpCtxImpl : public ConstantPad2DGradOpInterpCtx {
 public:
  ConstantPad2DGradOpInterpCtxImpl() = default;
  ConstantPad2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& padding() const override { return impl_.padding(); }
  std::vector<int64_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int64_t>& padding) override { impl_.set_padding(padding); }

  const double& floating_value() const override { return impl_.floating_value(); }
  double* mutable_floating_value() override { return impl_.mutable_floating_value(); }
  void set_floating_value(const double& floating_value) override {
    impl_.set_floating_value(floating_value);
  }

  const int64_t& integral_value() const override { return impl_.integral_value(); }
  int64_t* mutable_integral_value() override { return impl_.mutable_integral_value(); }
  void set_integral_value(const int64_t& integral_value) override {
    impl_.set_integral_value(integral_value);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConstantPad2DGradOp {
 public:
  ConstantPad2DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "floating_value") {
      return CastAttr(&internal_->floating_value);
    } else if (attr_name == "integral_value") {
      return CastAttr(&internal_->integral_value);
    } else {
      return Error::RuntimeError() << "ConstantPad2DGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& padding() const { return internal_->padding; }
  std::vector<int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int64_t>& padding) { internal_->padding = padding; }

  const double& floating_value() const { return internal_->floating_value; }
  double* mutable_floating_value() { return &internal_->floating_value; }
  void set_floating_value(const double& floating_value) {
    internal_->floating_value = floating_value;
  }

  const int64_t& integral_value() const { return internal_->integral_value; }
  int64_t* mutable_integral_value() { return &internal_->integral_value; }
  void set_integral_value(const int64_t& integral_value) {
    internal_->integral_value = integral_value;
  }

 private:
  struct Internal {
    std::vector<int64_t> padding;
    double floating_value;
    int64_t integral_value;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.constant_pad2d_grad",
                       ConstantPad2DGradOpInterpCtxImpl<schema::ConstantPad2DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ConstantPad3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& padding() const = 0;
  virtual std::vector<int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int64_t>& padding) = 0;

  virtual const double& floating_value() const = 0;
  virtual double* mutable_floating_value() = 0;
  virtual void set_floating_value(const double& floating_value) = 0;

  virtual const int64_t& integral_value() const = 0;
  virtual int64_t* mutable_integral_value() = 0;
  virtual void set_integral_value(const int64_t& integral_value) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding", "floating_value", "integral_value"};
    return attr_names;
  }
};
template<typename Provider>
class ConstantPad3DOpInterpCtxImpl : public ConstantPad3DOpInterpCtx {
 public:
  ConstantPad3DOpInterpCtxImpl() = default;
  ConstantPad3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& padding() const override { return impl_.padding(); }
  std::vector<int64_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int64_t>& padding) override { impl_.set_padding(padding); }

  const double& floating_value() const override { return impl_.floating_value(); }
  double* mutable_floating_value() override { return impl_.mutable_floating_value(); }
  void set_floating_value(const double& floating_value) override {
    impl_.set_floating_value(floating_value);
  }

  const int64_t& integral_value() const override { return impl_.integral_value(); }
  int64_t* mutable_integral_value() override { return impl_.mutable_integral_value(); }
  void set_integral_value(const int64_t& integral_value) override {
    impl_.set_integral_value(integral_value);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConstantPad3DOp {
 public:
  ConstantPad3DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "floating_value") {
      return CastAttr(&internal_->floating_value);
    } else if (attr_name == "integral_value") {
      return CastAttr(&internal_->integral_value);
    } else {
      return Error::RuntimeError() << "ConstantPad3D op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& padding() const { return internal_->padding; }
  std::vector<int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int64_t>& padding) { internal_->padding = padding; }

  const double& floating_value() const { return internal_->floating_value; }
  double* mutable_floating_value() { return &internal_->floating_value; }
  void set_floating_value(const double& floating_value) {
    internal_->floating_value = floating_value;
  }

  const int64_t& integral_value() const { return internal_->integral_value; }
  int64_t* mutable_integral_value() { return &internal_->integral_value; }
  void set_integral_value(const int64_t& integral_value) {
    internal_->integral_value = integral_value;
  }

 private:
  struct Internal {
    std::vector<int64_t> padding;
    double floating_value;
    int64_t integral_value;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.constant_pad3d",
                       ConstantPad3DOpInterpCtxImpl<schema::ConstantPad3DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ConstantPad3DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& padding() const = 0;
  virtual std::vector<int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int64_t>& padding) = 0;

  virtual const double& floating_value() const = 0;
  virtual double* mutable_floating_value() = 0;
  virtual void set_floating_value(const double& floating_value) = 0;

  virtual const int64_t& integral_value() const = 0;
  virtual int64_t* mutable_integral_value() = 0;
  virtual void set_integral_value(const int64_t& integral_value) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding", "floating_value", "integral_value"};
    return attr_names;
  }
};
template<typename Provider>
class ConstantPad3DGradOpInterpCtxImpl : public ConstantPad3DGradOpInterpCtx {
 public:
  ConstantPad3DGradOpInterpCtxImpl() = default;
  ConstantPad3DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& padding() const override { return impl_.padding(); }
  std::vector<int64_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int64_t>& padding) override { impl_.set_padding(padding); }

  const double& floating_value() const override { return impl_.floating_value(); }
  double* mutable_floating_value() override { return impl_.mutable_floating_value(); }
  void set_floating_value(const double& floating_value) override {
    impl_.set_floating_value(floating_value);
  }

  const int64_t& integral_value() const override { return impl_.integral_value(); }
  int64_t* mutable_integral_value() override { return impl_.mutable_integral_value(); }
  void set_integral_value(const int64_t& integral_value) override {
    impl_.set_integral_value(integral_value);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConstantPad3DGradOp {
 public:
  ConstantPad3DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "floating_value") {
      return CastAttr(&internal_->floating_value);
    } else if (attr_name == "integral_value") {
      return CastAttr(&internal_->integral_value);
    } else {
      return Error::RuntimeError() << "ConstantPad3DGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& padding() const { return internal_->padding; }
  std::vector<int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int64_t>& padding) { internal_->padding = padding; }

  const double& floating_value() const { return internal_->floating_value; }
  double* mutable_floating_value() { return &internal_->floating_value; }
  void set_floating_value(const double& floating_value) {
    internal_->floating_value = floating_value;
  }

  const int64_t& integral_value() const { return internal_->integral_value; }
  int64_t* mutable_integral_value() { return &internal_->integral_value; }
  void set_integral_value(const int64_t& integral_value) {
    internal_->integral_value = integral_value;
  }

 private:
  struct Internal {
    std::vector<int64_t> padding;
    double floating_value;
    int64_t integral_value;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.constant_pad3d_grad",
                       ConstantPad3DGradOpInterpCtxImpl<schema::ConstantPad3DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class Conv1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& filters() const = 0;
  virtual int32_t* mutable_filters() = 0;
  virtual void set_filters(const int32_t& filters) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const std::vector<int32_t>& dilation_rate() const = 0;
  virtual std::vector<int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<int32_t>& dilation_rate) = 0;

  virtual const int32_t& groups() const = 0;
  virtual int32_t* mutable_groups() = 0;
  virtual void set_groups(const int32_t& groups) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"filters",     "padding_before", "data_format",
                                           "kernel_size", "strides",        "dilation_rate",
                                           "groups"};
    return attr_names;
  }
};
template<typename Provider>
class Conv1DOpInterpCtxImpl : public Conv1DOpInterpCtx {
 public:
  Conv1DOpInterpCtxImpl() = default;
  Conv1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& filters() const override { return impl_.filters(); }
  int32_t* mutable_filters() override { return impl_.mutable_filters(); }
  void set_filters(const int32_t& filters) override { impl_.set_filters(filters); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const std::vector<int32_t>& dilation_rate() const override { return impl_.dilation_rate(); }
  std::vector<int32_t>* mutable_dilation_rate() override { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) override {
    impl_.set_dilation_rate(dilation_rate);
  }

  const int32_t& groups() const override { return impl_.groups(); }
  int32_t* mutable_groups() override { return impl_.mutable_groups(); }
  void set_groups(const int32_t& groups) override { impl_.set_groups(groups); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Conv1DOp {
 public:
  Conv1DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "filters") {
      return CastAttr(&internal_->filters);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "dilation_rate") {
      return CastAttr(&internal_->dilation_rate);
    } else if (attr_name == "groups") {
      return CastAttr(&internal_->groups);
    } else {
      return Error::RuntimeError() << "Conv1D op has no attribute named " << attr_name;
    }
  }

  const int32_t& filters() const { return internal_->filters; }
  int32_t* mutable_filters() { return &internal_->filters; }
  void set_filters(const int32_t& filters) { internal_->filters = filters; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const std::vector<int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) {
    internal_->dilation_rate = dilation_rate;
  }

  const int32_t& groups() const { return internal_->groups; }
  int32_t* mutable_groups() { return &internal_->groups; }
  void set_groups(const int32_t& groups) { internal_->groups = groups; }

 private:
  struct Internal {
    int32_t filters;
    std::vector<int32_t> padding_before;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> strides;
    std::vector<int32_t> dilation_rate;
    int32_t groups;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.conv1d", Conv1DOpInterpCtxImpl<schema::Conv1DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class Conv2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& filters() const = 0;
  virtual int32_t* mutable_filters() = 0;
  virtual void set_filters(const int32_t& filters) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const std::vector<int32_t>& dilation_rate() const = 0;
  virtual std::vector<int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<int32_t>& dilation_rate) = 0;

  virtual const int32_t& groups() const = 0;
  virtual int32_t* mutable_groups() = 0;
  virtual void set_groups(const int32_t& groups) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"filters",     "padding_before", "data_format",
                                           "kernel_size", "strides",        "dilation_rate",
                                           "groups"};
    return attr_names;
  }
};
template<typename Provider>
class Conv2DOpInterpCtxImpl : public Conv2DOpInterpCtx {
 public:
  Conv2DOpInterpCtxImpl() = default;
  Conv2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& filters() const override { return impl_.filters(); }
  int32_t* mutable_filters() override { return impl_.mutable_filters(); }
  void set_filters(const int32_t& filters) override { impl_.set_filters(filters); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const std::vector<int32_t>& dilation_rate() const override { return impl_.dilation_rate(); }
  std::vector<int32_t>* mutable_dilation_rate() override { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) override {
    impl_.set_dilation_rate(dilation_rate);
  }

  const int32_t& groups() const override { return impl_.groups(); }
  int32_t* mutable_groups() override { return impl_.mutable_groups(); }
  void set_groups(const int32_t& groups) override { impl_.set_groups(groups); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Conv2DOp {
 public:
  Conv2DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "filters") {
      return CastAttr(&internal_->filters);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "dilation_rate") {
      return CastAttr(&internal_->dilation_rate);
    } else if (attr_name == "groups") {
      return CastAttr(&internal_->groups);
    } else {
      return Error::RuntimeError() << "Conv2D op has no attribute named " << attr_name;
    }
  }

  const int32_t& filters() const { return internal_->filters; }
  int32_t* mutable_filters() { return &internal_->filters; }
  void set_filters(const int32_t& filters) { internal_->filters = filters; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const std::vector<int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) {
    internal_->dilation_rate = dilation_rate;
  }

  const int32_t& groups() const { return internal_->groups; }
  int32_t* mutable_groups() { return &internal_->groups; }
  void set_groups(const int32_t& groups) { internal_->groups = groups; }

 private:
  struct Internal {
    int32_t filters;
    std::vector<int32_t> padding_before;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> strides;
    std::vector<int32_t> dilation_rate;
    int32_t groups;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.conv2d", Conv2DOpInterpCtxImpl<schema::Conv2DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class Conv3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& filters() const = 0;
  virtual int32_t* mutable_filters() = 0;
  virtual void set_filters(const int32_t& filters) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const std::vector<int32_t>& dilation_rate() const = 0;
  virtual std::vector<int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<int32_t>& dilation_rate) = 0;

  virtual const int32_t& groups() const = 0;
  virtual int32_t* mutable_groups() = 0;
  virtual void set_groups(const int32_t& groups) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"filters",     "padding_before", "data_format",
                                           "kernel_size", "strides",        "dilation_rate",
                                           "groups"};
    return attr_names;
  }
};
template<typename Provider>
class Conv3DOpInterpCtxImpl : public Conv3DOpInterpCtx {
 public:
  Conv3DOpInterpCtxImpl() = default;
  Conv3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& filters() const override { return impl_.filters(); }
  int32_t* mutable_filters() override { return impl_.mutable_filters(); }
  void set_filters(const int32_t& filters) override { impl_.set_filters(filters); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const std::vector<int32_t>& dilation_rate() const override { return impl_.dilation_rate(); }
  std::vector<int32_t>* mutable_dilation_rate() override { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) override {
    impl_.set_dilation_rate(dilation_rate);
  }

  const int32_t& groups() const override { return impl_.groups(); }
  int32_t* mutable_groups() override { return impl_.mutable_groups(); }
  void set_groups(const int32_t& groups) override { impl_.set_groups(groups); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Conv3DOp {
 public:
  Conv3DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "filters") {
      return CastAttr(&internal_->filters);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "dilation_rate") {
      return CastAttr(&internal_->dilation_rate);
    } else if (attr_name == "groups") {
      return CastAttr(&internal_->groups);
    } else {
      return Error::RuntimeError() << "Conv3D op has no attribute named " << attr_name;
    }
  }

  const int32_t& filters() const { return internal_->filters; }
  int32_t* mutable_filters() { return &internal_->filters; }
  void set_filters(const int32_t& filters) { internal_->filters = filters; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const std::vector<int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) {
    internal_->dilation_rate = dilation_rate;
  }

  const int32_t& groups() const { return internal_->groups; }
  int32_t* mutable_groups() { return &internal_->groups; }
  void set_groups(const int32_t& groups) { internal_->groups = groups; }

 private:
  struct Internal {
    int32_t filters;
    std::vector<int32_t> padding_before;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> strides;
    std::vector<int32_t> dilation_rate;
    int32_t groups;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.conv3d", Conv3DOpInterpCtxImpl<schema::Conv3DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ConvBiasGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const int32_t& num_spatial_dims() const = 0;
  virtual int32_t* mutable_num_spatial_dims() = 0;
  virtual void set_num_spatial_dims(const int32_t& num_spatial_dims) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"data_format", "num_spatial_dims"};
    return attr_names;
  }
};
template<typename Provider>
class ConvBiasGradOpInterpCtxImpl : public ConvBiasGradOpInterpCtx {
 public:
  ConvBiasGradOpInterpCtxImpl() = default;
  ConvBiasGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const int32_t& num_spatial_dims() const override { return impl_.num_spatial_dims(); }
  int32_t* mutable_num_spatial_dims() override { return impl_.mutable_num_spatial_dims(); }
  void set_num_spatial_dims(const int32_t& num_spatial_dims) override {
    impl_.set_num_spatial_dims(num_spatial_dims);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConvBiasGradOp {
 public:
  ConvBiasGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "num_spatial_dims") {
      return CastAttr(&internal_->num_spatial_dims);
    } else {
      return Error::RuntimeError() << "ConvBiasGrad op has no attribute named " << attr_name;
    }
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const int32_t& num_spatial_dims() const { return internal_->num_spatial_dims; }
  int32_t* mutable_num_spatial_dims() { return &internal_->num_spatial_dims; }
  void set_num_spatial_dims(const int32_t& num_spatial_dims) {
    internal_->num_spatial_dims = num_spatial_dims;
  }

 private:
  struct Internal {
    std::string data_format;
    int32_t num_spatial_dims;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.conv_bias_grad", ConvBiasGradOpInterpCtxImpl<schema::ConvBiasGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ConvDataGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& num_spatial_dims() const = 0;
  virtual int32_t* mutable_num_spatial_dims() = 0;
  virtual void set_num_spatial_dims(const int32_t& num_spatial_dims) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const std::vector<int32_t>& dilation_rate() const = 0;
  virtual std::vector<int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<int32_t>& dilation_rate) = 0;

  virtual const int32_t& groups() const = 0;
  virtual int32_t* mutable_groups() = 0;
  virtual void set_groups(const int32_t& groups) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{
        "num_spatial_dims", "padding_before", "data_format", "kernel_size",
        "strides",          "dilation_rate",  "groups"};
    return attr_names;
  }
};
template<typename Provider>
class ConvDataGradOpInterpCtxImpl : public ConvDataGradOpInterpCtx {
 public:
  ConvDataGradOpInterpCtxImpl() = default;
  ConvDataGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& num_spatial_dims() const override { return impl_.num_spatial_dims(); }
  int32_t* mutable_num_spatial_dims() override { return impl_.mutable_num_spatial_dims(); }
  void set_num_spatial_dims(const int32_t& num_spatial_dims) override {
    impl_.set_num_spatial_dims(num_spatial_dims);
  }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const std::vector<int32_t>& dilation_rate() const override { return impl_.dilation_rate(); }
  std::vector<int32_t>* mutable_dilation_rate() override { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) override {
    impl_.set_dilation_rate(dilation_rate);
  }

  const int32_t& groups() const override { return impl_.groups(); }
  int32_t* mutable_groups() override { return impl_.mutable_groups(); }
  void set_groups(const int32_t& groups) override { impl_.set_groups(groups); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConvDataGradOp {
 public:
  ConvDataGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "num_spatial_dims") {
      return CastAttr(&internal_->num_spatial_dims);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "dilation_rate") {
      return CastAttr(&internal_->dilation_rate);
    } else if (attr_name == "groups") {
      return CastAttr(&internal_->groups);
    } else {
      return Error::RuntimeError() << "ConvDataGrad op has no attribute named " << attr_name;
    }
  }

  const int32_t& num_spatial_dims() const { return internal_->num_spatial_dims; }
  int32_t* mutable_num_spatial_dims() { return &internal_->num_spatial_dims; }
  void set_num_spatial_dims(const int32_t& num_spatial_dims) {
    internal_->num_spatial_dims = num_spatial_dims;
  }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const std::vector<int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) {
    internal_->dilation_rate = dilation_rate;
  }

  const int32_t& groups() const { return internal_->groups; }
  int32_t* mutable_groups() { return &internal_->groups; }
  void set_groups(const int32_t& groups) { internal_->groups = groups; }

 private:
  struct Internal {
    int32_t num_spatial_dims;
    std::vector<int32_t> padding_before;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> strides;
    std::vector<int32_t> dilation_rate;
    int32_t groups;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.conv_data_grad", ConvDataGradOpInterpCtxImpl<schema::ConvDataGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ConvFilterGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& num_spatial_dims() const = 0;
  virtual int32_t* mutable_num_spatial_dims() = 0;
  virtual void set_num_spatial_dims(const int32_t& num_spatial_dims) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const std::vector<int32_t>& dilation_rate() const = 0;
  virtual std::vector<int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<int32_t>& dilation_rate) = 0;

  virtual const int32_t& groups() const = 0;
  virtual int32_t* mutable_groups() = 0;
  virtual void set_groups(const int32_t& groups) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{
        "num_spatial_dims", "padding_before", "data_format", "kernel_size",
        "strides",          "dilation_rate",  "groups"};
    return attr_names;
  }
};
template<typename Provider>
class ConvFilterGradOpInterpCtxImpl : public ConvFilterGradOpInterpCtx {
 public:
  ConvFilterGradOpInterpCtxImpl() = default;
  ConvFilterGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& num_spatial_dims() const override { return impl_.num_spatial_dims(); }
  int32_t* mutable_num_spatial_dims() override { return impl_.mutable_num_spatial_dims(); }
  void set_num_spatial_dims(const int32_t& num_spatial_dims) override {
    impl_.set_num_spatial_dims(num_spatial_dims);
  }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const std::vector<int32_t>& dilation_rate() const override { return impl_.dilation_rate(); }
  std::vector<int32_t>* mutable_dilation_rate() override { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) override {
    impl_.set_dilation_rate(dilation_rate);
  }

  const int32_t& groups() const override { return impl_.groups(); }
  int32_t* mutable_groups() override { return impl_.mutable_groups(); }
  void set_groups(const int32_t& groups) override { impl_.set_groups(groups); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ConvFilterGradOp {
 public:
  ConvFilterGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "num_spatial_dims") {
      return CastAttr(&internal_->num_spatial_dims);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "dilation_rate") {
      return CastAttr(&internal_->dilation_rate);
    } else if (attr_name == "groups") {
      return CastAttr(&internal_->groups);
    } else {
      return Error::RuntimeError() << "ConvFilterGrad op has no attribute named " << attr_name;
    }
  }

  const int32_t& num_spatial_dims() const { return internal_->num_spatial_dims; }
  int32_t* mutable_num_spatial_dims() { return &internal_->num_spatial_dims; }
  void set_num_spatial_dims(const int32_t& num_spatial_dims) {
    internal_->num_spatial_dims = num_spatial_dims;
  }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const std::vector<int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) {
    internal_->dilation_rate = dilation_rate;
  }

  const int32_t& groups() const { return internal_->groups; }
  int32_t* mutable_groups() { return &internal_->groups; }
  void set_groups(const int32_t& groups) { internal_->groups = groups; }

 private:
  struct Internal {
    int32_t num_spatial_dims;
    std::vector<int32_t> padding_before;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> strides;
    std::vector<int32_t> dilation_rate;
    int32_t groups;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.conv_filter_grad",
                       ConvFilterGradOpInterpCtxImpl<schema::ConvFilterGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CopyOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& device_type() const = 0;
  virtual std::string* mutable_device_type() = 0;
  virtual void set_device_type(const std::string& device_type) = 0;

  virtual const int64_t& device_id() const = 0;
  virtual int64_t* mutable_device_id() = 0;
  virtual void set_device_id(const int64_t& device_id) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"device_type", "device_id"};
    return attr_names;
  }
};
template<typename Provider>
class CopyOpInterpCtxImpl : public CopyOpInterpCtx {
 public:
  CopyOpInterpCtxImpl() = default;
  CopyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& device_type() const override { return impl_.device_type(); }
  std::string* mutable_device_type() override { return impl_.mutable_device_type(); }
  void set_device_type(const std::string& device_type) override {
    impl_.set_device_type(device_type);
  }

  const int64_t& device_id() const override { return impl_.device_id(); }
  int64_t* mutable_device_id() override { return impl_.mutable_device_id(); }
  void set_device_id(const int64_t& device_id) override { impl_.set_device_id(device_id); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CopyOp {
 public:
  CopyOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "device_type") {
      return CastAttr(&internal_->device_type);
    } else if (attr_name == "device_id") {
      return CastAttr(&internal_->device_id);
    } else {
      return Error::RuntimeError() << "Copy op has no attribute named " << attr_name;
    }
  }

  const std::string& device_type() const { return internal_->device_type; }
  std::string* mutable_device_type() { return &internal_->device_type; }
  void set_device_type(const std::string& device_type) { internal_->device_type = device_type; }

  const int64_t& device_id() const { return internal_->device_id; }
  int64_t* mutable_device_id() { return &internal_->device_id; }
  void set_device_id(const int64_t& device_id) { internal_->device_id = device_id; }

 private:
  struct Internal {
    std::string device_type;
    int64_t device_id;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.copy", CopyOpInterpCtxImpl<schema::CopyOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CosOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class CosOpInterpCtxImpl : public CosOpInterpCtx {
 public:
  CosOpInterpCtxImpl() = default;
  CosOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CosOp {
 public:
  CosOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Cos op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.cos", CosOpInterpCtxImpl<schema::CosOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CosGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class CosGradOpInterpCtxImpl : public CosGradOpInterpCtx {
 public:
  CosGradOpInterpCtxImpl() = default;
  CosGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CosGradOp {
 public:
  CosGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "CosGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.cos_grad", CosGradOpInterpCtxImpl<schema::CosGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CoshOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class CoshOpInterpCtxImpl : public CoshOpInterpCtx {
 public:
  CoshOpInterpCtxImpl() = default;
  CoshOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CoshOp {
 public:
  CoshOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Cosh op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.cosh", CoshOpInterpCtxImpl<schema::CoshOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CoshGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class CoshGradOpInterpCtxImpl : public CoshGradOpInterpCtx {
 public:
  CoshGradOpInterpCtxImpl() = default;
  CoshGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CoshGradOp {
 public:
  CoshGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "CoshGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.cosh_grad", CoshGradOpInterpCtxImpl<schema::CoshGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CountNotFiniteOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class CountNotFiniteOpInterpCtxImpl : public CountNotFiniteOpInterpCtx {
 public:
  CountNotFiniteOpInterpCtxImpl() = default;
  CountNotFiniteOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CountNotFiniteOp {
 public:
  CountNotFiniteOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "CountNotFinite op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.count_not_finite",
                       CountNotFiniteOpInterpCtxImpl<schema::CountNotFiniteOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CpuOnlyReluTestOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class CpuOnlyReluTestOpInterpCtxImpl : public CpuOnlyReluTestOpInterpCtx {
 public:
  CpuOnlyReluTestOpInterpCtxImpl() = default;
  CpuOnlyReluTestOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CpuOnlyReluTestOp {
 public:
  CpuOnlyReluTestOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "CpuOnlyReluTest op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.cpu_only_relu_test",
                       CpuOnlyReluTestOpInterpCtxImpl<schema::CpuOnlyReluTestOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CreateSummaryWriterOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& logdir() const = 0;
  virtual std::string* mutable_logdir() = 0;
  virtual void set_logdir(const std::string& logdir) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"logdir"};
    return attr_names;
  }
};
template<typename Provider>
class CreateSummaryWriterOpInterpCtxImpl : public CreateSummaryWriterOpInterpCtx {
 public:
  CreateSummaryWriterOpInterpCtxImpl() = default;
  CreateSummaryWriterOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& logdir() const override { return impl_.logdir(); }
  std::string* mutable_logdir() override { return impl_.mutable_logdir(); }
  void set_logdir(const std::string& logdir) override { impl_.set_logdir(logdir); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CreateSummaryWriterOp {
 public:
  CreateSummaryWriterOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "logdir") {
      return CastAttr(&internal_->logdir);
    } else {
      return Error::RuntimeError() << "CreateSummaryWriter op has no attribute named " << attr_name;
    }
  }

  const std::string& logdir() const { return internal_->logdir; }
  std::string* mutable_logdir() { return &internal_->logdir; }
  void set_logdir(const std::string& logdir) { internal_->logdir = logdir; }

 private:
  struct Internal {
    std::string logdir;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.create_summary_writer",
                       CreateSummaryWriterOpInterpCtxImpl<schema::CreateSummaryWriterOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CropMirrorNormalizeFromTensorbufferOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& color_space() const = 0;
  virtual std::string* mutable_color_space() = 0;
  virtual void set_color_space(const std::string& color_space) = 0;

  virtual const std::string& output_layout() const = 0;
  virtual std::string* mutable_output_layout() = 0;
  virtual void set_output_layout(const std::string& output_layout) = 0;

  virtual const std::vector<float>& mean() const = 0;
  virtual std::vector<float>* mutable_mean() = 0;
  virtual void set_mean(const std::vector<float>& mean) = 0;

  virtual const std::vector<float>& std() const = 0;
  virtual std::vector<float>* mutable_std() = 0;
  virtual void set_std(const std::vector<float>& std) = 0;

  virtual const int64_t& crop_h() const = 0;
  virtual int64_t* mutable_crop_h() = 0;
  virtual void set_crop_h(const int64_t& crop_h) = 0;

  virtual const int64_t& crop_w() const = 0;
  virtual int64_t* mutable_crop_w() = 0;
  virtual void set_crop_w(const int64_t& crop_w) = 0;

  virtual const float& crop_pos_x() const = 0;
  virtual float* mutable_crop_pos_x() = 0;
  virtual void set_crop_pos_x(const float& crop_pos_x) = 0;

  virtual const float& crop_pos_y() const = 0;
  virtual float* mutable_crop_pos_y() = 0;
  virtual void set_crop_pos_y(const float& crop_pos_y) = 0;

  virtual const DataType& output_dtype() const = 0;
  virtual DataType* mutable_output_dtype() = 0;
  virtual void set_output_dtype(const DataType& output_dtype) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"color_space", "output_layout", "mean",
                                           "std",         "crop_h",        "crop_w",
                                           "crop_pos_x",  "crop_pos_y",    "output_dtype"};
    return attr_names;
  }
};
template<typename Provider>
class CropMirrorNormalizeFromTensorbufferOpInterpCtxImpl
    : public CropMirrorNormalizeFromTensorbufferOpInterpCtx {
 public:
  CropMirrorNormalizeFromTensorbufferOpInterpCtxImpl() = default;
  CropMirrorNormalizeFromTensorbufferOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& color_space() const override { return impl_.color_space(); }
  std::string* mutable_color_space() override { return impl_.mutable_color_space(); }
  void set_color_space(const std::string& color_space) override {
    impl_.set_color_space(color_space);
  }

  const std::string& output_layout() const override { return impl_.output_layout(); }
  std::string* mutable_output_layout() override { return impl_.mutable_output_layout(); }
  void set_output_layout(const std::string& output_layout) override {
    impl_.set_output_layout(output_layout);
  }

  const std::vector<float>& mean() const override { return impl_.mean(); }
  std::vector<float>* mutable_mean() override { return impl_.mutable_mean(); }
  void set_mean(const std::vector<float>& mean) override { impl_.set_mean(mean); }

  const std::vector<float>& std() const override { return impl_.std(); }
  std::vector<float>* mutable_std() override { return impl_.mutable_std(); }
  void set_std(const std::vector<float>& std) override { impl_.set_std(std); }

  const int64_t& crop_h() const override { return impl_.crop_h(); }
  int64_t* mutable_crop_h() override { return impl_.mutable_crop_h(); }
  void set_crop_h(const int64_t& crop_h) override { impl_.set_crop_h(crop_h); }

  const int64_t& crop_w() const override { return impl_.crop_w(); }
  int64_t* mutable_crop_w() override { return impl_.mutable_crop_w(); }
  void set_crop_w(const int64_t& crop_w) override { impl_.set_crop_w(crop_w); }

  const float& crop_pos_x() const override { return impl_.crop_pos_x(); }
  float* mutable_crop_pos_x() override { return impl_.mutable_crop_pos_x(); }
  void set_crop_pos_x(const float& crop_pos_x) override { impl_.set_crop_pos_x(crop_pos_x); }

  const float& crop_pos_y() const override { return impl_.crop_pos_y(); }
  float* mutable_crop_pos_y() override { return impl_.mutable_crop_pos_y(); }
  void set_crop_pos_y(const float& crop_pos_y) override { impl_.set_crop_pos_y(crop_pos_y); }

  const DataType& output_dtype() const override { return impl_.output_dtype(); }
  DataType* mutable_output_dtype() override { return impl_.mutable_output_dtype(); }
  void set_output_dtype(const DataType& output_dtype) override {
    impl_.set_output_dtype(output_dtype);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CropMirrorNormalizeFromTensorbufferOp {
 public:
  CropMirrorNormalizeFromTensorbufferOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "color_space") {
      return CastAttr(&internal_->color_space);
    } else if (attr_name == "output_layout") {
      return CastAttr(&internal_->output_layout);
    } else if (attr_name == "mean") {
      return CastAttr(&internal_->mean);
    } else if (attr_name == "std") {
      return CastAttr(&internal_->std);
    } else if (attr_name == "crop_h") {
      return CastAttr(&internal_->crop_h);
    } else if (attr_name == "crop_w") {
      return CastAttr(&internal_->crop_w);
    } else if (attr_name == "crop_pos_x") {
      return CastAttr(&internal_->crop_pos_x);
    } else if (attr_name == "crop_pos_y") {
      return CastAttr(&internal_->crop_pos_y);
    } else if (attr_name == "output_dtype") {
      return CastAttr(&internal_->output_dtype);
    } else {
      return Error::RuntimeError()
             << "CropMirrorNormalizeFromTensorbuffer op has no attribute named " << attr_name;
    }
  }

  const std::string& color_space() const { return internal_->color_space; }
  std::string* mutable_color_space() { return &internal_->color_space; }
  void set_color_space(const std::string& color_space) { internal_->color_space = color_space; }

  const std::string& output_layout() const { return internal_->output_layout; }
  std::string* mutable_output_layout() { return &internal_->output_layout; }
  void set_output_layout(const std::string& output_layout) {
    internal_->output_layout = output_layout;
  }

  const std::vector<float>& mean() const { return internal_->mean; }
  std::vector<float>* mutable_mean() { return &internal_->mean; }
  void set_mean(const std::vector<float>& mean) { internal_->mean = mean; }

  const std::vector<float>& std() const { return internal_->std; }
  std::vector<float>* mutable_std() { return &internal_->std; }
  void set_std(const std::vector<float>& std) { internal_->std = std; }

  const int64_t& crop_h() const { return internal_->crop_h; }
  int64_t* mutable_crop_h() { return &internal_->crop_h; }
  void set_crop_h(const int64_t& crop_h) { internal_->crop_h = crop_h; }

  const int64_t& crop_w() const { return internal_->crop_w; }
  int64_t* mutable_crop_w() { return &internal_->crop_w; }
  void set_crop_w(const int64_t& crop_w) { internal_->crop_w = crop_w; }

  const float& crop_pos_x() const { return internal_->crop_pos_x; }
  float* mutable_crop_pos_x() { return &internal_->crop_pos_x; }
  void set_crop_pos_x(const float& crop_pos_x) { internal_->crop_pos_x = crop_pos_x; }

  const float& crop_pos_y() const { return internal_->crop_pos_y; }
  float* mutable_crop_pos_y() { return &internal_->crop_pos_y; }
  void set_crop_pos_y(const float& crop_pos_y) { internal_->crop_pos_y = crop_pos_y; }

  const DataType& output_dtype() const { return internal_->output_dtype; }
  DataType* mutable_output_dtype() { return &internal_->output_dtype; }
  void set_output_dtype(const DataType& output_dtype) { internal_->output_dtype = output_dtype; }

 private:
  struct Internal {
    std::string color_space;
    std::string output_layout;
    std::vector<float> mean;
    std::vector<float> std;
    int64_t crop_h;
    int64_t crop_w;
    float crop_pos_x;
    float crop_pos_y;
    DataType output_dtype;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.crop_mirror_normalize_from_tensorbuffer",
                       CropMirrorNormalizeFromTensorbufferOpInterpCtxImpl<
                           schema::CropMirrorNormalizeFromTensorbufferOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CropMirrorNormalizeFromUint8OpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& color_space() const = 0;
  virtual std::string* mutable_color_space() = 0;
  virtual void set_color_space(const std::string& color_space) = 0;

  virtual const std::string& output_layout() const = 0;
  virtual std::string* mutable_output_layout() = 0;
  virtual void set_output_layout(const std::string& output_layout) = 0;

  virtual const std::vector<float>& mean() const = 0;
  virtual std::vector<float>* mutable_mean() = 0;
  virtual void set_mean(const std::vector<float>& mean) = 0;

  virtual const std::vector<float>& std() const = 0;
  virtual std::vector<float>* mutable_std() = 0;
  virtual void set_std(const std::vector<float>& std) = 0;

  virtual const int64_t& crop_h() const = 0;
  virtual int64_t* mutable_crop_h() = 0;
  virtual void set_crop_h(const int64_t& crop_h) = 0;

  virtual const int64_t& crop_w() const = 0;
  virtual int64_t* mutable_crop_w() = 0;
  virtual void set_crop_w(const int64_t& crop_w) = 0;

  virtual const float& crop_pos_x() const = 0;
  virtual float* mutable_crop_pos_x() = 0;
  virtual void set_crop_pos_x(const float& crop_pos_x) = 0;

  virtual const float& crop_pos_y() const = 0;
  virtual float* mutable_crop_pos_y() = 0;
  virtual void set_crop_pos_y(const float& crop_pos_y) = 0;

  virtual const DataType& output_dtype() const = 0;
  virtual DataType* mutable_output_dtype() = 0;
  virtual void set_output_dtype(const DataType& output_dtype) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"color_space", "output_layout", "mean",
                                           "std",         "crop_h",        "crop_w",
                                           "crop_pos_x",  "crop_pos_y",    "output_dtype"};
    return attr_names;
  }
};
template<typename Provider>
class CropMirrorNormalizeFromUint8OpInterpCtxImpl : public CropMirrorNormalizeFromUint8OpInterpCtx {
 public:
  CropMirrorNormalizeFromUint8OpInterpCtxImpl() = default;
  CropMirrorNormalizeFromUint8OpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& color_space() const override { return impl_.color_space(); }
  std::string* mutable_color_space() override { return impl_.mutable_color_space(); }
  void set_color_space(const std::string& color_space) override {
    impl_.set_color_space(color_space);
  }

  const std::string& output_layout() const override { return impl_.output_layout(); }
  std::string* mutable_output_layout() override { return impl_.mutable_output_layout(); }
  void set_output_layout(const std::string& output_layout) override {
    impl_.set_output_layout(output_layout);
  }

  const std::vector<float>& mean() const override { return impl_.mean(); }
  std::vector<float>* mutable_mean() override { return impl_.mutable_mean(); }
  void set_mean(const std::vector<float>& mean) override { impl_.set_mean(mean); }

  const std::vector<float>& std() const override { return impl_.std(); }
  std::vector<float>* mutable_std() override { return impl_.mutable_std(); }
  void set_std(const std::vector<float>& std) override { impl_.set_std(std); }

  const int64_t& crop_h() const override { return impl_.crop_h(); }
  int64_t* mutable_crop_h() override { return impl_.mutable_crop_h(); }
  void set_crop_h(const int64_t& crop_h) override { impl_.set_crop_h(crop_h); }

  const int64_t& crop_w() const override { return impl_.crop_w(); }
  int64_t* mutable_crop_w() override { return impl_.mutable_crop_w(); }
  void set_crop_w(const int64_t& crop_w) override { impl_.set_crop_w(crop_w); }

  const float& crop_pos_x() const override { return impl_.crop_pos_x(); }
  float* mutable_crop_pos_x() override { return impl_.mutable_crop_pos_x(); }
  void set_crop_pos_x(const float& crop_pos_x) override { impl_.set_crop_pos_x(crop_pos_x); }

  const float& crop_pos_y() const override { return impl_.crop_pos_y(); }
  float* mutable_crop_pos_y() override { return impl_.mutable_crop_pos_y(); }
  void set_crop_pos_y(const float& crop_pos_y) override { impl_.set_crop_pos_y(crop_pos_y); }

  const DataType& output_dtype() const override { return impl_.output_dtype(); }
  DataType* mutable_output_dtype() override { return impl_.mutable_output_dtype(); }
  void set_output_dtype(const DataType& output_dtype) override {
    impl_.set_output_dtype(output_dtype);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CropMirrorNormalizeFromUint8Op {
 public:
  CropMirrorNormalizeFromUint8Op() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "color_space") {
      return CastAttr(&internal_->color_space);
    } else if (attr_name == "output_layout") {
      return CastAttr(&internal_->output_layout);
    } else if (attr_name == "mean") {
      return CastAttr(&internal_->mean);
    } else if (attr_name == "std") {
      return CastAttr(&internal_->std);
    } else if (attr_name == "crop_h") {
      return CastAttr(&internal_->crop_h);
    } else if (attr_name == "crop_w") {
      return CastAttr(&internal_->crop_w);
    } else if (attr_name == "crop_pos_x") {
      return CastAttr(&internal_->crop_pos_x);
    } else if (attr_name == "crop_pos_y") {
      return CastAttr(&internal_->crop_pos_y);
    } else if (attr_name == "output_dtype") {
      return CastAttr(&internal_->output_dtype);
    } else {
      return Error::RuntimeError()
             << "CropMirrorNormalizeFromUint8 op has no attribute named " << attr_name;
    }
  }

  const std::string& color_space() const { return internal_->color_space; }
  std::string* mutable_color_space() { return &internal_->color_space; }
  void set_color_space(const std::string& color_space) { internal_->color_space = color_space; }

  const std::string& output_layout() const { return internal_->output_layout; }
  std::string* mutable_output_layout() { return &internal_->output_layout; }
  void set_output_layout(const std::string& output_layout) {
    internal_->output_layout = output_layout;
  }

  const std::vector<float>& mean() const { return internal_->mean; }
  std::vector<float>* mutable_mean() { return &internal_->mean; }
  void set_mean(const std::vector<float>& mean) { internal_->mean = mean; }

  const std::vector<float>& std() const { return internal_->std; }
  std::vector<float>* mutable_std() { return &internal_->std; }
  void set_std(const std::vector<float>& std) { internal_->std = std; }

  const int64_t& crop_h() const { return internal_->crop_h; }
  int64_t* mutable_crop_h() { return &internal_->crop_h; }
  void set_crop_h(const int64_t& crop_h) { internal_->crop_h = crop_h; }

  const int64_t& crop_w() const { return internal_->crop_w; }
  int64_t* mutable_crop_w() { return &internal_->crop_w; }
  void set_crop_w(const int64_t& crop_w) { internal_->crop_w = crop_w; }

  const float& crop_pos_x() const { return internal_->crop_pos_x; }
  float* mutable_crop_pos_x() { return &internal_->crop_pos_x; }
  void set_crop_pos_x(const float& crop_pos_x) { internal_->crop_pos_x = crop_pos_x; }

  const float& crop_pos_y() const { return internal_->crop_pos_y; }
  float* mutable_crop_pos_y() { return &internal_->crop_pos_y; }
  void set_crop_pos_y(const float& crop_pos_y) { internal_->crop_pos_y = crop_pos_y; }

  const DataType& output_dtype() const { return internal_->output_dtype; }
  DataType* mutable_output_dtype() { return &internal_->output_dtype; }
  void set_output_dtype(const DataType& output_dtype) { internal_->output_dtype = output_dtype; }

 private:
  struct Internal {
    std::string color_space;
    std::string output_layout;
    std::vector<float> mean;
    std::vector<float> std;
    int64_t crop_h;
    int64_t crop_w;
    float crop_pos_x;
    float crop_pos_y;
    DataType output_dtype;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.crop_mirror_normalize_from_uint8",
    CropMirrorNormalizeFromUint8OpInterpCtxImpl<schema::CropMirrorNormalizeFromUint8Op>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CtcGreedyDecoderOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& merge_repeated() const = 0;
  virtual bool* mutable_merge_repeated() = 0;
  virtual void set_merge_repeated(const bool& merge_repeated) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"merge_repeated"};
    return attr_names;
  }
};
template<typename Provider>
class CtcGreedyDecoderOpInterpCtxImpl : public CtcGreedyDecoderOpInterpCtx {
 public:
  CtcGreedyDecoderOpInterpCtxImpl() = default;
  CtcGreedyDecoderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& merge_repeated() const override { return impl_.merge_repeated(); }
  bool* mutable_merge_repeated() override { return impl_.mutable_merge_repeated(); }
  void set_merge_repeated(const bool& merge_repeated) override {
    impl_.set_merge_repeated(merge_repeated);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CtcGreedyDecoderOp {
 public:
  CtcGreedyDecoderOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "merge_repeated") {
      return CastAttr(&internal_->merge_repeated);
    } else {
      return Error::RuntimeError() << "CtcGreedyDecoder op has no attribute named " << attr_name;
    }
  }

  const bool& merge_repeated() const { return internal_->merge_repeated; }
  bool* mutable_merge_repeated() { return &internal_->merge_repeated; }
  void set_merge_repeated(const bool& merge_repeated) {
    internal_->merge_repeated = merge_repeated;
  }

 private:
  struct Internal {
    bool merge_repeated;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.ctc_greedy_decoder",
                       CtcGreedyDecoderOpInterpCtxImpl<schema::CtcGreedyDecoderOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CtcLossOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& max_target_length() const = 0;
  virtual int64_t* mutable_max_target_length() = 0;
  virtual void set_max_target_length(const int64_t& max_target_length) = 0;

  virtual const int32_t& blank() const = 0;
  virtual int32_t* mutable_blank() = 0;
  virtual void set_blank(const int32_t& blank) = 0;

  virtual const bool& zero_infinity() const = 0;
  virtual bool* mutable_zero_infinity() = 0;
  virtual void set_zero_infinity(const bool& zero_infinity) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"max_target_length", "blank", "zero_infinity"};
    return attr_names;
  }
};
template<typename Provider>
class CtcLossOpInterpCtxImpl : public CtcLossOpInterpCtx {
 public:
  CtcLossOpInterpCtxImpl() = default;
  CtcLossOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& max_target_length() const override { return impl_.max_target_length(); }
  int64_t* mutable_max_target_length() override { return impl_.mutable_max_target_length(); }
  void set_max_target_length(const int64_t& max_target_length) override {
    impl_.set_max_target_length(max_target_length);
  }

  const int32_t& blank() const override { return impl_.blank(); }
  int32_t* mutable_blank() override { return impl_.mutable_blank(); }
  void set_blank(const int32_t& blank) override { impl_.set_blank(blank); }

  const bool& zero_infinity() const override { return impl_.zero_infinity(); }
  bool* mutable_zero_infinity() override { return impl_.mutable_zero_infinity(); }
  void set_zero_infinity(const bool& zero_infinity) override {
    impl_.set_zero_infinity(zero_infinity);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CtcLossOp {
 public:
  CtcLossOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "max_target_length") {
      return CastAttr(&internal_->max_target_length);
    } else if (attr_name == "blank") {
      return CastAttr(&internal_->blank);
    } else if (attr_name == "zero_infinity") {
      return CastAttr(&internal_->zero_infinity);
    } else {
      return Error::RuntimeError() << "CtcLoss op has no attribute named " << attr_name;
    }
  }

  const int64_t& max_target_length() const { return internal_->max_target_length; }
  int64_t* mutable_max_target_length() { return &internal_->max_target_length; }
  void set_max_target_length(const int64_t& max_target_length) {
    internal_->max_target_length = max_target_length;
  }

  const int32_t& blank() const { return internal_->blank; }
  int32_t* mutable_blank() { return &internal_->blank; }
  void set_blank(const int32_t& blank) { internal_->blank = blank; }

  const bool& zero_infinity() const { return internal_->zero_infinity; }
  bool* mutable_zero_infinity() { return &internal_->zero_infinity; }
  void set_zero_infinity(const bool& zero_infinity) { internal_->zero_infinity = zero_infinity; }

 private:
  struct Internal {
    int64_t max_target_length;
    int32_t blank;
    bool zero_infinity;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.ctc_loss", CtcLossOpInterpCtxImpl<schema::CtcLossOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class CtcLossGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& max_target_length() const = 0;
  virtual int64_t* mutable_max_target_length() = 0;
  virtual void set_max_target_length(const int64_t& max_target_length) = 0;

  virtual const int32_t& blank() const = 0;
  virtual int32_t* mutable_blank() = 0;
  virtual void set_blank(const int32_t& blank) = 0;

  virtual const bool& zero_infinity() const = 0;
  virtual bool* mutable_zero_infinity() = 0;
  virtual void set_zero_infinity(const bool& zero_infinity) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"max_target_length", "blank", "zero_infinity"};
    return attr_names;
  }
};
template<typename Provider>
class CtcLossGradOpInterpCtxImpl : public CtcLossGradOpInterpCtx {
 public:
  CtcLossGradOpInterpCtxImpl() = default;
  CtcLossGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& max_target_length() const override { return impl_.max_target_length(); }
  int64_t* mutable_max_target_length() override { return impl_.mutable_max_target_length(); }
  void set_max_target_length(const int64_t& max_target_length) override {
    impl_.set_max_target_length(max_target_length);
  }

  const int32_t& blank() const override { return impl_.blank(); }
  int32_t* mutable_blank() override { return impl_.mutable_blank(); }
  void set_blank(const int32_t& blank) override { impl_.set_blank(blank); }

  const bool& zero_infinity() const override { return impl_.zero_infinity(); }
  bool* mutable_zero_infinity() override { return impl_.mutable_zero_infinity(); }
  void set_zero_infinity(const bool& zero_infinity) override {
    impl_.set_zero_infinity(zero_infinity);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class CtcLossGradOp {
 public:
  CtcLossGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "max_target_length") {
      return CastAttr(&internal_->max_target_length);
    } else if (attr_name == "blank") {
      return CastAttr(&internal_->blank);
    } else if (attr_name == "zero_infinity") {
      return CastAttr(&internal_->zero_infinity);
    } else {
      return Error::RuntimeError() << "CtcLossGrad op has no attribute named " << attr_name;
    }
  }

  const int64_t& max_target_length() const { return internal_->max_target_length; }
  int64_t* mutable_max_target_length() { return &internal_->max_target_length; }
  void set_max_target_length(const int64_t& max_target_length) {
    internal_->max_target_length = max_target_length;
  }

  const int32_t& blank() const { return internal_->blank; }
  int32_t* mutable_blank() { return &internal_->blank; }
  void set_blank(const int32_t& blank) { internal_->blank = blank; }

  const bool& zero_infinity() const { return internal_->zero_infinity; }
  bool* mutable_zero_infinity() { return &internal_->zero_infinity; }
  void set_zero_infinity(const bool& zero_infinity) { internal_->zero_infinity = zero_infinity; }

 private:
  struct Internal {
    int64_t max_target_length;
    int32_t blank;
    bool zero_infinity;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.ctc_loss_grad", CtcLossGradOpInterpCtxImpl<schema::CtcLossGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class Deconv1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& filters() const = 0;
  virtual int32_t* mutable_filters() = 0;
  virtual void set_filters(const int32_t& filters) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& output_padding() const = 0;
  virtual std::vector<int32_t>* mutable_output_padding() = 0;
  virtual void set_output_padding(const std::vector<int32_t>& output_padding) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const std::vector<int32_t>& dilation_rate() const = 0;
  virtual std::vector<int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<int32_t>& dilation_rate) = 0;

  virtual const int32_t& groups() const = 0;
  virtual int32_t* mutable_groups() = 0;
  virtual void set_groups(const int32_t& groups) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"filters",       "padding_before", "data_format",
                                           "kernel_size",   "output_padding", "strides",
                                           "dilation_rate", "groups"};
    return attr_names;
  }
};
template<typename Provider>
class Deconv1DOpInterpCtxImpl : public Deconv1DOpInterpCtx {
 public:
  Deconv1DOpInterpCtxImpl() = default;
  Deconv1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& filters() const override { return impl_.filters(); }
  int32_t* mutable_filters() override { return impl_.mutable_filters(); }
  void set_filters(const int32_t& filters) override { impl_.set_filters(filters); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& output_padding() const override { return impl_.output_padding(); }
  std::vector<int32_t>* mutable_output_padding() override { return impl_.mutable_output_padding(); }
  void set_output_padding(const std::vector<int32_t>& output_padding) override {
    impl_.set_output_padding(output_padding);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const std::vector<int32_t>& dilation_rate() const override { return impl_.dilation_rate(); }
  std::vector<int32_t>* mutable_dilation_rate() override { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) override {
    impl_.set_dilation_rate(dilation_rate);
  }

  const int32_t& groups() const override { return impl_.groups(); }
  int32_t* mutable_groups() override { return impl_.mutable_groups(); }
  void set_groups(const int32_t& groups) override { impl_.set_groups(groups); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Deconv1DOp {
 public:
  Deconv1DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "filters") {
      return CastAttr(&internal_->filters);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "output_padding") {
      return CastAttr(&internal_->output_padding);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "dilation_rate") {
      return CastAttr(&internal_->dilation_rate);
    } else if (attr_name == "groups") {
      return CastAttr(&internal_->groups);
    } else {
      return Error::RuntimeError() << "Deconv1D op has no attribute named " << attr_name;
    }
  }

  const int32_t& filters() const { return internal_->filters; }
  int32_t* mutable_filters() { return &internal_->filters; }
  void set_filters(const int32_t& filters) { internal_->filters = filters; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& output_padding() const { return internal_->output_padding; }
  std::vector<int32_t>* mutable_output_padding() { return &internal_->output_padding; }
  void set_output_padding(const std::vector<int32_t>& output_padding) {
    internal_->output_padding = output_padding;
  }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const std::vector<int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) {
    internal_->dilation_rate = dilation_rate;
  }

  const int32_t& groups() const { return internal_->groups; }
  int32_t* mutable_groups() { return &internal_->groups; }
  void set_groups(const int32_t& groups) { internal_->groups = groups; }

 private:
  struct Internal {
    int32_t filters;
    std::vector<int32_t> padding_before;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> output_padding;
    std::vector<int32_t> strides;
    std::vector<int32_t> dilation_rate;
    int32_t groups;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.deconv1d", Deconv1DOpInterpCtxImpl<schema::Deconv1DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class Deconv2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& filters() const = 0;
  virtual int32_t* mutable_filters() = 0;
  virtual void set_filters(const int32_t& filters) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& output_padding() const = 0;
  virtual std::vector<int32_t>* mutable_output_padding() = 0;
  virtual void set_output_padding(const std::vector<int32_t>& output_padding) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const std::vector<int32_t>& dilation_rate() const = 0;
  virtual std::vector<int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<int32_t>& dilation_rate) = 0;

  virtual const int32_t& groups() const = 0;
  virtual int32_t* mutable_groups() = 0;
  virtual void set_groups(const int32_t& groups) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"filters",       "padding_before", "data_format",
                                           "kernel_size",   "output_padding", "strides",
                                           "dilation_rate", "groups"};
    return attr_names;
  }
};
template<typename Provider>
class Deconv2DOpInterpCtxImpl : public Deconv2DOpInterpCtx {
 public:
  Deconv2DOpInterpCtxImpl() = default;
  Deconv2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& filters() const override { return impl_.filters(); }
  int32_t* mutable_filters() override { return impl_.mutable_filters(); }
  void set_filters(const int32_t& filters) override { impl_.set_filters(filters); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& output_padding() const override { return impl_.output_padding(); }
  std::vector<int32_t>* mutable_output_padding() override { return impl_.mutable_output_padding(); }
  void set_output_padding(const std::vector<int32_t>& output_padding) override {
    impl_.set_output_padding(output_padding);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const std::vector<int32_t>& dilation_rate() const override { return impl_.dilation_rate(); }
  std::vector<int32_t>* mutable_dilation_rate() override { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) override {
    impl_.set_dilation_rate(dilation_rate);
  }

  const int32_t& groups() const override { return impl_.groups(); }
  int32_t* mutable_groups() override { return impl_.mutable_groups(); }
  void set_groups(const int32_t& groups) override { impl_.set_groups(groups); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Deconv2DOp {
 public:
  Deconv2DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "filters") {
      return CastAttr(&internal_->filters);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "output_padding") {
      return CastAttr(&internal_->output_padding);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "dilation_rate") {
      return CastAttr(&internal_->dilation_rate);
    } else if (attr_name == "groups") {
      return CastAttr(&internal_->groups);
    } else {
      return Error::RuntimeError() << "Deconv2D op has no attribute named " << attr_name;
    }
  }

  const int32_t& filters() const { return internal_->filters; }
  int32_t* mutable_filters() { return &internal_->filters; }
  void set_filters(const int32_t& filters) { internal_->filters = filters; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& output_padding() const { return internal_->output_padding; }
  std::vector<int32_t>* mutable_output_padding() { return &internal_->output_padding; }
  void set_output_padding(const std::vector<int32_t>& output_padding) {
    internal_->output_padding = output_padding;
  }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const std::vector<int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) {
    internal_->dilation_rate = dilation_rate;
  }

  const int32_t& groups() const { return internal_->groups; }
  int32_t* mutable_groups() { return &internal_->groups; }
  void set_groups(const int32_t& groups) { internal_->groups = groups; }

 private:
  struct Internal {
    int32_t filters;
    std::vector<int32_t> padding_before;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> output_padding;
    std::vector<int32_t> strides;
    std::vector<int32_t> dilation_rate;
    int32_t groups;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.deconv2d", Deconv2DOpInterpCtxImpl<schema::Deconv2DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class Deconv3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& filters() const = 0;
  virtual int32_t* mutable_filters() = 0;
  virtual void set_filters(const int32_t& filters) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& output_padding() const = 0;
  virtual std::vector<int32_t>* mutable_output_padding() = 0;
  virtual void set_output_padding(const std::vector<int32_t>& output_padding) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const std::vector<int32_t>& dilation_rate() const = 0;
  virtual std::vector<int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<int32_t>& dilation_rate) = 0;

  virtual const int32_t& groups() const = 0;
  virtual int32_t* mutable_groups() = 0;
  virtual void set_groups(const int32_t& groups) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"filters",       "padding_before", "data_format",
                                           "kernel_size",   "output_padding", "strides",
                                           "dilation_rate", "groups"};
    return attr_names;
  }
};
template<typename Provider>
class Deconv3DOpInterpCtxImpl : public Deconv3DOpInterpCtx {
 public:
  Deconv3DOpInterpCtxImpl() = default;
  Deconv3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& filters() const override { return impl_.filters(); }
  int32_t* mutable_filters() override { return impl_.mutable_filters(); }
  void set_filters(const int32_t& filters) override { impl_.set_filters(filters); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& output_padding() const override { return impl_.output_padding(); }
  std::vector<int32_t>* mutable_output_padding() override { return impl_.mutable_output_padding(); }
  void set_output_padding(const std::vector<int32_t>& output_padding) override {
    impl_.set_output_padding(output_padding);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const std::vector<int32_t>& dilation_rate() const override { return impl_.dilation_rate(); }
  std::vector<int32_t>* mutable_dilation_rate() override { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) override {
    impl_.set_dilation_rate(dilation_rate);
  }

  const int32_t& groups() const override { return impl_.groups(); }
  int32_t* mutable_groups() override { return impl_.mutable_groups(); }
  void set_groups(const int32_t& groups) override { impl_.set_groups(groups); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Deconv3DOp {
 public:
  Deconv3DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "filters") {
      return CastAttr(&internal_->filters);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "output_padding") {
      return CastAttr(&internal_->output_padding);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "dilation_rate") {
      return CastAttr(&internal_->dilation_rate);
    } else if (attr_name == "groups") {
      return CastAttr(&internal_->groups);
    } else {
      return Error::RuntimeError() << "Deconv3D op has no attribute named " << attr_name;
    }
  }

  const int32_t& filters() const { return internal_->filters; }
  int32_t* mutable_filters() { return &internal_->filters; }
  void set_filters(const int32_t& filters) { internal_->filters = filters; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& output_padding() const { return internal_->output_padding; }
  std::vector<int32_t>* mutable_output_padding() { return &internal_->output_padding; }
  void set_output_padding(const std::vector<int32_t>& output_padding) {
    internal_->output_padding = output_padding;
  }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const std::vector<int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) {
    internal_->dilation_rate = dilation_rate;
  }

  const int32_t& groups() const { return internal_->groups; }
  int32_t* mutable_groups() { return &internal_->groups; }
  void set_groups(const int32_t& groups) { internal_->groups = groups; }

 private:
  struct Internal {
    int32_t filters;
    std::vector<int32_t> padding_before;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> output_padding;
    std::vector<int32_t> strides;
    std::vector<int32_t> dilation_rate;
    int32_t groups;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.deconv3d", Deconv3DOpInterpCtxImpl<schema::Deconv3DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class DiagOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& diagonal() const = 0;
  virtual int32_t* mutable_diagonal() = 0;
  virtual void set_diagonal(const int32_t& diagonal) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"diagonal"};
    return attr_names;
  }
};
template<typename Provider>
class DiagOpInterpCtxImpl : public DiagOpInterpCtx {
 public:
  DiagOpInterpCtxImpl() = default;
  DiagOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& diagonal() const override { return impl_.diagonal(); }
  int32_t* mutable_diagonal() override { return impl_.mutable_diagonal(); }
  void set_diagonal(const int32_t& diagonal) override { impl_.set_diagonal(diagonal); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DiagOp {
 public:
  DiagOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "diagonal") {
      return CastAttr(&internal_->diagonal);
    } else {
      return Error::RuntimeError() << "Diag op has no attribute named " << attr_name;
    }
  }

  const int32_t& diagonal() const { return internal_->diagonal; }
  int32_t* mutable_diagonal() { return &internal_->diagonal; }
  void set_diagonal(const int32_t& diagonal) { internal_->diagonal = diagonal; }

 private:
  struct Internal {
    int32_t diagonal;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.diag", DiagOpInterpCtxImpl<schema::DiagOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class DiagGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& diagonal() const = 0;
  virtual int32_t* mutable_diagonal() = 0;
  virtual void set_diagonal(const int32_t& diagonal) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"diagonal"};
    return attr_names;
  }
};
template<typename Provider>
class DiagGradOpInterpCtxImpl : public DiagGradOpInterpCtx {
 public:
  DiagGradOpInterpCtxImpl() = default;
  DiagGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& diagonal() const override { return impl_.diagonal(); }
  int32_t* mutable_diagonal() override { return impl_.mutable_diagonal(); }
  void set_diagonal(const int32_t& diagonal) override { impl_.set_diagonal(diagonal); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DiagGradOp {
 public:
  DiagGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "diagonal") {
      return CastAttr(&internal_->diagonal);
    } else {
      return Error::RuntimeError() << "DiagGrad op has no attribute named " << attr_name;
    }
  }

  const int32_t& diagonal() const { return internal_->diagonal; }
  int32_t* mutable_diagonal() { return &internal_->diagonal; }
  void set_diagonal(const int32_t& diagonal) { internal_->diagonal = diagonal; }

 private:
  struct Internal {
    int32_t diagonal;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.diag_grad", DiagGradOpInterpCtxImpl<schema::DiagGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class DimGatherOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& dim() const = 0;
  virtual int32_t* mutable_dim() = 0;
  virtual void set_dim(const int32_t& dim) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"dim"};
    return attr_names;
  }
};
template<typename Provider>
class DimGatherOpInterpCtxImpl : public DimGatherOpInterpCtx {
 public:
  DimGatherOpInterpCtxImpl() = default;
  DimGatherOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& dim() const override { return impl_.dim(); }
  int32_t* mutable_dim() override { return impl_.mutable_dim(); }
  void set_dim(const int32_t& dim) override { impl_.set_dim(dim); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DimGatherOp {
 public:
  DimGatherOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "dim") {
      return CastAttr(&internal_->dim);
    } else {
      return Error::RuntimeError() << "DimGather op has no attribute named " << attr_name;
    }
  }

  const int32_t& dim() const { return internal_->dim; }
  int32_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int32_t& dim) { internal_->dim = dim; }

 private:
  struct Internal {
    int32_t dim;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.dim_gather", DimGatherOpInterpCtxImpl<schema::DimGatherOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class DimScatterAddOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& dim() const = 0;
  virtual int32_t* mutable_dim() = 0;
  virtual void set_dim(const int32_t& dim) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"dim"};
    return attr_names;
  }
};
template<typename Provider>
class DimScatterAddOpInterpCtxImpl : public DimScatterAddOpInterpCtx {
 public:
  DimScatterAddOpInterpCtxImpl() = default;
  DimScatterAddOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& dim() const override { return impl_.dim(); }
  int32_t* mutable_dim() override { return impl_.mutable_dim(); }
  void set_dim(const int32_t& dim) override { impl_.set_dim(dim); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DimScatterAddOp {
 public:
  DimScatterAddOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "dim") {
      return CastAttr(&internal_->dim);
    } else {
      return Error::RuntimeError() << "DimScatterAdd op has no attribute named " << attr_name;
    }
  }

  const int32_t& dim() const { return internal_->dim; }
  int32_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int32_t& dim) { internal_->dim = dim; }

 private:
  struct Internal {
    int32_t dim;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.dim_scatter_add",
                       DimScatterAddOpInterpCtxImpl<schema::DimScatterAddOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class DimScatterAddLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& dim() const = 0;
  virtual int32_t* mutable_dim() = 0;
  virtual void set_dim(const int32_t& dim) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"dim"};
    return attr_names;
  }
};
template<typename Provider>
class DimScatterAddLikeOpInterpCtxImpl : public DimScatterAddLikeOpInterpCtx {
 public:
  DimScatterAddLikeOpInterpCtxImpl() = default;
  DimScatterAddLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& dim() const override { return impl_.dim(); }
  int32_t* mutable_dim() override { return impl_.mutable_dim(); }
  void set_dim(const int32_t& dim) override { impl_.set_dim(dim); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DimScatterAddLikeOp {
 public:
  DimScatterAddLikeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "dim") {
      return CastAttr(&internal_->dim);
    } else {
      return Error::RuntimeError() << "DimScatterAddLike op has no attribute named " << attr_name;
    }
  }

  const int32_t& dim() const { return internal_->dim; }
  int32_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int32_t& dim) { internal_->dim = dim; }

 private:
  struct Internal {
    int32_t dim;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.dim_scatter_add_like",
                       DimScatterAddLikeOpInterpCtxImpl<schema::DimScatterAddLikeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class DimScatterAddScalarOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& src_scalar() const = 0;
  virtual float* mutable_src_scalar() = 0;
  virtual void set_src_scalar(const float& src_scalar) = 0;

  virtual const int32_t& dim() const = 0;
  virtual int32_t* mutable_dim() = 0;
  virtual void set_dim(const int32_t& dim) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"src_scalar", "dim"};
    return attr_names;
  }
};
template<typename Provider>
class DimScatterAddScalarOpInterpCtxImpl : public DimScatterAddScalarOpInterpCtx {
 public:
  DimScatterAddScalarOpInterpCtxImpl() = default;
  DimScatterAddScalarOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& src_scalar() const override { return impl_.src_scalar(); }
  float* mutable_src_scalar() override { return impl_.mutable_src_scalar(); }
  void set_src_scalar(const float& src_scalar) override { impl_.set_src_scalar(src_scalar); }

  const int32_t& dim() const override { return impl_.dim(); }
  int32_t* mutable_dim() override { return impl_.mutable_dim(); }
  void set_dim(const int32_t& dim) override { impl_.set_dim(dim); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DimScatterAddScalarOp {
 public:
  DimScatterAddScalarOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "src_scalar") {
      return CastAttr(&internal_->src_scalar);
    } else if (attr_name == "dim") {
      return CastAttr(&internal_->dim);
    } else {
      return Error::RuntimeError() << "DimScatterAddScalar op has no attribute named " << attr_name;
    }
  }

  const float& src_scalar() const { return internal_->src_scalar; }
  float* mutable_src_scalar() { return &internal_->src_scalar; }
  void set_src_scalar(const float& src_scalar) { internal_->src_scalar = src_scalar; }

  const int32_t& dim() const { return internal_->dim; }
  int32_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int32_t& dim) { internal_->dim = dim; }

 private:
  struct Internal {
    float src_scalar;
    int32_t dim;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.dim_scatter_add_scalar",
                       DimScatterAddScalarOpInterpCtxImpl<schema::DimScatterAddScalarOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class DimScatterMulOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& dim() const = 0;
  virtual int32_t* mutable_dim() = 0;
  virtual void set_dim(const int32_t& dim) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"dim"};
    return attr_names;
  }
};
template<typename Provider>
class DimScatterMulOpInterpCtxImpl : public DimScatterMulOpInterpCtx {
 public:
  DimScatterMulOpInterpCtxImpl() = default;
  DimScatterMulOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& dim() const override { return impl_.dim(); }
  int32_t* mutable_dim() override { return impl_.mutable_dim(); }
  void set_dim(const int32_t& dim) override { impl_.set_dim(dim); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DimScatterMulOp {
 public:
  DimScatterMulOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "dim") {
      return CastAttr(&internal_->dim);
    } else {
      return Error::RuntimeError() << "DimScatterMul op has no attribute named " << attr_name;
    }
  }

  const int32_t& dim() const { return internal_->dim; }
  int32_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int32_t& dim) { internal_->dim = dim; }

 private:
  struct Internal {
    int32_t dim;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.dim_scatter_mul",
                       DimScatterMulOpInterpCtxImpl<schema::DimScatterMulOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class DimScatterMulScalarOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& src_scalar() const = 0;
  virtual float* mutable_src_scalar() = 0;
  virtual void set_src_scalar(const float& src_scalar) = 0;

  virtual const int32_t& dim() const = 0;
  virtual int32_t* mutable_dim() = 0;
  virtual void set_dim(const int32_t& dim) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"src_scalar", "dim"};
    return attr_names;
  }
};
template<typename Provider>
class DimScatterMulScalarOpInterpCtxImpl : public DimScatterMulScalarOpInterpCtx {
 public:
  DimScatterMulScalarOpInterpCtxImpl() = default;
  DimScatterMulScalarOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& src_scalar() const override { return impl_.src_scalar(); }
  float* mutable_src_scalar() override { return impl_.mutable_src_scalar(); }
  void set_src_scalar(const float& src_scalar) override { impl_.set_src_scalar(src_scalar); }

  const int32_t& dim() const override { return impl_.dim(); }
  int32_t* mutable_dim() override { return impl_.mutable_dim(); }
  void set_dim(const int32_t& dim) override { impl_.set_dim(dim); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DimScatterMulScalarOp {
 public:
  DimScatterMulScalarOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "src_scalar") {
      return CastAttr(&internal_->src_scalar);
    } else if (attr_name == "dim") {
      return CastAttr(&internal_->dim);
    } else {
      return Error::RuntimeError() << "DimScatterMulScalar op has no attribute named " << attr_name;
    }
  }

  const float& src_scalar() const { return internal_->src_scalar; }
  float* mutable_src_scalar() { return &internal_->src_scalar; }
  void set_src_scalar(const float& src_scalar) { internal_->src_scalar = src_scalar; }

  const int32_t& dim() const { return internal_->dim; }
  int32_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int32_t& dim) { internal_->dim = dim; }

 private:
  struct Internal {
    float src_scalar;
    int32_t dim;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.dim_scatter_mul_scalar",
                       DimScatterMulScalarOpInterpCtxImpl<schema::DimScatterMulScalarOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class DimScatterUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& dim() const = 0;
  virtual int32_t* mutable_dim() = 0;
  virtual void set_dim(const int32_t& dim) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"dim"};
    return attr_names;
  }
};
template<typename Provider>
class DimScatterUpdateOpInterpCtxImpl : public DimScatterUpdateOpInterpCtx {
 public:
  DimScatterUpdateOpInterpCtxImpl() = default;
  DimScatterUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& dim() const override { return impl_.dim(); }
  int32_t* mutable_dim() override { return impl_.mutable_dim(); }
  void set_dim(const int32_t& dim) override { impl_.set_dim(dim); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DimScatterUpdateOp {
 public:
  DimScatterUpdateOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "dim") {
      return CastAttr(&internal_->dim);
    } else {
      return Error::RuntimeError() << "DimScatterUpdate op has no attribute named " << attr_name;
    }
  }

  const int32_t& dim() const { return internal_->dim; }
  int32_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int32_t& dim) { internal_->dim = dim; }

 private:
  struct Internal {
    int32_t dim;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.dim_scatter_update",
                       DimScatterUpdateOpInterpCtxImpl<schema::DimScatterUpdateOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class DimScatterUpdateScalarOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& src_scalar() const = 0;
  virtual float* mutable_src_scalar() = 0;
  virtual void set_src_scalar(const float& src_scalar) = 0;

  virtual const int32_t& dim() const = 0;
  virtual int32_t* mutable_dim() = 0;
  virtual void set_dim(const int32_t& dim) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"src_scalar", "dim"};
    return attr_names;
  }
};
template<typename Provider>
class DimScatterUpdateScalarOpInterpCtxImpl : public DimScatterUpdateScalarOpInterpCtx {
 public:
  DimScatterUpdateScalarOpInterpCtxImpl() = default;
  DimScatterUpdateScalarOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& src_scalar() const override { return impl_.src_scalar(); }
  float* mutable_src_scalar() override { return impl_.mutable_src_scalar(); }
  void set_src_scalar(const float& src_scalar) override { impl_.set_src_scalar(src_scalar); }

  const int32_t& dim() const override { return impl_.dim(); }
  int32_t* mutable_dim() override { return impl_.mutable_dim(); }
  void set_dim(const int32_t& dim) override { impl_.set_dim(dim); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DimScatterUpdateScalarOp {
 public:
  DimScatterUpdateScalarOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "src_scalar") {
      return CastAttr(&internal_->src_scalar);
    } else if (attr_name == "dim") {
      return CastAttr(&internal_->dim);
    } else {
      return Error::RuntimeError()
             << "DimScatterUpdateScalar op has no attribute named " << attr_name;
    }
  }

  const float& src_scalar() const { return internal_->src_scalar; }
  float* mutable_src_scalar() { return &internal_->src_scalar; }
  void set_src_scalar(const float& src_scalar) { internal_->src_scalar = src_scalar; }

  const int32_t& dim() const { return internal_->dim; }
  int32_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int32_t& dim) { internal_->dim = dim; }

 private:
  struct Internal {
    float src_scalar;
    int32_t dim;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.dim_scatter_update_scalar",
                       DimScatterUpdateScalarOpInterpCtxImpl<schema::DimScatterUpdateScalarOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class DistributedPartialFcSampleOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& num_sample() const = 0;
  virtual int64_t* mutable_num_sample() = 0;
  virtual void set_num_sample(const int64_t& num_sample) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"num_sample", "seed"};
    return attr_names;
  }
};
template<typename Provider>
class DistributedPartialFcSampleOpInterpCtxImpl : public DistributedPartialFcSampleOpInterpCtx {
 public:
  DistributedPartialFcSampleOpInterpCtxImpl() = default;
  DistributedPartialFcSampleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& num_sample() const override { return impl_.num_sample(); }
  int64_t* mutable_num_sample() override { return impl_.mutable_num_sample(); }
  void set_num_sample(const int64_t& num_sample) override { impl_.set_num_sample(num_sample); }

  const int64_t& seed() const override { return impl_.seed(); }
  int64_t* mutable_seed() override { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) override { impl_.set_seed(seed); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DistributedPartialFcSampleOp {
 public:
  DistributedPartialFcSampleOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "num_sample") {
      return CastAttr(&internal_->num_sample);
    } else if (attr_name == "seed") {
      return CastAttr(&internal_->seed);
    } else {
      return Error::RuntimeError()
             << "DistributedPartialFcSample op has no attribute named " << attr_name;
    }
  }

  const int64_t& num_sample() const { return internal_->num_sample; }
  int64_t* mutable_num_sample() { return &internal_->num_sample; }
  void set_num_sample(const int64_t& num_sample) { internal_->num_sample = num_sample; }

  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }

 private:
  struct Internal {
    int64_t num_sample;
    int64_t seed;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.distributed_partial_fc_sample",
    DistributedPartialFcSampleOpInterpCtxImpl<schema::DistributedPartialFcSampleOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class DistributedPartialFcSampleDisableBoxingOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class DistributedPartialFcSampleDisableBoxingOpInterpCtxImpl
    : public DistributedPartialFcSampleDisableBoxingOpInterpCtx {
 public:
  DistributedPartialFcSampleDisableBoxingOpInterpCtxImpl() = default;
  DistributedPartialFcSampleDisableBoxingOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DistributedPartialFcSampleDisableBoxingOp {
 public:
  DistributedPartialFcSampleDisableBoxingOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError()
           << "DistributedPartialFcSampleDisableBoxing op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.distributed_partial_fc_sample_disable_boxing",
                       DistributedPartialFcSampleDisableBoxingOpInterpCtxImpl<
                           schema::DistributedPartialFcSampleDisableBoxingOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class DotOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class DotOpInterpCtxImpl : public DotOpInterpCtx {
 public:
  DotOpInterpCtxImpl() = default;
  DotOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DotOp {
 public:
  DotOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Dot op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.dot", DotOpInterpCtxImpl<schema::DotOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class DropoutOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& rate() const = 0;
  virtual float* mutable_rate() = 0;
  virtual void set_rate(const float& rate) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"rate"};
    return attr_names;
  }
};
template<typename Provider>
class DropoutOpInterpCtxImpl : public DropoutOpInterpCtx {
 public:
  DropoutOpInterpCtxImpl() = default;
  DropoutOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& rate() const override { return impl_.rate(); }
  float* mutable_rate() override { return impl_.mutable_rate(); }
  void set_rate(const float& rate) override { impl_.set_rate(rate); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DropoutOp {
 public:
  DropoutOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "rate") {
      return CastAttr(&internal_->rate);
    } else {
      return Error::RuntimeError() << "Dropout op has no attribute named " << attr_name;
    }
  }

  const float& rate() const { return internal_->rate; }
  float* mutable_rate() { return &internal_->rate; }
  void set_rate(const float& rate) { internal_->rate = rate; }

 private:
  struct Internal {
    float rate;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.dropout", DropoutOpInterpCtxImpl<schema::DropoutOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class DropoutGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& scale() const = 0;
  virtual float* mutable_scale() = 0;
  virtual void set_scale(const float& scale) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"scale"};
    return attr_names;
  }
};
template<typename Provider>
class DropoutGradOpInterpCtxImpl : public DropoutGradOpInterpCtx {
 public:
  DropoutGradOpInterpCtxImpl() = default;
  DropoutGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& scale() const override { return impl_.scale(); }
  float* mutable_scale() override { return impl_.mutable_scale(); }
  void set_scale(const float& scale) override { impl_.set_scale(scale); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DropoutGradOp {
 public:
  DropoutGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "scale") {
      return CastAttr(&internal_->scale);
    } else {
      return Error::RuntimeError() << "DropoutGrad op has no attribute named " << attr_name;
    }
  }

  const float& scale() const { return internal_->scale; }
  float* mutable_scale() { return &internal_->scale; }
  void set_scale(const float& scale) { internal_->scale = scale; }

 private:
  struct Internal {
    float scale;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.dropout_grad", DropoutGradOpInterpCtxImpl<schema::DropoutGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class DynamicLossScaleScheduleOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& increment_period() const = 0;
  virtual int64_t* mutable_increment_period() = 0;
  virtual void set_increment_period(const int64_t& increment_period) = 0;

  virtual const float& multiplier() const = 0;
  virtual float* mutable_multiplier() = 0;
  virtual void set_multiplier(const float& multiplier) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"increment_period", "multiplier"};
    return attr_names;
  }
};
template<typename Provider>
class DynamicLossScaleScheduleOpInterpCtxImpl : public DynamicLossScaleScheduleOpInterpCtx {
 public:
  DynamicLossScaleScheduleOpInterpCtxImpl() = default;
  DynamicLossScaleScheduleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& increment_period() const override { return impl_.increment_period(); }
  int64_t* mutable_increment_period() override { return impl_.mutable_increment_period(); }
  void set_increment_period(const int64_t& increment_period) override {
    impl_.set_increment_period(increment_period);
  }

  const float& multiplier() const override { return impl_.multiplier(); }
  float* mutable_multiplier() override { return impl_.mutable_multiplier(); }
  void set_multiplier(const float& multiplier) override { impl_.set_multiplier(multiplier); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class DynamicLossScaleScheduleOp {
 public:
  DynamicLossScaleScheduleOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "increment_period") {
      return CastAttr(&internal_->increment_period);
    } else if (attr_name == "multiplier") {
      return CastAttr(&internal_->multiplier);
    } else {
      return Error::RuntimeError()
             << "DynamicLossScaleSchedule op has no attribute named " << attr_name;
    }
  }

  const int64_t& increment_period() const { return internal_->increment_period; }
  int64_t* mutable_increment_period() { return &internal_->increment_period; }
  void set_increment_period(const int64_t& increment_period) {
    internal_->increment_period = increment_period;
  }

  const float& multiplier() const { return internal_->multiplier; }
  float* mutable_multiplier() { return &internal_->multiplier; }
  void set_multiplier(const float& multiplier) { internal_->multiplier = multiplier; }

 private:
  struct Internal {
    int64_t increment_period;
    float multiplier;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.dynamic_loss_scale_schedule",
                       DynamicLossScaleScheduleOpInterpCtxImpl<schema::DynamicLossScaleScheduleOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class EagerBToSOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& out_split_axis() const = 0;
  virtual int64_t* mutable_out_split_axis() = 0;
  virtual void set_out_split_axis(const int64_t& out_split_axis) = 0;

  virtual const std::string& in_parallel_conf() const = 0;
  virtual std::string* mutable_in_parallel_conf() = 0;
  virtual void set_in_parallel_conf(const std::string& in_parallel_conf) = 0;

  virtual const std::string& out_parallel_conf() const = 0;
  virtual std::string* mutable_out_parallel_conf() = 0;
  virtual void set_out_parallel_conf(const std::string& out_parallel_conf) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"out_split_axis", "in_parallel_conf",
                                           "out_parallel_conf", "shape"};
    return attr_names;
  }
};
template<typename Provider>
class EagerBToSOpInterpCtxImpl : public EagerBToSOpInterpCtx {
 public:
  EagerBToSOpInterpCtxImpl() = default;
  EagerBToSOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& out_split_axis() const override { return impl_.out_split_axis(); }
  int64_t* mutable_out_split_axis() override { return impl_.mutable_out_split_axis(); }
  void set_out_split_axis(const int64_t& out_split_axis) override {
    impl_.set_out_split_axis(out_split_axis);
  }

  const std::string& in_parallel_conf() const override { return impl_.in_parallel_conf(); }
  std::string* mutable_in_parallel_conf() override { return impl_.mutable_in_parallel_conf(); }
  void set_in_parallel_conf(const std::string& in_parallel_conf) override {
    impl_.set_in_parallel_conf(in_parallel_conf);
  }

  const std::string& out_parallel_conf() const override { return impl_.out_parallel_conf(); }
  std::string* mutable_out_parallel_conf() override { return impl_.mutable_out_parallel_conf(); }
  void set_out_parallel_conf(const std::string& out_parallel_conf) override {
    impl_.set_out_parallel_conf(out_parallel_conf);
  }

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerBToSOp {
 public:
  EagerBToSOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "out_split_axis") {
      return CastAttr(&internal_->out_split_axis);
    } else if (attr_name == "in_parallel_conf") {
      return CastAttr(&internal_->in_parallel_conf);
    } else if (attr_name == "out_parallel_conf") {
      return CastAttr(&internal_->out_parallel_conf);
    } else if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else {
      return Error::RuntimeError() << "EagerBToS op has no attribute named " << attr_name;
    }
  }

  const int64_t& out_split_axis() const { return internal_->out_split_axis; }
  int64_t* mutable_out_split_axis() { return &internal_->out_split_axis; }
  void set_out_split_axis(const int64_t& out_split_axis) {
    internal_->out_split_axis = out_split_axis;
  }

  const std::string& in_parallel_conf() const { return internal_->in_parallel_conf; }
  std::string* mutable_in_parallel_conf() { return &internal_->in_parallel_conf; }
  void set_in_parallel_conf(const std::string& in_parallel_conf) {
    internal_->in_parallel_conf = in_parallel_conf;
  }

  const std::string& out_parallel_conf() const { return internal_->out_parallel_conf; }
  std::string* mutable_out_parallel_conf() { return &internal_->out_parallel_conf; }
  void set_out_parallel_conf(const std::string& out_parallel_conf) {
    internal_->out_parallel_conf = out_parallel_conf;
  }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

 private:
  struct Internal {
    int64_t out_split_axis;
    std::string in_parallel_conf;
    std::string out_parallel_conf;
    Shape shape;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.eager_b_to_s", EagerBToSOpInterpCtxImpl<schema::EagerBToSOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class EagerNaiveSToSOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& in_split_axis() const = 0;
  virtual int64_t* mutable_in_split_axis() = 0;
  virtual void set_in_split_axis(const int64_t& in_split_axis) = 0;

  virtual const int64_t& out_split_axis() const = 0;
  virtual int64_t* mutable_out_split_axis() = 0;
  virtual void set_out_split_axis(const int64_t& out_split_axis) = 0;

  virtual const std::string& in_parallel_conf() const = 0;
  virtual std::string* mutable_in_parallel_conf() = 0;
  virtual void set_in_parallel_conf(const std::string& in_parallel_conf) = 0;

  virtual const std::string& out_parallel_conf() const = 0;
  virtual std::string* mutable_out_parallel_conf() = 0;
  virtual void set_out_parallel_conf(const std::string& out_parallel_conf) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"in_split_axis", "out_split_axis", "in_parallel_conf",
                                           "out_parallel_conf", "shape"};
    return attr_names;
  }
};
template<typename Provider>
class EagerNaiveSToSOpInterpCtxImpl : public EagerNaiveSToSOpInterpCtx {
 public:
  EagerNaiveSToSOpInterpCtxImpl() = default;
  EagerNaiveSToSOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& in_split_axis() const override { return impl_.in_split_axis(); }
  int64_t* mutable_in_split_axis() override { return impl_.mutable_in_split_axis(); }
  void set_in_split_axis(const int64_t& in_split_axis) override {
    impl_.set_in_split_axis(in_split_axis);
  }

  const int64_t& out_split_axis() const override { return impl_.out_split_axis(); }
  int64_t* mutable_out_split_axis() override { return impl_.mutable_out_split_axis(); }
  void set_out_split_axis(const int64_t& out_split_axis) override {
    impl_.set_out_split_axis(out_split_axis);
  }

  const std::string& in_parallel_conf() const override { return impl_.in_parallel_conf(); }
  std::string* mutable_in_parallel_conf() override { return impl_.mutable_in_parallel_conf(); }
  void set_in_parallel_conf(const std::string& in_parallel_conf) override {
    impl_.set_in_parallel_conf(in_parallel_conf);
  }

  const std::string& out_parallel_conf() const override { return impl_.out_parallel_conf(); }
  std::string* mutable_out_parallel_conf() override { return impl_.mutable_out_parallel_conf(); }
  void set_out_parallel_conf(const std::string& out_parallel_conf) override {
    impl_.set_out_parallel_conf(out_parallel_conf);
  }

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerNaiveSToSOp {
 public:
  EagerNaiveSToSOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "in_split_axis") {
      return CastAttr(&internal_->in_split_axis);
    } else if (attr_name == "out_split_axis") {
      return CastAttr(&internal_->out_split_axis);
    } else if (attr_name == "in_parallel_conf") {
      return CastAttr(&internal_->in_parallel_conf);
    } else if (attr_name == "out_parallel_conf") {
      return CastAttr(&internal_->out_parallel_conf);
    } else if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else {
      return Error::RuntimeError() << "EagerNaiveSToS op has no attribute named " << attr_name;
    }
  }

  const int64_t& in_split_axis() const { return internal_->in_split_axis; }
  int64_t* mutable_in_split_axis() { return &internal_->in_split_axis; }
  void set_in_split_axis(const int64_t& in_split_axis) { internal_->in_split_axis = in_split_axis; }

  const int64_t& out_split_axis() const { return internal_->out_split_axis; }
  int64_t* mutable_out_split_axis() { return &internal_->out_split_axis; }
  void set_out_split_axis(const int64_t& out_split_axis) {
    internal_->out_split_axis = out_split_axis;
  }

  const std::string& in_parallel_conf() const { return internal_->in_parallel_conf; }
  std::string* mutable_in_parallel_conf() { return &internal_->in_parallel_conf; }
  void set_in_parallel_conf(const std::string& in_parallel_conf) {
    internal_->in_parallel_conf = in_parallel_conf;
  }

  const std::string& out_parallel_conf() const { return internal_->out_parallel_conf; }
  std::string* mutable_out_parallel_conf() { return &internal_->out_parallel_conf; }
  void set_out_parallel_conf(const std::string& out_parallel_conf) {
    internal_->out_parallel_conf = out_parallel_conf;
  }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

 private:
  struct Internal {
    int64_t in_split_axis;
    int64_t out_split_axis;
    std::string in_parallel_conf;
    std::string out_parallel_conf;
    Shape shape;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.eager_naive_s_to_s",
                       EagerNaiveSToSOpInterpCtxImpl<schema::EagerNaiveSToSOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class EagerNcclAllGatherOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& parallel_conf() const = 0;
  virtual std::string* mutable_parallel_conf() = 0;
  virtual void set_parallel_conf(const std::string& parallel_conf) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"parallel_conf"};
    return attr_names;
  }
};
template<typename Provider>
class EagerNcclAllGatherOpInterpCtxImpl : public EagerNcclAllGatherOpInterpCtx {
 public:
  EagerNcclAllGatherOpInterpCtxImpl() = default;
  EagerNcclAllGatherOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& parallel_conf() const override { return impl_.parallel_conf(); }
  std::string* mutable_parallel_conf() override { return impl_.mutable_parallel_conf(); }
  void set_parallel_conf(const std::string& parallel_conf) override {
    impl_.set_parallel_conf(parallel_conf);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerNcclAllGatherOp {
 public:
  EagerNcclAllGatherOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "parallel_conf") {
      return CastAttr(&internal_->parallel_conf);
    } else {
      return Error::RuntimeError() << "EagerNcclAllGather op has no attribute named " << attr_name;
    }
  }

  const std::string& parallel_conf() const { return internal_->parallel_conf; }
  std::string* mutable_parallel_conf() { return &internal_->parallel_conf; }
  void set_parallel_conf(const std::string& parallel_conf) {
    internal_->parallel_conf = parallel_conf;
  }

 private:
  struct Internal {
    std::string parallel_conf;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.eager_nccl_all_gather",
                       EagerNcclAllGatherOpInterpCtxImpl<schema::EagerNcclAllGatherOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class EagerNcclAllReduceOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& parallel_conf() const = 0;
  virtual std::string* mutable_parallel_conf() = 0;
  virtual void set_parallel_conf(const std::string& parallel_conf) = 0;

  virtual const bool& async_launch() const = 0;
  virtual bool* mutable_async_launch() = 0;
  virtual void set_async_launch(const bool& async_launch) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"parallel_conf", "async_launch"};
    return attr_names;
  }
};
template<typename Provider>
class EagerNcclAllReduceOpInterpCtxImpl : public EagerNcclAllReduceOpInterpCtx {
 public:
  EagerNcclAllReduceOpInterpCtxImpl() = default;
  EagerNcclAllReduceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& parallel_conf() const override { return impl_.parallel_conf(); }
  std::string* mutable_parallel_conf() override { return impl_.mutable_parallel_conf(); }
  void set_parallel_conf(const std::string& parallel_conf) override {
    impl_.set_parallel_conf(parallel_conf);
  }

  const bool& async_launch() const override { return impl_.async_launch(); }
  bool* mutable_async_launch() override { return impl_.mutable_async_launch(); }
  void set_async_launch(const bool& async_launch) override { impl_.set_async_launch(async_launch); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerNcclAllReduceOp {
 public:
  EagerNcclAllReduceOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "parallel_conf") {
      return CastAttr(&internal_->parallel_conf);
    } else if (attr_name == "async_launch") {
      return CastAttr(&internal_->async_launch);
    } else {
      return Error::RuntimeError() << "EagerNcclAllReduce op has no attribute named " << attr_name;
    }
  }

  const std::string& parallel_conf() const { return internal_->parallel_conf; }
  std::string* mutable_parallel_conf() { return &internal_->parallel_conf; }
  void set_parallel_conf(const std::string& parallel_conf) {
    internal_->parallel_conf = parallel_conf;
  }

  const bool& async_launch() const { return internal_->async_launch; }
  bool* mutable_async_launch() { return &internal_->async_launch; }
  void set_async_launch(const bool& async_launch) { internal_->async_launch = async_launch; }

 private:
  struct Internal {
    std::string parallel_conf;
    bool async_launch;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.eager_nccl_all_reduce",
                       EagerNcclAllReduceOpInterpCtxImpl<schema::EagerNcclAllReduceOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class EagerNcclBroadcastOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& parallel_conf() const = 0;
  virtual std::string* mutable_parallel_conf() = 0;
  virtual void set_parallel_conf(const std::string& parallel_conf) = 0;

  virtual const int64_t& root() const = 0;
  virtual int64_t* mutable_root() = 0;
  virtual void set_root(const int64_t& root) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"parallel_conf", "root"};
    return attr_names;
  }
};
template<typename Provider>
class EagerNcclBroadcastOpInterpCtxImpl : public EagerNcclBroadcastOpInterpCtx {
 public:
  EagerNcclBroadcastOpInterpCtxImpl() = default;
  EagerNcclBroadcastOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& parallel_conf() const override { return impl_.parallel_conf(); }
  std::string* mutable_parallel_conf() override { return impl_.mutable_parallel_conf(); }
  void set_parallel_conf(const std::string& parallel_conf) override {
    impl_.set_parallel_conf(parallel_conf);
  }

  const int64_t& root() const override { return impl_.root(); }
  int64_t* mutable_root() override { return impl_.mutable_root(); }
  void set_root(const int64_t& root) override { impl_.set_root(root); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerNcclBroadcastOp {
 public:
  EagerNcclBroadcastOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "parallel_conf") {
      return CastAttr(&internal_->parallel_conf);
    } else if (attr_name == "root") {
      return CastAttr(&internal_->root);
    } else {
      return Error::RuntimeError() << "EagerNcclBroadcast op has no attribute named " << attr_name;
    }
  }

  const std::string& parallel_conf() const { return internal_->parallel_conf; }
  std::string* mutable_parallel_conf() { return &internal_->parallel_conf; }
  void set_parallel_conf(const std::string& parallel_conf) {
    internal_->parallel_conf = parallel_conf;
  }

  const int64_t& root() const { return internal_->root; }
  int64_t* mutable_root() { return &internal_->root; }
  void set_root(const int64_t& root) { internal_->root = root; }

 private:
  struct Internal {
    std::string parallel_conf;
    int64_t root;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.eager_nccl_broadcast",
                       EagerNcclBroadcastOpInterpCtxImpl<schema::EagerNcclBroadcastOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class EagerNcclReduceOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& parallel_conf() const = 0;
  virtual std::string* mutable_parallel_conf() = 0;
  virtual void set_parallel_conf(const std::string& parallel_conf) = 0;

  virtual const int64_t& root() const = 0;
  virtual int64_t* mutable_root() = 0;
  virtual void set_root(const int64_t& root) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"parallel_conf", "root"};
    return attr_names;
  }
};
template<typename Provider>
class EagerNcclReduceOpInterpCtxImpl : public EagerNcclReduceOpInterpCtx {
 public:
  EagerNcclReduceOpInterpCtxImpl() = default;
  EagerNcclReduceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& parallel_conf() const override { return impl_.parallel_conf(); }
  std::string* mutable_parallel_conf() override { return impl_.mutable_parallel_conf(); }
  void set_parallel_conf(const std::string& parallel_conf) override {
    impl_.set_parallel_conf(parallel_conf);
  }

  const int64_t& root() const override { return impl_.root(); }
  int64_t* mutable_root() override { return impl_.mutable_root(); }
  void set_root(const int64_t& root) override { impl_.set_root(root); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerNcclReduceOp {
 public:
  EagerNcclReduceOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "parallel_conf") {
      return CastAttr(&internal_->parallel_conf);
    } else if (attr_name == "root") {
      return CastAttr(&internal_->root);
    } else {
      return Error::RuntimeError() << "EagerNcclReduce op has no attribute named " << attr_name;
    }
  }

  const std::string& parallel_conf() const { return internal_->parallel_conf; }
  std::string* mutable_parallel_conf() { return &internal_->parallel_conf; }
  void set_parallel_conf(const std::string& parallel_conf) {
    internal_->parallel_conf = parallel_conf;
  }

  const int64_t& root() const { return internal_->root; }
  int64_t* mutable_root() { return &internal_->root; }
  void set_root(const int64_t& root) { internal_->root = root; }

 private:
  struct Internal {
    std::string parallel_conf;
    int64_t root;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.eager_nccl_reduce",
                       EagerNcclReduceOpInterpCtxImpl<schema::EagerNcclReduceOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class EagerNcclReduceScatterOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& parallel_conf() const = 0;
  virtual std::string* mutable_parallel_conf() = 0;
  virtual void set_parallel_conf(const std::string& parallel_conf) = 0;

  virtual const std::string& op_type() const = 0;
  virtual std::string* mutable_op_type() = 0;
  virtual void set_op_type(const std::string& op_type) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"parallel_conf", "op_type"};
    return attr_names;
  }
};
template<typename Provider>
class EagerNcclReduceScatterOpInterpCtxImpl : public EagerNcclReduceScatterOpInterpCtx {
 public:
  EagerNcclReduceScatterOpInterpCtxImpl() = default;
  EagerNcclReduceScatterOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& parallel_conf() const override { return impl_.parallel_conf(); }
  std::string* mutable_parallel_conf() override { return impl_.mutable_parallel_conf(); }
  void set_parallel_conf(const std::string& parallel_conf) override {
    impl_.set_parallel_conf(parallel_conf);
  }

  const std::string& op_type() const override { return impl_.op_type(); }
  std::string* mutable_op_type() override { return impl_.mutable_op_type(); }
  void set_op_type(const std::string& op_type) override { impl_.set_op_type(op_type); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerNcclReduceScatterOp {
 public:
  EagerNcclReduceScatterOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "parallel_conf") {
      return CastAttr(&internal_->parallel_conf);
    } else if (attr_name == "op_type") {
      return CastAttr(&internal_->op_type);
    } else {
      return Error::RuntimeError()
             << "EagerNcclReduceScatter op has no attribute named " << attr_name;
    }
  }

  const std::string& parallel_conf() const { return internal_->parallel_conf; }
  std::string* mutable_parallel_conf() { return &internal_->parallel_conf; }
  void set_parallel_conf(const std::string& parallel_conf) {
    internal_->parallel_conf = parallel_conf;
  }

  const std::string& op_type() const { return internal_->op_type; }
  std::string* mutable_op_type() { return &internal_->op_type; }
  void set_op_type(const std::string& op_type) { internal_->op_type = op_type; }

 private:
  struct Internal {
    std::string parallel_conf;
    std::string op_type;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.eager_nccl_reduce_scatter",
                       EagerNcclReduceScatterOpInterpCtxImpl<schema::EagerNcclReduceScatterOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class EagerNcclS2sOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& in_split_axis() const = 0;
  virtual int64_t* mutable_in_split_axis() = 0;
  virtual void set_in_split_axis(const int64_t& in_split_axis) = 0;

  virtual const int64_t& out_split_axis() const = 0;
  virtual int64_t* mutable_out_split_axis() = 0;
  virtual void set_out_split_axis(const int64_t& out_split_axis) = 0;

  virtual const std::string& parallel_conf() const = 0;
  virtual std::string* mutable_parallel_conf() = 0;
  virtual void set_parallel_conf(const std::string& parallel_conf) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"in_split_axis", "out_split_axis", "parallel_conf"};
    return attr_names;
  }
};
template<typename Provider>
class EagerNcclS2sOpInterpCtxImpl : public EagerNcclS2sOpInterpCtx {
 public:
  EagerNcclS2sOpInterpCtxImpl() = default;
  EagerNcclS2sOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& in_split_axis() const override { return impl_.in_split_axis(); }
  int64_t* mutable_in_split_axis() override { return impl_.mutable_in_split_axis(); }
  void set_in_split_axis(const int64_t& in_split_axis) override {
    impl_.set_in_split_axis(in_split_axis);
  }

  const int64_t& out_split_axis() const override { return impl_.out_split_axis(); }
  int64_t* mutable_out_split_axis() override { return impl_.mutable_out_split_axis(); }
  void set_out_split_axis(const int64_t& out_split_axis) override {
    impl_.set_out_split_axis(out_split_axis);
  }

  const std::string& parallel_conf() const override { return impl_.parallel_conf(); }
  std::string* mutable_parallel_conf() override { return impl_.mutable_parallel_conf(); }
  void set_parallel_conf(const std::string& parallel_conf) override {
    impl_.set_parallel_conf(parallel_conf);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerNcclS2sOp {
 public:
  EagerNcclS2sOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "in_split_axis") {
      return CastAttr(&internal_->in_split_axis);
    } else if (attr_name == "out_split_axis") {
      return CastAttr(&internal_->out_split_axis);
    } else if (attr_name == "parallel_conf") {
      return CastAttr(&internal_->parallel_conf);
    } else {
      return Error::RuntimeError() << "EagerNcclS2s op has no attribute named " << attr_name;
    }
  }

  const int64_t& in_split_axis() const { return internal_->in_split_axis; }
  int64_t* mutable_in_split_axis() { return &internal_->in_split_axis; }
  void set_in_split_axis(const int64_t& in_split_axis) { internal_->in_split_axis = in_split_axis; }

  const int64_t& out_split_axis() const { return internal_->out_split_axis; }
  int64_t* mutable_out_split_axis() { return &internal_->out_split_axis; }
  void set_out_split_axis(const int64_t& out_split_axis) {
    internal_->out_split_axis = out_split_axis;
  }

  const std::string& parallel_conf() const { return internal_->parallel_conf; }
  std::string* mutable_parallel_conf() { return &internal_->parallel_conf; }
  void set_parallel_conf(const std::string& parallel_conf) {
    internal_->parallel_conf = parallel_conf;
  }

 private:
  struct Internal {
    int64_t in_split_axis;
    int64_t out_split_axis;
    std::string parallel_conf;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.eager_nccl_s2s", EagerNcclS2sOpInterpCtxImpl<schema::EagerNcclS2sOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class EagerPToBOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& in_parallel_conf() const = 0;
  virtual std::string* mutable_in_parallel_conf() = 0;
  virtual void set_in_parallel_conf(const std::string& in_parallel_conf) = 0;

  virtual const std::string& out_parallel_conf() const = 0;
  virtual std::string* mutable_out_parallel_conf() = 0;
  virtual void set_out_parallel_conf(const std::string& out_parallel_conf) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"in_parallel_conf", "out_parallel_conf", "shape"};
    return attr_names;
  }
};
template<typename Provider>
class EagerPToBOpInterpCtxImpl : public EagerPToBOpInterpCtx {
 public:
  EagerPToBOpInterpCtxImpl() = default;
  EagerPToBOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& in_parallel_conf() const override { return impl_.in_parallel_conf(); }
  std::string* mutable_in_parallel_conf() override { return impl_.mutable_in_parallel_conf(); }
  void set_in_parallel_conf(const std::string& in_parallel_conf) override {
    impl_.set_in_parallel_conf(in_parallel_conf);
  }

  const std::string& out_parallel_conf() const override { return impl_.out_parallel_conf(); }
  std::string* mutable_out_parallel_conf() override { return impl_.mutable_out_parallel_conf(); }
  void set_out_parallel_conf(const std::string& out_parallel_conf) override {
    impl_.set_out_parallel_conf(out_parallel_conf);
  }

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerPToBOp {
 public:
  EagerPToBOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "in_parallel_conf") {
      return CastAttr(&internal_->in_parallel_conf);
    } else if (attr_name == "out_parallel_conf") {
      return CastAttr(&internal_->out_parallel_conf);
    } else if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else {
      return Error::RuntimeError() << "EagerPToB op has no attribute named " << attr_name;
    }
  }

  const std::string& in_parallel_conf() const { return internal_->in_parallel_conf; }
  std::string* mutable_in_parallel_conf() { return &internal_->in_parallel_conf; }
  void set_in_parallel_conf(const std::string& in_parallel_conf) {
    internal_->in_parallel_conf = in_parallel_conf;
  }

  const std::string& out_parallel_conf() const { return internal_->out_parallel_conf; }
  std::string* mutable_out_parallel_conf() { return &internal_->out_parallel_conf; }
  void set_out_parallel_conf(const std::string& out_parallel_conf) {
    internal_->out_parallel_conf = out_parallel_conf;
  }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

 private:
  struct Internal {
    std::string in_parallel_conf;
    std::string out_parallel_conf;
    Shape shape;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.eager_p_to_b", EagerPToBOpInterpCtxImpl<schema::EagerPToBOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class EagerPToSOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& out_split_axis() const = 0;
  virtual int64_t* mutable_out_split_axis() = 0;
  virtual void set_out_split_axis(const int64_t& out_split_axis) = 0;

  virtual const std::string& in_parallel_conf() const = 0;
  virtual std::string* mutable_in_parallel_conf() = 0;
  virtual void set_in_parallel_conf(const std::string& in_parallel_conf) = 0;

  virtual const std::string& out_parallel_conf() const = 0;
  virtual std::string* mutable_out_parallel_conf() = 0;
  virtual void set_out_parallel_conf(const std::string& out_parallel_conf) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"out_split_axis", "in_parallel_conf",
                                           "out_parallel_conf", "shape"};
    return attr_names;
  }
};
template<typename Provider>
class EagerPToSOpInterpCtxImpl : public EagerPToSOpInterpCtx {
 public:
  EagerPToSOpInterpCtxImpl() = default;
  EagerPToSOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& out_split_axis() const override { return impl_.out_split_axis(); }
  int64_t* mutable_out_split_axis() override { return impl_.mutable_out_split_axis(); }
  void set_out_split_axis(const int64_t& out_split_axis) override {
    impl_.set_out_split_axis(out_split_axis);
  }

  const std::string& in_parallel_conf() const override { return impl_.in_parallel_conf(); }
  std::string* mutable_in_parallel_conf() override { return impl_.mutable_in_parallel_conf(); }
  void set_in_parallel_conf(const std::string& in_parallel_conf) override {
    impl_.set_in_parallel_conf(in_parallel_conf);
  }

  const std::string& out_parallel_conf() const override { return impl_.out_parallel_conf(); }
  std::string* mutable_out_parallel_conf() override { return impl_.mutable_out_parallel_conf(); }
  void set_out_parallel_conf(const std::string& out_parallel_conf) override {
    impl_.set_out_parallel_conf(out_parallel_conf);
  }

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerPToSOp {
 public:
  EagerPToSOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "out_split_axis") {
      return CastAttr(&internal_->out_split_axis);
    } else if (attr_name == "in_parallel_conf") {
      return CastAttr(&internal_->in_parallel_conf);
    } else if (attr_name == "out_parallel_conf") {
      return CastAttr(&internal_->out_parallel_conf);
    } else if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else {
      return Error::RuntimeError() << "EagerPToS op has no attribute named " << attr_name;
    }
  }

  const int64_t& out_split_axis() const { return internal_->out_split_axis; }
  int64_t* mutable_out_split_axis() { return &internal_->out_split_axis; }
  void set_out_split_axis(const int64_t& out_split_axis) {
    internal_->out_split_axis = out_split_axis;
  }

  const std::string& in_parallel_conf() const { return internal_->in_parallel_conf; }
  std::string* mutable_in_parallel_conf() { return &internal_->in_parallel_conf; }
  void set_in_parallel_conf(const std::string& in_parallel_conf) {
    internal_->in_parallel_conf = in_parallel_conf;
  }

  const std::string& out_parallel_conf() const { return internal_->out_parallel_conf; }
  std::string* mutable_out_parallel_conf() { return &internal_->out_parallel_conf; }
  void set_out_parallel_conf(const std::string& out_parallel_conf) {
    internal_->out_parallel_conf = out_parallel_conf;
  }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

 private:
  struct Internal {
    int64_t out_split_axis;
    std::string in_parallel_conf;
    std::string out_parallel_conf;
    Shape shape;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.eager_p_to_s", EagerPToSOpInterpCtxImpl<schema::EagerPToSOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class EagerSToBOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& in_split_axis() const = 0;
  virtual int64_t* mutable_in_split_axis() = 0;
  virtual void set_in_split_axis(const int64_t& in_split_axis) = 0;

  virtual const std::string& in_parallel_conf() const = 0;
  virtual std::string* mutable_in_parallel_conf() = 0;
  virtual void set_in_parallel_conf(const std::string& in_parallel_conf) = 0;

  virtual const std::string& out_parallel_conf() const = 0;
  virtual std::string* mutable_out_parallel_conf() = 0;
  virtual void set_out_parallel_conf(const std::string& out_parallel_conf) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"in_split_axis", "in_parallel_conf", "out_parallel_conf",
                                           "shape"};
    return attr_names;
  }
};
template<typename Provider>
class EagerSToBOpInterpCtxImpl : public EagerSToBOpInterpCtx {
 public:
  EagerSToBOpInterpCtxImpl() = default;
  EagerSToBOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& in_split_axis() const override { return impl_.in_split_axis(); }
  int64_t* mutable_in_split_axis() override { return impl_.mutable_in_split_axis(); }
  void set_in_split_axis(const int64_t& in_split_axis) override {
    impl_.set_in_split_axis(in_split_axis);
  }

  const std::string& in_parallel_conf() const override { return impl_.in_parallel_conf(); }
  std::string* mutable_in_parallel_conf() override { return impl_.mutable_in_parallel_conf(); }
  void set_in_parallel_conf(const std::string& in_parallel_conf) override {
    impl_.set_in_parallel_conf(in_parallel_conf);
  }

  const std::string& out_parallel_conf() const override { return impl_.out_parallel_conf(); }
  std::string* mutable_out_parallel_conf() override { return impl_.mutable_out_parallel_conf(); }
  void set_out_parallel_conf(const std::string& out_parallel_conf) override {
    impl_.set_out_parallel_conf(out_parallel_conf);
  }

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerSToBOp {
 public:
  EagerSToBOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "in_split_axis") {
      return CastAttr(&internal_->in_split_axis);
    } else if (attr_name == "in_parallel_conf") {
      return CastAttr(&internal_->in_parallel_conf);
    } else if (attr_name == "out_parallel_conf") {
      return CastAttr(&internal_->out_parallel_conf);
    } else if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else {
      return Error::RuntimeError() << "EagerSToB op has no attribute named " << attr_name;
    }
  }

  const int64_t& in_split_axis() const { return internal_->in_split_axis; }
  int64_t* mutable_in_split_axis() { return &internal_->in_split_axis; }
  void set_in_split_axis(const int64_t& in_split_axis) { internal_->in_split_axis = in_split_axis; }

  const std::string& in_parallel_conf() const { return internal_->in_parallel_conf; }
  std::string* mutable_in_parallel_conf() { return &internal_->in_parallel_conf; }
  void set_in_parallel_conf(const std::string& in_parallel_conf) {
    internal_->in_parallel_conf = in_parallel_conf;
  }

  const std::string& out_parallel_conf() const { return internal_->out_parallel_conf; }
  std::string* mutable_out_parallel_conf() { return &internal_->out_parallel_conf; }
  void set_out_parallel_conf(const std::string& out_parallel_conf) {
    internal_->out_parallel_conf = out_parallel_conf;
  }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

 private:
  struct Internal {
    int64_t in_split_axis;
    std::string in_parallel_conf;
    std::string out_parallel_conf;
    Shape shape;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.eager_s_to_b", EagerSToBOpInterpCtxImpl<schema::EagerSToBOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class EagerSymmetricSToPOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& in_split_axis() const = 0;
  virtual int64_t* mutable_in_split_axis() = 0;
  virtual void set_in_split_axis(const int64_t& in_split_axis) = 0;

  virtual const std::string& parallel_conf() const = 0;
  virtual std::string* mutable_parallel_conf() = 0;
  virtual void set_parallel_conf(const std::string& parallel_conf) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"in_split_axis", "parallel_conf"};
    return attr_names;
  }
};
template<typename Provider>
class EagerSymmetricSToPOpInterpCtxImpl : public EagerSymmetricSToPOpInterpCtx {
 public:
  EagerSymmetricSToPOpInterpCtxImpl() = default;
  EagerSymmetricSToPOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& in_split_axis() const override { return impl_.in_split_axis(); }
  int64_t* mutable_in_split_axis() override { return impl_.mutable_in_split_axis(); }
  void set_in_split_axis(const int64_t& in_split_axis) override {
    impl_.set_in_split_axis(in_split_axis);
  }

  const std::string& parallel_conf() const override { return impl_.parallel_conf(); }
  std::string* mutable_parallel_conf() override { return impl_.mutable_parallel_conf(); }
  void set_parallel_conf(const std::string& parallel_conf) override {
    impl_.set_parallel_conf(parallel_conf);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EagerSymmetricSToPOp {
 public:
  EagerSymmetricSToPOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "in_split_axis") {
      return CastAttr(&internal_->in_split_axis);
    } else if (attr_name == "parallel_conf") {
      return CastAttr(&internal_->parallel_conf);
    } else {
      return Error::RuntimeError() << "EagerSymmetricSToP op has no attribute named " << attr_name;
    }
  }

  const int64_t& in_split_axis() const { return internal_->in_split_axis; }
  int64_t* mutable_in_split_axis() { return &internal_->in_split_axis; }
  void set_in_split_axis(const int64_t& in_split_axis) { internal_->in_split_axis = in_split_axis; }

  const std::string& parallel_conf() const { return internal_->parallel_conf; }
  std::string* mutable_parallel_conf() { return &internal_->parallel_conf; }
  void set_parallel_conf(const std::string& parallel_conf) {
    internal_->parallel_conf = parallel_conf;
  }

 private:
  struct Internal {
    int64_t in_split_axis;
    std::string parallel_conf;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.eager_symmetric_s_to_p",
                       EagerSymmetricSToPOpInterpCtxImpl<schema::EagerSymmetricSToPOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ElementwiseMaximumOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ElementwiseMaximumOpInterpCtxImpl : public ElementwiseMaximumOpInterpCtx {
 public:
  ElementwiseMaximumOpInterpCtxImpl() = default;
  ElementwiseMaximumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ElementwiseMaximumOp {
 public:
  ElementwiseMaximumOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ElementwiseMaximum op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.elementwise_maximum",
                       ElementwiseMaximumOpInterpCtxImpl<schema::ElementwiseMaximumOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ElementwiseMaximumBackwardOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ElementwiseMaximumBackwardOpInterpCtxImpl : public ElementwiseMaximumBackwardOpInterpCtx {
 public:
  ElementwiseMaximumBackwardOpInterpCtxImpl() = default;
  ElementwiseMaximumBackwardOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ElementwiseMaximumBackwardOp {
 public:
  ElementwiseMaximumBackwardOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ElementwiseMaximumBackward op has no attribute named "
                                 << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.elementwise_maximum_backward",
    ElementwiseMaximumBackwardOpInterpCtxImpl<schema::ElementwiseMaximumBackwardOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ElementwiseMinimumOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ElementwiseMinimumOpInterpCtxImpl : public ElementwiseMinimumOpInterpCtx {
 public:
  ElementwiseMinimumOpInterpCtxImpl() = default;
  ElementwiseMinimumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ElementwiseMinimumOp {
 public:
  ElementwiseMinimumOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ElementwiseMinimum op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.elementwise_minimum",
                       ElementwiseMinimumOpInterpCtxImpl<schema::ElementwiseMinimumOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ElementwiseMinimumBackwardOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ElementwiseMinimumBackwardOpInterpCtxImpl : public ElementwiseMinimumBackwardOpInterpCtx {
 public:
  ElementwiseMinimumBackwardOpInterpCtxImpl() = default;
  ElementwiseMinimumBackwardOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ElementwiseMinimumBackwardOp {
 public:
  ElementwiseMinimumBackwardOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ElementwiseMinimumBackward op has no attribute named "
                                 << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.elementwise_minimum_backward",
    ElementwiseMinimumBackwardOpInterpCtxImpl<schema::ElementwiseMinimumBackwardOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class EluOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& alpha() const = 0;
  virtual double* mutable_alpha() = 0;
  virtual void set_alpha(const double& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"alpha"};
    return attr_names;
  }
};
template<typename Provider>
class EluOpInterpCtxImpl : public EluOpInterpCtx {
 public:
  EluOpInterpCtxImpl() = default;
  EluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& alpha() const override { return impl_.alpha(); }
  double* mutable_alpha() override { return impl_.mutable_alpha(); }
  void set_alpha(const double& alpha) override { impl_.set_alpha(alpha); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EluOp {
 public:
  EluOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "alpha") {
      return CastAttr(&internal_->alpha);
    } else {
      return Error::RuntimeError() << "Elu op has no attribute named " << attr_name;
    }
  }

  const double& alpha() const { return internal_->alpha; }
  double* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const double& alpha) { internal_->alpha = alpha; }

 private:
  struct Internal {
    double alpha;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.elu", EluOpInterpCtxImpl<schema::EluOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class EluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& alpha() const = 0;
  virtual double* mutable_alpha() = 0;
  virtual void set_alpha(const double& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"alpha"};
    return attr_names;
  }
};
template<typename Provider>
class EluGradOpInterpCtxImpl : public EluGradOpInterpCtx {
 public:
  EluGradOpInterpCtxImpl() = default;
  EluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& alpha() const override { return impl_.alpha(); }
  double* mutable_alpha() override { return impl_.mutable_alpha(); }
  void set_alpha(const double& alpha) override { impl_.set_alpha(alpha); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EluGradOp {
 public:
  EluGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "alpha") {
      return CastAttr(&internal_->alpha);
    } else {
      return Error::RuntimeError() << "EluGrad op has no attribute named " << attr_name;
    }
  }

  const double& alpha() const { return internal_->alpha; }
  double* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const double& alpha) { internal_->alpha = alpha; }

 private:
  struct Internal {
    double alpha;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.elu_grad", EluGradOpInterpCtxImpl<schema::EluGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class EmptyOpInterpCtx : public OpInterpCtx {
 public:
  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"dtype", "shape", "nd_sbp"};
    return attr_names;
  }
};
template<typename Provider>
class EmptyOpInterpCtxImpl : public EmptyOpInterpCtx {
 public:
  EmptyOpInterpCtxImpl() = default;
  EmptyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const DataType& dtype() const override { return impl_.dtype(); }
  DataType* mutable_dtype() override { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) override { impl_.set_dtype(dtype); }

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  const std::vector<std::string>& nd_sbp() const override { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() override { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) override { impl_.set_nd_sbp(nd_sbp); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EmptyOp {
 public:
  EmptyOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "dtype") {
      return CastAttr(&internal_->dtype);
    } else if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else if (attr_name == "nd_sbp") {
      return CastAttr(&internal_->nd_sbp);
    } else {
      return Error::RuntimeError() << "Empty op has no attribute named " << attr_name;
    }
  }

  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }

 private:
  struct Internal {
    DataType dtype;
    Shape shape;
    std::vector<std::string> nd_sbp;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.empty", EmptyOpInterpCtxImpl<schema::EmptyOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ErfOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ErfOpInterpCtxImpl : public ErfOpInterpCtx {
 public:
  ErfOpInterpCtxImpl() = default;
  ErfOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ErfOp {
 public:
  ErfOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Erf op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.erf", ErfOpInterpCtxImpl<schema::ErfOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ErfGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ErfGradOpInterpCtxImpl : public ErfGradOpInterpCtx {
 public:
  ErfGradOpInterpCtxImpl() = default;
  ErfGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ErfGradOp {
 public:
  ErfGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ErfGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.erf_grad", ErfGradOpInterpCtxImpl<schema::ErfGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ErfcOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ErfcOpInterpCtxImpl : public ErfcOpInterpCtx {
 public:
  ErfcOpInterpCtxImpl() = default;
  ErfcOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ErfcOp {
 public:
  ErfcOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Erfc op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.erfc", ErfcOpInterpCtxImpl<schema::ErfcOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ErfcGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ErfcGradOpInterpCtxImpl : public ErfcGradOpInterpCtx {
 public:
  ErfcGradOpInterpCtxImpl() = default;
  ErfcGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ErfcGradOp {
 public:
  ErfcGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ErfcGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.erfc_grad", ErfcGradOpInterpCtxImpl<schema::ErfcGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ExpOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ExpOpInterpCtxImpl : public ExpOpInterpCtx {
 public:
  ExpOpInterpCtxImpl() = default;
  ExpOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ExpOp {
 public:
  ExpOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Exp op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.exp", ExpOpInterpCtxImpl<schema::ExpOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ExpGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ExpGradOpInterpCtxImpl : public ExpGradOpInterpCtx {
 public:
  ExpGradOpInterpCtxImpl() = default;
  ExpGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ExpGradOp {
 public:
  ExpGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ExpGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.exp_grad", ExpGradOpInterpCtxImpl<schema::ExpGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ExpandOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& logical_in_shape() const = 0;
  virtual std::vector<int32_t>* mutable_logical_in_shape() = 0;
  virtual void set_logical_in_shape(const std::vector<int32_t>& logical_in_shape) = 0;

  virtual const std::vector<int32_t>& logical_expand_shape() const = 0;
  virtual std::vector<int32_t>* mutable_logical_expand_shape() = 0;
  virtual void set_logical_expand_shape(const std::vector<int32_t>& logical_expand_shape) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"logical_in_shape", "logical_expand_shape"};
    return attr_names;
  }
};
template<typename Provider>
class ExpandOpInterpCtxImpl : public ExpandOpInterpCtx {
 public:
  ExpandOpInterpCtxImpl() = default;
  ExpandOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& logical_in_shape() const override { return impl_.logical_in_shape(); }
  std::vector<int32_t>* mutable_logical_in_shape() override {
    return impl_.mutable_logical_in_shape();
  }
  void set_logical_in_shape(const std::vector<int32_t>& logical_in_shape) override {
    impl_.set_logical_in_shape(logical_in_shape);
  }

  const std::vector<int32_t>& logical_expand_shape() const override {
    return impl_.logical_expand_shape();
  }
  std::vector<int32_t>* mutable_logical_expand_shape() override {
    return impl_.mutable_logical_expand_shape();
  }
  void set_logical_expand_shape(const std::vector<int32_t>& logical_expand_shape) override {
    impl_.set_logical_expand_shape(logical_expand_shape);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ExpandOp {
 public:
  ExpandOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "logical_in_shape") {
      return CastAttr(&internal_->logical_in_shape);
    } else if (attr_name == "logical_expand_shape") {
      return CastAttr(&internal_->logical_expand_shape);
    } else {
      return Error::RuntimeError() << "Expand op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& logical_in_shape() const { return internal_->logical_in_shape; }
  std::vector<int32_t>* mutable_logical_in_shape() { return &internal_->logical_in_shape; }
  void set_logical_in_shape(const std::vector<int32_t>& logical_in_shape) {
    internal_->logical_in_shape = logical_in_shape;
  }

  const std::vector<int32_t>& logical_expand_shape() const {
    return internal_->logical_expand_shape;
  }
  std::vector<int32_t>* mutable_logical_expand_shape() { return &internal_->logical_expand_shape; }
  void set_logical_expand_shape(const std::vector<int32_t>& logical_expand_shape) {
    internal_->logical_expand_shape = logical_expand_shape;
  }

 private:
  struct Internal {
    std::vector<int32_t> logical_in_shape;
    std::vector<int32_t> logical_expand_shape;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.expand", ExpandOpInterpCtxImpl<schema::ExpandOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ExpandDimsOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis"};
    return attr_names;
  }
};
template<typename Provider>
class ExpandDimsOpInterpCtxImpl : public ExpandDimsOpInterpCtx {
 public:
  ExpandDimsOpInterpCtxImpl() = default;
  ExpandDimsOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& axis() const override { return impl_.axis(); }
  int32_t* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) override { impl_.set_axis(axis); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ExpandDimsOp {
 public:
  ExpandDimsOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else {
      return Error::RuntimeError() << "ExpandDims op has no attribute named " << attr_name;
    }
  }

  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }

 private:
  struct Internal {
    int32_t axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.expand_dims", ExpandDimsOpInterpCtxImpl<schema::ExpandDimsOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ExpandGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& logical_out_shape() const = 0;
  virtual std::vector<int32_t>* mutable_logical_out_shape() = 0;
  virtual void set_logical_out_shape(const std::vector<int32_t>& logical_out_shape) = 0;

  virtual const std::vector<int32_t>& logical_expand_shape() const = 0;
  virtual std::vector<int32_t>* mutable_logical_expand_shape() = 0;
  virtual void set_logical_expand_shape(const std::vector<int32_t>& logical_expand_shape) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"logical_out_shape", "logical_expand_shape"};
    return attr_names;
  }
};
template<typename Provider>
class ExpandGradOpInterpCtxImpl : public ExpandGradOpInterpCtx {
 public:
  ExpandGradOpInterpCtxImpl() = default;
  ExpandGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& logical_out_shape() const override {
    return impl_.logical_out_shape();
  }
  std::vector<int32_t>* mutable_logical_out_shape() override {
    return impl_.mutable_logical_out_shape();
  }
  void set_logical_out_shape(const std::vector<int32_t>& logical_out_shape) override {
    impl_.set_logical_out_shape(logical_out_shape);
  }

  const std::vector<int32_t>& logical_expand_shape() const override {
    return impl_.logical_expand_shape();
  }
  std::vector<int32_t>* mutable_logical_expand_shape() override {
    return impl_.mutable_logical_expand_shape();
  }
  void set_logical_expand_shape(const std::vector<int32_t>& logical_expand_shape) override {
    impl_.set_logical_expand_shape(logical_expand_shape);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ExpandGradOp {
 public:
  ExpandGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "logical_out_shape") {
      return CastAttr(&internal_->logical_out_shape);
    } else if (attr_name == "logical_expand_shape") {
      return CastAttr(&internal_->logical_expand_shape);
    } else {
      return Error::RuntimeError() << "ExpandGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& logical_out_shape() const { return internal_->logical_out_shape; }
  std::vector<int32_t>* mutable_logical_out_shape() { return &internal_->logical_out_shape; }
  void set_logical_out_shape(const std::vector<int32_t>& logical_out_shape) {
    internal_->logical_out_shape = logical_out_shape;
  }

  const std::vector<int32_t>& logical_expand_shape() const {
    return internal_->logical_expand_shape;
  }
  std::vector<int32_t>* mutable_logical_expand_shape() { return &internal_->logical_expand_shape; }
  void set_logical_expand_shape(const std::vector<int32_t>& logical_expand_shape) {
    internal_->logical_expand_shape = logical_expand_shape;
  }

 private:
  struct Internal {
    std::vector<int32_t> logical_out_shape;
    std::vector<int32_t> logical_expand_shape;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.expand_grad", ExpandGradOpInterpCtxImpl<schema::ExpandGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class Expm1OpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class Expm1OpInterpCtxImpl : public Expm1OpInterpCtx {
 public:
  Expm1OpInterpCtxImpl() = default;
  Expm1OpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Expm1Op {
 public:
  Expm1Op() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Expm1 op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.expm1", Expm1OpInterpCtxImpl<schema::Expm1Op>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class Expm1GradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class Expm1GradOpInterpCtxImpl : public Expm1GradOpInterpCtx {
 public:
  Expm1GradOpInterpCtxImpl() = default;
  Expm1GradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Expm1GradOp {
 public:
  Expm1GradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Expm1Grad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.expm1_grad", Expm1GradOpInterpCtxImpl<schema::Expm1GradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class EyeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& rows() const = 0;
  virtual int64_t* mutable_rows() = 0;
  virtual void set_rows(const int64_t& rows) = 0;

  virtual const int64_t& cols() const = 0;
  virtual int64_t* mutable_cols() = 0;
  virtual void set_cols(const int64_t& cols) = 0;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"rows", "cols", "dtype", "nd_sbp"};
    return attr_names;
  }
};
template<typename Provider>
class EyeOpInterpCtxImpl : public EyeOpInterpCtx {
 public:
  EyeOpInterpCtxImpl() = default;
  EyeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& rows() const override { return impl_.rows(); }
  int64_t* mutable_rows() override { return impl_.mutable_rows(); }
  void set_rows(const int64_t& rows) override { impl_.set_rows(rows); }

  const int64_t& cols() const override { return impl_.cols(); }
  int64_t* mutable_cols() override { return impl_.mutable_cols(); }
  void set_cols(const int64_t& cols) override { impl_.set_cols(cols); }

  const DataType& dtype() const override { return impl_.dtype(); }
  DataType* mutable_dtype() override { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) override { impl_.set_dtype(dtype); }

  const std::vector<std::string>& nd_sbp() const override { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() override { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) override { impl_.set_nd_sbp(nd_sbp); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class EyeOp {
 public:
  EyeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "rows") {
      return CastAttr(&internal_->rows);
    } else if (attr_name == "cols") {
      return CastAttr(&internal_->cols);
    } else if (attr_name == "dtype") {
      return CastAttr(&internal_->dtype);
    } else if (attr_name == "nd_sbp") {
      return CastAttr(&internal_->nd_sbp);
    } else {
      return Error::RuntimeError() << "Eye op has no attribute named " << attr_name;
    }
  }

  const int64_t& rows() const { return internal_->rows; }
  int64_t* mutable_rows() { return &internal_->rows; }
  void set_rows(const int64_t& rows) { internal_->rows = rows; }

  const int64_t& cols() const { return internal_->cols; }
  int64_t* mutable_cols() { return &internal_->cols; }
  void set_cols(const int64_t& cols) { internal_->cols = cols; }

  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }

  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }

 private:
  struct Internal {
    int64_t rows;
    int64_t cols;
    DataType dtype;
    std::vector<std::string> nd_sbp;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.eye", EyeOpInterpCtxImpl<schema::EyeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FakeQuantizationOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& quantization_formula() const = 0;
  virtual std::string* mutable_quantization_formula() = 0;
  virtual void set_quantization_formula(const std::string& quantization_formula) = 0;

  virtual const int32_t& quantization_bit() const = 0;
  virtual int32_t* mutable_quantization_bit() = 0;
  virtual void set_quantization_bit(const int32_t& quantization_bit) = 0;

  virtual const std::string& quantization_scheme() const = 0;
  virtual std::string* mutable_quantization_scheme() = 0;
  virtual void set_quantization_scheme(const std::string& quantization_scheme) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"quantization_formula", "quantization_bit",
                                           "quantization_scheme"};
    return attr_names;
  }
};
template<typename Provider>
class FakeQuantizationOpInterpCtxImpl : public FakeQuantizationOpInterpCtx {
 public:
  FakeQuantizationOpInterpCtxImpl() = default;
  FakeQuantizationOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& quantization_formula() const override { return impl_.quantization_formula(); }
  std::string* mutable_quantization_formula() override {
    return impl_.mutable_quantization_formula();
  }
  void set_quantization_formula(const std::string& quantization_formula) override {
    impl_.set_quantization_formula(quantization_formula);
  }

  const int32_t& quantization_bit() const override { return impl_.quantization_bit(); }
  int32_t* mutable_quantization_bit() override { return impl_.mutable_quantization_bit(); }
  void set_quantization_bit(const int32_t& quantization_bit) override {
    impl_.set_quantization_bit(quantization_bit);
  }

  const std::string& quantization_scheme() const override { return impl_.quantization_scheme(); }
  std::string* mutable_quantization_scheme() override {
    return impl_.mutable_quantization_scheme();
  }
  void set_quantization_scheme(const std::string& quantization_scheme) override {
    impl_.set_quantization_scheme(quantization_scheme);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FakeQuantizationOp {
 public:
  FakeQuantizationOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "quantization_formula") {
      return CastAttr(&internal_->quantization_formula);
    } else if (attr_name == "quantization_bit") {
      return CastAttr(&internal_->quantization_bit);
    } else if (attr_name == "quantization_scheme") {
      return CastAttr(&internal_->quantization_scheme);
    } else {
      return Error::RuntimeError() << "FakeQuantization op has no attribute named " << attr_name;
    }
  }

  const std::string& quantization_formula() const { return internal_->quantization_formula; }
  std::string* mutable_quantization_formula() { return &internal_->quantization_formula; }
  void set_quantization_formula(const std::string& quantization_formula) {
    internal_->quantization_formula = quantization_formula;
  }

  const int32_t& quantization_bit() const { return internal_->quantization_bit; }
  int32_t* mutable_quantization_bit() { return &internal_->quantization_bit; }
  void set_quantization_bit(const int32_t& quantization_bit) {
    internal_->quantization_bit = quantization_bit;
  }

  const std::string& quantization_scheme() const { return internal_->quantization_scheme; }
  std::string* mutable_quantization_scheme() { return &internal_->quantization_scheme; }
  void set_quantization_scheme(const std::string& quantization_scheme) {
    internal_->quantization_scheme = quantization_scheme;
  }

 private:
  struct Internal {
    std::string quantization_formula;
    int32_t quantization_bit;
    std::string quantization_scheme;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.fake_quantization",
                       FakeQuantizationOpInterpCtxImpl<schema::FakeQuantizationOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FlattenOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& start_dim() const = 0;
  virtual int32_t* mutable_start_dim() = 0;
  virtual void set_start_dim(const int32_t& start_dim) = 0;

  virtual const int32_t& end_dim() const = 0;
  virtual int32_t* mutable_end_dim() = 0;
  virtual void set_end_dim(const int32_t& end_dim) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"start_dim", "end_dim"};
    return attr_names;
  }
};
template<typename Provider>
class FlattenOpInterpCtxImpl : public FlattenOpInterpCtx {
 public:
  FlattenOpInterpCtxImpl() = default;
  FlattenOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& start_dim() const override { return impl_.start_dim(); }
  int32_t* mutable_start_dim() override { return impl_.mutable_start_dim(); }
  void set_start_dim(const int32_t& start_dim) override { impl_.set_start_dim(start_dim); }

  const int32_t& end_dim() const override { return impl_.end_dim(); }
  int32_t* mutable_end_dim() override { return impl_.mutable_end_dim(); }
  void set_end_dim(const int32_t& end_dim) override { impl_.set_end_dim(end_dim); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FlattenOp {
 public:
  FlattenOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "start_dim") {
      return CastAttr(&internal_->start_dim);
    } else if (attr_name == "end_dim") {
      return CastAttr(&internal_->end_dim);
    } else {
      return Error::RuntimeError() << "Flatten op has no attribute named " << attr_name;
    }
  }

  const int32_t& start_dim() const { return internal_->start_dim; }
  int32_t* mutable_start_dim() { return &internal_->start_dim; }
  void set_start_dim(const int32_t& start_dim) { internal_->start_dim = start_dim; }

  const int32_t& end_dim() const { return internal_->end_dim; }
  int32_t* mutable_end_dim() { return &internal_->end_dim; }
  void set_end_dim(const int32_t& end_dim) { internal_->end_dim = end_dim; }

 private:
  struct Internal {
    int32_t start_dim;
    int32_t end_dim;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.flatten", FlattenOpInterpCtxImpl<schema::FlattenOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FlipOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& dims() const = 0;
  virtual std::vector<int32_t>* mutable_dims() = 0;
  virtual void set_dims(const std::vector<int32_t>& dims) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"dims"};
    return attr_names;
  }
};
template<typename Provider>
class FlipOpInterpCtxImpl : public FlipOpInterpCtx {
 public:
  FlipOpInterpCtxImpl() = default;
  FlipOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& dims() const override { return impl_.dims(); }
  std::vector<int32_t>* mutable_dims() override { return impl_.mutable_dims(); }
  void set_dims(const std::vector<int32_t>& dims) override { impl_.set_dims(dims); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FlipOp {
 public:
  FlipOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "dims") {
      return CastAttr(&internal_->dims);
    } else {
      return Error::RuntimeError() << "Flip op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& dims() const { return internal_->dims; }
  std::vector<int32_t>* mutable_dims() { return &internal_->dims; }
  void set_dims(const std::vector<int32_t>& dims) { internal_->dims = dims; }

 private:
  struct Internal {
    std::vector<int32_t> dims;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.flip", FlipOpInterpCtxImpl<schema::FlipOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FlipGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& dims() const = 0;
  virtual std::vector<int32_t>* mutable_dims() = 0;
  virtual void set_dims(const std::vector<int32_t>& dims) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"dims"};
    return attr_names;
  }
};
template<typename Provider>
class FlipGradOpInterpCtxImpl : public FlipGradOpInterpCtx {
 public:
  FlipGradOpInterpCtxImpl() = default;
  FlipGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& dims() const override { return impl_.dims(); }
  std::vector<int32_t>* mutable_dims() override { return impl_.mutable_dims(); }
  void set_dims(const std::vector<int32_t>& dims) override { impl_.set_dims(dims); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FlipGradOp {
 public:
  FlipGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "dims") {
      return CastAttr(&internal_->dims);
    } else {
      return Error::RuntimeError() << "FlipGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& dims() const { return internal_->dims; }
  std::vector<int32_t>* mutable_dims() { return &internal_->dims; }
  void set_dims(const std::vector<int32_t>& dims) { internal_->dims = dims; }

 private:
  struct Internal {
    std::vector<int32_t> dims;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.flip_grad", FlipGradOpInterpCtxImpl<schema::FlipGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FloorOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class FloorOpInterpCtxImpl : public FloorOpInterpCtx {
 public:
  FloorOpInterpCtxImpl() = default;
  FloorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FloorOp {
 public:
  FloorOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Floor op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.floor", FloorOpInterpCtxImpl<schema::FloorOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FloorGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class FloorGradOpInterpCtxImpl : public FloorGradOpInterpCtx {
 public:
  FloorGradOpInterpCtxImpl() = default;
  FloorGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FloorGradOp {
 public:
  FloorGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "FloorGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.floor_grad", FloorGradOpInterpCtxImpl<schema::FloorGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FloordivOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class FloordivOpInterpCtxImpl : public FloordivOpInterpCtx {
 public:
  FloordivOpInterpCtxImpl() = default;
  FloordivOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FloordivOp {
 public:
  FloordivOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Floordiv op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.floordiv", FloordivOpInterpCtxImpl<schema::FloordivOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FloordivXGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class FloordivXGradOpInterpCtxImpl : public FloordivXGradOpInterpCtx {
 public:
  FloordivXGradOpInterpCtxImpl() = default;
  FloordivXGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FloordivXGradOp {
 public:
  FloordivXGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "FloordivXGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.floordiv_x_grad",
                       FloordivXGradOpInterpCtxImpl<schema::FloordivXGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FloordivYGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class FloordivYGradOpInterpCtxImpl : public FloordivYGradOpInterpCtx {
 public:
  FloordivYGradOpInterpCtxImpl() = default;
  FloordivYGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FloordivYGradOp {
 public:
  FloordivYGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "FloordivYGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.floordiv_y_grad",
                       FloordivYGradOpInterpCtxImpl<schema::FloordivYGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FlushSummaryWriterOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class FlushSummaryWriterOpInterpCtxImpl : public FlushSummaryWriterOpInterpCtx {
 public:
  FlushSummaryWriterOpInterpCtxImpl() = default;
  FlushSummaryWriterOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FlushSummaryWriterOp {
 public:
  FlushSummaryWriterOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "FlushSummaryWriter op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.flush_summary_writer",
                       FlushSummaryWriterOpInterpCtxImpl<schema::FlushSummaryWriterOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FoldOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& output_size() const = 0;
  virtual std::vector<int32_t>* mutable_output_size() = 0;
  virtual void set_output_size(const std::vector<int32_t>& output_size) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const std::vector<int32_t>& padding() const = 0;
  virtual std::vector<int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int32_t>& padding) = 0;

  virtual const std::vector<int32_t>& dilation_rate() const = 0;
  virtual std::vector<int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<int32_t>& dilation_rate) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"output_size", "kernel_size", "strides", "padding",
                                           "dilation_rate"};
    return attr_names;
  }
};
template<typename Provider>
class FoldOpInterpCtxImpl : public FoldOpInterpCtx {
 public:
  FoldOpInterpCtxImpl() = default;
  FoldOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& output_size() const override { return impl_.output_size(); }
  std::vector<int32_t>* mutable_output_size() override { return impl_.mutable_output_size(); }
  void set_output_size(const std::vector<int32_t>& output_size) override {
    impl_.set_output_size(output_size);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const std::vector<int32_t>& padding() const override { return impl_.padding(); }
  std::vector<int32_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int32_t>& padding) override { impl_.set_padding(padding); }

  const std::vector<int32_t>& dilation_rate() const override { return impl_.dilation_rate(); }
  std::vector<int32_t>* mutable_dilation_rate() override { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) override {
    impl_.set_dilation_rate(dilation_rate);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FoldOp {
 public:
  FoldOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "output_size") {
      return CastAttr(&internal_->output_size);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "dilation_rate") {
      return CastAttr(&internal_->dilation_rate);
    } else {
      return Error::RuntimeError() << "Fold op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& output_size() const { return internal_->output_size; }
  std::vector<int32_t>* mutable_output_size() { return &internal_->output_size; }
  void set_output_size(const std::vector<int32_t>& output_size) {
    internal_->output_size = output_size;
  }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const std::vector<int32_t>& padding() const { return internal_->padding; }
  std::vector<int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int32_t>& padding) { internal_->padding = padding; }

  const std::vector<int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) {
    internal_->dilation_rate = dilation_rate;
  }

 private:
  struct Internal {
    std::vector<int32_t> output_size;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> strides;
    std::vector<int32_t> padding;
    std::vector<int32_t> dilation_rate;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.fold", FoldOpInterpCtxImpl<schema::FoldOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FusedBiasAddGeluOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis"};
    return attr_names;
  }
};
template<typename Provider>
class FusedBiasAddGeluOpInterpCtxImpl : public FusedBiasAddGeluOpInterpCtx {
 public:
  FusedBiasAddGeluOpInterpCtxImpl() = default;
  FusedBiasAddGeluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& axis() const override { return impl_.axis(); }
  int32_t* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) override { impl_.set_axis(axis); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedBiasAddGeluOp {
 public:
  FusedBiasAddGeluOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else {
      return Error::RuntimeError() << "FusedBiasAddGelu op has no attribute named " << attr_name;
    }
  }

  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }

 private:
  struct Internal {
    int32_t axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.fused_bias_add_gelu",
                       FusedBiasAddGeluOpInterpCtxImpl<schema::FusedBiasAddGeluOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FusedBiasAddGeluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis"};
    return attr_names;
  }
};
template<typename Provider>
class FusedBiasAddGeluGradOpInterpCtxImpl : public FusedBiasAddGeluGradOpInterpCtx {
 public:
  FusedBiasAddGeluGradOpInterpCtxImpl() = default;
  FusedBiasAddGeluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& axis() const override { return impl_.axis(); }
  int32_t* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) override { impl_.set_axis(axis); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedBiasAddGeluGradOp {
 public:
  FusedBiasAddGeluGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else {
      return Error::RuntimeError()
             << "FusedBiasAddGeluGrad op has no attribute named " << attr_name;
    }
  }

  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }

 private:
  struct Internal {
    int32_t axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.fused_bias_add_gelu_grad",
                       FusedBiasAddGeluGradOpInterpCtxImpl<schema::FusedBiasAddGeluGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FusedBiasAddMaskScaleOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  virtual const float& scale() const = 0;
  virtual float* mutable_scale() = 0;
  virtual void set_scale(const float& scale) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "scale"};
    return attr_names;
  }
};
template<typename Provider>
class FusedBiasAddMaskScaleOpInterpCtxImpl : public FusedBiasAddMaskScaleOpInterpCtx {
 public:
  FusedBiasAddMaskScaleOpInterpCtxImpl() = default;
  FusedBiasAddMaskScaleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& axis() const override { return impl_.axis(); }
  int32_t* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) override { impl_.set_axis(axis); }

  const float& scale() const override { return impl_.scale(); }
  float* mutable_scale() override { return impl_.mutable_scale(); }
  void set_scale(const float& scale) override { impl_.set_scale(scale); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedBiasAddMaskScaleOp {
 public:
  FusedBiasAddMaskScaleOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "scale") {
      return CastAttr(&internal_->scale);
    } else {
      return Error::RuntimeError()
             << "FusedBiasAddMaskScale op has no attribute named " << attr_name;
    }
  }

  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }

  const float& scale() const { return internal_->scale; }
  float* mutable_scale() { return &internal_->scale; }
  void set_scale(const float& scale) { internal_->scale = scale; }

 private:
  struct Internal {
    int32_t axis;
    float scale;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.fused_bias_add_mask_scale",
                       FusedBiasAddMaskScaleOpInterpCtxImpl<schema::FusedBiasAddMaskScaleOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FusedCastScaleOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& scale() const = 0;
  virtual double* mutable_scale() = 0;
  virtual void set_scale(const double& scale) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"scale"};
    return attr_names;
  }
};
template<typename Provider>
class FusedCastScaleOpInterpCtxImpl : public FusedCastScaleOpInterpCtx {
 public:
  FusedCastScaleOpInterpCtxImpl() = default;
  FusedCastScaleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& scale() const override { return impl_.scale(); }
  double* mutable_scale() override { return impl_.mutable_scale(); }
  void set_scale(const double& scale) override { impl_.set_scale(scale); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedCastScaleOp {
 public:
  FusedCastScaleOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "scale") {
      return CastAttr(&internal_->scale);
    } else {
      return Error::RuntimeError() << "FusedCastScale op has no attribute named " << attr_name;
    }
  }

  const double& scale() const { return internal_->scale; }
  double* mutable_scale() { return &internal_->scale; }
  void set_scale(const double& scale) { internal_->scale = scale; }

 private:
  struct Internal {
    double scale;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.fused_cast_scale",
                       FusedCastScaleOpInterpCtxImpl<schema::FusedCastScaleOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FusedScaleMaskSoftmaxOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& scale_value() const = 0;
  virtual float* mutable_scale_value() = 0;
  virtual void set_scale_value(const float& scale_value) = 0;

  virtual const float& mask_fill_value() const = 0;
  virtual float* mutable_mask_fill_value() = 0;
  virtual void set_mask_fill_value(const float& mask_fill_value) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"scale_value", "mask_fill_value"};
    return attr_names;
  }
};
template<typename Provider>
class FusedScaleMaskSoftmaxOpInterpCtxImpl : public FusedScaleMaskSoftmaxOpInterpCtx {
 public:
  FusedScaleMaskSoftmaxOpInterpCtxImpl() = default;
  FusedScaleMaskSoftmaxOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& scale_value() const override { return impl_.scale_value(); }
  float* mutable_scale_value() override { return impl_.mutable_scale_value(); }
  void set_scale_value(const float& scale_value) override { impl_.set_scale_value(scale_value); }

  const float& mask_fill_value() const override { return impl_.mask_fill_value(); }
  float* mutable_mask_fill_value() override { return impl_.mutable_mask_fill_value(); }
  void set_mask_fill_value(const float& mask_fill_value) override {
    impl_.set_mask_fill_value(mask_fill_value);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedScaleMaskSoftmaxOp {
 public:
  FusedScaleMaskSoftmaxOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "scale_value") {
      return CastAttr(&internal_->scale_value);
    } else if (attr_name == "mask_fill_value") {
      return CastAttr(&internal_->mask_fill_value);
    } else {
      return Error::RuntimeError()
             << "FusedScaleMaskSoftmax op has no attribute named " << attr_name;
    }
  }

  const float& scale_value() const { return internal_->scale_value; }
  float* mutable_scale_value() { return &internal_->scale_value; }
  void set_scale_value(const float& scale_value) { internal_->scale_value = scale_value; }

  const float& mask_fill_value() const { return internal_->mask_fill_value; }
  float* mutable_mask_fill_value() { return &internal_->mask_fill_value; }
  void set_mask_fill_value(const float& mask_fill_value) {
    internal_->mask_fill_value = mask_fill_value;
  }

 private:
  struct Internal {
    float scale_value;
    float mask_fill_value;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.fused_scale_mask_softmax",
                       FusedScaleMaskSoftmaxOpInterpCtxImpl<schema::FusedScaleMaskSoftmaxOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FusedScaleMaskSoftmaxDropoutOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& scale_value() const = 0;
  virtual float* mutable_scale_value() = 0;
  virtual void set_scale_value(const float& scale_value) = 0;

  virtual const float& mask_fill_value() const = 0;
  virtual float* mutable_mask_fill_value() = 0;
  virtual void set_mask_fill_value(const float& mask_fill_value) = 0;

  virtual const float& dropout_scale_value() const = 0;
  virtual float* mutable_dropout_scale_value() = 0;
  virtual void set_dropout_scale_value(const float& dropout_scale_value) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"scale_value", "mask_fill_value", "dropout_scale_value"};
    return attr_names;
  }
};
template<typename Provider>
class FusedScaleMaskSoftmaxDropoutOpInterpCtxImpl : public FusedScaleMaskSoftmaxDropoutOpInterpCtx {
 public:
  FusedScaleMaskSoftmaxDropoutOpInterpCtxImpl() = default;
  FusedScaleMaskSoftmaxDropoutOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& scale_value() const override { return impl_.scale_value(); }
  float* mutable_scale_value() override { return impl_.mutable_scale_value(); }
  void set_scale_value(const float& scale_value) override { impl_.set_scale_value(scale_value); }

  const float& mask_fill_value() const override { return impl_.mask_fill_value(); }
  float* mutable_mask_fill_value() override { return impl_.mutable_mask_fill_value(); }
  void set_mask_fill_value(const float& mask_fill_value) override {
    impl_.set_mask_fill_value(mask_fill_value);
  }

  const float& dropout_scale_value() const override { return impl_.dropout_scale_value(); }
  float* mutable_dropout_scale_value() override { return impl_.mutable_dropout_scale_value(); }
  void set_dropout_scale_value(const float& dropout_scale_value) override {
    impl_.set_dropout_scale_value(dropout_scale_value);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedScaleMaskSoftmaxDropoutOp {
 public:
  FusedScaleMaskSoftmaxDropoutOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "scale_value") {
      return CastAttr(&internal_->scale_value);
    } else if (attr_name == "mask_fill_value") {
      return CastAttr(&internal_->mask_fill_value);
    } else if (attr_name == "dropout_scale_value") {
      return CastAttr(&internal_->dropout_scale_value);
    } else {
      return Error::RuntimeError()
             << "FusedScaleMaskSoftmaxDropout op has no attribute named " << attr_name;
    }
  }

  const float& scale_value() const { return internal_->scale_value; }
  float* mutable_scale_value() { return &internal_->scale_value; }
  void set_scale_value(const float& scale_value) { internal_->scale_value = scale_value; }

  const float& mask_fill_value() const { return internal_->mask_fill_value; }
  float* mutable_mask_fill_value() { return &internal_->mask_fill_value; }
  void set_mask_fill_value(const float& mask_fill_value) {
    internal_->mask_fill_value = mask_fill_value;
  }

  const float& dropout_scale_value() const { return internal_->dropout_scale_value; }
  float* mutable_dropout_scale_value() { return &internal_->dropout_scale_value; }
  void set_dropout_scale_value(const float& dropout_scale_value) {
    internal_->dropout_scale_value = dropout_scale_value;
  }

 private:
  struct Internal {
    float scale_value;
    float mask_fill_value;
    float dropout_scale_value;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.fused_scale_mask_softmax_dropout",
    FusedScaleMaskSoftmaxDropoutOpInterpCtxImpl<schema::FusedScaleMaskSoftmaxDropoutOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FusedScaleMaskSoftmaxDropoutGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& scale_value() const = 0;
  virtual float* mutable_scale_value() = 0;
  virtual void set_scale_value(const float& scale_value) = 0;

  virtual const float& dropout_scale_value() const = 0;
  virtual float* mutable_dropout_scale_value() = 0;
  virtual void set_dropout_scale_value(const float& dropout_scale_value) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"scale_value", "dropout_scale_value"};
    return attr_names;
  }
};
template<typename Provider>
class FusedScaleMaskSoftmaxDropoutGradOpInterpCtxImpl
    : public FusedScaleMaskSoftmaxDropoutGradOpInterpCtx {
 public:
  FusedScaleMaskSoftmaxDropoutGradOpInterpCtxImpl() = default;
  FusedScaleMaskSoftmaxDropoutGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& scale_value() const override { return impl_.scale_value(); }
  float* mutable_scale_value() override { return impl_.mutable_scale_value(); }
  void set_scale_value(const float& scale_value) override { impl_.set_scale_value(scale_value); }

  const float& dropout_scale_value() const override { return impl_.dropout_scale_value(); }
  float* mutable_dropout_scale_value() override { return impl_.mutable_dropout_scale_value(); }
  void set_dropout_scale_value(const float& dropout_scale_value) override {
    impl_.set_dropout_scale_value(dropout_scale_value);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedScaleMaskSoftmaxDropoutGradOp {
 public:
  FusedScaleMaskSoftmaxDropoutGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "scale_value") {
      return CastAttr(&internal_->scale_value);
    } else if (attr_name == "dropout_scale_value") {
      return CastAttr(&internal_->dropout_scale_value);
    } else {
      return Error::RuntimeError()
             << "FusedScaleMaskSoftmaxDropoutGrad op has no attribute named " << attr_name;
    }
  }

  const float& scale_value() const { return internal_->scale_value; }
  float* mutable_scale_value() { return &internal_->scale_value; }
  void set_scale_value(const float& scale_value) { internal_->scale_value = scale_value; }

  const float& dropout_scale_value() const { return internal_->dropout_scale_value; }
  float* mutable_dropout_scale_value() { return &internal_->dropout_scale_value; }
  void set_dropout_scale_value(const float& dropout_scale_value) {
    internal_->dropout_scale_value = dropout_scale_value;
  }

 private:
  struct Internal {
    float scale_value;
    float dropout_scale_value;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.fused_scale_mask_softmax_dropout_grad",
    FusedScaleMaskSoftmaxDropoutGradOpInterpCtxImpl<schema::FusedScaleMaskSoftmaxDropoutGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FusedScaleMaskSoftmaxGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& scale_value() const = 0;
  virtual float* mutable_scale_value() = 0;
  virtual void set_scale_value(const float& scale_value) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"scale_value"};
    return attr_names;
  }
};
template<typename Provider>
class FusedScaleMaskSoftmaxGradOpInterpCtxImpl : public FusedScaleMaskSoftmaxGradOpInterpCtx {
 public:
  FusedScaleMaskSoftmaxGradOpInterpCtxImpl() = default;
  FusedScaleMaskSoftmaxGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& scale_value() const override { return impl_.scale_value(); }
  float* mutable_scale_value() override { return impl_.mutable_scale_value(); }
  void set_scale_value(const float& scale_value) override { impl_.set_scale_value(scale_value); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedScaleMaskSoftmaxGradOp {
 public:
  FusedScaleMaskSoftmaxGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "scale_value") {
      return CastAttr(&internal_->scale_value);
    } else {
      return Error::RuntimeError()
             << "FusedScaleMaskSoftmaxGrad op has no attribute named " << attr_name;
    }
  }

  const float& scale_value() const { return internal_->scale_value; }
  float* mutable_scale_value() { return &internal_->scale_value; }
  void set_scale_value(const float& scale_value) { internal_->scale_value = scale_value; }

 private:
  struct Internal {
    float scale_value;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.fused_scale_mask_softmax_grad",
    FusedScaleMaskSoftmaxGradOpInterpCtxImpl<schema::FusedScaleMaskSoftmaxGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FusedScaleTrilOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& diagonal() const = 0;
  virtual int64_t* mutable_diagonal() = 0;
  virtual void set_diagonal(const int64_t& diagonal) = 0;

  virtual const double& floating_fill_value() const = 0;
  virtual double* mutable_floating_fill_value() = 0;
  virtual void set_floating_fill_value(const double& floating_fill_value) = 0;

  virtual const int64_t& integer_fill_value() const = 0;
  virtual int64_t* mutable_integer_fill_value() = 0;
  virtual void set_integer_fill_value(const int64_t& integer_fill_value) = 0;

  virtual const bool& is_floating_fill_value() const = 0;
  virtual bool* mutable_is_floating_fill_value() = 0;
  virtual void set_is_floating_fill_value(const bool& is_floating_fill_value) = 0;

  virtual const double& floating_scale_value() const = 0;
  virtual double* mutable_floating_scale_value() = 0;
  virtual void set_floating_scale_value(const double& floating_scale_value) = 0;

  virtual const int64_t& integer_scale_value() const = 0;
  virtual int64_t* mutable_integer_scale_value() = 0;
  virtual void set_integer_scale_value(const int64_t& integer_scale_value) = 0;

  virtual const bool& is_floating_scale_value() const = 0;
  virtual bool* mutable_is_floating_scale_value() = 0;
  virtual void set_is_floating_scale_value(const bool& is_floating_scale_value) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"diagonal",
                                           "floating_fill_value",
                                           "integer_fill_value",
                                           "is_floating_fill_value",
                                           "floating_scale_value",
                                           "integer_scale_value",
                                           "is_floating_scale_value"};
    return attr_names;
  }
};
template<typename Provider>
class FusedScaleTrilOpInterpCtxImpl : public FusedScaleTrilOpInterpCtx {
 public:
  FusedScaleTrilOpInterpCtxImpl() = default;
  FusedScaleTrilOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& diagonal() const override { return impl_.diagonal(); }
  int64_t* mutable_diagonal() override { return impl_.mutable_diagonal(); }
  void set_diagonal(const int64_t& diagonal) override { impl_.set_diagonal(diagonal); }

  const double& floating_fill_value() const override { return impl_.floating_fill_value(); }
  double* mutable_floating_fill_value() override { return impl_.mutable_floating_fill_value(); }
  void set_floating_fill_value(const double& floating_fill_value) override {
    impl_.set_floating_fill_value(floating_fill_value);
  }

  const int64_t& integer_fill_value() const override { return impl_.integer_fill_value(); }
  int64_t* mutable_integer_fill_value() override { return impl_.mutable_integer_fill_value(); }
  void set_integer_fill_value(const int64_t& integer_fill_value) override {
    impl_.set_integer_fill_value(integer_fill_value);
  }

  const bool& is_floating_fill_value() const override { return impl_.is_floating_fill_value(); }
  bool* mutable_is_floating_fill_value() override { return impl_.mutable_is_floating_fill_value(); }
  void set_is_floating_fill_value(const bool& is_floating_fill_value) override {
    impl_.set_is_floating_fill_value(is_floating_fill_value);
  }

  const double& floating_scale_value() const override { return impl_.floating_scale_value(); }
  double* mutable_floating_scale_value() override { return impl_.mutable_floating_scale_value(); }
  void set_floating_scale_value(const double& floating_scale_value) override {
    impl_.set_floating_scale_value(floating_scale_value);
  }

  const int64_t& integer_scale_value() const override { return impl_.integer_scale_value(); }
  int64_t* mutable_integer_scale_value() override { return impl_.mutable_integer_scale_value(); }
  void set_integer_scale_value(const int64_t& integer_scale_value) override {
    impl_.set_integer_scale_value(integer_scale_value);
  }

  const bool& is_floating_scale_value() const override { return impl_.is_floating_scale_value(); }
  bool* mutable_is_floating_scale_value() override {
    return impl_.mutable_is_floating_scale_value();
  }
  void set_is_floating_scale_value(const bool& is_floating_scale_value) override {
    impl_.set_is_floating_scale_value(is_floating_scale_value);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedScaleTrilOp {
 public:
  FusedScaleTrilOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "diagonal") {
      return CastAttr(&internal_->diagonal);
    } else if (attr_name == "floating_fill_value") {
      return CastAttr(&internal_->floating_fill_value);
    } else if (attr_name == "integer_fill_value") {
      return CastAttr(&internal_->integer_fill_value);
    } else if (attr_name == "is_floating_fill_value") {
      return CastAttr(&internal_->is_floating_fill_value);
    } else if (attr_name == "floating_scale_value") {
      return CastAttr(&internal_->floating_scale_value);
    } else if (attr_name == "integer_scale_value") {
      return CastAttr(&internal_->integer_scale_value);
    } else if (attr_name == "is_floating_scale_value") {
      return CastAttr(&internal_->is_floating_scale_value);
    } else {
      return Error::RuntimeError() << "FusedScaleTril op has no attribute named " << attr_name;
    }
  }

  const int64_t& diagonal() const { return internal_->diagonal; }
  int64_t* mutable_diagonal() { return &internal_->diagonal; }
  void set_diagonal(const int64_t& diagonal) { internal_->diagonal = diagonal; }

  const double& floating_fill_value() const { return internal_->floating_fill_value; }
  double* mutable_floating_fill_value() { return &internal_->floating_fill_value; }
  void set_floating_fill_value(const double& floating_fill_value) {
    internal_->floating_fill_value = floating_fill_value;
  }

  const int64_t& integer_fill_value() const { return internal_->integer_fill_value; }
  int64_t* mutable_integer_fill_value() { return &internal_->integer_fill_value; }
  void set_integer_fill_value(const int64_t& integer_fill_value) {
    internal_->integer_fill_value = integer_fill_value;
  }

  const bool& is_floating_fill_value() const { return internal_->is_floating_fill_value; }
  bool* mutable_is_floating_fill_value() { return &internal_->is_floating_fill_value; }
  void set_is_floating_fill_value(const bool& is_floating_fill_value) {
    internal_->is_floating_fill_value = is_floating_fill_value;
  }

  const double& floating_scale_value() const { return internal_->floating_scale_value; }
  double* mutable_floating_scale_value() { return &internal_->floating_scale_value; }
  void set_floating_scale_value(const double& floating_scale_value) {
    internal_->floating_scale_value = floating_scale_value;
  }

  const int64_t& integer_scale_value() const { return internal_->integer_scale_value; }
  int64_t* mutable_integer_scale_value() { return &internal_->integer_scale_value; }
  void set_integer_scale_value(const int64_t& integer_scale_value) {
    internal_->integer_scale_value = integer_scale_value;
  }

  const bool& is_floating_scale_value() const { return internal_->is_floating_scale_value; }
  bool* mutable_is_floating_scale_value() { return &internal_->is_floating_scale_value; }
  void set_is_floating_scale_value(const bool& is_floating_scale_value) {
    internal_->is_floating_scale_value = is_floating_scale_value;
  }

 private:
  struct Internal {
    int64_t diagonal;
    double floating_fill_value;
    int64_t integer_fill_value;
    bool is_floating_fill_value;
    double floating_scale_value;
    int64_t integer_scale_value;
    bool is_floating_scale_value;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.fused_scale_tril",
                       FusedScaleTrilOpInterpCtxImpl<schema::FusedScaleTrilOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FusedSelfAttentionQueryMulKeyAndValueOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& head_size() const = 0;
  virtual int64_t* mutable_head_size() = 0;
  virtual void set_head_size(const int64_t& head_size) = 0;

  virtual const float& alpha() const = 0;
  virtual float* mutable_alpha() = 0;
  virtual void set_alpha(const float& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"head_size", "alpha"};
    return attr_names;
  }
};
template<typename Provider>
class FusedSelfAttentionQueryMulKeyAndValueOpInterpCtxImpl
    : public FusedSelfAttentionQueryMulKeyAndValueOpInterpCtx {
 public:
  FusedSelfAttentionQueryMulKeyAndValueOpInterpCtxImpl() = default;
  FusedSelfAttentionQueryMulKeyAndValueOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& head_size() const override { return impl_.head_size(); }
  int64_t* mutable_head_size() override { return impl_.mutable_head_size(); }
  void set_head_size(const int64_t& head_size) override { impl_.set_head_size(head_size); }

  const float& alpha() const override { return impl_.alpha(); }
  float* mutable_alpha() override { return impl_.mutable_alpha(); }
  void set_alpha(const float& alpha) override { impl_.set_alpha(alpha); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedSelfAttentionQueryMulKeyAndValueOp {
 public:
  FusedSelfAttentionQueryMulKeyAndValueOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "head_size") {
      return CastAttr(&internal_->head_size);
    } else if (attr_name == "alpha") {
      return CastAttr(&internal_->alpha);
    } else {
      return Error::RuntimeError()
             << "FusedSelfAttentionQueryMulKeyAndValue op has no attribute named " << attr_name;
    }
  }

  const int64_t& head_size() const { return internal_->head_size; }
  int64_t* mutable_head_size() { return &internal_->head_size; }
  void set_head_size(const int64_t& head_size) { internal_->head_size = head_size; }

  const float& alpha() const { return internal_->alpha; }
  float* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const float& alpha) { internal_->alpha = alpha; }

 private:
  struct Internal {
    int64_t head_size;
    float alpha;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.fused_self_attention_query_mul_key_and_value",
                       FusedSelfAttentionQueryMulKeyAndValueOpInterpCtxImpl<
                           schema::FusedSelfAttentionQueryMulKeyAndValueOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FusedSelfAttentionQueryMulKeyAndValueGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& alpha() const = 0;
  virtual float* mutable_alpha() = 0;
  virtual void set_alpha(const float& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"alpha"};
    return attr_names;
  }
};
template<typename Provider>
class FusedSelfAttentionQueryMulKeyAndValueGradOpInterpCtxImpl
    : public FusedSelfAttentionQueryMulKeyAndValueGradOpInterpCtx {
 public:
  FusedSelfAttentionQueryMulKeyAndValueGradOpInterpCtxImpl() = default;
  FusedSelfAttentionQueryMulKeyAndValueGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& alpha() const override { return impl_.alpha(); }
  float* mutable_alpha() override { return impl_.mutable_alpha(); }
  void set_alpha(const float& alpha) override { impl_.set_alpha(alpha); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedSelfAttentionQueryMulKeyAndValueGradOp {
 public:
  FusedSelfAttentionQueryMulKeyAndValueGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "alpha") {
      return CastAttr(&internal_->alpha);
    } else {
      return Error::RuntimeError()
             << "FusedSelfAttentionQueryMulKeyAndValueGrad op has no attribute named " << attr_name;
    }
  }

  const float& alpha() const { return internal_->alpha; }
  float* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const float& alpha) { internal_->alpha = alpha; }

 private:
  struct Internal {
    float alpha;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.fused_self_attention_query_mul_key_and_value_grad",
                       FusedSelfAttentionQueryMulKeyAndValueGradOpInterpCtxImpl<
                           schema::FusedSelfAttentionQueryMulKeyAndValueGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FusedTrilScaleSoftmaxMaskScaleOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& diagonal() const = 0;
  virtual int64_t* mutable_diagonal() = 0;
  virtual void set_diagonal(const int64_t& diagonal) = 0;

  virtual const float& tril_fill_value() const = 0;
  virtual float* mutable_tril_fill_value() = 0;
  virtual void set_tril_fill_value(const float& tril_fill_value) = 0;

  virtual const float& tril_scale_value() const = 0;
  virtual float* mutable_tril_scale_value() = 0;
  virtual void set_tril_scale_value(const float& tril_scale_value) = 0;

  virtual const float& mask_scale_value() const = 0;
  virtual float* mutable_mask_scale_value() = 0;
  virtual void set_mask_scale_value(const float& mask_scale_value) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"diagonal", "tril_fill_value", "tril_scale_value",
                                           "mask_scale_value"};
    return attr_names;
  }
};
template<typename Provider>
class FusedTrilScaleSoftmaxMaskScaleOpInterpCtxImpl
    : public FusedTrilScaleSoftmaxMaskScaleOpInterpCtx {
 public:
  FusedTrilScaleSoftmaxMaskScaleOpInterpCtxImpl() = default;
  FusedTrilScaleSoftmaxMaskScaleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& diagonal() const override { return impl_.diagonal(); }
  int64_t* mutable_diagonal() override { return impl_.mutable_diagonal(); }
  void set_diagonal(const int64_t& diagonal) override { impl_.set_diagonal(diagonal); }

  const float& tril_fill_value() const override { return impl_.tril_fill_value(); }
  float* mutable_tril_fill_value() override { return impl_.mutable_tril_fill_value(); }
  void set_tril_fill_value(const float& tril_fill_value) override {
    impl_.set_tril_fill_value(tril_fill_value);
  }

  const float& tril_scale_value() const override { return impl_.tril_scale_value(); }
  float* mutable_tril_scale_value() override { return impl_.mutable_tril_scale_value(); }
  void set_tril_scale_value(const float& tril_scale_value) override {
    impl_.set_tril_scale_value(tril_scale_value);
  }

  const float& mask_scale_value() const override { return impl_.mask_scale_value(); }
  float* mutable_mask_scale_value() override { return impl_.mutable_mask_scale_value(); }
  void set_mask_scale_value(const float& mask_scale_value) override {
    impl_.set_mask_scale_value(mask_scale_value);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedTrilScaleSoftmaxMaskScaleOp {
 public:
  FusedTrilScaleSoftmaxMaskScaleOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "diagonal") {
      return CastAttr(&internal_->diagonal);
    } else if (attr_name == "tril_fill_value") {
      return CastAttr(&internal_->tril_fill_value);
    } else if (attr_name == "tril_scale_value") {
      return CastAttr(&internal_->tril_scale_value);
    } else if (attr_name == "mask_scale_value") {
      return CastAttr(&internal_->mask_scale_value);
    } else {
      return Error::RuntimeError()
             << "FusedTrilScaleSoftmaxMaskScale op has no attribute named " << attr_name;
    }
  }

  const int64_t& diagonal() const { return internal_->diagonal; }
  int64_t* mutable_diagonal() { return &internal_->diagonal; }
  void set_diagonal(const int64_t& diagonal) { internal_->diagonal = diagonal; }

  const float& tril_fill_value() const { return internal_->tril_fill_value; }
  float* mutable_tril_fill_value() { return &internal_->tril_fill_value; }
  void set_tril_fill_value(const float& tril_fill_value) {
    internal_->tril_fill_value = tril_fill_value;
  }

  const float& tril_scale_value() const { return internal_->tril_scale_value; }
  float* mutable_tril_scale_value() { return &internal_->tril_scale_value; }
  void set_tril_scale_value(const float& tril_scale_value) {
    internal_->tril_scale_value = tril_scale_value;
  }

  const float& mask_scale_value() const { return internal_->mask_scale_value; }
  float* mutable_mask_scale_value() { return &internal_->mask_scale_value; }
  void set_mask_scale_value(const float& mask_scale_value) {
    internal_->mask_scale_value = mask_scale_value;
  }

 private:
  struct Internal {
    int64_t diagonal;
    float tril_fill_value;
    float tril_scale_value;
    float mask_scale_value;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.fused_tril_scale_softmax_mask_scale",
    FusedTrilScaleSoftmaxMaskScaleOpInterpCtxImpl<schema::FusedTrilScaleSoftmaxMaskScaleOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class FusedTrilScaleSoftmaxMaskScaleGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& diagonal() const = 0;
  virtual int64_t* mutable_diagonal() = 0;
  virtual void set_diagonal(const int64_t& diagonal) = 0;

  virtual const float& tril_scale_value() const = 0;
  virtual float* mutable_tril_scale_value() = 0;
  virtual void set_tril_scale_value(const float& tril_scale_value) = 0;

  virtual const float& mask_scale_value() const = 0;
  virtual float* mutable_mask_scale_value() = 0;
  virtual void set_mask_scale_value(const float& mask_scale_value) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"diagonal", "tril_scale_value", "mask_scale_value"};
    return attr_names;
  }
};
template<typename Provider>
class FusedTrilScaleSoftmaxMaskScaleGradOpInterpCtxImpl
    : public FusedTrilScaleSoftmaxMaskScaleGradOpInterpCtx {
 public:
  FusedTrilScaleSoftmaxMaskScaleGradOpInterpCtxImpl() = default;
  FusedTrilScaleSoftmaxMaskScaleGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& diagonal() const override { return impl_.diagonal(); }
  int64_t* mutable_diagonal() override { return impl_.mutable_diagonal(); }
  void set_diagonal(const int64_t& diagonal) override { impl_.set_diagonal(diagonal); }

  const float& tril_scale_value() const override { return impl_.tril_scale_value(); }
  float* mutable_tril_scale_value() override { return impl_.mutable_tril_scale_value(); }
  void set_tril_scale_value(const float& tril_scale_value) override {
    impl_.set_tril_scale_value(tril_scale_value);
  }

  const float& mask_scale_value() const override { return impl_.mask_scale_value(); }
  float* mutable_mask_scale_value() override { return impl_.mutable_mask_scale_value(); }
  void set_mask_scale_value(const float& mask_scale_value) override {
    impl_.set_mask_scale_value(mask_scale_value);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class FusedTrilScaleSoftmaxMaskScaleGradOp {
 public:
  FusedTrilScaleSoftmaxMaskScaleGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "diagonal") {
      return CastAttr(&internal_->diagonal);
    } else if (attr_name == "tril_scale_value") {
      return CastAttr(&internal_->tril_scale_value);
    } else if (attr_name == "mask_scale_value") {
      return CastAttr(&internal_->mask_scale_value);
    } else {
      return Error::RuntimeError()
             << "FusedTrilScaleSoftmaxMaskScaleGrad op has no attribute named " << attr_name;
    }
  }

  const int64_t& diagonal() const { return internal_->diagonal; }
  int64_t* mutable_diagonal() { return &internal_->diagonal; }
  void set_diagonal(const int64_t& diagonal) { internal_->diagonal = diagonal; }

  const float& tril_scale_value() const { return internal_->tril_scale_value; }
  float* mutable_tril_scale_value() { return &internal_->tril_scale_value; }
  void set_tril_scale_value(const float& tril_scale_value) {
    internal_->tril_scale_value = tril_scale_value;
  }

  const float& mask_scale_value() const { return internal_->mask_scale_value; }
  float* mutable_mask_scale_value() { return &internal_->mask_scale_value; }
  void set_mask_scale_value(const float& mask_scale_value) {
    internal_->mask_scale_value = mask_scale_value;
  }

 private:
  struct Internal {
    int64_t diagonal;
    float tril_scale_value;
    float mask_scale_value;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.fused_tril_scale_softmax_mask_scale_grad",
                       FusedTrilScaleSoftmaxMaskScaleGradOpInterpCtxImpl<
                           schema::FusedTrilScaleSoftmaxMaskScaleGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class GatherOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& axis() const = 0;
  virtual int64_t* mutable_axis() = 0;
  virtual void set_axis(const int64_t& axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis"};
    return attr_names;
  }
};
template<typename Provider>
class GatherOpInterpCtxImpl : public GatherOpInterpCtx {
 public:
  GatherOpInterpCtxImpl() = default;
  GatherOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& axis() const override { return impl_.axis(); }
  int64_t* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const int64_t& axis) override { impl_.set_axis(axis); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class GatherOp {
 public:
  GatherOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else {
      return Error::RuntimeError() << "Gather op has no attribute named " << attr_name;
    }
  }

  const int64_t& axis() const { return internal_->axis; }
  int64_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int64_t& axis) { internal_->axis = axis; }

 private:
  struct Internal {
    int64_t axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.gather", GatherOpInterpCtxImpl<schema::GatherOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class GatherNdOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class GatherNdOpInterpCtxImpl : public GatherNdOpInterpCtx {
 public:
  GatherNdOpInterpCtxImpl() = default;
  GatherNdOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class GatherNdOp {
 public:
  GatherNdOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "GatherNd op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.gather_nd", GatherNdOpInterpCtxImpl<schema::GatherNdOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class GeluOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class GeluOpInterpCtxImpl : public GeluOpInterpCtx {
 public:
  GeluOpInterpCtxImpl() = default;
  GeluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class GeluOp {
 public:
  GeluOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Gelu op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.gelu", GeluOpInterpCtxImpl<schema::GeluOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class GeluGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class GeluGradOpInterpCtxImpl : public GeluGradOpInterpCtx {
 public:
  GeluGradOpInterpCtxImpl() = default;
  GeluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class GeluGradOp {
 public:
  GeluGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "GeluGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.gelu_grad", GeluGradOpInterpCtxImpl<schema::GeluGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class GenTensorBufferOpInterpCtx : public OpInterpCtx {
 public:
  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  virtual const std::vector<Shape>& shape_list() const = 0;
  virtual std::vector<Shape>* mutable_shape_list() = 0;
  virtual void set_shape_list(const std::vector<Shape>& shape_list) = 0;

  virtual const std::vector<float>& value_list() const = 0;
  virtual std::vector<float>* mutable_value_list() = 0;
  virtual void set_value_list(const std::vector<float>& value_list) = 0;

  virtual const DataType& data_type() const = 0;
  virtual DataType* mutable_data_type() = 0;
  virtual void set_data_type(const DataType& data_type) = 0;

  virtual const bool& dynamic_out() const = 0;
  virtual bool* mutable_dynamic_out() = 0;
  virtual void set_dynamic_out(const bool& dynamic_out) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"shape", "shape_list", "value_list", "data_type",
                                           "dynamic_out"};
    return attr_names;
  }
};
template<typename Provider>
class GenTensorBufferOpInterpCtxImpl : public GenTensorBufferOpInterpCtx {
 public:
  GenTensorBufferOpInterpCtxImpl() = default;
  GenTensorBufferOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  const std::vector<Shape>& shape_list() const override { return impl_.shape_list(); }
  std::vector<Shape>* mutable_shape_list() override { return impl_.mutable_shape_list(); }
  void set_shape_list(const std::vector<Shape>& shape_list) override {
    impl_.set_shape_list(shape_list);
  }

  const std::vector<float>& value_list() const override { return impl_.value_list(); }
  std::vector<float>* mutable_value_list() override { return impl_.mutable_value_list(); }
  void set_value_list(const std::vector<float>& value_list) override {
    impl_.set_value_list(value_list);
  }

  const DataType& data_type() const override { return impl_.data_type(); }
  DataType* mutable_data_type() override { return impl_.mutable_data_type(); }
  void set_data_type(const DataType& data_type) override { impl_.set_data_type(data_type); }

  const bool& dynamic_out() const override { return impl_.dynamic_out(); }
  bool* mutable_dynamic_out() override { return impl_.mutable_dynamic_out(); }
  void set_dynamic_out(const bool& dynamic_out) override { impl_.set_dynamic_out(dynamic_out); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class GenTensorBufferOp {
 public:
  GenTensorBufferOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else if (attr_name == "shape_list") {
      return CastAttr(&internal_->shape_list);
    } else if (attr_name == "value_list") {
      return CastAttr(&internal_->value_list);
    } else if (attr_name == "data_type") {
      return CastAttr(&internal_->data_type);
    } else if (attr_name == "dynamic_out") {
      return CastAttr(&internal_->dynamic_out);
    } else {
      return Error::RuntimeError() << "GenTensorBuffer op has no attribute named " << attr_name;
    }
  }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

  const std::vector<Shape>& shape_list() const { return internal_->shape_list; }
  std::vector<Shape>* mutable_shape_list() { return &internal_->shape_list; }
  void set_shape_list(const std::vector<Shape>& shape_list) { internal_->shape_list = shape_list; }

  const std::vector<float>& value_list() const { return internal_->value_list; }
  std::vector<float>* mutable_value_list() { return &internal_->value_list; }
  void set_value_list(const std::vector<float>& value_list) { internal_->value_list = value_list; }

  const DataType& data_type() const { return internal_->data_type; }
  DataType* mutable_data_type() { return &internal_->data_type; }
  void set_data_type(const DataType& data_type) { internal_->data_type = data_type; }

  const bool& dynamic_out() const { return internal_->dynamic_out; }
  bool* mutable_dynamic_out() { return &internal_->dynamic_out; }
  void set_dynamic_out(const bool& dynamic_out) { internal_->dynamic_out = dynamic_out; }

 private:
  struct Internal {
    Shape shape;
    std::vector<Shape> shape_list;
    std::vector<float> value_list;
    DataType data_type;
    bool dynamic_out;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.gen_tensor_buffer",
                       GenTensorBufferOpInterpCtxImpl<schema::GenTensorBufferOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class GenerateRandomBatchPermutationIndicesOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"seed"};
    return attr_names;
  }
};
template<typename Provider>
class GenerateRandomBatchPermutationIndicesOpInterpCtxImpl
    : public GenerateRandomBatchPermutationIndicesOpInterpCtx {
 public:
  GenerateRandomBatchPermutationIndicesOpInterpCtxImpl() = default;
  GenerateRandomBatchPermutationIndicesOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& seed() const override { return impl_.seed(); }
  int64_t* mutable_seed() override { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) override { impl_.set_seed(seed); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class GenerateRandomBatchPermutationIndicesOp {
 public:
  GenerateRandomBatchPermutationIndicesOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "seed") {
      return CastAttr(&internal_->seed);
    } else {
      return Error::RuntimeError()
             << "GenerateRandomBatchPermutationIndices op has no attribute named " << attr_name;
    }
  }

  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }

 private:
  struct Internal {
    int64_t seed;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.generate_random_batch_permutation_indices",
                       GenerateRandomBatchPermutationIndicesOpInterpCtxImpl<
                           schema::GenerateRandomBatchPermutationIndicesOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class GridSampleOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& interpolation_mode() const = 0;
  virtual std::string* mutable_interpolation_mode() = 0;
  virtual void set_interpolation_mode(const std::string& interpolation_mode) = 0;

  virtual const std::string& padding_mode() const = 0;
  virtual std::string* mutable_padding_mode() = 0;
  virtual void set_padding_mode(const std::string& padding_mode) = 0;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"interpolation_mode", "padding_mode", "align_corners"};
    return attr_names;
  }
};
template<typename Provider>
class GridSampleOpInterpCtxImpl : public GridSampleOpInterpCtx {
 public:
  GridSampleOpInterpCtxImpl() = default;
  GridSampleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& interpolation_mode() const override { return impl_.interpolation_mode(); }
  std::string* mutable_interpolation_mode() override { return impl_.mutable_interpolation_mode(); }
  void set_interpolation_mode(const std::string& interpolation_mode) override {
    impl_.set_interpolation_mode(interpolation_mode);
  }

  const std::string& padding_mode() const override { return impl_.padding_mode(); }
  std::string* mutable_padding_mode() override { return impl_.mutable_padding_mode(); }
  void set_padding_mode(const std::string& padding_mode) override {
    impl_.set_padding_mode(padding_mode);
  }

  const bool& align_corners() const override { return impl_.align_corners(); }
  bool* mutable_align_corners() override { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) override {
    impl_.set_align_corners(align_corners);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class GridSampleOp {
 public:
  GridSampleOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "interpolation_mode") {
      return CastAttr(&internal_->interpolation_mode);
    } else if (attr_name == "padding_mode") {
      return CastAttr(&internal_->padding_mode);
    } else if (attr_name == "align_corners") {
      return CastAttr(&internal_->align_corners);
    } else {
      return Error::RuntimeError() << "GridSample op has no attribute named " << attr_name;
    }
  }

  const std::string& interpolation_mode() const { return internal_->interpolation_mode; }
  std::string* mutable_interpolation_mode() { return &internal_->interpolation_mode; }
  void set_interpolation_mode(const std::string& interpolation_mode) {
    internal_->interpolation_mode = interpolation_mode;
  }

  const std::string& padding_mode() const { return internal_->padding_mode; }
  std::string* mutable_padding_mode() { return &internal_->padding_mode; }
  void set_padding_mode(const std::string& padding_mode) { internal_->padding_mode = padding_mode; }

  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }

 private:
  struct Internal {
    std::string interpolation_mode;
    std::string padding_mode;
    bool align_corners;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.grid_sample", GridSampleOpInterpCtxImpl<schema::GridSampleOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class GridSampleGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& interpolation_mode() const = 0;
  virtual std::string* mutable_interpolation_mode() = 0;
  virtual void set_interpolation_mode(const std::string& interpolation_mode) = 0;

  virtual const std::string& padding_mode() const = 0;
  virtual std::string* mutable_padding_mode() = 0;
  virtual void set_padding_mode(const std::string& padding_mode) = 0;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"interpolation_mode", "padding_mode", "align_corners"};
    return attr_names;
  }
};
template<typename Provider>
class GridSampleGradOpInterpCtxImpl : public GridSampleGradOpInterpCtx {
 public:
  GridSampleGradOpInterpCtxImpl() = default;
  GridSampleGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& interpolation_mode() const override { return impl_.interpolation_mode(); }
  std::string* mutable_interpolation_mode() override { return impl_.mutable_interpolation_mode(); }
  void set_interpolation_mode(const std::string& interpolation_mode) override {
    impl_.set_interpolation_mode(interpolation_mode);
  }

  const std::string& padding_mode() const override { return impl_.padding_mode(); }
  std::string* mutable_padding_mode() override { return impl_.mutable_padding_mode(); }
  void set_padding_mode(const std::string& padding_mode) override {
    impl_.set_padding_mode(padding_mode);
  }

  const bool& align_corners() const override { return impl_.align_corners(); }
  bool* mutable_align_corners() override { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) override {
    impl_.set_align_corners(align_corners);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class GridSampleGradOp {
 public:
  GridSampleGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "interpolation_mode") {
      return CastAttr(&internal_->interpolation_mode);
    } else if (attr_name == "padding_mode") {
      return CastAttr(&internal_->padding_mode);
    } else if (attr_name == "align_corners") {
      return CastAttr(&internal_->align_corners);
    } else {
      return Error::RuntimeError() << "GridSampleGrad op has no attribute named " << attr_name;
    }
  }

  const std::string& interpolation_mode() const { return internal_->interpolation_mode; }
  std::string* mutable_interpolation_mode() { return &internal_->interpolation_mode; }
  void set_interpolation_mode(const std::string& interpolation_mode) {
    internal_->interpolation_mode = interpolation_mode;
  }

  const std::string& padding_mode() const { return internal_->padding_mode; }
  std::string* mutable_padding_mode() { return &internal_->padding_mode; }
  void set_padding_mode(const std::string& padding_mode) { internal_->padding_mode = padding_mode; }

  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }

 private:
  struct Internal {
    std::string interpolation_mode;
    std::string padding_mode;
    bool align_corners;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.grid_sample_grad",
                       GridSampleGradOpInterpCtxImpl<schema::GridSampleGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class HardsigmoidOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class HardsigmoidOpInterpCtxImpl : public HardsigmoidOpInterpCtx {
 public:
  HardsigmoidOpInterpCtxImpl() = default;
  HardsigmoidOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class HardsigmoidOp {
 public:
  HardsigmoidOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Hardsigmoid op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.hardsigmoid", HardsigmoidOpInterpCtxImpl<schema::HardsigmoidOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class HardsigmoidGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class HardsigmoidGradOpInterpCtxImpl : public HardsigmoidGradOpInterpCtx {
 public:
  HardsigmoidGradOpInterpCtxImpl() = default;
  HardsigmoidGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class HardsigmoidGradOp {
 public:
  HardsigmoidGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "HardsigmoidGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.hardsigmoid_grad",
                       HardsigmoidGradOpInterpCtxImpl<schema::HardsigmoidGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class HardswishOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class HardswishOpInterpCtxImpl : public HardswishOpInterpCtx {
 public:
  HardswishOpInterpCtxImpl() = default;
  HardswishOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class HardswishOp {
 public:
  HardswishOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Hardswish op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.hardswish", HardswishOpInterpCtxImpl<schema::HardswishOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class HardswishGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class HardswishGradOpInterpCtxImpl : public HardswishGradOpInterpCtx {
 public:
  HardswishGradOpInterpCtxImpl() = default;
  HardswishGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class HardswishGradOp {
 public:
  HardswishGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "HardswishGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.hardswish_grad",
                       HardswishGradOpInterpCtxImpl<schema::HardswishGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class HardtanhOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& min_val() const = 0;
  virtual double* mutable_min_val() = 0;
  virtual void set_min_val(const double& min_val) = 0;

  virtual const double& max_val() const = 0;
  virtual double* mutable_max_val() = 0;
  virtual void set_max_val(const double& max_val) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"min_val", "max_val"};
    return attr_names;
  }
};
template<typename Provider>
class HardtanhOpInterpCtxImpl : public HardtanhOpInterpCtx {
 public:
  HardtanhOpInterpCtxImpl() = default;
  HardtanhOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& min_val() const override { return impl_.min_val(); }
  double* mutable_min_val() override { return impl_.mutable_min_val(); }
  void set_min_val(const double& min_val) override { impl_.set_min_val(min_val); }

  const double& max_val() const override { return impl_.max_val(); }
  double* mutable_max_val() override { return impl_.mutable_max_val(); }
  void set_max_val(const double& max_val) override { impl_.set_max_val(max_val); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class HardtanhOp {
 public:
  HardtanhOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "min_val") {
      return CastAttr(&internal_->min_val);
    } else if (attr_name == "max_val") {
      return CastAttr(&internal_->max_val);
    } else {
      return Error::RuntimeError() << "Hardtanh op has no attribute named " << attr_name;
    }
  }

  const double& min_val() const { return internal_->min_val; }
  double* mutable_min_val() { return &internal_->min_val; }
  void set_min_val(const double& min_val) { internal_->min_val = min_val; }

  const double& max_val() const { return internal_->max_val; }
  double* mutable_max_val() { return &internal_->max_val; }
  void set_max_val(const double& max_val) { internal_->max_val = max_val; }

 private:
  struct Internal {
    double min_val;
    double max_val;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.hardtanh", HardtanhOpInterpCtxImpl<schema::HardtanhOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class HardtanhGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& min_val() const = 0;
  virtual double* mutable_min_val() = 0;
  virtual void set_min_val(const double& min_val) = 0;

  virtual const double& max_val() const = 0;
  virtual double* mutable_max_val() = 0;
  virtual void set_max_val(const double& max_val) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"min_val", "max_val"};
    return attr_names;
  }
};
template<typename Provider>
class HardtanhGradOpInterpCtxImpl : public HardtanhGradOpInterpCtx {
 public:
  HardtanhGradOpInterpCtxImpl() = default;
  HardtanhGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& min_val() const override { return impl_.min_val(); }
  double* mutable_min_val() override { return impl_.mutable_min_val(); }
  void set_min_val(const double& min_val) override { impl_.set_min_val(min_val); }

  const double& max_val() const override { return impl_.max_val(); }
  double* mutable_max_val() override { return impl_.mutable_max_val(); }
  void set_max_val(const double& max_val) override { impl_.set_max_val(max_val); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class HardtanhGradOp {
 public:
  HardtanhGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "min_val") {
      return CastAttr(&internal_->min_val);
    } else if (attr_name == "max_val") {
      return CastAttr(&internal_->max_val);
    } else {
      return Error::RuntimeError() << "HardtanhGrad op has no attribute named " << attr_name;
    }
  }

  const double& min_val() const { return internal_->min_val; }
  double* mutable_min_val() { return &internal_->min_val; }
  void set_min_val(const double& min_val) { internal_->min_val = min_val; }

  const double& max_val() const { return internal_->max_val; }
  double* mutable_max_val() { return &internal_->max_val; }
  void set_max_val(const double& max_val) { internal_->max_val = max_val; }

 private:
  struct Internal {
    double min_val;
    double max_val;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.hardtanh_grad", HardtanhGradOpInterpCtxImpl<schema::HardtanhGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class HierarchicalParallelCastOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  virtual const std::string& grad_mode() const = 0;
  virtual std::string* mutable_grad_mode() = 0;
  virtual void set_grad_mode(const std::string& grad_mode) = 0;

  virtual const std::vector<std::string>& grad_nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_grad_nd_sbp() = 0;
  virtual void set_grad_nd_sbp(const std::vector<std::string>& grad_nd_sbp) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"nd_sbp", "grad_mode", "grad_nd_sbp"};
    return attr_names;
  }
};
template<typename Provider>
class HierarchicalParallelCastOpInterpCtxImpl : public HierarchicalParallelCastOpInterpCtx {
 public:
  HierarchicalParallelCastOpInterpCtxImpl() = default;
  HierarchicalParallelCastOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<std::string>& nd_sbp() const override { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() override { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) override { impl_.set_nd_sbp(nd_sbp); }

  const std::string& grad_mode() const override { return impl_.grad_mode(); }
  std::string* mutable_grad_mode() override { return impl_.mutable_grad_mode(); }
  void set_grad_mode(const std::string& grad_mode) override { impl_.set_grad_mode(grad_mode); }

  const std::vector<std::string>& grad_nd_sbp() const override { return impl_.grad_nd_sbp(); }
  std::vector<std::string>* mutable_grad_nd_sbp() override { return impl_.mutable_grad_nd_sbp(); }
  void set_grad_nd_sbp(const std::vector<std::string>& grad_nd_sbp) override {
    impl_.set_grad_nd_sbp(grad_nd_sbp);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class HierarchicalParallelCastOp {
 public:
  HierarchicalParallelCastOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "nd_sbp") {
      return CastAttr(&internal_->nd_sbp);
    } else if (attr_name == "grad_mode") {
      return CastAttr(&internal_->grad_mode);
    } else if (attr_name == "grad_nd_sbp") {
      return CastAttr(&internal_->grad_nd_sbp);
    } else {
      return Error::RuntimeError()
             << "HierarchicalParallelCast op has no attribute named " << attr_name;
    }
  }

  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }

  const std::string& grad_mode() const { return internal_->grad_mode; }
  std::string* mutable_grad_mode() { return &internal_->grad_mode; }
  void set_grad_mode(const std::string& grad_mode) { internal_->grad_mode = grad_mode; }

  const std::vector<std::string>& grad_nd_sbp() const { return internal_->grad_nd_sbp; }
  std::vector<std::string>* mutable_grad_nd_sbp() { return &internal_->grad_nd_sbp; }
  void set_grad_nd_sbp(const std::vector<std::string>& grad_nd_sbp) {
    internal_->grad_nd_sbp = grad_nd_sbp;
  }

 private:
  struct Internal {
    std::vector<std::string> nd_sbp;
    std::string grad_mode;
    std::vector<std::string> grad_nd_sbp;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.hierarchical_parallel_cast",
                       HierarchicalParallelCastOpInterpCtxImpl<schema::HierarchicalParallelCastOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class HierarchicalParallelCastLikeOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class HierarchicalParallelCastLikeOpInterpCtxImpl : public HierarchicalParallelCastLikeOpInterpCtx {
 public:
  HierarchicalParallelCastLikeOpInterpCtxImpl() = default;
  HierarchicalParallelCastLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class HierarchicalParallelCastLikeOp {
 public:
  HierarchicalParallelCastLikeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "HierarchicalParallelCastLike op has no attribute named "
                                 << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.hierarchical_parallel_cast_like",
    HierarchicalParallelCastLikeOpInterpCtxImpl<schema::HierarchicalParallelCastLikeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class IdentityOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class IdentityOpInterpCtxImpl : public IdentityOpInterpCtx {
 public:
  IdentityOpInterpCtxImpl() = default;
  IdentityOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class IdentityOp {
 public:
  IdentityOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Identity op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.identity", IdentityOpInterpCtxImpl<schema::IdentityOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class IdentityBufferOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& buffer_size() const = 0;
  virtual int64_t* mutable_buffer_size() = 0;
  virtual void set_buffer_size(const int64_t& buffer_size) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"buffer_size"};
    return attr_names;
  }
};
template<typename Provider>
class IdentityBufferOpInterpCtxImpl : public IdentityBufferOpInterpCtx {
 public:
  IdentityBufferOpInterpCtxImpl() = default;
  IdentityBufferOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& buffer_size() const override { return impl_.buffer_size(); }
  int64_t* mutable_buffer_size() override { return impl_.mutable_buffer_size(); }
  void set_buffer_size(const int64_t& buffer_size) override { impl_.set_buffer_size(buffer_size); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class IdentityBufferOp {
 public:
  IdentityBufferOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "buffer_size") {
      return CastAttr(&internal_->buffer_size);
    } else {
      return Error::RuntimeError() << "IdentityBuffer op has no attribute named " << attr_name;
    }
  }

  const int64_t& buffer_size() const { return internal_->buffer_size; }
  int64_t* mutable_buffer_size() { return &internal_->buffer_size; }
  void set_buffer_size(const int64_t& buffer_size) { internal_->buffer_size = buffer_size; }

 private:
  struct Internal {
    int64_t buffer_size;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.identity_buffer",
                       IdentityBufferOpInterpCtxImpl<schema::IdentityBufferOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ImageBatchAlignOpInterpCtx : public OpInterpCtx {
 public:
  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  virtual const DataType& data_type() const = 0;
  virtual DataType* mutable_data_type() = 0;
  virtual void set_data_type(const DataType& data_type) = 0;

  virtual const int32_t& alignment() const = 0;
  virtual int32_t* mutable_alignment() = 0;
  virtual void set_alignment(const int32_t& alignment) = 0;

  virtual const bool& dynamic_out() const = 0;
  virtual bool* mutable_dynamic_out() = 0;
  virtual void set_dynamic_out(const bool& dynamic_out) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"shape", "data_type", "alignment", "dynamic_out"};
    return attr_names;
  }
};
template<typename Provider>
class ImageBatchAlignOpInterpCtxImpl : public ImageBatchAlignOpInterpCtx {
 public:
  ImageBatchAlignOpInterpCtxImpl() = default;
  ImageBatchAlignOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  const DataType& data_type() const override { return impl_.data_type(); }
  DataType* mutable_data_type() override { return impl_.mutable_data_type(); }
  void set_data_type(const DataType& data_type) override { impl_.set_data_type(data_type); }

  const int32_t& alignment() const override { return impl_.alignment(); }
  int32_t* mutable_alignment() override { return impl_.mutable_alignment(); }
  void set_alignment(const int32_t& alignment) override { impl_.set_alignment(alignment); }

  const bool& dynamic_out() const override { return impl_.dynamic_out(); }
  bool* mutable_dynamic_out() override { return impl_.mutable_dynamic_out(); }
  void set_dynamic_out(const bool& dynamic_out) override { impl_.set_dynamic_out(dynamic_out); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ImageBatchAlignOp {
 public:
  ImageBatchAlignOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else if (attr_name == "data_type") {
      return CastAttr(&internal_->data_type);
    } else if (attr_name == "alignment") {
      return CastAttr(&internal_->alignment);
    } else if (attr_name == "dynamic_out") {
      return CastAttr(&internal_->dynamic_out);
    } else {
      return Error::RuntimeError() << "ImageBatchAlign op has no attribute named " << attr_name;
    }
  }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

  const DataType& data_type() const { return internal_->data_type; }
  DataType* mutable_data_type() { return &internal_->data_type; }
  void set_data_type(const DataType& data_type) { internal_->data_type = data_type; }

  const int32_t& alignment() const { return internal_->alignment; }
  int32_t* mutable_alignment() { return &internal_->alignment; }
  void set_alignment(const int32_t& alignment) { internal_->alignment = alignment; }

  const bool& dynamic_out() const { return internal_->dynamic_out; }
  bool* mutable_dynamic_out() { return &internal_->dynamic_out; }
  void set_dynamic_out(const bool& dynamic_out) { internal_->dynamic_out = dynamic_out; }

 private:
  struct Internal {
    Shape shape;
    DataType data_type;
    int32_t alignment;
    bool dynamic_out;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.image_batch_align",
                       ImageBatchAlignOpInterpCtxImpl<schema::ImageBatchAlignOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ImageDecodeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& color_space() const = 0;
  virtual std::string* mutable_color_space() = 0;
  virtual void set_color_space(const std::string& color_space) = 0;

  virtual const DataType& data_type() const = 0;
  virtual DataType* mutable_data_type() = 0;
  virtual void set_data_type(const DataType& data_type) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"color_space", "data_type"};
    return attr_names;
  }
};
template<typename Provider>
class ImageDecodeOpInterpCtxImpl : public ImageDecodeOpInterpCtx {
 public:
  ImageDecodeOpInterpCtxImpl() = default;
  ImageDecodeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& color_space() const override { return impl_.color_space(); }
  std::string* mutable_color_space() override { return impl_.mutable_color_space(); }
  void set_color_space(const std::string& color_space) override {
    impl_.set_color_space(color_space);
  }

  const DataType& data_type() const override { return impl_.data_type(); }
  DataType* mutable_data_type() override { return impl_.mutable_data_type(); }
  void set_data_type(const DataType& data_type) override { impl_.set_data_type(data_type); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ImageDecodeOp {
 public:
  ImageDecodeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "color_space") {
      return CastAttr(&internal_->color_space);
    } else if (attr_name == "data_type") {
      return CastAttr(&internal_->data_type);
    } else {
      return Error::RuntimeError() << "ImageDecode op has no attribute named " << attr_name;
    }
  }

  const std::string& color_space() const { return internal_->color_space; }
  std::string* mutable_color_space() { return &internal_->color_space; }
  void set_color_space(const std::string& color_space) { internal_->color_space = color_space; }

  const DataType& data_type() const { return internal_->data_type; }
  DataType* mutable_data_type() { return &internal_->data_type; }
  void set_data_type(const DataType& data_type) { internal_->data_type = data_type; }

 private:
  struct Internal {
    std::string color_space;
    DataType data_type;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.image_decode", ImageDecodeOpInterpCtxImpl<schema::ImageDecodeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ImageFlipOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ImageFlipOpInterpCtxImpl : public ImageFlipOpInterpCtx {
 public:
  ImageFlipOpInterpCtxImpl() = default;
  ImageFlipOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ImageFlipOp {
 public:
  ImageFlipOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ImageFlip op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.image_flip", ImageFlipOpInterpCtxImpl<schema::ImageFlipOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ImageNormalizeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<float>& std() const = 0;
  virtual std::vector<float>* mutable_std() = 0;
  virtual void set_std(const std::vector<float>& std) = 0;

  virtual const std::vector<float>& mean() const = 0;
  virtual std::vector<float>* mutable_mean() = 0;
  virtual void set_mean(const std::vector<float>& mean) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"std", "mean"};
    return attr_names;
  }
};
template<typename Provider>
class ImageNormalizeOpInterpCtxImpl : public ImageNormalizeOpInterpCtx {
 public:
  ImageNormalizeOpInterpCtxImpl() = default;
  ImageNormalizeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<float>& std() const override { return impl_.std(); }
  std::vector<float>* mutable_std() override { return impl_.mutable_std(); }
  void set_std(const std::vector<float>& std) override { impl_.set_std(std); }

  const std::vector<float>& mean() const override { return impl_.mean(); }
  std::vector<float>* mutable_mean() override { return impl_.mutable_mean(); }
  void set_mean(const std::vector<float>& mean) override { impl_.set_mean(mean); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ImageNormalizeOp {
 public:
  ImageNormalizeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "std") {
      return CastAttr(&internal_->std);
    } else if (attr_name == "mean") {
      return CastAttr(&internal_->mean);
    } else {
      return Error::RuntimeError() << "ImageNormalize op has no attribute named " << attr_name;
    }
  }

  const std::vector<float>& std() const { return internal_->std; }
  std::vector<float>* mutable_std() { return &internal_->std; }
  void set_std(const std::vector<float>& std) { internal_->std = std; }

  const std::vector<float>& mean() const { return internal_->mean; }
  std::vector<float>* mutable_mean() { return &internal_->mean; }
  void set_mean(const std::vector<float>& mean) { internal_->mean = mean; }

 private:
  struct Internal {
    std::vector<float> std;
    std::vector<float> mean;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.image_normalize",
                       ImageNormalizeOpInterpCtxImpl<schema::ImageNormalizeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ImageRandomCropOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& num_attempts() const = 0;
  virtual int32_t* mutable_num_attempts() = 0;
  virtual void set_num_attempts(const int32_t& num_attempts) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const bool& has_seed() const = 0;
  virtual bool* mutable_has_seed() = 0;
  virtual void set_has_seed(const bool& has_seed) = 0;

  virtual const std::vector<float>& random_area() const = 0;
  virtual std::vector<float>* mutable_random_area() = 0;
  virtual void set_random_area(const std::vector<float>& random_area) = 0;

  virtual const std::vector<float>& random_aspect_ratio() const = 0;
  virtual std::vector<float>* mutable_random_aspect_ratio() = 0;
  virtual void set_random_aspect_ratio(const std::vector<float>& random_aspect_ratio) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"num_attempts", "seed", "has_seed", "random_area",
                                           "random_aspect_ratio"};
    return attr_names;
  }
};
template<typename Provider>
class ImageRandomCropOpInterpCtxImpl : public ImageRandomCropOpInterpCtx {
 public:
  ImageRandomCropOpInterpCtxImpl() = default;
  ImageRandomCropOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& num_attempts() const override { return impl_.num_attempts(); }
  int32_t* mutable_num_attempts() override { return impl_.mutable_num_attempts(); }
  void set_num_attempts(const int32_t& num_attempts) override {
    impl_.set_num_attempts(num_attempts);
  }

  const int64_t& seed() const override { return impl_.seed(); }
  int64_t* mutable_seed() override { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) override { impl_.set_seed(seed); }

  const bool& has_seed() const override { return impl_.has_seed(); }
  bool* mutable_has_seed() override { return impl_.mutable_has_seed(); }
  void set_has_seed(const bool& has_seed) override { impl_.set_has_seed(has_seed); }

  const std::vector<float>& random_area() const override { return impl_.random_area(); }
  std::vector<float>* mutable_random_area() override { return impl_.mutable_random_area(); }
  void set_random_area(const std::vector<float>& random_area) override {
    impl_.set_random_area(random_area);
  }

  const std::vector<float>& random_aspect_ratio() const override {
    return impl_.random_aspect_ratio();
  }
  std::vector<float>* mutable_random_aspect_ratio() override {
    return impl_.mutable_random_aspect_ratio();
  }
  void set_random_aspect_ratio(const std::vector<float>& random_aspect_ratio) override {
    impl_.set_random_aspect_ratio(random_aspect_ratio);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ImageRandomCropOp {
 public:
  ImageRandomCropOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "num_attempts") {
      return CastAttr(&internal_->num_attempts);
    } else if (attr_name == "seed") {
      return CastAttr(&internal_->seed);
    } else if (attr_name == "has_seed") {
      return CastAttr(&internal_->has_seed);
    } else if (attr_name == "random_area") {
      return CastAttr(&internal_->random_area);
    } else if (attr_name == "random_aspect_ratio") {
      return CastAttr(&internal_->random_aspect_ratio);
    } else {
      return Error::RuntimeError() << "ImageRandomCrop op has no attribute named " << attr_name;
    }
  }

  const int32_t& num_attempts() const { return internal_->num_attempts; }
  int32_t* mutable_num_attempts() { return &internal_->num_attempts; }
  void set_num_attempts(const int32_t& num_attempts) { internal_->num_attempts = num_attempts; }

  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }

  const bool& has_seed() const { return internal_->has_seed; }
  bool* mutable_has_seed() { return &internal_->has_seed; }
  void set_has_seed(const bool& has_seed) { internal_->has_seed = has_seed; }

  const std::vector<float>& random_area() const { return internal_->random_area; }
  std::vector<float>* mutable_random_area() { return &internal_->random_area; }
  void set_random_area(const std::vector<float>& random_area) {
    internal_->random_area = random_area;
  }

  const std::vector<float>& random_aspect_ratio() const { return internal_->random_aspect_ratio; }
  std::vector<float>* mutable_random_aspect_ratio() { return &internal_->random_aspect_ratio; }
  void set_random_aspect_ratio(const std::vector<float>& random_aspect_ratio) {
    internal_->random_aspect_ratio = random_aspect_ratio;
  }

 private:
  struct Internal {
    int32_t num_attempts;
    int64_t seed;
    bool has_seed;
    std::vector<float> random_area;
    std::vector<float> random_aspect_ratio;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.image_random_crop",
                       ImageRandomCropOpInterpCtxImpl<schema::ImageRandomCropOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ImageResizeKeepAspectRatioOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& target_size() const = 0;
  virtual int32_t* mutable_target_size() = 0;
  virtual void set_target_size(const int32_t& target_size) = 0;

  virtual const int32_t& min_size() const = 0;
  virtual int32_t* mutable_min_size() = 0;
  virtual void set_min_size(const int32_t& min_size) = 0;

  virtual const int32_t& max_size() const = 0;
  virtual int32_t* mutable_max_size() = 0;
  virtual void set_max_size(const int32_t& max_size) = 0;

  virtual const bool& resize_longer() const = 0;
  virtual bool* mutable_resize_longer() = 0;
  virtual void set_resize_longer(const bool& resize_longer) = 0;

  virtual const std::string& interpolation_type() const = 0;
  virtual std::string* mutable_interpolation_type() = 0;
  virtual void set_interpolation_type(const std::string& interpolation_type) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"target_size", "min_size", "max_size", "resize_longer",
                                           "interpolation_type"};
    return attr_names;
  }
};
template<typename Provider>
class ImageResizeKeepAspectRatioOpInterpCtxImpl : public ImageResizeKeepAspectRatioOpInterpCtx {
 public:
  ImageResizeKeepAspectRatioOpInterpCtxImpl() = default;
  ImageResizeKeepAspectRatioOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& target_size() const override { return impl_.target_size(); }
  int32_t* mutable_target_size() override { return impl_.mutable_target_size(); }
  void set_target_size(const int32_t& target_size) override { impl_.set_target_size(target_size); }

  const int32_t& min_size() const override { return impl_.min_size(); }
  int32_t* mutable_min_size() override { return impl_.mutable_min_size(); }
  void set_min_size(const int32_t& min_size) override { impl_.set_min_size(min_size); }

  const int32_t& max_size() const override { return impl_.max_size(); }
  int32_t* mutable_max_size() override { return impl_.mutable_max_size(); }
  void set_max_size(const int32_t& max_size) override { impl_.set_max_size(max_size); }

  const bool& resize_longer() const override { return impl_.resize_longer(); }
  bool* mutable_resize_longer() override { return impl_.mutable_resize_longer(); }
  void set_resize_longer(const bool& resize_longer) override {
    impl_.set_resize_longer(resize_longer);
  }

  const std::string& interpolation_type() const override { return impl_.interpolation_type(); }
  std::string* mutable_interpolation_type() override { return impl_.mutable_interpolation_type(); }
  void set_interpolation_type(const std::string& interpolation_type) override {
    impl_.set_interpolation_type(interpolation_type);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ImageResizeKeepAspectRatioOp {
 public:
  ImageResizeKeepAspectRatioOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "target_size") {
      return CastAttr(&internal_->target_size);
    } else if (attr_name == "min_size") {
      return CastAttr(&internal_->min_size);
    } else if (attr_name == "max_size") {
      return CastAttr(&internal_->max_size);
    } else if (attr_name == "resize_longer") {
      return CastAttr(&internal_->resize_longer);
    } else if (attr_name == "interpolation_type") {
      return CastAttr(&internal_->interpolation_type);
    } else {
      return Error::RuntimeError()
             << "ImageResizeKeepAspectRatio op has no attribute named " << attr_name;
    }
  }

  const int32_t& target_size() const { return internal_->target_size; }
  int32_t* mutable_target_size() { return &internal_->target_size; }
  void set_target_size(const int32_t& target_size) { internal_->target_size = target_size; }

  const int32_t& min_size() const { return internal_->min_size; }
  int32_t* mutable_min_size() { return &internal_->min_size; }
  void set_min_size(const int32_t& min_size) { internal_->min_size = min_size; }

  const int32_t& max_size() const { return internal_->max_size; }
  int32_t* mutable_max_size() { return &internal_->max_size; }
  void set_max_size(const int32_t& max_size) { internal_->max_size = max_size; }

  const bool& resize_longer() const { return internal_->resize_longer; }
  bool* mutable_resize_longer() { return &internal_->resize_longer; }
  void set_resize_longer(const bool& resize_longer) { internal_->resize_longer = resize_longer; }

  const std::string& interpolation_type() const { return internal_->interpolation_type; }
  std::string* mutable_interpolation_type() { return &internal_->interpolation_type; }
  void set_interpolation_type(const std::string& interpolation_type) {
    internal_->interpolation_type = interpolation_type;
  }

 private:
  struct Internal {
    int32_t target_size;
    int32_t min_size;
    int32_t max_size;
    bool resize_longer;
    std::string interpolation_type;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.image_resize_keep_aspect_ratio",
    ImageResizeKeepAspectRatioOpInterpCtxImpl<schema::ImageResizeKeepAspectRatioOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ImageResizeToFixedOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& target_width() const = 0;
  virtual int64_t* mutable_target_width() = 0;
  virtual void set_target_width(const int64_t& target_width) = 0;

  virtual const int64_t& target_height() const = 0;
  virtual int64_t* mutable_target_height() = 0;
  virtual void set_target_height(const int64_t& target_height) = 0;

  virtual const int64_t& channels() const = 0;
  virtual int64_t* mutable_channels() = 0;
  virtual void set_channels(const int64_t& channels) = 0;

  virtual const DataType& data_type() const = 0;
  virtual DataType* mutable_data_type() = 0;
  virtual void set_data_type(const DataType& data_type) = 0;

  virtual const std::string& interpolation_type() const = 0;
  virtual std::string* mutable_interpolation_type() = 0;
  virtual void set_interpolation_type(const std::string& interpolation_type) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"target_width", "target_height", "channels", "data_type",
                                           "interpolation_type"};
    return attr_names;
  }
};
template<typename Provider>
class ImageResizeToFixedOpInterpCtxImpl : public ImageResizeToFixedOpInterpCtx {
 public:
  ImageResizeToFixedOpInterpCtxImpl() = default;
  ImageResizeToFixedOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& target_width() const override { return impl_.target_width(); }
  int64_t* mutable_target_width() override { return impl_.mutable_target_width(); }
  void set_target_width(const int64_t& target_width) override {
    impl_.set_target_width(target_width);
  }

  const int64_t& target_height() const override { return impl_.target_height(); }
  int64_t* mutable_target_height() override { return impl_.mutable_target_height(); }
  void set_target_height(const int64_t& target_height) override {
    impl_.set_target_height(target_height);
  }

  const int64_t& channels() const override { return impl_.channels(); }
  int64_t* mutable_channels() override { return impl_.mutable_channels(); }
  void set_channels(const int64_t& channels) override { impl_.set_channels(channels); }

  const DataType& data_type() const override { return impl_.data_type(); }
  DataType* mutable_data_type() override { return impl_.mutable_data_type(); }
  void set_data_type(const DataType& data_type) override { impl_.set_data_type(data_type); }

  const std::string& interpolation_type() const override { return impl_.interpolation_type(); }
  std::string* mutable_interpolation_type() override { return impl_.mutable_interpolation_type(); }
  void set_interpolation_type(const std::string& interpolation_type) override {
    impl_.set_interpolation_type(interpolation_type);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ImageResizeToFixedOp {
 public:
  ImageResizeToFixedOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "target_width") {
      return CastAttr(&internal_->target_width);
    } else if (attr_name == "target_height") {
      return CastAttr(&internal_->target_height);
    } else if (attr_name == "channels") {
      return CastAttr(&internal_->channels);
    } else if (attr_name == "data_type") {
      return CastAttr(&internal_->data_type);
    } else if (attr_name == "interpolation_type") {
      return CastAttr(&internal_->interpolation_type);
    } else {
      return Error::RuntimeError() << "ImageResizeToFixed op has no attribute named " << attr_name;
    }
  }

  const int64_t& target_width() const { return internal_->target_width; }
  int64_t* mutable_target_width() { return &internal_->target_width; }
  void set_target_width(const int64_t& target_width) { internal_->target_width = target_width; }

  const int64_t& target_height() const { return internal_->target_height; }
  int64_t* mutable_target_height() { return &internal_->target_height; }
  void set_target_height(const int64_t& target_height) { internal_->target_height = target_height; }

  const int64_t& channels() const { return internal_->channels; }
  int64_t* mutable_channels() { return &internal_->channels; }
  void set_channels(const int64_t& channels) { internal_->channels = channels; }

  const DataType& data_type() const { return internal_->data_type; }
  DataType* mutable_data_type() { return &internal_->data_type; }
  void set_data_type(const DataType& data_type) { internal_->data_type = data_type; }

  const std::string& interpolation_type() const { return internal_->interpolation_type; }
  std::string* mutable_interpolation_type() { return &internal_->interpolation_type; }
  void set_interpolation_type(const std::string& interpolation_type) {
    internal_->interpolation_type = interpolation_type;
  }

 private:
  struct Internal {
    int64_t target_width;
    int64_t target_height;
    int64_t channels;
    DataType data_type;
    std::string interpolation_type;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.image_resize_to_fixed",
                       ImageResizeToFixedOpInterpCtxImpl<schema::ImageResizeToFixedOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ImageTargetResizeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& target_size() const = 0;
  virtual int32_t* mutable_target_size() = 0;
  virtual void set_target_size(const int32_t& target_size) = 0;

  virtual const int32_t& max_size() const = 0;
  virtual int32_t* mutable_max_size() = 0;
  virtual void set_max_size(const int32_t& max_size) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"target_size", "max_size"};
    return attr_names;
  }
};
template<typename Provider>
class ImageTargetResizeOpInterpCtxImpl : public ImageTargetResizeOpInterpCtx {
 public:
  ImageTargetResizeOpInterpCtxImpl() = default;
  ImageTargetResizeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& target_size() const override { return impl_.target_size(); }
  int32_t* mutable_target_size() override { return impl_.mutable_target_size(); }
  void set_target_size(const int32_t& target_size) override { impl_.set_target_size(target_size); }

  const int32_t& max_size() const override { return impl_.max_size(); }
  int32_t* mutable_max_size() override { return impl_.mutable_max_size(); }
  void set_max_size(const int32_t& max_size) override { impl_.set_max_size(max_size); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ImageTargetResizeOp {
 public:
  ImageTargetResizeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "target_size") {
      return CastAttr(&internal_->target_size);
    } else if (attr_name == "max_size") {
      return CastAttr(&internal_->max_size);
    } else {
      return Error::RuntimeError() << "ImageTargetResize op has no attribute named " << attr_name;
    }
  }

  const int32_t& target_size() const { return internal_->target_size; }
  int32_t* mutable_target_size() { return &internal_->target_size; }
  void set_target_size(const int32_t& target_size) { internal_->target_size = target_size; }

  const int32_t& max_size() const { return internal_->max_size; }
  int32_t* mutable_max_size() { return &internal_->max_size; }
  void set_max_size(const int32_t& max_size) { internal_->max_size = max_size; }

 private:
  struct Internal {
    int32_t target_size;
    int32_t max_size;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.image_target_resize",
                       ImageTargetResizeOpInterpCtxImpl<schema::ImageTargetResizeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class InTopKOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& k() const = 0;
  virtual int32_t* mutable_k() = 0;
  virtual void set_k(const int32_t& k) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"k"};
    return attr_names;
  }
};
template<typename Provider>
class InTopKOpInterpCtxImpl : public InTopKOpInterpCtx {
 public:
  InTopKOpInterpCtxImpl() = default;
  InTopKOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& k() const override { return impl_.k(); }
  int32_t* mutable_k() override { return impl_.mutable_k(); }
  void set_k(const int32_t& k) override { impl_.set_k(k); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class InTopKOp {
 public:
  InTopKOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "k") {
      return CastAttr(&internal_->k);
    } else {
      return Error::RuntimeError() << "InTopK op has no attribute named " << attr_name;
    }
  }

  const int32_t& k() const { return internal_->k; }
  int32_t* mutable_k() { return &internal_->k; }
  void set_k(const int32_t& k) { internal_->k = k; }

 private:
  struct Internal {
    int32_t k;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.in_top_k", InTopKOpInterpCtxImpl<schema::InTopKOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class IndexedSlicesAdamUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& learning_rate_val() const = 0;
  virtual float* mutable_learning_rate_val() = 0;
  virtual void set_learning_rate_val(const float& learning_rate_val) = 0;

  virtual const float& beta1() const = 0;
  virtual float* mutable_beta1() = 0;
  virtual void set_beta1(const float& beta1) = 0;

  virtual const float& beta2() const = 0;
  virtual float* mutable_beta2() = 0;
  virtual void set_beta2(const float& beta2) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  virtual const bool& amsgrad() const = 0;
  virtual bool* mutable_amsgrad() = 0;
  virtual void set_amsgrad(const bool& amsgrad) = 0;

  virtual const bool& do_bias_correction() const = 0;
  virtual bool* mutable_do_bias_correction() = 0;
  virtual void set_do_bias_correction(const bool& do_bias_correction) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"learning_rate_val", "beta1",        "beta2",
                                           "epsilon",           "weight_decay", "amsgrad",
                                           "do_bias_correction"};
    return attr_names;
  }
};
template<typename Provider>
class IndexedSlicesAdamUpdateOpInterpCtxImpl : public IndexedSlicesAdamUpdateOpInterpCtx {
 public:
  IndexedSlicesAdamUpdateOpInterpCtxImpl() = default;
  IndexedSlicesAdamUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& learning_rate_val() const override { return impl_.learning_rate_val(); }
  float* mutable_learning_rate_val() override { return impl_.mutable_learning_rate_val(); }
  void set_learning_rate_val(const float& learning_rate_val) override {
    impl_.set_learning_rate_val(learning_rate_val);
  }

  const float& beta1() const override { return impl_.beta1(); }
  float* mutable_beta1() override { return impl_.mutable_beta1(); }
  void set_beta1(const float& beta1) override { impl_.set_beta1(beta1); }

  const float& beta2() const override { return impl_.beta2(); }
  float* mutable_beta2() override { return impl_.mutable_beta2(); }
  void set_beta2(const float& beta2) override { impl_.set_beta2(beta2); }

  const float& epsilon() const override { return impl_.epsilon(); }
  float* mutable_epsilon() override { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) override { impl_.set_epsilon(epsilon); }

  const float& weight_decay() const override { return impl_.weight_decay(); }
  float* mutable_weight_decay() override { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) override {
    impl_.set_weight_decay(weight_decay);
  }

  const bool& amsgrad() const override { return impl_.amsgrad(); }
  bool* mutable_amsgrad() override { return impl_.mutable_amsgrad(); }
  void set_amsgrad(const bool& amsgrad) override { impl_.set_amsgrad(amsgrad); }

  const bool& do_bias_correction() const override { return impl_.do_bias_correction(); }
  bool* mutable_do_bias_correction() override { return impl_.mutable_do_bias_correction(); }
  void set_do_bias_correction(const bool& do_bias_correction) override {
    impl_.set_do_bias_correction(do_bias_correction);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class IndexedSlicesAdamUpdateOp {
 public:
  IndexedSlicesAdamUpdateOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "learning_rate_val") {
      return CastAttr(&internal_->learning_rate_val);
    } else if (attr_name == "beta1") {
      return CastAttr(&internal_->beta1);
    } else if (attr_name == "beta2") {
      return CastAttr(&internal_->beta2);
    } else if (attr_name == "epsilon") {
      return CastAttr(&internal_->epsilon);
    } else if (attr_name == "weight_decay") {
      return CastAttr(&internal_->weight_decay);
    } else if (attr_name == "amsgrad") {
      return CastAttr(&internal_->amsgrad);
    } else if (attr_name == "do_bias_correction") {
      return CastAttr(&internal_->do_bias_correction);
    } else {
      return Error::RuntimeError()
             << "IndexedSlicesAdamUpdate op has no attribute named " << attr_name;
    }
  }

  const float& learning_rate_val() const { return internal_->learning_rate_val; }
  float* mutable_learning_rate_val() { return &internal_->learning_rate_val; }
  void set_learning_rate_val(const float& learning_rate_val) {
    internal_->learning_rate_val = learning_rate_val;
  }

  const float& beta1() const { return internal_->beta1; }
  float* mutable_beta1() { return &internal_->beta1; }
  void set_beta1(const float& beta1) { internal_->beta1 = beta1; }

  const float& beta2() const { return internal_->beta2; }
  float* mutable_beta2() { return &internal_->beta2; }
  void set_beta2(const float& beta2) { internal_->beta2 = beta2; }

  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }

  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }

  const bool& amsgrad() const { return internal_->amsgrad; }
  bool* mutable_amsgrad() { return &internal_->amsgrad; }
  void set_amsgrad(const bool& amsgrad) { internal_->amsgrad = amsgrad; }

  const bool& do_bias_correction() const { return internal_->do_bias_correction; }
  bool* mutable_do_bias_correction() { return &internal_->do_bias_correction; }
  void set_do_bias_correction(const bool& do_bias_correction) {
    internal_->do_bias_correction = do_bias_correction;
  }

 private:
  struct Internal {
    float learning_rate_val;
    float beta1;
    float beta2;
    float epsilon;
    float weight_decay;
    bool amsgrad;
    bool do_bias_correction;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.indexed_slices_adam_update",
                       IndexedSlicesAdamUpdateOpInterpCtxImpl<schema::IndexedSlicesAdamUpdateOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class IndexedSlicesMomentumUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& beta() const = 0;
  virtual float* mutable_beta() = 0;
  virtual void set_beta(const float& beta) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"beta", "weight_decay"};
    return attr_names;
  }
};
template<typename Provider>
class IndexedSlicesMomentumUpdateOpInterpCtxImpl : public IndexedSlicesMomentumUpdateOpInterpCtx {
 public:
  IndexedSlicesMomentumUpdateOpInterpCtxImpl() = default;
  IndexedSlicesMomentumUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& beta() const override { return impl_.beta(); }
  float* mutable_beta() override { return impl_.mutable_beta(); }
  void set_beta(const float& beta) override { impl_.set_beta(beta); }

  const float& weight_decay() const override { return impl_.weight_decay(); }
  float* mutable_weight_decay() override { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) override {
    impl_.set_weight_decay(weight_decay);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class IndexedSlicesMomentumUpdateOp {
 public:
  IndexedSlicesMomentumUpdateOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "beta") {
      return CastAttr(&internal_->beta);
    } else if (attr_name == "weight_decay") {
      return CastAttr(&internal_->weight_decay);
    } else {
      return Error::RuntimeError()
             << "IndexedSlicesMomentumUpdate op has no attribute named " << attr_name;
    }
  }

  const float& beta() const { return internal_->beta; }
  float* mutable_beta() { return &internal_->beta; }
  void set_beta(const float& beta) { internal_->beta = beta; }

  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }

 private:
  struct Internal {
    float beta;
    float weight_decay;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.indexed_slices_momentum_update",
    IndexedSlicesMomentumUpdateOpInterpCtxImpl<schema::IndexedSlicesMomentumUpdateOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class IndexedSlicesReduceSumOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class IndexedSlicesReduceSumOpInterpCtxImpl : public IndexedSlicesReduceSumOpInterpCtx {
 public:
  IndexedSlicesReduceSumOpInterpCtxImpl() = default;
  IndexedSlicesReduceSumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class IndexedSlicesReduceSumOp {
 public:
  IndexedSlicesReduceSumOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "IndexedSlicesReduceSum op has no attribute named "
                                 << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.indexed_slices_reduce_sum",
                       IndexedSlicesReduceSumOpInterpCtxImpl<schema::IndexedSlicesReduceSumOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class IndexedSlicesSgdUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"weight_decay"};
    return attr_names;
  }
};
template<typename Provider>
class IndexedSlicesSgdUpdateOpInterpCtxImpl : public IndexedSlicesSgdUpdateOpInterpCtx {
 public:
  IndexedSlicesSgdUpdateOpInterpCtxImpl() = default;
  IndexedSlicesSgdUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& weight_decay() const override { return impl_.weight_decay(); }
  float* mutable_weight_decay() override { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) override {
    impl_.set_weight_decay(weight_decay);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class IndexedSlicesSgdUpdateOp {
 public:
  IndexedSlicesSgdUpdateOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "weight_decay") {
      return CastAttr(&internal_->weight_decay);
    } else {
      return Error::RuntimeError()
             << "IndexedSlicesSgdUpdate op has no attribute named " << attr_name;
    }
  }

  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }

 private:
  struct Internal {
    float weight_decay;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.indexed_slices_sgd_update",
                       IndexedSlicesSgdUpdateOpInterpCtxImpl<schema::IndexedSlicesSgdUpdateOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class KlDivLossOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& log_target() const = 0;
  virtual bool* mutable_log_target() = 0;
  virtual void set_log_target(const bool& log_target) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"log_target"};
    return attr_names;
  }
};
template<typename Provider>
class KlDivLossOpInterpCtxImpl : public KlDivLossOpInterpCtx {
 public:
  KlDivLossOpInterpCtxImpl() = default;
  KlDivLossOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& log_target() const override { return impl_.log_target(); }
  bool* mutable_log_target() override { return impl_.mutable_log_target(); }
  void set_log_target(const bool& log_target) override { impl_.set_log_target(log_target); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class KlDivLossOp {
 public:
  KlDivLossOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "log_target") {
      return CastAttr(&internal_->log_target);
    } else {
      return Error::RuntimeError() << "KlDivLoss op has no attribute named " << attr_name;
    }
  }

  const bool& log_target() const { return internal_->log_target; }
  bool* mutable_log_target() { return &internal_->log_target; }
  void set_log_target(const bool& log_target) { internal_->log_target = log_target; }

 private:
  struct Internal {
    bool log_target;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.kl_div_loss", KlDivLossOpInterpCtxImpl<schema::KlDivLossOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class KlDivLossGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& log_target() const = 0;
  virtual bool* mutable_log_target() = 0;
  virtual void set_log_target(const bool& log_target) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"log_target"};
    return attr_names;
  }
};
template<typename Provider>
class KlDivLossGradOpInterpCtxImpl : public KlDivLossGradOpInterpCtx {
 public:
  KlDivLossGradOpInterpCtxImpl() = default;
  KlDivLossGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& log_target() const override { return impl_.log_target(); }
  bool* mutable_log_target() override { return impl_.mutable_log_target(); }
  void set_log_target(const bool& log_target) override { impl_.set_log_target(log_target); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class KlDivLossGradOp {
 public:
  KlDivLossGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "log_target") {
      return CastAttr(&internal_->log_target);
    } else {
      return Error::RuntimeError() << "KlDivLossGrad op has no attribute named " << attr_name;
    }
  }

  const bool& log_target() const { return internal_->log_target; }
  bool* mutable_log_target() { return &internal_->log_target; }
  void set_log_target(const bool& log_target) { internal_->log_target = log_target; }

 private:
  struct Internal {
    bool log_target;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.kl_div_loss_grad",
                       KlDivLossGradOpInterpCtxImpl<schema::KlDivLossGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class L1L2RegularizeGradientOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& l1() const = 0;
  virtual float* mutable_l1() = 0;
  virtual void set_l1(const float& l1) = 0;

  virtual const float& l2() const = 0;
  virtual float* mutable_l2() = 0;
  virtual void set_l2(const float& l2) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"l1", "l2"};
    return attr_names;
  }
};
template<typename Provider>
class L1L2RegularizeGradientOpInterpCtxImpl : public L1L2RegularizeGradientOpInterpCtx {
 public:
  L1L2RegularizeGradientOpInterpCtxImpl() = default;
  L1L2RegularizeGradientOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& l1() const override { return impl_.l1(); }
  float* mutable_l1() override { return impl_.mutable_l1(); }
  void set_l1(const float& l1) override { impl_.set_l1(l1); }

  const float& l2() const override { return impl_.l2(); }
  float* mutable_l2() override { return impl_.mutable_l2(); }
  void set_l2(const float& l2) override { impl_.set_l2(l2); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class L1L2RegularizeGradientOp {
 public:
  L1L2RegularizeGradientOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "l1") {
      return CastAttr(&internal_->l1);
    } else if (attr_name == "l2") {
      return CastAttr(&internal_->l2);
    } else {
      return Error::RuntimeError()
             << "L1L2RegularizeGradient op has no attribute named " << attr_name;
    }
  }

  const float& l1() const { return internal_->l1; }
  float* mutable_l1() { return &internal_->l1; }
  void set_l1(const float& l1) { internal_->l1 = l1; }

  const float& l2() const { return internal_->l2; }
  float* mutable_l2() { return &internal_->l2; }
  void set_l2(const float& l2) { internal_->l2 = l2; }

 private:
  struct Internal {
    float l1;
    float l2;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.l1_l2_regularize_gradient",
                       L1L2RegularizeGradientOpInterpCtxImpl<schema::L1L2RegularizeGradientOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class L2NormalizeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "epsilon"};
    return attr_names;
  }
};
template<typename Provider>
class L2NormalizeOpInterpCtxImpl : public L2NormalizeOpInterpCtx {
 public:
  L2NormalizeOpInterpCtxImpl() = default;
  L2NormalizeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& axis() const override { return impl_.axis(); }
  int32_t* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) override { impl_.set_axis(axis); }

  const float& epsilon() const override { return impl_.epsilon(); }
  float* mutable_epsilon() override { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) override { impl_.set_epsilon(epsilon); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class L2NormalizeOp {
 public:
  L2NormalizeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "epsilon") {
      return CastAttr(&internal_->epsilon);
    } else {
      return Error::RuntimeError() << "L2Normalize op has no attribute named " << attr_name;
    }
  }

  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }

  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }

 private:
  struct Internal {
    int32_t axis;
    float epsilon;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.l2_normalize", L2NormalizeOpInterpCtxImpl<schema::L2NormalizeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class L2NormalizeGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "epsilon"};
    return attr_names;
  }
};
template<typename Provider>
class L2NormalizeGradOpInterpCtxImpl : public L2NormalizeGradOpInterpCtx {
 public:
  L2NormalizeGradOpInterpCtxImpl() = default;
  L2NormalizeGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& axis() const override { return impl_.axis(); }
  int32_t* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) override { impl_.set_axis(axis); }

  const float& epsilon() const override { return impl_.epsilon(); }
  float* mutable_epsilon() override { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) override { impl_.set_epsilon(epsilon); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class L2NormalizeGradOp {
 public:
  L2NormalizeGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "epsilon") {
      return CastAttr(&internal_->epsilon);
    } else {
      return Error::RuntimeError() << "L2NormalizeGrad op has no attribute named " << attr_name;
    }
  }

  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }

  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }

 private:
  struct Internal {
    int32_t axis;
    float epsilon;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.l2_normalize_grad",
                       L2NormalizeGradOpInterpCtxImpl<schema::L2NormalizeGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LambUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& beta1() const = 0;
  virtual float* mutable_beta1() = 0;
  virtual void set_beta1(const float& beta1) = 0;

  virtual const float& beta2() const = 0;
  virtual float* mutable_beta2() = 0;
  virtual void set_beta2(const float& beta2) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  virtual const double& scale() const = 0;
  virtual double* mutable_scale() = 0;
  virtual void set_scale(const double& scale) = 0;

  virtual const float& l1() const = 0;
  virtual float* mutable_l1() = 0;
  virtual void set_l1(const float& l1) = 0;

  virtual const float& l2() const = 0;
  virtual float* mutable_l2() = 0;
  virtual void set_l2(const float& l2) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"beta1", "beta2", "epsilon",     "scale",
                                           "l1",    "l2",    "weight_decay"};
    return attr_names;
  }
};
template<typename Provider>
class LambUpdateOpInterpCtxImpl : public LambUpdateOpInterpCtx {
 public:
  LambUpdateOpInterpCtxImpl() = default;
  LambUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& beta1() const override { return impl_.beta1(); }
  float* mutable_beta1() override { return impl_.mutable_beta1(); }
  void set_beta1(const float& beta1) override { impl_.set_beta1(beta1); }

  const float& beta2() const override { return impl_.beta2(); }
  float* mutable_beta2() override { return impl_.mutable_beta2(); }
  void set_beta2(const float& beta2) override { impl_.set_beta2(beta2); }

  const float& epsilon() const override { return impl_.epsilon(); }
  float* mutable_epsilon() override { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) override { impl_.set_epsilon(epsilon); }

  const double& scale() const override { return impl_.scale(); }
  double* mutable_scale() override { return impl_.mutable_scale(); }
  void set_scale(const double& scale) override { impl_.set_scale(scale); }

  const float& l1() const override { return impl_.l1(); }
  float* mutable_l1() override { return impl_.mutable_l1(); }
  void set_l1(const float& l1) override { impl_.set_l1(l1); }

  const float& l2() const override { return impl_.l2(); }
  float* mutable_l2() override { return impl_.mutable_l2(); }
  void set_l2(const float& l2) override { impl_.set_l2(l2); }

  const float& weight_decay() const override { return impl_.weight_decay(); }
  float* mutable_weight_decay() override { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) override {
    impl_.set_weight_decay(weight_decay);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LambUpdateOp {
 public:
  LambUpdateOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "beta1") {
      return CastAttr(&internal_->beta1);
    } else if (attr_name == "beta2") {
      return CastAttr(&internal_->beta2);
    } else if (attr_name == "epsilon") {
      return CastAttr(&internal_->epsilon);
    } else if (attr_name == "scale") {
      return CastAttr(&internal_->scale);
    } else if (attr_name == "l1") {
      return CastAttr(&internal_->l1);
    } else if (attr_name == "l2") {
      return CastAttr(&internal_->l2);
    } else if (attr_name == "weight_decay") {
      return CastAttr(&internal_->weight_decay);
    } else {
      return Error::RuntimeError() << "LambUpdate op has no attribute named " << attr_name;
    }
  }

  const float& beta1() const { return internal_->beta1; }
  float* mutable_beta1() { return &internal_->beta1; }
  void set_beta1(const float& beta1) { internal_->beta1 = beta1; }

  const float& beta2() const { return internal_->beta2; }
  float* mutable_beta2() { return &internal_->beta2; }
  void set_beta2(const float& beta2) { internal_->beta2 = beta2; }

  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }

  const double& scale() const { return internal_->scale; }
  double* mutable_scale() { return &internal_->scale; }
  void set_scale(const double& scale) { internal_->scale = scale; }

  const float& l1() const { return internal_->l1; }
  float* mutable_l1() { return &internal_->l1; }
  void set_l1(const float& l1) { internal_->l1 = l1; }

  const float& l2() const { return internal_->l2; }
  float* mutable_l2() { return &internal_->l2; }
  void set_l2(const float& l2) { internal_->l2 = l2; }

  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }

 private:
  struct Internal {
    float beta1;
    float beta2;
    float epsilon;
    double scale;
    float l1;
    float l2;
    float weight_decay;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.lamb_update", LambUpdateOpInterpCtxImpl<schema::LambUpdateOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LarsUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& scale() const = 0;
  virtual double* mutable_scale() = 0;
  virtual void set_scale(const double& scale) = 0;

  virtual const float& l1() const = 0;
  virtual float* mutable_l1() = 0;
  virtual void set_l1(const float& l1) = 0;

  virtual const float& l2() const = 0;
  virtual float* mutable_l2() = 0;
  virtual void set_l2(const float& l2) = 0;

  virtual const float& momentum_beta() const = 0;
  virtual float* mutable_momentum_beta() = 0;
  virtual void set_momentum_beta(const float& momentum_beta) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  virtual const float& lars_coefficient() const = 0;
  virtual float* mutable_lars_coefficient() = 0;
  virtual void set_lars_coefficient(const float& lars_coefficient) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{
        "scale", "l1", "l2", "momentum_beta", "epsilon", "lars_coefficient", "weight_decay"};
    return attr_names;
  }
};
template<typename Provider>
class LarsUpdateOpInterpCtxImpl : public LarsUpdateOpInterpCtx {
 public:
  LarsUpdateOpInterpCtxImpl() = default;
  LarsUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& scale() const override { return impl_.scale(); }
  double* mutable_scale() override { return impl_.mutable_scale(); }
  void set_scale(const double& scale) override { impl_.set_scale(scale); }

  const float& l1() const override { return impl_.l1(); }
  float* mutable_l1() override { return impl_.mutable_l1(); }
  void set_l1(const float& l1) override { impl_.set_l1(l1); }

  const float& l2() const override { return impl_.l2(); }
  float* mutable_l2() override { return impl_.mutable_l2(); }
  void set_l2(const float& l2) override { impl_.set_l2(l2); }

  const float& momentum_beta() const override { return impl_.momentum_beta(); }
  float* mutable_momentum_beta() override { return impl_.mutable_momentum_beta(); }
  void set_momentum_beta(const float& momentum_beta) override {
    impl_.set_momentum_beta(momentum_beta);
  }

  const float& epsilon() const override { return impl_.epsilon(); }
  float* mutable_epsilon() override { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) override { impl_.set_epsilon(epsilon); }

  const float& lars_coefficient() const override { return impl_.lars_coefficient(); }
  float* mutable_lars_coefficient() override { return impl_.mutable_lars_coefficient(); }
  void set_lars_coefficient(const float& lars_coefficient) override {
    impl_.set_lars_coefficient(lars_coefficient);
  }

  const float& weight_decay() const override { return impl_.weight_decay(); }
  float* mutable_weight_decay() override { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) override {
    impl_.set_weight_decay(weight_decay);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LarsUpdateOp {
 public:
  LarsUpdateOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "scale") {
      return CastAttr(&internal_->scale);
    } else if (attr_name == "l1") {
      return CastAttr(&internal_->l1);
    } else if (attr_name == "l2") {
      return CastAttr(&internal_->l2);
    } else if (attr_name == "momentum_beta") {
      return CastAttr(&internal_->momentum_beta);
    } else if (attr_name == "epsilon") {
      return CastAttr(&internal_->epsilon);
    } else if (attr_name == "lars_coefficient") {
      return CastAttr(&internal_->lars_coefficient);
    } else if (attr_name == "weight_decay") {
      return CastAttr(&internal_->weight_decay);
    } else {
      return Error::RuntimeError() << "LarsUpdate op has no attribute named " << attr_name;
    }
  }

  const double& scale() const { return internal_->scale; }
  double* mutable_scale() { return &internal_->scale; }
  void set_scale(const double& scale) { internal_->scale = scale; }

  const float& l1() const { return internal_->l1; }
  float* mutable_l1() { return &internal_->l1; }
  void set_l1(const float& l1) { internal_->l1 = l1; }

  const float& l2() const { return internal_->l2; }
  float* mutable_l2() { return &internal_->l2; }
  void set_l2(const float& l2) { internal_->l2 = l2; }

  const float& momentum_beta() const { return internal_->momentum_beta; }
  float* mutable_momentum_beta() { return &internal_->momentum_beta; }
  void set_momentum_beta(const float& momentum_beta) { internal_->momentum_beta = momentum_beta; }

  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }

  const float& lars_coefficient() const { return internal_->lars_coefficient; }
  float* mutable_lars_coefficient() { return &internal_->lars_coefficient; }
  void set_lars_coefficient(const float& lars_coefficient) {
    internal_->lars_coefficient = lars_coefficient;
  }

  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }

 private:
  struct Internal {
    double scale;
    float l1;
    float l2;
    float momentum_beta;
    float epsilon;
    float lars_coefficient;
    float weight_decay;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.lars_update", LarsUpdateOpInterpCtxImpl<schema::LarsUpdateOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LayerNormOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& center() const = 0;
  virtual bool* mutable_center() = 0;
  virtual void set_center(const bool& center) = 0;

  virtual const bool& scale() const = 0;
  virtual bool* mutable_scale() = 0;
  virtual void set_scale(const bool& scale) = 0;

  virtual const int64_t& begin_norm_axis() const = 0;
  virtual int64_t* mutable_begin_norm_axis() = 0;
  virtual void set_begin_norm_axis(const int64_t& begin_norm_axis) = 0;

  virtual const int64_t& begin_params_axis() const = 0;
  virtual int64_t* mutable_begin_params_axis() = 0;
  virtual void set_begin_params_axis(const int64_t& begin_params_axis) = 0;

  virtual const double& epsilon() const = 0;
  virtual double* mutable_epsilon() = 0;
  virtual void set_epsilon(const double& epsilon) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"center", "scale", "begin_norm_axis",
                                           "begin_params_axis", "epsilon"};
    return attr_names;
  }
};
template<typename Provider>
class LayerNormOpInterpCtxImpl : public LayerNormOpInterpCtx {
 public:
  LayerNormOpInterpCtxImpl() = default;
  LayerNormOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& center() const override { return impl_.center(); }
  bool* mutable_center() override { return impl_.mutable_center(); }
  void set_center(const bool& center) override { impl_.set_center(center); }

  const bool& scale() const override { return impl_.scale(); }
  bool* mutable_scale() override { return impl_.mutable_scale(); }
  void set_scale(const bool& scale) override { impl_.set_scale(scale); }

  const int64_t& begin_norm_axis() const override { return impl_.begin_norm_axis(); }
  int64_t* mutable_begin_norm_axis() override { return impl_.mutable_begin_norm_axis(); }
  void set_begin_norm_axis(const int64_t& begin_norm_axis) override {
    impl_.set_begin_norm_axis(begin_norm_axis);
  }

  const int64_t& begin_params_axis() const override { return impl_.begin_params_axis(); }
  int64_t* mutable_begin_params_axis() override { return impl_.mutable_begin_params_axis(); }
  void set_begin_params_axis(const int64_t& begin_params_axis) override {
    impl_.set_begin_params_axis(begin_params_axis);
  }

  const double& epsilon() const override { return impl_.epsilon(); }
  double* mutable_epsilon() override { return impl_.mutable_epsilon(); }
  void set_epsilon(const double& epsilon) override { impl_.set_epsilon(epsilon); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LayerNormOp {
 public:
  LayerNormOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "center") {
      return CastAttr(&internal_->center);
    } else if (attr_name == "scale") {
      return CastAttr(&internal_->scale);
    } else if (attr_name == "begin_norm_axis") {
      return CastAttr(&internal_->begin_norm_axis);
    } else if (attr_name == "begin_params_axis") {
      return CastAttr(&internal_->begin_params_axis);
    } else if (attr_name == "epsilon") {
      return CastAttr(&internal_->epsilon);
    } else {
      return Error::RuntimeError() << "LayerNorm op has no attribute named " << attr_name;
    }
  }

  const bool& center() const { return internal_->center; }
  bool* mutable_center() { return &internal_->center; }
  void set_center(const bool& center) { internal_->center = center; }

  const bool& scale() const { return internal_->scale; }
  bool* mutable_scale() { return &internal_->scale; }
  void set_scale(const bool& scale) { internal_->scale = scale; }

  const int64_t& begin_norm_axis() const { return internal_->begin_norm_axis; }
  int64_t* mutable_begin_norm_axis() { return &internal_->begin_norm_axis; }
  void set_begin_norm_axis(const int64_t& begin_norm_axis) {
    internal_->begin_norm_axis = begin_norm_axis;
  }

  const int64_t& begin_params_axis() const { return internal_->begin_params_axis; }
  int64_t* mutable_begin_params_axis() { return &internal_->begin_params_axis; }
  void set_begin_params_axis(const int64_t& begin_params_axis) {
    internal_->begin_params_axis = begin_params_axis;
  }

  const double& epsilon() const { return internal_->epsilon; }
  double* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const double& epsilon) { internal_->epsilon = epsilon; }

 private:
  struct Internal {
    bool center;
    bool scale;
    int64_t begin_norm_axis;
    int64_t begin_params_axis;
    double epsilon;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.layer_norm", LayerNormOpInterpCtxImpl<schema::LayerNormOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LayerNormGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& begin_norm_axis() const = 0;
  virtual int64_t* mutable_begin_norm_axis() = 0;
  virtual void set_begin_norm_axis(const int64_t& begin_norm_axis) = 0;

  virtual const double& epsilon() const = 0;
  virtual double* mutable_epsilon() = 0;
  virtual void set_epsilon(const double& epsilon) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"begin_norm_axis", "epsilon"};
    return attr_names;
  }
};
template<typename Provider>
class LayerNormGradOpInterpCtxImpl : public LayerNormGradOpInterpCtx {
 public:
  LayerNormGradOpInterpCtxImpl() = default;
  LayerNormGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& begin_norm_axis() const override { return impl_.begin_norm_axis(); }
  int64_t* mutable_begin_norm_axis() override { return impl_.mutable_begin_norm_axis(); }
  void set_begin_norm_axis(const int64_t& begin_norm_axis) override {
    impl_.set_begin_norm_axis(begin_norm_axis);
  }

  const double& epsilon() const override { return impl_.epsilon(); }
  double* mutable_epsilon() override { return impl_.mutable_epsilon(); }
  void set_epsilon(const double& epsilon) override { impl_.set_epsilon(epsilon); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LayerNormGradOp {
 public:
  LayerNormGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "begin_norm_axis") {
      return CastAttr(&internal_->begin_norm_axis);
    } else if (attr_name == "epsilon") {
      return CastAttr(&internal_->epsilon);
    } else {
      return Error::RuntimeError() << "LayerNormGrad op has no attribute named " << attr_name;
    }
  }

  const int64_t& begin_norm_axis() const { return internal_->begin_norm_axis; }
  int64_t* mutable_begin_norm_axis() { return &internal_->begin_norm_axis; }
  void set_begin_norm_axis(const int64_t& begin_norm_axis) {
    internal_->begin_norm_axis = begin_norm_axis;
  }

  const double& epsilon() const { return internal_->epsilon; }
  double* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const double& epsilon) { internal_->epsilon = epsilon; }

 private:
  struct Internal {
    int64_t begin_norm_axis;
    double epsilon;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.layer_norm_grad",
                       LayerNormGradOpInterpCtxImpl<schema::LayerNormGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LayerNormParamGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& begin_params_axis() const = 0;
  virtual int64_t* mutable_begin_params_axis() = 0;
  virtual void set_begin_params_axis(const int64_t& begin_params_axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"begin_params_axis"};
    return attr_names;
  }
};
template<typename Provider>
class LayerNormParamGradOpInterpCtxImpl : public LayerNormParamGradOpInterpCtx {
 public:
  LayerNormParamGradOpInterpCtxImpl() = default;
  LayerNormParamGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& begin_params_axis() const override { return impl_.begin_params_axis(); }
  int64_t* mutable_begin_params_axis() override { return impl_.mutable_begin_params_axis(); }
  void set_begin_params_axis(const int64_t& begin_params_axis) override {
    impl_.set_begin_params_axis(begin_params_axis);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LayerNormParamGradOp {
 public:
  LayerNormParamGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "begin_params_axis") {
      return CastAttr(&internal_->begin_params_axis);
    } else {
      return Error::RuntimeError() << "LayerNormParamGrad op has no attribute named " << attr_name;
    }
  }

  const int64_t& begin_params_axis() const { return internal_->begin_params_axis; }
  int64_t* mutable_begin_params_axis() { return &internal_->begin_params_axis; }
  void set_begin_params_axis(const int64_t& begin_params_axis) {
    internal_->begin_params_axis = begin_params_axis;
  }

 private:
  struct Internal {
    int64_t begin_params_axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.layer_norm_param_grad",
                       LayerNormParamGradOpInterpCtxImpl<schema::LayerNormParamGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LeakyReluOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& alpha() const = 0;
  virtual float* mutable_alpha() = 0;
  virtual void set_alpha(const float& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"alpha"};
    return attr_names;
  }
};
template<typename Provider>
class LeakyReluOpInterpCtxImpl : public LeakyReluOpInterpCtx {
 public:
  LeakyReluOpInterpCtxImpl() = default;
  LeakyReluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& alpha() const override { return impl_.alpha(); }
  float* mutable_alpha() override { return impl_.mutable_alpha(); }
  void set_alpha(const float& alpha) override { impl_.set_alpha(alpha); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LeakyReluOp {
 public:
  LeakyReluOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "alpha") {
      return CastAttr(&internal_->alpha);
    } else {
      return Error::RuntimeError() << "LeakyRelu op has no attribute named " << attr_name;
    }
  }

  const float& alpha() const { return internal_->alpha; }
  float* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const float& alpha) { internal_->alpha = alpha; }

 private:
  struct Internal {
    float alpha;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.leaky_relu", LeakyReluOpInterpCtxImpl<schema::LeakyReluOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LeakyReluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& alpha() const = 0;
  virtual float* mutable_alpha() = 0;
  virtual void set_alpha(const float& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"alpha"};
    return attr_names;
  }
};
template<typename Provider>
class LeakyReluGradOpInterpCtxImpl : public LeakyReluGradOpInterpCtx {
 public:
  LeakyReluGradOpInterpCtxImpl() = default;
  LeakyReluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& alpha() const override { return impl_.alpha(); }
  float* mutable_alpha() override { return impl_.mutable_alpha(); }
  void set_alpha(const float& alpha) override { impl_.set_alpha(alpha); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LeakyReluGradOp {
 public:
  LeakyReluGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "alpha") {
      return CastAttr(&internal_->alpha);
    } else {
      return Error::RuntimeError() << "LeakyReluGrad op has no attribute named " << attr_name;
    }
  }

  const float& alpha() const { return internal_->alpha; }
  float* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const float& alpha) { internal_->alpha = alpha; }

 private:
  struct Internal {
    float alpha;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.leaky_relu_grad",
                       LeakyReluGradOpInterpCtxImpl<schema::LeakyReluGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LgammaOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class LgammaOpInterpCtxImpl : public LgammaOpInterpCtx {
 public:
  LgammaOpInterpCtxImpl() = default;
  LgammaOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LgammaOp {
 public:
  LgammaOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Lgamma op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.lgamma", LgammaOpInterpCtxImpl<schema::LgammaOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LgammaGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class LgammaGradOpInterpCtxImpl : public LgammaGradOpInterpCtx {
 public:
  LgammaGradOpInterpCtxImpl() = default;
  LgammaGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LgammaGradOp {
 public:
  LgammaGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "LgammaGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.lgamma_grad", LgammaGradOpInterpCtxImpl<schema::LgammaGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LogOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class LogOpInterpCtxImpl : public LogOpInterpCtx {
 public:
  LogOpInterpCtxImpl() = default;
  LogOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogOp {
 public:
  LogOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Log op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.log", LogOpInterpCtxImpl<schema::LogOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class Log1pOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class Log1pOpInterpCtxImpl : public Log1pOpInterpCtx {
 public:
  Log1pOpInterpCtxImpl() = default;
  Log1pOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Log1pOp {
 public:
  Log1pOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Log1p op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.log1p", Log1pOpInterpCtxImpl<schema::Log1pOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class Log1pGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class Log1pGradOpInterpCtxImpl : public Log1pGradOpInterpCtx {
 public:
  Log1pGradOpInterpCtxImpl() = default;
  Log1pGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class Log1pGradOp {
 public:
  Log1pGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Log1pGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.log1p_grad", Log1pGradOpInterpCtxImpl<schema::Log1pGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LogGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class LogGradOpInterpCtxImpl : public LogGradOpInterpCtx {
 public:
  LogGradOpInterpCtxImpl() = default;
  LogGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogGradOp {
 public:
  LogGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "LogGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.log_grad", LogGradOpInterpCtxImpl<schema::LogGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LogSigmoidOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class LogSigmoidOpInterpCtxImpl : public LogSigmoidOpInterpCtx {
 public:
  LogSigmoidOpInterpCtxImpl() = default;
  LogSigmoidOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogSigmoidOp {
 public:
  LogSigmoidOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "LogSigmoid op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.log_sigmoid", LogSigmoidOpInterpCtxImpl<schema::LogSigmoidOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LogSigmoidGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class LogSigmoidGradOpInterpCtxImpl : public LogSigmoidGradOpInterpCtx {
 public:
  LogSigmoidGradOpInterpCtxImpl() = default;
  LogSigmoidGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogSigmoidGradOp {
 public:
  LogSigmoidGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "LogSigmoidGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.log_sigmoid_grad",
                       LogSigmoidGradOpInterpCtxImpl<schema::LogSigmoidGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LogSoftmaxOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class LogSoftmaxOpInterpCtxImpl : public LogSoftmaxOpInterpCtx {
 public:
  LogSoftmaxOpInterpCtxImpl() = default;
  LogSoftmaxOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogSoftmaxOp {
 public:
  LogSoftmaxOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "LogSoftmax op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.log_softmax", LogSoftmaxOpInterpCtxImpl<schema::LogSoftmaxOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LogSoftmaxGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class LogSoftmaxGradOpInterpCtxImpl : public LogSoftmaxGradOpInterpCtx {
 public:
  LogSoftmaxGradOpInterpCtxImpl() = default;
  LogSoftmaxGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogSoftmaxGradOp {
 public:
  LogSoftmaxGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "LogSoftmaxGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.log_softmax_grad",
                       LogSoftmaxGradOpInterpCtxImpl<schema::LogSoftmaxGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LogicalNotOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class LogicalNotOpInterpCtxImpl : public LogicalNotOpInterpCtx {
 public:
  LogicalNotOpInterpCtxImpl() = default;
  LogicalNotOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogicalNotOp {
 public:
  LogicalNotOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "LogicalNot op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.logical_not", LogicalNotOpInterpCtxImpl<schema::LogicalNotOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LogicalSliceOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& start() const = 0;
  virtual std::vector<int64_t>* mutable_start() = 0;
  virtual void set_start(const std::vector<int64_t>& start) = 0;

  virtual const std::vector<int64_t>& stop() const = 0;
  virtual std::vector<int64_t>* mutable_stop() = 0;
  virtual void set_stop(const std::vector<int64_t>& stop) = 0;

  virtual const std::vector<int64_t>& step() const = 0;
  virtual std::vector<int64_t>* mutable_step() = 0;
  virtual void set_step(const std::vector<int64_t>& step) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"start", "stop", "step"};
    return attr_names;
  }
};
template<typename Provider>
class LogicalSliceOpInterpCtxImpl : public LogicalSliceOpInterpCtx {
 public:
  LogicalSliceOpInterpCtxImpl() = default;
  LogicalSliceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& start() const override { return impl_.start(); }
  std::vector<int64_t>* mutable_start() override { return impl_.mutable_start(); }
  void set_start(const std::vector<int64_t>& start) override { impl_.set_start(start); }

  const std::vector<int64_t>& stop() const override { return impl_.stop(); }
  std::vector<int64_t>* mutable_stop() override { return impl_.mutable_stop(); }
  void set_stop(const std::vector<int64_t>& stop) override { impl_.set_stop(stop); }

  const std::vector<int64_t>& step() const override { return impl_.step(); }
  std::vector<int64_t>* mutable_step() override { return impl_.mutable_step(); }
  void set_step(const std::vector<int64_t>& step) override { impl_.set_step(step); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogicalSliceOp {
 public:
  LogicalSliceOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "start") {
      return CastAttr(&internal_->start);
    } else if (attr_name == "stop") {
      return CastAttr(&internal_->stop);
    } else if (attr_name == "step") {
      return CastAttr(&internal_->step);
    } else {
      return Error::RuntimeError() << "LogicalSlice op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& start() const { return internal_->start; }
  std::vector<int64_t>* mutable_start() { return &internal_->start; }
  void set_start(const std::vector<int64_t>& start) { internal_->start = start; }

  const std::vector<int64_t>& stop() const { return internal_->stop; }
  std::vector<int64_t>* mutable_stop() { return &internal_->stop; }
  void set_stop(const std::vector<int64_t>& stop) { internal_->stop = stop; }

  const std::vector<int64_t>& step() const { return internal_->step; }
  std::vector<int64_t>* mutable_step() { return &internal_->step; }
  void set_step(const std::vector<int64_t>& step) { internal_->step = step; }

 private:
  struct Internal {
    std::vector<int64_t> start;
    std::vector<int64_t> stop;
    std::vector<int64_t> step;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.logical_slice", LogicalSliceOpInterpCtxImpl<schema::LogicalSliceOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class LogicalSliceAssignOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& start() const = 0;
  virtual std::vector<int64_t>* mutable_start() = 0;
  virtual void set_start(const std::vector<int64_t>& start) = 0;

  virtual const std::vector<int64_t>& stop() const = 0;
  virtual std::vector<int64_t>* mutable_stop() = 0;
  virtual void set_stop(const std::vector<int64_t>& stop) = 0;

  virtual const std::vector<int64_t>& step() const = 0;
  virtual std::vector<int64_t>* mutable_step() = 0;
  virtual void set_step(const std::vector<int64_t>& step) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"start", "stop", "step"};
    return attr_names;
  }
};
template<typename Provider>
class LogicalSliceAssignOpInterpCtxImpl : public LogicalSliceAssignOpInterpCtx {
 public:
  LogicalSliceAssignOpInterpCtxImpl() = default;
  LogicalSliceAssignOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& start() const override { return impl_.start(); }
  std::vector<int64_t>* mutable_start() override { return impl_.mutable_start(); }
  void set_start(const std::vector<int64_t>& start) override { impl_.set_start(start); }

  const std::vector<int64_t>& stop() const override { return impl_.stop(); }
  std::vector<int64_t>* mutable_stop() override { return impl_.mutable_stop(); }
  void set_stop(const std::vector<int64_t>& stop) override { impl_.set_stop(stop); }

  const std::vector<int64_t>& step() const override { return impl_.step(); }
  std::vector<int64_t>* mutable_step() override { return impl_.mutable_step(); }
  void set_step(const std::vector<int64_t>& step) override { impl_.set_step(step); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class LogicalSliceAssignOp {
 public:
  LogicalSliceAssignOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "start") {
      return CastAttr(&internal_->start);
    } else if (attr_name == "stop") {
      return CastAttr(&internal_->stop);
    } else if (attr_name == "step") {
      return CastAttr(&internal_->step);
    } else {
      return Error::RuntimeError() << "LogicalSliceAssign op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& start() const { return internal_->start; }
  std::vector<int64_t>* mutable_start() { return &internal_->start; }
  void set_start(const std::vector<int64_t>& start) { internal_->start = start; }

  const std::vector<int64_t>& stop() const { return internal_->stop; }
  std::vector<int64_t>* mutable_stop() { return &internal_->stop; }
  void set_stop(const std::vector<int64_t>& stop) { internal_->stop = stop; }

  const std::vector<int64_t>& step() const { return internal_->step; }
  std::vector<int64_t>* mutable_step() { return &internal_->step; }
  void set_step(const std::vector<int64_t>& step) { internal_->step = step; }

 private:
  struct Internal {
    std::vector<int64_t> start;
    std::vector<int64_t> stop;
    std::vector<int64_t> step;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.logical_slice_assign",
                       LogicalSliceAssignOpInterpCtxImpl<schema::LogicalSliceAssignOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MaskedFillOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class MaskedFillOpInterpCtxImpl : public MaskedFillOpInterpCtx {
 public:
  MaskedFillOpInterpCtxImpl() = default;
  MaskedFillOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MaskedFillOp {
 public:
  MaskedFillOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError() << "MaskedFill op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.masked_fill", MaskedFillOpInterpCtxImpl<schema::MaskedFillOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MatmulOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& transpose_a() const = 0;
  virtual bool* mutable_transpose_a() = 0;
  virtual void set_transpose_a(const bool& transpose_a) = 0;

  virtual const bool& transpose_b() const = 0;
  virtual bool* mutable_transpose_b() = 0;
  virtual void set_transpose_b(const bool& transpose_b) = 0;

  virtual const double& alpha() const = 0;
  virtual double* mutable_alpha() = 0;
  virtual void set_alpha(const double& alpha) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"transpose_a", "transpose_b", "alpha"};
    return attr_names;
  }
};
template<typename Provider>
class MatmulOpInterpCtxImpl : public MatmulOpInterpCtx {
 public:
  MatmulOpInterpCtxImpl() = default;
  MatmulOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& transpose_a() const override { return impl_.transpose_a(); }
  bool* mutable_transpose_a() override { return impl_.mutable_transpose_a(); }
  void set_transpose_a(const bool& transpose_a) override { impl_.set_transpose_a(transpose_a); }

  const bool& transpose_b() const override { return impl_.transpose_b(); }
  bool* mutable_transpose_b() override { return impl_.mutable_transpose_b(); }
  void set_transpose_b(const bool& transpose_b) override { impl_.set_transpose_b(transpose_b); }

  const double& alpha() const override { return impl_.alpha(); }
  double* mutable_alpha() override { return impl_.mutable_alpha(); }
  void set_alpha(const double& alpha) override { impl_.set_alpha(alpha); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MatmulOp {
 public:
  MatmulOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "transpose_a") {
      return CastAttr(&internal_->transpose_a);
    } else if (attr_name == "transpose_b") {
      return CastAttr(&internal_->transpose_b);
    } else if (attr_name == "alpha") {
      return CastAttr(&internal_->alpha);
    } else {
      return Error::RuntimeError() << "Matmul op has no attribute named " << attr_name;
    }
  }

  const bool& transpose_a() const { return internal_->transpose_a; }
  bool* mutable_transpose_a() { return &internal_->transpose_a; }
  void set_transpose_a(const bool& transpose_a) { internal_->transpose_a = transpose_a; }

  const bool& transpose_b() const { return internal_->transpose_b; }
  bool* mutable_transpose_b() { return &internal_->transpose_b; }
  void set_transpose_b(const bool& transpose_b) { internal_->transpose_b = transpose_b; }

  const double& alpha() const { return internal_->alpha; }
  double* mutable_alpha() { return &internal_->alpha; }
  void set_alpha(const double& alpha) { internal_->alpha = alpha; }

 private:
  struct Internal {
    bool transpose_a;
    bool transpose_b;
    double alpha;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.matmul", MatmulOpInterpCtxImpl<schema::MatmulOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MaxPool1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& padding() const = 0;
  virtual std::vector<int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int32_t>& padding) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& stride() const = 0;
  virtual std::vector<int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<int32_t>& stride) = 0;

  virtual const std::vector<int32_t>& dilation() const = 0;
  virtual std::vector<int32_t>* mutable_dilation() = 0;
  virtual void set_dilation(const std::vector<int32_t>& dilation) = 0;

  virtual const bool& return_indices() const = 0;
  virtual bool* mutable_return_indices() = 0;
  virtual void set_return_indices(const bool& return_indices) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",  "data_format",    "kernel_size", "stride",
                                           "dilation", "return_indices", "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class MaxPool1DOpInterpCtxImpl : public MaxPool1DOpInterpCtx {
 public:
  MaxPool1DOpInterpCtxImpl() = default;
  MaxPool1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& padding() const override { return impl_.padding(); }
  std::vector<int32_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int32_t>& padding) override { impl_.set_padding(padding); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& stride() const override { return impl_.stride(); }
  std::vector<int32_t>* mutable_stride() override { return impl_.mutable_stride(); }
  void set_stride(const std::vector<int32_t>& stride) override { impl_.set_stride(stride); }

  const std::vector<int32_t>& dilation() const override { return impl_.dilation(); }
  std::vector<int32_t>* mutable_dilation() override { return impl_.mutable_dilation(); }
  void set_dilation(const std::vector<int32_t>& dilation) override { impl_.set_dilation(dilation); }

  const bool& return_indices() const override { return impl_.return_indices(); }
  bool* mutable_return_indices() override { return impl_.mutable_return_indices(); }
  void set_return_indices(const bool& return_indices) override {
    impl_.set_return_indices(return_indices);
  }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MaxPool1DOp {
 public:
  MaxPool1DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "stride") {
      return CastAttr(&internal_->stride);
    } else if (attr_name == "dilation") {
      return CastAttr(&internal_->dilation);
    } else if (attr_name == "return_indices") {
      return CastAttr(&internal_->return_indices);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "MaxPool1D op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& padding() const { return internal_->padding; }
  std::vector<int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int32_t>& padding) { internal_->padding = padding; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& stride() const { return internal_->stride; }
  std::vector<int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<int32_t>& stride) { internal_->stride = stride; }

  const std::vector<int32_t>& dilation() const { return internal_->dilation; }
  std::vector<int32_t>* mutable_dilation() { return &internal_->dilation; }
  void set_dilation(const std::vector<int32_t>& dilation) { internal_->dilation = dilation; }

  const bool& return_indices() const { return internal_->return_indices; }
  bool* mutable_return_indices() { return &internal_->return_indices; }
  void set_return_indices(const bool& return_indices) {
    internal_->return_indices = return_indices;
  }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::vector<int32_t> padding;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> stride;
    std::vector<int32_t> dilation;
    bool return_indices;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.maxpool_1d", MaxPool1DOpInterpCtxImpl<schema::MaxPool1DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MaxPool1DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& padding() const = 0;
  virtual std::vector<int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int32_t>& padding) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& stride() const = 0;
  virtual std::vector<int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<int32_t>& stride) = 0;

  virtual const std::vector<int32_t>& dilation() const = 0;
  virtual std::vector<int32_t>* mutable_dilation() = 0;
  virtual void set_dilation(const std::vector<int32_t>& dilation) = 0;

  virtual const bool& return_indices() const = 0;
  virtual bool* mutable_return_indices() = 0;
  virtual void set_return_indices(const bool& return_indices) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",  "data_format",    "kernel_size", "stride",
                                           "dilation", "return_indices", "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class MaxPool1DGradOpInterpCtxImpl : public MaxPool1DGradOpInterpCtx {
 public:
  MaxPool1DGradOpInterpCtxImpl() = default;
  MaxPool1DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& padding() const override { return impl_.padding(); }
  std::vector<int32_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int32_t>& padding) override { impl_.set_padding(padding); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& stride() const override { return impl_.stride(); }
  std::vector<int32_t>* mutable_stride() override { return impl_.mutable_stride(); }
  void set_stride(const std::vector<int32_t>& stride) override { impl_.set_stride(stride); }

  const std::vector<int32_t>& dilation() const override { return impl_.dilation(); }
  std::vector<int32_t>* mutable_dilation() override { return impl_.mutable_dilation(); }
  void set_dilation(const std::vector<int32_t>& dilation) override { impl_.set_dilation(dilation); }

  const bool& return_indices() const override { return impl_.return_indices(); }
  bool* mutable_return_indices() override { return impl_.mutable_return_indices(); }
  void set_return_indices(const bool& return_indices) override {
    impl_.set_return_indices(return_indices);
  }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MaxPool1DGradOp {
 public:
  MaxPool1DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "stride") {
      return CastAttr(&internal_->stride);
    } else if (attr_name == "dilation") {
      return CastAttr(&internal_->dilation);
    } else if (attr_name == "return_indices") {
      return CastAttr(&internal_->return_indices);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "MaxPool1DGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& padding() const { return internal_->padding; }
  std::vector<int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int32_t>& padding) { internal_->padding = padding; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& stride() const { return internal_->stride; }
  std::vector<int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<int32_t>& stride) { internal_->stride = stride; }

  const std::vector<int32_t>& dilation() const { return internal_->dilation; }
  std::vector<int32_t>* mutable_dilation() { return &internal_->dilation; }
  void set_dilation(const std::vector<int32_t>& dilation) { internal_->dilation = dilation; }

  const bool& return_indices() const { return internal_->return_indices; }
  bool* mutable_return_indices() { return &internal_->return_indices; }
  void set_return_indices(const bool& return_indices) {
    internal_->return_indices = return_indices;
  }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::vector<int32_t> padding;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> stride;
    std::vector<int32_t> dilation;
    bool return_indices;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.maxpool_1d_grad",
                       MaxPool1DGradOpInterpCtxImpl<schema::MaxPool1DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MaxPool2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& padding() const = 0;
  virtual std::vector<int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int32_t>& padding) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& stride() const = 0;
  virtual std::vector<int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<int32_t>& stride) = 0;

  virtual const std::vector<int32_t>& dilation() const = 0;
  virtual std::vector<int32_t>* mutable_dilation() = 0;
  virtual void set_dilation(const std::vector<int32_t>& dilation) = 0;

  virtual const bool& return_indices() const = 0;
  virtual bool* mutable_return_indices() = 0;
  virtual void set_return_indices(const bool& return_indices) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",  "data_format",    "kernel_size", "stride",
                                           "dilation", "return_indices", "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class MaxPool2DOpInterpCtxImpl : public MaxPool2DOpInterpCtx {
 public:
  MaxPool2DOpInterpCtxImpl() = default;
  MaxPool2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& padding() const override { return impl_.padding(); }
  std::vector<int32_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int32_t>& padding) override { impl_.set_padding(padding); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& stride() const override { return impl_.stride(); }
  std::vector<int32_t>* mutable_stride() override { return impl_.mutable_stride(); }
  void set_stride(const std::vector<int32_t>& stride) override { impl_.set_stride(stride); }

  const std::vector<int32_t>& dilation() const override { return impl_.dilation(); }
  std::vector<int32_t>* mutable_dilation() override { return impl_.mutable_dilation(); }
  void set_dilation(const std::vector<int32_t>& dilation) override { impl_.set_dilation(dilation); }

  const bool& return_indices() const override { return impl_.return_indices(); }
  bool* mutable_return_indices() override { return impl_.mutable_return_indices(); }
  void set_return_indices(const bool& return_indices) override {
    impl_.set_return_indices(return_indices);
  }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MaxPool2DOp {
 public:
  MaxPool2DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "stride") {
      return CastAttr(&internal_->stride);
    } else if (attr_name == "dilation") {
      return CastAttr(&internal_->dilation);
    } else if (attr_name == "return_indices") {
      return CastAttr(&internal_->return_indices);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "MaxPool2D op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& padding() const { return internal_->padding; }
  std::vector<int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int32_t>& padding) { internal_->padding = padding; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& stride() const { return internal_->stride; }
  std::vector<int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<int32_t>& stride) { internal_->stride = stride; }

  const std::vector<int32_t>& dilation() const { return internal_->dilation; }
  std::vector<int32_t>* mutable_dilation() { return &internal_->dilation; }
  void set_dilation(const std::vector<int32_t>& dilation) { internal_->dilation = dilation; }

  const bool& return_indices() const { return internal_->return_indices; }
  bool* mutable_return_indices() { return &internal_->return_indices; }
  void set_return_indices(const bool& return_indices) {
    internal_->return_indices = return_indices;
  }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::vector<int32_t> padding;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> stride;
    std::vector<int32_t> dilation;
    bool return_indices;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.maxpool_2d", MaxPool2DOpInterpCtxImpl<schema::MaxPool2DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MaxPool2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& padding() const = 0;
  virtual std::vector<int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int32_t>& padding) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& stride() const = 0;
  virtual std::vector<int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<int32_t>& stride) = 0;

  virtual const std::vector<int32_t>& dilation() const = 0;
  virtual std::vector<int32_t>* mutable_dilation() = 0;
  virtual void set_dilation(const std::vector<int32_t>& dilation) = 0;

  virtual const bool& return_indices() const = 0;
  virtual bool* mutable_return_indices() = 0;
  virtual void set_return_indices(const bool& return_indices) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",  "data_format",    "kernel_size", "stride",
                                           "dilation", "return_indices", "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class MaxPool2DGradOpInterpCtxImpl : public MaxPool2DGradOpInterpCtx {
 public:
  MaxPool2DGradOpInterpCtxImpl() = default;
  MaxPool2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& padding() const override { return impl_.padding(); }
  std::vector<int32_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int32_t>& padding) override { impl_.set_padding(padding); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& stride() const override { return impl_.stride(); }
  std::vector<int32_t>* mutable_stride() override { return impl_.mutable_stride(); }
  void set_stride(const std::vector<int32_t>& stride) override { impl_.set_stride(stride); }

  const std::vector<int32_t>& dilation() const override { return impl_.dilation(); }
  std::vector<int32_t>* mutable_dilation() override { return impl_.mutable_dilation(); }
  void set_dilation(const std::vector<int32_t>& dilation) override { impl_.set_dilation(dilation); }

  const bool& return_indices() const override { return impl_.return_indices(); }
  bool* mutable_return_indices() override { return impl_.mutable_return_indices(); }
  void set_return_indices(const bool& return_indices) override {
    impl_.set_return_indices(return_indices);
  }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MaxPool2DGradOp {
 public:
  MaxPool2DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "stride") {
      return CastAttr(&internal_->stride);
    } else if (attr_name == "dilation") {
      return CastAttr(&internal_->dilation);
    } else if (attr_name == "return_indices") {
      return CastAttr(&internal_->return_indices);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "MaxPool2DGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& padding() const { return internal_->padding; }
  std::vector<int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int32_t>& padding) { internal_->padding = padding; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& stride() const { return internal_->stride; }
  std::vector<int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<int32_t>& stride) { internal_->stride = stride; }

  const std::vector<int32_t>& dilation() const { return internal_->dilation; }
  std::vector<int32_t>* mutable_dilation() { return &internal_->dilation; }
  void set_dilation(const std::vector<int32_t>& dilation) { internal_->dilation = dilation; }

  const bool& return_indices() const { return internal_->return_indices; }
  bool* mutable_return_indices() { return &internal_->return_indices; }
  void set_return_indices(const bool& return_indices) {
    internal_->return_indices = return_indices;
  }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::vector<int32_t> padding;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> stride;
    std::vector<int32_t> dilation;
    bool return_indices;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.maxpool_2d_grad",
                       MaxPool2DGradOpInterpCtxImpl<schema::MaxPool2DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MaxPool3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& padding() const = 0;
  virtual std::vector<int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int32_t>& padding) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& stride() const = 0;
  virtual std::vector<int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<int32_t>& stride) = 0;

  virtual const std::vector<int32_t>& dilation() const = 0;
  virtual std::vector<int32_t>* mutable_dilation() = 0;
  virtual void set_dilation(const std::vector<int32_t>& dilation) = 0;

  virtual const bool& return_indices() const = 0;
  virtual bool* mutable_return_indices() = 0;
  virtual void set_return_indices(const bool& return_indices) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",  "data_format",    "kernel_size", "stride",
                                           "dilation", "return_indices", "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class MaxPool3DOpInterpCtxImpl : public MaxPool3DOpInterpCtx {
 public:
  MaxPool3DOpInterpCtxImpl() = default;
  MaxPool3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& padding() const override { return impl_.padding(); }
  std::vector<int32_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int32_t>& padding) override { impl_.set_padding(padding); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& stride() const override { return impl_.stride(); }
  std::vector<int32_t>* mutable_stride() override { return impl_.mutable_stride(); }
  void set_stride(const std::vector<int32_t>& stride) override { impl_.set_stride(stride); }

  const std::vector<int32_t>& dilation() const override { return impl_.dilation(); }
  std::vector<int32_t>* mutable_dilation() override { return impl_.mutable_dilation(); }
  void set_dilation(const std::vector<int32_t>& dilation) override { impl_.set_dilation(dilation); }

  const bool& return_indices() const override { return impl_.return_indices(); }
  bool* mutable_return_indices() override { return impl_.mutable_return_indices(); }
  void set_return_indices(const bool& return_indices) override {
    impl_.set_return_indices(return_indices);
  }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MaxPool3DOp {
 public:
  MaxPool3DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "stride") {
      return CastAttr(&internal_->stride);
    } else if (attr_name == "dilation") {
      return CastAttr(&internal_->dilation);
    } else if (attr_name == "return_indices") {
      return CastAttr(&internal_->return_indices);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "MaxPool3D op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& padding() const { return internal_->padding; }
  std::vector<int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int32_t>& padding) { internal_->padding = padding; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& stride() const { return internal_->stride; }
  std::vector<int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<int32_t>& stride) { internal_->stride = stride; }

  const std::vector<int32_t>& dilation() const { return internal_->dilation; }
  std::vector<int32_t>* mutable_dilation() { return &internal_->dilation; }
  void set_dilation(const std::vector<int32_t>& dilation) { internal_->dilation = dilation; }

  const bool& return_indices() const { return internal_->return_indices; }
  bool* mutable_return_indices() { return &internal_->return_indices; }
  void set_return_indices(const bool& return_indices) {
    internal_->return_indices = return_indices;
  }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::vector<int32_t> padding;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> stride;
    std::vector<int32_t> dilation;
    bool return_indices;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.maxpool_3d", MaxPool3DOpInterpCtxImpl<schema::MaxPool3DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MaxPool3DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& padding() const = 0;
  virtual std::vector<int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int32_t>& padding) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& stride() const = 0;
  virtual std::vector<int32_t>* mutable_stride() = 0;
  virtual void set_stride(const std::vector<int32_t>& stride) = 0;

  virtual const std::vector<int32_t>& dilation() const = 0;
  virtual std::vector<int32_t>* mutable_dilation() = 0;
  virtual void set_dilation(const std::vector<int32_t>& dilation) = 0;

  virtual const bool& return_indices() const = 0;
  virtual bool* mutable_return_indices() = 0;
  virtual void set_return_indices(const bool& return_indices) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",  "data_format",    "kernel_size", "stride",
                                           "dilation", "return_indices", "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class MaxPool3DGradOpInterpCtxImpl : public MaxPool3DGradOpInterpCtx {
 public:
  MaxPool3DGradOpInterpCtxImpl() = default;
  MaxPool3DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& padding() const override { return impl_.padding(); }
  std::vector<int32_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int32_t>& padding) override { impl_.set_padding(padding); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& stride() const override { return impl_.stride(); }
  std::vector<int32_t>* mutable_stride() override { return impl_.mutable_stride(); }
  void set_stride(const std::vector<int32_t>& stride) override { impl_.set_stride(stride); }

  const std::vector<int32_t>& dilation() const override { return impl_.dilation(); }
  std::vector<int32_t>* mutable_dilation() override { return impl_.mutable_dilation(); }
  void set_dilation(const std::vector<int32_t>& dilation) override { impl_.set_dilation(dilation); }

  const bool& return_indices() const override { return impl_.return_indices(); }
  bool* mutable_return_indices() override { return impl_.mutable_return_indices(); }
  void set_return_indices(const bool& return_indices) override {
    impl_.set_return_indices(return_indices);
  }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MaxPool3DGradOp {
 public:
  MaxPool3DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "stride") {
      return CastAttr(&internal_->stride);
    } else if (attr_name == "dilation") {
      return CastAttr(&internal_->dilation);
    } else if (attr_name == "return_indices") {
      return CastAttr(&internal_->return_indices);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "MaxPool3DGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& padding() const { return internal_->padding; }
  std::vector<int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int32_t>& padding) { internal_->padding = padding; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& stride() const { return internal_->stride; }
  std::vector<int32_t>* mutable_stride() { return &internal_->stride; }
  void set_stride(const std::vector<int32_t>& stride) { internal_->stride = stride; }

  const std::vector<int32_t>& dilation() const { return internal_->dilation; }
  std::vector<int32_t>* mutable_dilation() { return &internal_->dilation; }
  void set_dilation(const std::vector<int32_t>& dilation) { internal_->dilation = dilation; }

  const bool& return_indices() const { return internal_->return_indices; }
  bool* mutable_return_indices() { return &internal_->return_indices; }
  void set_return_indices(const bool& return_indices) {
    internal_->return_indices = return_indices;
  }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::vector<int32_t> padding;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> stride;
    std::vector<int32_t> dilation;
    bool return_indices;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.maxpool_3d_grad",
                       MaxPool3DGradOpInterpCtxImpl<schema::MaxPool3DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MegatronGptMmapDataLoaderOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& data_file_prefix() const = 0;
  virtual std::string* mutable_data_file_prefix() = 0;
  virtual void set_data_file_prefix(const std::string& data_file_prefix) = 0;

  virtual const int64_t& seq_length() const = 0;
  virtual int64_t* mutable_seq_length() = 0;
  virtual void set_seq_length(const int64_t& seq_length) = 0;

  virtual const int64_t& label_length() const = 0;
  virtual int64_t* mutable_label_length() = 0;
  virtual void set_label_length(const int64_t& label_length) = 0;

  virtual const int64_t& num_samples() const = 0;
  virtual int64_t* mutable_num_samples() = 0;
  virtual void set_num_samples(const int64_t& num_samples) = 0;

  virtual const int64_t& batch_size() const = 0;
  virtual int64_t* mutable_batch_size() = 0;
  virtual void set_batch_size(const int64_t& batch_size) = 0;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const std::vector<int64_t>& split_sizes() const = 0;
  virtual std::vector<int64_t>* mutable_split_sizes() = 0;
  virtual void set_split_sizes(const std::vector<int64_t>& split_sizes) = 0;

  virtual const int64_t& split_index() const = 0;
  virtual int64_t* mutable_split_index() = 0;
  virtual void set_split_index(const int64_t& split_index) = 0;

  virtual const bool& shuffle() const = 0;
  virtual bool* mutable_shuffle() = 0;
  virtual void set_shuffle(const bool& shuffle) = 0;

  virtual const int64_t& random_seed() const = 0;
  virtual int64_t* mutable_random_seed() = 0;
  virtual void set_random_seed(const int64_t& random_seed) = 0;

  virtual const std::vector<std::string>& nd_sbp() const = 0;
  virtual std::vector<std::string>* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::vector<std::string>& nd_sbp) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{
        "data_file_prefix", "seq_length",  "label_length", "num_samples", "batch_size", "dtype",
        "split_sizes",      "split_index", "shuffle",      "random_seed", "nd_sbp"};
    return attr_names;
  }
};
template<typename Provider>
class MegatronGptMmapDataLoaderOpInterpCtxImpl : public MegatronGptMmapDataLoaderOpInterpCtx {
 public:
  MegatronGptMmapDataLoaderOpInterpCtxImpl() = default;
  MegatronGptMmapDataLoaderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& data_file_prefix() const override { return impl_.data_file_prefix(); }
  std::string* mutable_data_file_prefix() override { return impl_.mutable_data_file_prefix(); }
  void set_data_file_prefix(const std::string& data_file_prefix) override {
    impl_.set_data_file_prefix(data_file_prefix);
  }

  const int64_t& seq_length() const override { return impl_.seq_length(); }
  int64_t* mutable_seq_length() override { return impl_.mutable_seq_length(); }
  void set_seq_length(const int64_t& seq_length) override { impl_.set_seq_length(seq_length); }

  const int64_t& label_length() const override { return impl_.label_length(); }
  int64_t* mutable_label_length() override { return impl_.mutable_label_length(); }
  void set_label_length(const int64_t& label_length) override {
    impl_.set_label_length(label_length);
  }

  const int64_t& num_samples() const override { return impl_.num_samples(); }
  int64_t* mutable_num_samples() override { return impl_.mutable_num_samples(); }
  void set_num_samples(const int64_t& num_samples) override { impl_.set_num_samples(num_samples); }

  const int64_t& batch_size() const override { return impl_.batch_size(); }
  int64_t* mutable_batch_size() override { return impl_.mutable_batch_size(); }
  void set_batch_size(const int64_t& batch_size) override { impl_.set_batch_size(batch_size); }

  const DataType& dtype() const override { return impl_.dtype(); }
  DataType* mutable_dtype() override { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) override { impl_.set_dtype(dtype); }

  const std::vector<int64_t>& split_sizes() const override { return impl_.split_sizes(); }
  std::vector<int64_t>* mutable_split_sizes() override { return impl_.mutable_split_sizes(); }
  void set_split_sizes(const std::vector<int64_t>& split_sizes) override {
    impl_.set_split_sizes(split_sizes);
  }

  const int64_t& split_index() const override { return impl_.split_index(); }
  int64_t* mutable_split_index() override { return impl_.mutable_split_index(); }
  void set_split_index(const int64_t& split_index) override { impl_.set_split_index(split_index); }

  const bool& shuffle() const override { return impl_.shuffle(); }
  bool* mutable_shuffle() override { return impl_.mutable_shuffle(); }
  void set_shuffle(const bool& shuffle) override { impl_.set_shuffle(shuffle); }

  const int64_t& random_seed() const override { return impl_.random_seed(); }
  int64_t* mutable_random_seed() override { return impl_.mutable_random_seed(); }
  void set_random_seed(const int64_t& random_seed) override { impl_.set_random_seed(random_seed); }

  const std::vector<std::string>& nd_sbp() const override { return impl_.nd_sbp(); }
  std::vector<std::string>* mutable_nd_sbp() override { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) override { impl_.set_nd_sbp(nd_sbp); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MegatronGptMmapDataLoaderOp {
 public:
  MegatronGptMmapDataLoaderOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "data_file_prefix") {
      return CastAttr(&internal_->data_file_prefix);
    } else if (attr_name == "seq_length") {
      return CastAttr(&internal_->seq_length);
    } else if (attr_name == "label_length") {
      return CastAttr(&internal_->label_length);
    } else if (attr_name == "num_samples") {
      return CastAttr(&internal_->num_samples);
    } else if (attr_name == "batch_size") {
      return CastAttr(&internal_->batch_size);
    } else if (attr_name == "dtype") {
      return CastAttr(&internal_->dtype);
    } else if (attr_name == "split_sizes") {
      return CastAttr(&internal_->split_sizes);
    } else if (attr_name == "split_index") {
      return CastAttr(&internal_->split_index);
    } else if (attr_name == "shuffle") {
      return CastAttr(&internal_->shuffle);
    } else if (attr_name == "random_seed") {
      return CastAttr(&internal_->random_seed);
    } else if (attr_name == "nd_sbp") {
      return CastAttr(&internal_->nd_sbp);
    } else {
      return Error::RuntimeError()
             << "MegatronGptMmapDataLoader op has no attribute named " << attr_name;
    }
  }

  const std::string& data_file_prefix() const { return internal_->data_file_prefix; }
  std::string* mutable_data_file_prefix() { return &internal_->data_file_prefix; }
  void set_data_file_prefix(const std::string& data_file_prefix) {
    internal_->data_file_prefix = data_file_prefix;
  }

  const int64_t& seq_length() const { return internal_->seq_length; }
  int64_t* mutable_seq_length() { return &internal_->seq_length; }
  void set_seq_length(const int64_t& seq_length) { internal_->seq_length = seq_length; }

  const int64_t& label_length() const { return internal_->label_length; }
  int64_t* mutable_label_length() { return &internal_->label_length; }
  void set_label_length(const int64_t& label_length) { internal_->label_length = label_length; }

  const int64_t& num_samples() const { return internal_->num_samples; }
  int64_t* mutable_num_samples() { return &internal_->num_samples; }
  void set_num_samples(const int64_t& num_samples) { internal_->num_samples = num_samples; }

  const int64_t& batch_size() const { return internal_->batch_size; }
  int64_t* mutable_batch_size() { return &internal_->batch_size; }
  void set_batch_size(const int64_t& batch_size) { internal_->batch_size = batch_size; }

  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }

  const std::vector<int64_t>& split_sizes() const { return internal_->split_sizes; }
  std::vector<int64_t>* mutable_split_sizes() { return &internal_->split_sizes; }
  void set_split_sizes(const std::vector<int64_t>& split_sizes) {
    internal_->split_sizes = split_sizes;
  }

  const int64_t& split_index() const { return internal_->split_index; }
  int64_t* mutable_split_index() { return &internal_->split_index; }
  void set_split_index(const int64_t& split_index) { internal_->split_index = split_index; }

  const bool& shuffle() const { return internal_->shuffle; }
  bool* mutable_shuffle() { return &internal_->shuffle; }
  void set_shuffle(const bool& shuffle) { internal_->shuffle = shuffle; }

  const int64_t& random_seed() const { return internal_->random_seed; }
  int64_t* mutable_random_seed() { return &internal_->random_seed; }
  void set_random_seed(const int64_t& random_seed) { internal_->random_seed = random_seed; }

  const std::vector<std::string>& nd_sbp() const { return internal_->nd_sbp; }
  std::vector<std::string>* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::vector<std::string>& nd_sbp) { internal_->nd_sbp = nd_sbp; }

 private:
  struct Internal {
    std::string data_file_prefix;
    int64_t seq_length;
    int64_t label_length;
    int64_t num_samples;
    int64_t batch_size;
    DataType dtype;
    std::vector<int64_t> split_sizes;
    int64_t split_index;
    bool shuffle;
    int64_t random_seed;
    std::vector<std::string> nd_sbp;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.megatron_gpt_mmap_data_loader",
    MegatronGptMmapDataLoaderOpInterpCtxImpl<schema::MegatronGptMmapDataLoaderOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MinMaxObserverOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& quantization_formula() const = 0;
  virtual std::string* mutable_quantization_formula() = 0;
  virtual void set_quantization_formula(const std::string& quantization_formula) = 0;

  virtual const int32_t& quantization_bit() const = 0;
  virtual int32_t* mutable_quantization_bit() = 0;
  virtual void set_quantization_bit(const int32_t& quantization_bit) = 0;

  virtual const std::string& quantization_scheme() const = 0;
  virtual std::string* mutable_quantization_scheme() = 0;
  virtual void set_quantization_scheme(const std::string& quantization_scheme) = 0;

  virtual const bool& per_layer_quantization() const = 0;
  virtual bool* mutable_per_layer_quantization() = 0;
  virtual void set_per_layer_quantization(const bool& per_layer_quantization) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"quantization_formula", "quantization_bit",
                                           "quantization_scheme", "per_layer_quantization"};
    return attr_names;
  }
};
template<typename Provider>
class MinMaxObserverOpInterpCtxImpl : public MinMaxObserverOpInterpCtx {
 public:
  MinMaxObserverOpInterpCtxImpl() = default;
  MinMaxObserverOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& quantization_formula() const override { return impl_.quantization_formula(); }
  std::string* mutable_quantization_formula() override {
    return impl_.mutable_quantization_formula();
  }
  void set_quantization_formula(const std::string& quantization_formula) override {
    impl_.set_quantization_formula(quantization_formula);
  }

  const int32_t& quantization_bit() const override { return impl_.quantization_bit(); }
  int32_t* mutable_quantization_bit() override { return impl_.mutable_quantization_bit(); }
  void set_quantization_bit(const int32_t& quantization_bit) override {
    impl_.set_quantization_bit(quantization_bit);
  }

  const std::string& quantization_scheme() const override { return impl_.quantization_scheme(); }
  std::string* mutable_quantization_scheme() override {
    return impl_.mutable_quantization_scheme();
  }
  void set_quantization_scheme(const std::string& quantization_scheme) override {
    impl_.set_quantization_scheme(quantization_scheme);
  }

  const bool& per_layer_quantization() const override { return impl_.per_layer_quantization(); }
  bool* mutable_per_layer_quantization() override { return impl_.mutable_per_layer_quantization(); }
  void set_per_layer_quantization(const bool& per_layer_quantization) override {
    impl_.set_per_layer_quantization(per_layer_quantization);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MinMaxObserverOp {
 public:
  MinMaxObserverOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "quantization_formula") {
      return CastAttr(&internal_->quantization_formula);
    } else if (attr_name == "quantization_bit") {
      return CastAttr(&internal_->quantization_bit);
    } else if (attr_name == "quantization_scheme") {
      return CastAttr(&internal_->quantization_scheme);
    } else if (attr_name == "per_layer_quantization") {
      return CastAttr(&internal_->per_layer_quantization);
    } else {
      return Error::RuntimeError() << "MinMaxObserver op has no attribute named " << attr_name;
    }
  }

  const std::string& quantization_formula() const { return internal_->quantization_formula; }
  std::string* mutable_quantization_formula() { return &internal_->quantization_formula; }
  void set_quantization_formula(const std::string& quantization_formula) {
    internal_->quantization_formula = quantization_formula;
  }

  const int32_t& quantization_bit() const { return internal_->quantization_bit; }
  int32_t* mutable_quantization_bit() { return &internal_->quantization_bit; }
  void set_quantization_bit(const int32_t& quantization_bit) {
    internal_->quantization_bit = quantization_bit;
  }

  const std::string& quantization_scheme() const { return internal_->quantization_scheme; }
  std::string* mutable_quantization_scheme() { return &internal_->quantization_scheme; }
  void set_quantization_scheme(const std::string& quantization_scheme) {
    internal_->quantization_scheme = quantization_scheme;
  }

  const bool& per_layer_quantization() const { return internal_->per_layer_quantization; }
  bool* mutable_per_layer_quantization() { return &internal_->per_layer_quantization; }
  void set_per_layer_quantization(const bool& per_layer_quantization) {
    internal_->per_layer_quantization = per_layer_quantization;
  }

 private:
  struct Internal {
    std::string quantization_formula;
    int32_t quantization_bit;
    std::string quantization_scheme;
    bool per_layer_quantization;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.min_max_observer",
                       MinMaxObserverOpInterpCtxImpl<schema::MinMaxObserverOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MishOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class MishOpInterpCtxImpl : public MishOpInterpCtx {
 public:
  MishOpInterpCtxImpl() = default;
  MishOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MishOp {
 public:
  MishOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Mish op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.mish", MishOpInterpCtxImpl<schema::MishOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MishGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class MishGradOpInterpCtxImpl : public MishGradOpInterpCtx {
 public:
  MishGradOpInterpCtxImpl() = default;
  MishGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MishGradOp {
 public:
  MishGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "MishGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.mish_grad", MishGradOpInterpCtxImpl<schema::MishGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MomentumUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& learning_rate_val() const = 0;
  virtual float* mutable_learning_rate_val() = 0;
  virtual void set_learning_rate_val(const float& learning_rate_val) = 0;

  virtual const double& scale() const = 0;
  virtual double* mutable_scale() = 0;
  virtual void set_scale(const double& scale) = 0;

  virtual const float& l1() const = 0;
  virtual float* mutable_l1() = 0;
  virtual void set_l1(const float& l1) = 0;

  virtual const float& l2() const = 0;
  virtual float* mutable_l2() = 0;
  virtual void set_l2(const float& l2) = 0;

  virtual const float& beta() const = 0;
  virtual float* mutable_beta() = 0;
  virtual void set_beta(const float& beta) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"learning_rate_val", "scale", "l1", "l2", "beta",
                                           "weight_decay"};
    return attr_names;
  }
};
template<typename Provider>
class MomentumUpdateOpInterpCtxImpl : public MomentumUpdateOpInterpCtx {
 public:
  MomentumUpdateOpInterpCtxImpl() = default;
  MomentumUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& learning_rate_val() const override { return impl_.learning_rate_val(); }
  float* mutable_learning_rate_val() override { return impl_.mutable_learning_rate_val(); }
  void set_learning_rate_val(const float& learning_rate_val) override {
    impl_.set_learning_rate_val(learning_rate_val);
  }

  const double& scale() const override { return impl_.scale(); }
  double* mutable_scale() override { return impl_.mutable_scale(); }
  void set_scale(const double& scale) override { impl_.set_scale(scale); }

  const float& l1() const override { return impl_.l1(); }
  float* mutable_l1() override { return impl_.mutable_l1(); }
  void set_l1(const float& l1) override { impl_.set_l1(l1); }

  const float& l2() const override { return impl_.l2(); }
  float* mutable_l2() override { return impl_.mutable_l2(); }
  void set_l2(const float& l2) override { impl_.set_l2(l2); }

  const float& beta() const override { return impl_.beta(); }
  float* mutable_beta() override { return impl_.mutable_beta(); }
  void set_beta(const float& beta) override { impl_.set_beta(beta); }

  const float& weight_decay() const override { return impl_.weight_decay(); }
  float* mutable_weight_decay() override { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) override {
    impl_.set_weight_decay(weight_decay);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MomentumUpdateOp {
 public:
  MomentumUpdateOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "learning_rate_val") {
      return CastAttr(&internal_->learning_rate_val);
    } else if (attr_name == "scale") {
      return CastAttr(&internal_->scale);
    } else if (attr_name == "l1") {
      return CastAttr(&internal_->l1);
    } else if (attr_name == "l2") {
      return CastAttr(&internal_->l2);
    } else if (attr_name == "beta") {
      return CastAttr(&internal_->beta);
    } else if (attr_name == "weight_decay") {
      return CastAttr(&internal_->weight_decay);
    } else {
      return Error::RuntimeError() << "MomentumUpdate op has no attribute named " << attr_name;
    }
  }

  const float& learning_rate_val() const { return internal_->learning_rate_val; }
  float* mutable_learning_rate_val() { return &internal_->learning_rate_val; }
  void set_learning_rate_val(const float& learning_rate_val) {
    internal_->learning_rate_val = learning_rate_val;
  }

  const double& scale() const { return internal_->scale; }
  double* mutable_scale() { return &internal_->scale; }
  void set_scale(const double& scale) { internal_->scale = scale; }

  const float& l1() const { return internal_->l1; }
  float* mutable_l1() { return &internal_->l1; }
  void set_l1(const float& l1) { internal_->l1 = l1; }

  const float& l2() const { return internal_->l2; }
  float* mutable_l2() { return &internal_->l2; }
  void set_l2(const float& l2) { internal_->l2 = l2; }

  const float& beta() const { return internal_->beta; }
  float* mutable_beta() { return &internal_->beta; }
  void set_beta(const float& beta) { internal_->beta = beta; }

  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }

 private:
  struct Internal {
    float learning_rate_val;
    double scale;
    float l1;
    float l2;
    float beta;
    float weight_decay;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.momentum_update",
                       MomentumUpdateOpInterpCtxImpl<schema::MomentumUpdateOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MovingAverageMinMaxObserverOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& training() const = 0;
  virtual bool* mutable_training() = 0;
  virtual void set_training(const bool& training) = 0;

  virtual const std::string& quantization_formula() const = 0;
  virtual std::string* mutable_quantization_formula() = 0;
  virtual void set_quantization_formula(const std::string& quantization_formula) = 0;

  virtual const int64_t& stop_update_after_iters() const = 0;
  virtual int64_t* mutable_stop_update_after_iters() = 0;
  virtual void set_stop_update_after_iters(const int64_t& stop_update_after_iters) = 0;

  virtual const int32_t& quantization_bit() const = 0;
  virtual int32_t* mutable_quantization_bit() = 0;
  virtual void set_quantization_bit(const int32_t& quantization_bit) = 0;

  virtual const std::string& quantization_scheme() const = 0;
  virtual std::string* mutable_quantization_scheme() = 0;
  virtual void set_quantization_scheme(const std::string& quantization_scheme) = 0;

  virtual const float& momentum() const = 0;
  virtual float* mutable_momentum() = 0;
  virtual void set_momentum(const float& momentum) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{
        "training",         "quantization_formula", "stop_update_after_iters",
        "quantization_bit", "quantization_scheme",  "momentum"};
    return attr_names;
  }
};
template<typename Provider>
class MovingAverageMinMaxObserverOpInterpCtxImpl : public MovingAverageMinMaxObserverOpInterpCtx {
 public:
  MovingAverageMinMaxObserverOpInterpCtxImpl() = default;
  MovingAverageMinMaxObserverOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& training() const override { return impl_.training(); }
  bool* mutable_training() override { return impl_.mutable_training(); }
  void set_training(const bool& training) override { impl_.set_training(training); }

  const std::string& quantization_formula() const override { return impl_.quantization_formula(); }
  std::string* mutable_quantization_formula() override {
    return impl_.mutable_quantization_formula();
  }
  void set_quantization_formula(const std::string& quantization_formula) override {
    impl_.set_quantization_formula(quantization_formula);
  }

  const int64_t& stop_update_after_iters() const override {
    return impl_.stop_update_after_iters();
  }
  int64_t* mutable_stop_update_after_iters() override {
    return impl_.mutable_stop_update_after_iters();
  }
  void set_stop_update_after_iters(const int64_t& stop_update_after_iters) override {
    impl_.set_stop_update_after_iters(stop_update_after_iters);
  }

  const int32_t& quantization_bit() const override { return impl_.quantization_bit(); }
  int32_t* mutable_quantization_bit() override { return impl_.mutable_quantization_bit(); }
  void set_quantization_bit(const int32_t& quantization_bit) override {
    impl_.set_quantization_bit(quantization_bit);
  }

  const std::string& quantization_scheme() const override { return impl_.quantization_scheme(); }
  std::string* mutable_quantization_scheme() override {
    return impl_.mutable_quantization_scheme();
  }
  void set_quantization_scheme(const std::string& quantization_scheme) override {
    impl_.set_quantization_scheme(quantization_scheme);
  }

  const float& momentum() const override { return impl_.momentum(); }
  float* mutable_momentum() override { return impl_.mutable_momentum(); }
  void set_momentum(const float& momentum) override { impl_.set_momentum(momentum); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MovingAverageMinMaxObserverOp {
 public:
  MovingAverageMinMaxObserverOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "training") {
      return CastAttr(&internal_->training);
    } else if (attr_name == "quantization_formula") {
      return CastAttr(&internal_->quantization_formula);
    } else if (attr_name == "stop_update_after_iters") {
      return CastAttr(&internal_->stop_update_after_iters);
    } else if (attr_name == "quantization_bit") {
      return CastAttr(&internal_->quantization_bit);
    } else if (attr_name == "quantization_scheme") {
      return CastAttr(&internal_->quantization_scheme);
    } else if (attr_name == "momentum") {
      return CastAttr(&internal_->momentum);
    } else {
      return Error::RuntimeError()
             << "MovingAverageMinMaxObserver op has no attribute named " << attr_name;
    }
  }

  const bool& training() const { return internal_->training; }
  bool* mutable_training() { return &internal_->training; }
  void set_training(const bool& training) { internal_->training = training; }

  const std::string& quantization_formula() const { return internal_->quantization_formula; }
  std::string* mutable_quantization_formula() { return &internal_->quantization_formula; }
  void set_quantization_formula(const std::string& quantization_formula) {
    internal_->quantization_formula = quantization_formula;
  }

  const int64_t& stop_update_after_iters() const { return internal_->stop_update_after_iters; }
  int64_t* mutable_stop_update_after_iters() { return &internal_->stop_update_after_iters; }
  void set_stop_update_after_iters(const int64_t& stop_update_after_iters) {
    internal_->stop_update_after_iters = stop_update_after_iters;
  }

  const int32_t& quantization_bit() const { return internal_->quantization_bit; }
  int32_t* mutable_quantization_bit() { return &internal_->quantization_bit; }
  void set_quantization_bit(const int32_t& quantization_bit) {
    internal_->quantization_bit = quantization_bit;
  }

  const std::string& quantization_scheme() const { return internal_->quantization_scheme; }
  std::string* mutable_quantization_scheme() { return &internal_->quantization_scheme; }
  void set_quantization_scheme(const std::string& quantization_scheme) {
    internal_->quantization_scheme = quantization_scheme;
  }

  const float& momentum() const { return internal_->momentum; }
  float* mutable_momentum() { return &internal_->momentum; }
  void set_momentum(const float& momentum) { internal_->momentum = momentum; }

 private:
  struct Internal {
    bool training;
    std::string quantization_formula;
    int64_t stop_update_after_iters;
    int32_t quantization_bit;
    std::string quantization_scheme;
    float momentum;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.moving_average_min_max_observer",
    MovingAverageMinMaxObserverOpInterpCtxImpl<schema::MovingAverageMinMaxObserverOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MultiCountNotFiniteOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class MultiCountNotFiniteOpInterpCtxImpl : public MultiCountNotFiniteOpInterpCtx {
 public:
  MultiCountNotFiniteOpInterpCtxImpl() = default;
  MultiCountNotFiniteOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MultiCountNotFiniteOp {
 public:
  MultiCountNotFiniteOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "MultiCountNotFinite op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.multi_count_not_finite",
                       MultiCountNotFiniteOpInterpCtxImpl<schema::MultiCountNotFiniteOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MultiSquareSumOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class MultiSquareSumOpInterpCtxImpl : public MultiSquareSumOpInterpCtx {
 public:
  MultiSquareSumOpInterpCtxImpl() = default;
  MultiSquareSumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MultiSquareSumOp {
 public:
  MultiSquareSumOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "MultiSquareSum op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.multi_square_sum",
                       MultiSquareSumOpInterpCtxImpl<schema::MultiSquareSumOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class MultiplyOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class MultiplyOpInterpCtxImpl : public MultiplyOpInterpCtx {
 public:
  MultiplyOpInterpCtxImpl() = default;
  MultiplyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class MultiplyOp {
 public:
  MultiplyOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Multiply op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.multiply", MultiplyOpInterpCtxImpl<schema::MultiplyOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class NarrowOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& dim() const = 0;
  virtual int64_t* mutable_dim() = 0;
  virtual void set_dim(const int64_t& dim) = 0;

  virtual const int64_t& start() const = 0;
  virtual int64_t* mutable_start() = 0;
  virtual void set_start(const int64_t& start) = 0;

  virtual const int64_t& length() const = 0;
  virtual int64_t* mutable_length() = 0;
  virtual void set_length(const int64_t& length) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"dim", "start", "length"};
    return attr_names;
  }
};
template<typename Provider>
class NarrowOpInterpCtxImpl : public NarrowOpInterpCtx {
 public:
  NarrowOpInterpCtxImpl() = default;
  NarrowOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& dim() const override { return impl_.dim(); }
  int64_t* mutable_dim() override { return impl_.mutable_dim(); }
  void set_dim(const int64_t& dim) override { impl_.set_dim(dim); }

  const int64_t& start() const override { return impl_.start(); }
  int64_t* mutable_start() override { return impl_.mutable_start(); }
  void set_start(const int64_t& start) override { impl_.set_start(start); }

  const int64_t& length() const override { return impl_.length(); }
  int64_t* mutable_length() override { return impl_.mutable_length(); }
  void set_length(const int64_t& length) override { impl_.set_length(length); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NarrowOp {
 public:
  NarrowOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "dim") {
      return CastAttr(&internal_->dim);
    } else if (attr_name == "start") {
      return CastAttr(&internal_->start);
    } else if (attr_name == "length") {
      return CastAttr(&internal_->length);
    } else {
      return Error::RuntimeError() << "Narrow op has no attribute named " << attr_name;
    }
  }

  const int64_t& dim() const { return internal_->dim; }
  int64_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int64_t& dim) { internal_->dim = dim; }

  const int64_t& start() const { return internal_->start; }
  int64_t* mutable_start() { return &internal_->start; }
  void set_start(const int64_t& start) { internal_->start = start; }

  const int64_t& length() const { return internal_->length; }
  int64_t* mutable_length() { return &internal_->length; }
  void set_length(const int64_t& length) { internal_->length = length; }

 private:
  struct Internal {
    int64_t dim;
    int64_t start;
    int64_t length;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.narrow", NarrowOpInterpCtxImpl<schema::NarrowOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class NarrowGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& dim() const = 0;
  virtual int64_t* mutable_dim() = 0;
  virtual void set_dim(const int64_t& dim) = 0;

  virtual const int64_t& start() const = 0;
  virtual int64_t* mutable_start() = 0;
  virtual void set_start(const int64_t& start) = 0;

  virtual const int64_t& length() const = 0;
  virtual int64_t* mutable_length() = 0;
  virtual void set_length(const int64_t& length) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"dim", "start", "length"};
    return attr_names;
  }
};
template<typename Provider>
class NarrowGradOpInterpCtxImpl : public NarrowGradOpInterpCtx {
 public:
  NarrowGradOpInterpCtxImpl() = default;
  NarrowGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& dim() const override { return impl_.dim(); }
  int64_t* mutable_dim() override { return impl_.mutable_dim(); }
  void set_dim(const int64_t& dim) override { impl_.set_dim(dim); }

  const int64_t& start() const override { return impl_.start(); }
  int64_t* mutable_start() override { return impl_.mutable_start(); }
  void set_start(const int64_t& start) override { impl_.set_start(start); }

  const int64_t& length() const override { return impl_.length(); }
  int64_t* mutable_length() override { return impl_.mutable_length(); }
  void set_length(const int64_t& length) override { impl_.set_length(length); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NarrowGradOp {
 public:
  NarrowGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "dim") {
      return CastAttr(&internal_->dim);
    } else if (attr_name == "start") {
      return CastAttr(&internal_->start);
    } else if (attr_name == "length") {
      return CastAttr(&internal_->length);
    } else {
      return Error::RuntimeError() << "NarrowGrad op has no attribute named " << attr_name;
    }
  }

  const int64_t& dim() const { return internal_->dim; }
  int64_t* mutable_dim() { return &internal_->dim; }
  void set_dim(const int64_t& dim) { internal_->dim = dim; }

  const int64_t& start() const { return internal_->start; }
  int64_t* mutable_start() { return &internal_->start; }
  void set_start(const int64_t& start) { internal_->start = start; }

  const int64_t& length() const { return internal_->length; }
  int64_t* mutable_length() { return &internal_->length; }
  void set_length(const int64_t& length) { internal_->length = length; }

 private:
  struct Internal {
    int64_t dim;
    int64_t start;
    int64_t length;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.narrow_grad", NarrowGradOpInterpCtxImpl<schema::NarrowGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class NegativeOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class NegativeOpInterpCtxImpl : public NegativeOpInterpCtx {
 public:
  NegativeOpInterpCtxImpl() = default;
  NegativeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NegativeOp {
 public:
  NegativeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Negative op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.negative", NegativeOpInterpCtxImpl<schema::NegativeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class NegativeGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class NegativeGradOpInterpCtxImpl : public NegativeGradOpInterpCtx {
 public:
  NegativeGradOpInterpCtxImpl() = default;
  NegativeGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NegativeGradOp {
 public:
  NegativeGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "NegativeGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.negative_grad", NegativeGradOpInterpCtxImpl<schema::NegativeGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class NllOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& ignore_index() const = 0;
  virtual int64_t* mutable_ignore_index() = 0;
  virtual void set_ignore_index(const int64_t& ignore_index) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"ignore_index"};
    return attr_names;
  }
};
template<typename Provider>
class NllOpInterpCtxImpl : public NllOpInterpCtx {
 public:
  NllOpInterpCtxImpl() = default;
  NllOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& ignore_index() const override { return impl_.ignore_index(); }
  int64_t* mutable_ignore_index() override { return impl_.mutable_ignore_index(); }
  void set_ignore_index(const int64_t& ignore_index) override {
    impl_.set_ignore_index(ignore_index);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NllOp {
 public:
  NllOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "ignore_index") {
      return CastAttr(&internal_->ignore_index);
    } else {
      return Error::RuntimeError() << "Nll op has no attribute named " << attr_name;
    }
  }

  const int64_t& ignore_index() const { return internal_->ignore_index; }
  int64_t* mutable_ignore_index() { return &internal_->ignore_index; }
  void set_ignore_index(const int64_t& ignore_index) { internal_->ignore_index = ignore_index; }

 private:
  struct Internal {
    int64_t ignore_index;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.nll", NllOpInterpCtxImpl<schema::NllOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class NllGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& ignore_index() const = 0;
  virtual int64_t* mutable_ignore_index() = 0;
  virtual void set_ignore_index(const int64_t& ignore_index) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"ignore_index"};
    return attr_names;
  }
};
template<typename Provider>
class NllGradOpInterpCtxImpl : public NllGradOpInterpCtx {
 public:
  NllGradOpInterpCtxImpl() = default;
  NllGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& ignore_index() const override { return impl_.ignore_index(); }
  int64_t* mutable_ignore_index() override { return impl_.mutable_ignore_index(); }
  void set_ignore_index(const int64_t& ignore_index) override {
    impl_.set_ignore_index(ignore_index);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NllGradOp {
 public:
  NllGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "ignore_index") {
      return CastAttr(&internal_->ignore_index);
    } else {
      return Error::RuntimeError() << "NllGrad op has no attribute named " << attr_name;
    }
  }

  const int64_t& ignore_index() const { return internal_->ignore_index; }
  int64_t* mutable_ignore_index() { return &internal_->ignore_index; }
  void set_ignore_index(const int64_t& ignore_index) { internal_->ignore_index = ignore_index; }

 private:
  struct Internal {
    int64_t ignore_index;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.nll_grad", NllGradOpInterpCtxImpl<schema::NllGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class NmsOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& iou_threshold() const = 0;
  virtual float* mutable_iou_threshold() = 0;
  virtual void set_iou_threshold(const float& iou_threshold) = 0;

  virtual const int32_t& keep_n() const = 0;
  virtual int32_t* mutable_keep_n() = 0;
  virtual void set_keep_n(const int32_t& keep_n) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"iou_threshold", "keep_n"};
    return attr_names;
  }
};
template<typename Provider>
class NmsOpInterpCtxImpl : public NmsOpInterpCtx {
 public:
  NmsOpInterpCtxImpl() = default;
  NmsOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& iou_threshold() const override { return impl_.iou_threshold(); }
  float* mutable_iou_threshold() override { return impl_.mutable_iou_threshold(); }
  void set_iou_threshold(const float& iou_threshold) override {
    impl_.set_iou_threshold(iou_threshold);
  }

  const int32_t& keep_n() const override { return impl_.keep_n(); }
  int32_t* mutable_keep_n() override { return impl_.mutable_keep_n(); }
  void set_keep_n(const int32_t& keep_n) override { impl_.set_keep_n(keep_n); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NmsOp {
 public:
  NmsOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "iou_threshold") {
      return CastAttr(&internal_->iou_threshold);
    } else if (attr_name == "keep_n") {
      return CastAttr(&internal_->keep_n);
    } else {
      return Error::RuntimeError() << "Nms op has no attribute named " << attr_name;
    }
  }

  const float& iou_threshold() const { return internal_->iou_threshold; }
  float* mutable_iou_threshold() { return &internal_->iou_threshold; }
  void set_iou_threshold(const float& iou_threshold) { internal_->iou_threshold = iou_threshold; }

  const int32_t& keep_n() const { return internal_->keep_n; }
  int32_t* mutable_keep_n() { return &internal_->keep_n; }
  void set_keep_n(const int32_t& keep_n) { internal_->keep_n = keep_n; }

 private:
  struct Internal {
    float iou_threshold;
    int32_t keep_n;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.nms", NmsOpInterpCtxImpl<schema::NmsOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class NormalOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& mean() const = 0;
  virtual double* mutable_mean() = 0;
  virtual void set_mean(const double& mean) = 0;

  virtual const double& std() const = 0;
  virtual double* mutable_std() = 0;
  virtual void set_std(const double& std) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  virtual const std::string& nd_sbp() const = 0;
  virtual std::string* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::string& nd_sbp) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"mean", "std", "seed", "dtype", "shape", "nd_sbp"};
    return attr_names;
  }
};
template<typename Provider>
class NormalOpInterpCtxImpl : public NormalOpInterpCtx {
 public:
  NormalOpInterpCtxImpl() = default;
  NormalOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& mean() const override { return impl_.mean(); }
  double* mutable_mean() override { return impl_.mutable_mean(); }
  void set_mean(const double& mean) override { impl_.set_mean(mean); }

  const double& std() const override { return impl_.std(); }
  double* mutable_std() override { return impl_.mutable_std(); }
  void set_std(const double& std) override { impl_.set_std(std); }

  const int64_t& seed() const override { return impl_.seed(); }
  int64_t* mutable_seed() override { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) override { impl_.set_seed(seed); }

  const DataType& dtype() const override { return impl_.dtype(); }
  DataType* mutable_dtype() override { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) override { impl_.set_dtype(dtype); }

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  const std::string& nd_sbp() const override { return impl_.nd_sbp(); }
  std::string* mutable_nd_sbp() override { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::string& nd_sbp) override { impl_.set_nd_sbp(nd_sbp); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NormalOp {
 public:
  NormalOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "mean") {
      return CastAttr(&internal_->mean);
    } else if (attr_name == "std") {
      return CastAttr(&internal_->std);
    } else if (attr_name == "seed") {
      return CastAttr(&internal_->seed);
    } else if (attr_name == "dtype") {
      return CastAttr(&internal_->dtype);
    } else if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else if (attr_name == "nd_sbp") {
      return CastAttr(&internal_->nd_sbp);
    } else {
      return Error::RuntimeError() << "Normal op has no attribute named " << attr_name;
    }
  }

  const double& mean() const { return internal_->mean; }
  double* mutable_mean() { return &internal_->mean; }
  void set_mean(const double& mean) { internal_->mean = mean; }

  const double& std() const { return internal_->std; }
  double* mutable_std() { return &internal_->std; }
  void set_std(const double& std) { internal_->std = std; }

  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }

  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

  const std::string& nd_sbp() const { return internal_->nd_sbp; }
  std::string* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::string& nd_sbp) { internal_->nd_sbp = nd_sbp; }

 private:
  struct Internal {
    double mean;
    double std;
    int64_t seed;
    DataType dtype;
    Shape shape;
    std::string nd_sbp;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.normal", NormalOpInterpCtxImpl<schema::NormalOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class NormalizationOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  virtual const bool& training() const = 0;
  virtual bool* mutable_training() = 0;
  virtual void set_training(const bool& training) = 0;

  virtual const float& momentum() const = 0;
  virtual float* mutable_momentum() = 0;
  virtual void set_momentum(const float& momentum) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "epsilon", "training", "momentum"};
    return attr_names;
  }
};
template<typename Provider>
class NormalizationOpInterpCtxImpl : public NormalizationOpInterpCtx {
 public:
  NormalizationOpInterpCtxImpl() = default;
  NormalizationOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& axis() const override { return impl_.axis(); }
  int32_t* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) override { impl_.set_axis(axis); }

  const float& epsilon() const override { return impl_.epsilon(); }
  float* mutable_epsilon() override { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) override { impl_.set_epsilon(epsilon); }

  const bool& training() const override { return impl_.training(); }
  bool* mutable_training() override { return impl_.mutable_training(); }
  void set_training(const bool& training) override { impl_.set_training(training); }

  const float& momentum() const override { return impl_.momentum(); }
  float* mutable_momentum() override { return impl_.mutable_momentum(); }
  void set_momentum(const float& momentum) override { impl_.set_momentum(momentum); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NormalizationOp {
 public:
  NormalizationOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "epsilon") {
      return CastAttr(&internal_->epsilon);
    } else if (attr_name == "training") {
      return CastAttr(&internal_->training);
    } else if (attr_name == "momentum") {
      return CastAttr(&internal_->momentum);
    } else {
      return Error::RuntimeError() << "Normalization op has no attribute named " << attr_name;
    }
  }

  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }

  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }

  const bool& training() const { return internal_->training; }
  bool* mutable_training() { return &internal_->training; }
  void set_training(const bool& training) { internal_->training = training; }

  const float& momentum() const { return internal_->momentum; }
  float* mutable_momentum() { return &internal_->momentum; }
  void set_momentum(const float& momentum) { internal_->momentum = momentum; }

 private:
  struct Internal {
    int32_t axis;
    float epsilon;
    bool training;
    float momentum;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.normalization", NormalizationOpInterpCtxImpl<schema::NormalizationOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class NormalizationAddReluBaseOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  virtual const bool& training() const = 0;
  virtual bool* mutable_training() = 0;
  virtual void set_training(const bool& training) = 0;

  virtual const float& momentum() const = 0;
  virtual float* mutable_momentum() = 0;
  virtual void set_momentum(const float& momentum) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "epsilon", "training", "momentum"};
    return attr_names;
  }
};
template<typename Provider>
class NormalizationAddReluBaseOpInterpCtxImpl : public NormalizationAddReluBaseOpInterpCtx {
 public:
  NormalizationAddReluBaseOpInterpCtxImpl() = default;
  NormalizationAddReluBaseOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& axis() const override { return impl_.axis(); }
  int32_t* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) override { impl_.set_axis(axis); }

  const float& epsilon() const override { return impl_.epsilon(); }
  float* mutable_epsilon() override { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) override { impl_.set_epsilon(epsilon); }

  const bool& training() const override { return impl_.training(); }
  bool* mutable_training() override { return impl_.mutable_training(); }
  void set_training(const bool& training) override { impl_.set_training(training); }

  const float& momentum() const override { return impl_.momentum(); }
  float* mutable_momentum() override { return impl_.mutable_momentum(); }
  void set_momentum(const float& momentum) override { impl_.set_momentum(momentum); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NormalizationAddReluBaseOp {
 public:
  NormalizationAddReluBaseOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "epsilon") {
      return CastAttr(&internal_->epsilon);
    } else if (attr_name == "training") {
      return CastAttr(&internal_->training);
    } else if (attr_name == "momentum") {
      return CastAttr(&internal_->momentum);
    } else {
      return Error::RuntimeError()
             << "NormalizationAddReluBase op has no attribute named " << attr_name;
    }
  }

  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }

  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }

  const bool& training() const { return internal_->training; }
  bool* mutable_training() { return &internal_->training; }
  void set_training(const bool& training) { internal_->training = training; }

  const float& momentum() const { return internal_->momentum; }
  float* mutable_momentum() { return &internal_->momentum; }
  void set_momentum(const float& momentum) { internal_->momentum = momentum; }

 private:
  struct Internal {
    int32_t axis;
    float epsilon;
    bool training;
    float momentum;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.normalization_add_relu",
                       NormalizationAddReluBaseOpInterpCtxImpl<schema::NormalizationAddReluBaseOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class NormalizationAddReluGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "epsilon"};
    return attr_names;
  }
};
template<typename Provider>
class NormalizationAddReluGradOpInterpCtxImpl : public NormalizationAddReluGradOpInterpCtx {
 public:
  NormalizationAddReluGradOpInterpCtxImpl() = default;
  NormalizationAddReluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& axis() const override { return impl_.axis(); }
  int32_t* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) override { impl_.set_axis(axis); }

  const float& epsilon() const override { return impl_.epsilon(); }
  float* mutable_epsilon() override { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) override { impl_.set_epsilon(epsilon); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NormalizationAddReluGradOp {
 public:
  NormalizationAddReluGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "epsilon") {
      return CastAttr(&internal_->epsilon);
    } else {
      return Error::RuntimeError()
             << "NormalizationAddReluGrad op has no attribute named " << attr_name;
    }
  }

  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }

  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }

 private:
  struct Internal {
    int32_t axis;
    float epsilon;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.normalization_add_relu_grad",
                       NormalizationAddReluGradOpInterpCtxImpl<schema::NormalizationAddReluGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class NormalizationGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& axis() const = 0;
  virtual int32_t* mutable_axis() = 0;
  virtual void set_axis(const int32_t& axis) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "epsilon"};
    return attr_names;
  }
};
template<typename Provider>
class NormalizationGradOpInterpCtxImpl : public NormalizationGradOpInterpCtx {
 public:
  NormalizationGradOpInterpCtxImpl() = default;
  NormalizationGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& axis() const override { return impl_.axis(); }
  int32_t* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const int32_t& axis) override { impl_.set_axis(axis); }

  const float& epsilon() const override { return impl_.epsilon(); }
  float* mutable_epsilon() override { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) override { impl_.set_epsilon(epsilon); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NormalizationGradOp {
 public:
  NormalizationGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "epsilon") {
      return CastAttr(&internal_->epsilon);
    } else {
      return Error::RuntimeError() << "NormalizationGrad op has no attribute named " << attr_name;
    }
  }

  const int32_t& axis() const { return internal_->axis; }
  int32_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int32_t& axis) { internal_->axis = axis; }

  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }

 private:
  struct Internal {
    int32_t axis;
    float epsilon;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.normalization_grad",
                       NormalizationGradOpInterpCtxImpl<schema::NormalizationGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class NvtxEndOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& mark_prefix() const = 0;
  virtual std::string* mutable_mark_prefix() = 0;
  virtual void set_mark_prefix(const std::string& mark_prefix) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"mark_prefix"};
    return attr_names;
  }
};
template<typename Provider>
class NvtxEndOpInterpCtxImpl : public NvtxEndOpInterpCtx {
 public:
  NvtxEndOpInterpCtxImpl() = default;
  NvtxEndOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& mark_prefix() const override { return impl_.mark_prefix(); }
  std::string* mutable_mark_prefix() override { return impl_.mutable_mark_prefix(); }
  void set_mark_prefix(const std::string& mark_prefix) override {
    impl_.set_mark_prefix(mark_prefix);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NvtxEndOp {
 public:
  NvtxEndOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "mark_prefix") {
      return CastAttr(&internal_->mark_prefix);
    } else {
      return Error::RuntimeError() << "NvtxEnd op has no attribute named " << attr_name;
    }
  }

  const std::string& mark_prefix() const { return internal_->mark_prefix; }
  std::string* mutable_mark_prefix() { return &internal_->mark_prefix; }
  void set_mark_prefix(const std::string& mark_prefix) { internal_->mark_prefix = mark_prefix; }

 private:
  struct Internal {
    std::string mark_prefix;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.nvtx_end", NvtxEndOpInterpCtxImpl<schema::NvtxEndOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class NvtxStartOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& mark_prefix() const = 0;
  virtual std::string* mutable_mark_prefix() = 0;
  virtual void set_mark_prefix(const std::string& mark_prefix) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"mark_prefix"};
    return attr_names;
  }
};
template<typename Provider>
class NvtxStartOpInterpCtxImpl : public NvtxStartOpInterpCtx {
 public:
  NvtxStartOpInterpCtxImpl() = default;
  NvtxStartOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& mark_prefix() const override { return impl_.mark_prefix(); }
  std::string* mutable_mark_prefix() override { return impl_.mutable_mark_prefix(); }
  void set_mark_prefix(const std::string& mark_prefix) override {
    impl_.set_mark_prefix(mark_prefix);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class NvtxStartOp {
 public:
  NvtxStartOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "mark_prefix") {
      return CastAttr(&internal_->mark_prefix);
    } else {
      return Error::RuntimeError() << "NvtxStart op has no attribute named " << attr_name;
    }
  }

  const std::string& mark_prefix() const { return internal_->mark_prefix; }
  std::string* mutable_mark_prefix() { return &internal_->mark_prefix; }
  void set_mark_prefix(const std::string& mark_prefix) { internal_->mark_prefix = mark_prefix; }

 private:
  struct Internal {
    std::string mark_prefix;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.nvtx_start", NvtxStartOpInterpCtxImpl<schema::NvtxStartOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ObjectBboxFlipOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ObjectBboxFlipOpInterpCtxImpl : public ObjectBboxFlipOpInterpCtx {
 public:
  ObjectBboxFlipOpInterpCtxImpl() = default;
  ObjectBboxFlipOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ObjectBboxFlipOp {
 public:
  ObjectBboxFlipOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ObjectBboxFlip op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.object_bbox_flip",
                       ObjectBboxFlipOpInterpCtxImpl<schema::ObjectBboxFlipOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ObjectBboxScaleOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ObjectBboxScaleOpInterpCtxImpl : public ObjectBboxScaleOpInterpCtx {
 public:
  ObjectBboxScaleOpInterpCtxImpl() = default;
  ObjectBboxScaleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ObjectBboxScaleOp {
 public:
  ObjectBboxScaleOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ObjectBboxScale op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.object_bbox_scale",
                       ObjectBboxScaleOpInterpCtxImpl<schema::ObjectBboxScaleOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ObjectSegmentationPolygonFlipOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ObjectSegmentationPolygonFlipOpInterpCtxImpl
    : public ObjectSegmentationPolygonFlipOpInterpCtx {
 public:
  ObjectSegmentationPolygonFlipOpInterpCtxImpl() = default;
  ObjectSegmentationPolygonFlipOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ObjectSegmentationPolygonFlipOp {
 public:
  ObjectSegmentationPolygonFlipOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ObjectSegmentationPolygonFlip op has no attribute named "
                                 << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.object_segmentation_polygon_flip",
    ObjectSegmentationPolygonFlipOpInterpCtxImpl<schema::ObjectSegmentationPolygonFlipOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ObjectSegmentationPolygonScaleOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ObjectSegmentationPolygonScaleOpInterpCtxImpl
    : public ObjectSegmentationPolygonScaleOpInterpCtx {
 public:
  ObjectSegmentationPolygonScaleOpInterpCtxImpl() = default;
  ObjectSegmentationPolygonScaleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ObjectSegmentationPolygonScaleOp {
 public:
  ObjectSegmentationPolygonScaleOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ObjectSegmentationPolygonScale op has no attribute named "
                                 << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.object_segmentation_polygon_scale",
    ObjectSegmentationPolygonScaleOpInterpCtxImpl<schema::ObjectSegmentationPolygonScaleOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ObjectSegmentationPolygonToMaskOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ObjectSegmentationPolygonToMaskOpInterpCtxImpl
    : public ObjectSegmentationPolygonToMaskOpInterpCtx {
 public:
  ObjectSegmentationPolygonToMaskOpInterpCtxImpl() = default;
  ObjectSegmentationPolygonToMaskOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ObjectSegmentationPolygonToMaskOp {
 public:
  ObjectSegmentationPolygonToMaskOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ObjectSegmentationPolygonToMask op has no attribute named "
                                 << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.object_segmentation_polygon_to_mask",
    ObjectSegmentationPolygonToMaskOpInterpCtxImpl<schema::ObjectSegmentationPolygonToMaskOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class OfrecordBytesDecoderOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& name() const = 0;
  virtual std::string* mutable_name() = 0;
  virtual void set_name(const std::string& name) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"name"};
    return attr_names;
  }
};
template<typename Provider>
class OfrecordBytesDecoderOpInterpCtxImpl : public OfrecordBytesDecoderOpInterpCtx {
 public:
  OfrecordBytesDecoderOpInterpCtxImpl() = default;
  OfrecordBytesDecoderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& name() const override { return impl_.name(); }
  std::string* mutable_name() override { return impl_.mutable_name(); }
  void set_name(const std::string& name) override { impl_.set_name(name); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OfrecordBytesDecoderOp {
 public:
  OfrecordBytesDecoderOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "name") {
      return CastAttr(&internal_->name);
    } else {
      return Error::RuntimeError()
             << "OfrecordBytesDecoder op has no attribute named " << attr_name;
    }
  }

  const std::string& name() const { return internal_->name; }
  std::string* mutable_name() { return &internal_->name; }
  void set_name(const std::string& name) { internal_->name = name; }

 private:
  struct Internal {
    std::string name;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.ofrecord_bytes_decoder",
                       OfrecordBytesDecoderOpInterpCtxImpl<schema::OfrecordBytesDecoderOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class OfrecordImageClassificationReaderOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& data_dir() const = 0;
  virtual std::string* mutable_data_dir() = 0;
  virtual void set_data_dir(const std::string& data_dir) = 0;

  virtual const int32_t& data_part_num() const = 0;
  virtual int32_t* mutable_data_part_num() = 0;
  virtual void set_data_part_num(const int32_t& data_part_num) = 0;

  virtual const int32_t& batch_size() const = 0;
  virtual int32_t* mutable_batch_size() = 0;
  virtual void set_batch_size(const int32_t& batch_size) = 0;

  virtual const std::string& part_name_prefix() const = 0;
  virtual std::string* mutable_part_name_prefix() = 0;
  virtual void set_part_name_prefix(const std::string& part_name_prefix) = 0;

  virtual const int32_t& part_name_suffix_length() const = 0;
  virtual int32_t* mutable_part_name_suffix_length() = 0;
  virtual void set_part_name_suffix_length(const int32_t& part_name_suffix_length) = 0;

  virtual const bool& random_shuffle() const = 0;
  virtual bool* mutable_random_shuffle() = 0;
  virtual void set_random_shuffle(const bool& random_shuffle) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const int32_t& shuffle_buffer_size() const = 0;
  virtual int32_t* mutable_shuffle_buffer_size() = 0;
  virtual void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) = 0;

  virtual const bool& shuffle_after_epoch() const = 0;
  virtual bool* mutable_shuffle_after_epoch() = 0;
  virtual void set_shuffle_after_epoch(const bool& shuffle_after_epoch) = 0;

  virtual const std::string& color_space() const = 0;
  virtual std::string* mutable_color_space() = 0;
  virtual void set_color_space(const std::string& color_space) = 0;

  virtual const std::string& image_feature_name() const = 0;
  virtual std::string* mutable_image_feature_name() = 0;
  virtual void set_image_feature_name(const std::string& image_feature_name) = 0;

  virtual const std::string& label_feature_name() const = 0;
  virtual std::string* mutable_label_feature_name() = 0;
  virtual void set_label_feature_name(const std::string& label_feature_name) = 0;

  virtual const int32_t& decode_buffer_size_per_thread() const = 0;
  virtual int32_t* mutable_decode_buffer_size_per_thread() = 0;
  virtual void set_decode_buffer_size_per_thread(const int32_t& decode_buffer_size_per_thread) = 0;

  virtual const int32_t& num_decode_threads_per_machine() const = 0;
  virtual int32_t* mutable_num_decode_threads_per_machine() = 0;
  virtual void set_num_decode_threads_per_machine(
      const int32_t& num_decode_threads_per_machine) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"data_dir",
                                           "data_part_num",
                                           "batch_size",
                                           "part_name_prefix",
                                           "part_name_suffix_length",
                                           "random_shuffle",
                                           "seed",
                                           "shuffle_buffer_size",
                                           "shuffle_after_epoch",
                                           "color_space",
                                           "image_feature_name",
                                           "label_feature_name",
                                           "decode_buffer_size_per_thread",
                                           "num_decode_threads_per_machine"};
    return attr_names;
  }
};
template<typename Provider>
class OfrecordImageClassificationReaderOpInterpCtxImpl
    : public OfrecordImageClassificationReaderOpInterpCtx {
 public:
  OfrecordImageClassificationReaderOpInterpCtxImpl() = default;
  OfrecordImageClassificationReaderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& data_dir() const override { return impl_.data_dir(); }
  std::string* mutable_data_dir() override { return impl_.mutable_data_dir(); }
  void set_data_dir(const std::string& data_dir) override { impl_.set_data_dir(data_dir); }

  const int32_t& data_part_num() const override { return impl_.data_part_num(); }
  int32_t* mutable_data_part_num() override { return impl_.mutable_data_part_num(); }
  void set_data_part_num(const int32_t& data_part_num) override {
    impl_.set_data_part_num(data_part_num);
  }

  const int32_t& batch_size() const override { return impl_.batch_size(); }
  int32_t* mutable_batch_size() override { return impl_.mutable_batch_size(); }
  void set_batch_size(const int32_t& batch_size) override { impl_.set_batch_size(batch_size); }

  const std::string& part_name_prefix() const override { return impl_.part_name_prefix(); }
  std::string* mutable_part_name_prefix() override { return impl_.mutable_part_name_prefix(); }
  void set_part_name_prefix(const std::string& part_name_prefix) override {
    impl_.set_part_name_prefix(part_name_prefix);
  }

  const int32_t& part_name_suffix_length() const override {
    return impl_.part_name_suffix_length();
  }
  int32_t* mutable_part_name_suffix_length() override {
    return impl_.mutable_part_name_suffix_length();
  }
  void set_part_name_suffix_length(const int32_t& part_name_suffix_length) override {
    impl_.set_part_name_suffix_length(part_name_suffix_length);
  }

  const bool& random_shuffle() const override { return impl_.random_shuffle(); }
  bool* mutable_random_shuffle() override { return impl_.mutable_random_shuffle(); }
  void set_random_shuffle(const bool& random_shuffle) override {
    impl_.set_random_shuffle(random_shuffle);
  }

  const int64_t& seed() const override { return impl_.seed(); }
  int64_t* mutable_seed() override { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) override { impl_.set_seed(seed); }

  const int32_t& shuffle_buffer_size() const override { return impl_.shuffle_buffer_size(); }
  int32_t* mutable_shuffle_buffer_size() override { return impl_.mutable_shuffle_buffer_size(); }
  void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) override {
    impl_.set_shuffle_buffer_size(shuffle_buffer_size);
  }

  const bool& shuffle_after_epoch() const override { return impl_.shuffle_after_epoch(); }
  bool* mutable_shuffle_after_epoch() override { return impl_.mutable_shuffle_after_epoch(); }
  void set_shuffle_after_epoch(const bool& shuffle_after_epoch) override {
    impl_.set_shuffle_after_epoch(shuffle_after_epoch);
  }

  const std::string& color_space() const override { return impl_.color_space(); }
  std::string* mutable_color_space() override { return impl_.mutable_color_space(); }
  void set_color_space(const std::string& color_space) override {
    impl_.set_color_space(color_space);
  }

  const std::string& image_feature_name() const override { return impl_.image_feature_name(); }
  std::string* mutable_image_feature_name() override { return impl_.mutable_image_feature_name(); }
  void set_image_feature_name(const std::string& image_feature_name) override {
    impl_.set_image_feature_name(image_feature_name);
  }

  const std::string& label_feature_name() const override { return impl_.label_feature_name(); }
  std::string* mutable_label_feature_name() override { return impl_.mutable_label_feature_name(); }
  void set_label_feature_name(const std::string& label_feature_name) override {
    impl_.set_label_feature_name(label_feature_name);
  }

  const int32_t& decode_buffer_size_per_thread() const override {
    return impl_.decode_buffer_size_per_thread();
  }
  int32_t* mutable_decode_buffer_size_per_thread() override {
    return impl_.mutable_decode_buffer_size_per_thread();
  }
  void set_decode_buffer_size_per_thread(const int32_t& decode_buffer_size_per_thread) override {
    impl_.set_decode_buffer_size_per_thread(decode_buffer_size_per_thread);
  }

  const int32_t& num_decode_threads_per_machine() const override {
    return impl_.num_decode_threads_per_machine();
  }
  int32_t* mutable_num_decode_threads_per_machine() override {
    return impl_.mutable_num_decode_threads_per_machine();
  }
  void set_num_decode_threads_per_machine(const int32_t& num_decode_threads_per_machine) override {
    impl_.set_num_decode_threads_per_machine(num_decode_threads_per_machine);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OfrecordImageClassificationReaderOp {
 public:
  OfrecordImageClassificationReaderOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "data_dir") {
      return CastAttr(&internal_->data_dir);
    } else if (attr_name == "data_part_num") {
      return CastAttr(&internal_->data_part_num);
    } else if (attr_name == "batch_size") {
      return CastAttr(&internal_->batch_size);
    } else if (attr_name == "part_name_prefix") {
      return CastAttr(&internal_->part_name_prefix);
    } else if (attr_name == "part_name_suffix_length") {
      return CastAttr(&internal_->part_name_suffix_length);
    } else if (attr_name == "random_shuffle") {
      return CastAttr(&internal_->random_shuffle);
    } else if (attr_name == "seed") {
      return CastAttr(&internal_->seed);
    } else if (attr_name == "shuffle_buffer_size") {
      return CastAttr(&internal_->shuffle_buffer_size);
    } else if (attr_name == "shuffle_after_epoch") {
      return CastAttr(&internal_->shuffle_after_epoch);
    } else if (attr_name == "color_space") {
      return CastAttr(&internal_->color_space);
    } else if (attr_name == "image_feature_name") {
      return CastAttr(&internal_->image_feature_name);
    } else if (attr_name == "label_feature_name") {
      return CastAttr(&internal_->label_feature_name);
    } else if (attr_name == "decode_buffer_size_per_thread") {
      return CastAttr(&internal_->decode_buffer_size_per_thread);
    } else if (attr_name == "num_decode_threads_per_machine") {
      return CastAttr(&internal_->num_decode_threads_per_machine);
    } else {
      return Error::RuntimeError()
             << "OfrecordImageClassificationReader op has no attribute named " << attr_name;
    }
  }

  const std::string& data_dir() const { return internal_->data_dir; }
  std::string* mutable_data_dir() { return &internal_->data_dir; }
  void set_data_dir(const std::string& data_dir) { internal_->data_dir = data_dir; }

  const int32_t& data_part_num() const { return internal_->data_part_num; }
  int32_t* mutable_data_part_num() { return &internal_->data_part_num; }
  void set_data_part_num(const int32_t& data_part_num) { internal_->data_part_num = data_part_num; }

  const int32_t& batch_size() const { return internal_->batch_size; }
  int32_t* mutable_batch_size() { return &internal_->batch_size; }
  void set_batch_size(const int32_t& batch_size) { internal_->batch_size = batch_size; }

  const std::string& part_name_prefix() const { return internal_->part_name_prefix; }
  std::string* mutable_part_name_prefix() { return &internal_->part_name_prefix; }
  void set_part_name_prefix(const std::string& part_name_prefix) {
    internal_->part_name_prefix = part_name_prefix;
  }

  const int32_t& part_name_suffix_length() const { return internal_->part_name_suffix_length; }
  int32_t* mutable_part_name_suffix_length() { return &internal_->part_name_suffix_length; }
  void set_part_name_suffix_length(const int32_t& part_name_suffix_length) {
    internal_->part_name_suffix_length = part_name_suffix_length;
  }

  const bool& random_shuffle() const { return internal_->random_shuffle; }
  bool* mutable_random_shuffle() { return &internal_->random_shuffle; }
  void set_random_shuffle(const bool& random_shuffle) {
    internal_->random_shuffle = random_shuffle;
  }

  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }

  const int32_t& shuffle_buffer_size() const { return internal_->shuffle_buffer_size; }
  int32_t* mutable_shuffle_buffer_size() { return &internal_->shuffle_buffer_size; }
  void set_shuffle_buffer_size(const int32_t& shuffle_buffer_size) {
    internal_->shuffle_buffer_size = shuffle_buffer_size;
  }

  const bool& shuffle_after_epoch() const { return internal_->shuffle_after_epoch; }
  bool* mutable_shuffle_after_epoch() { return &internal_->shuffle_after_epoch; }
  void set_shuffle_after_epoch(const bool& shuffle_after_epoch) {
    internal_->shuffle_after_epoch = shuffle_after_epoch;
  }

  const std::string& color_space() const { return internal_->color_space; }
  std::string* mutable_color_space() { return &internal_->color_space; }
  void set_color_space(const std::string& color_space) { internal_->color_space = color_space; }

  const std::string& image_feature_name() const { return internal_->image_feature_name; }
  std::string* mutable_image_feature_name() { return &internal_->image_feature_name; }
  void set_image_feature_name(const std::string& image_feature_name) {
    internal_->image_feature_name = image_feature_name;
  }

  const std::string& label_feature_name() const { return internal_->label_feature_name; }
  std::string* mutable_label_feature_name() { return &internal_->label_feature_name; }
  void set_label_feature_name(const std::string& label_feature_name) {
    internal_->label_feature_name = label_feature_name;
  }

  const int32_t& decode_buffer_size_per_thread() const {
    return internal_->decode_buffer_size_per_thread;
  }
  int32_t* mutable_decode_buffer_size_per_thread() {
    return &internal_->decode_buffer_size_per_thread;
  }
  void set_decode_buffer_size_per_thread(const int32_t& decode_buffer_size_per_thread) {
    internal_->decode_buffer_size_per_thread = decode_buffer_size_per_thread;
  }

  const int32_t& num_decode_threads_per_machine() const {
    return internal_->num_decode_threads_per_machine;
  }
  int32_t* mutable_num_decode_threads_per_machine() {
    return &internal_->num_decode_threads_per_machine;
  }
  void set_num_decode_threads_per_machine(const int32_t& num_decode_threads_per_machine) {
    internal_->num_decode_threads_per_machine = num_decode_threads_per_machine;
  }

 private:
  struct Internal {
    std::string data_dir;
    int32_t data_part_num;
    int32_t batch_size;
    std::string part_name_prefix;
    int32_t part_name_suffix_length;
    bool random_shuffle;
    int64_t seed;
    int32_t shuffle_buffer_size;
    bool shuffle_after_epoch;
    std::string color_space;
    std::string image_feature_name;
    std::string label_feature_name;
    int32_t decode_buffer_size_per_thread;
    int32_t num_decode_threads_per_machine;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.ofrecord_image_classification_reader",
    OfrecordImageClassificationReaderOpInterpCtxImpl<schema::OfrecordImageClassificationReaderOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class OfrecordImageDecoderOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& name() const = 0;
  virtual std::string* mutable_name() = 0;
  virtual void set_name(const std::string& name) = 0;

  virtual const std::string& color_space() const = 0;
  virtual std::string* mutable_color_space() = 0;
  virtual void set_color_space(const std::string& color_space) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"name", "color_space"};
    return attr_names;
  }
};
template<typename Provider>
class OfrecordImageDecoderOpInterpCtxImpl : public OfrecordImageDecoderOpInterpCtx {
 public:
  OfrecordImageDecoderOpInterpCtxImpl() = default;
  OfrecordImageDecoderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& name() const override { return impl_.name(); }
  std::string* mutable_name() override { return impl_.mutable_name(); }
  void set_name(const std::string& name) override { impl_.set_name(name); }

  const std::string& color_space() const override { return impl_.color_space(); }
  std::string* mutable_color_space() override { return impl_.mutable_color_space(); }
  void set_color_space(const std::string& color_space) override {
    impl_.set_color_space(color_space);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OfrecordImageDecoderOp {
 public:
  OfrecordImageDecoderOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "name") {
      return CastAttr(&internal_->name);
    } else if (attr_name == "color_space") {
      return CastAttr(&internal_->color_space);
    } else {
      return Error::RuntimeError()
             << "OfrecordImageDecoder op has no attribute named " << attr_name;
    }
  }

  const std::string& name() const { return internal_->name; }
  std::string* mutable_name() { return &internal_->name; }
  void set_name(const std::string& name) { internal_->name = name; }

  const std::string& color_space() const { return internal_->color_space; }
  std::string* mutable_color_space() { return &internal_->color_space; }
  void set_color_space(const std::string& color_space) { internal_->color_space = color_space; }

 private:
  struct Internal {
    std::string name;
    std::string color_space;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.ofrecord_image_decoder",
                       OfrecordImageDecoderOpInterpCtxImpl<schema::OfrecordImageDecoderOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class OfrecordImageDecoderRandomCropOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& name() const = 0;
  virtual std::string* mutable_name() = 0;
  virtual void set_name(const std::string& name) = 0;

  virtual const std::string& color_space() const = 0;
  virtual std::string* mutable_color_space() = 0;
  virtual void set_color_space(const std::string& color_space) = 0;

  virtual const int32_t& num_attempts() const = 0;
  virtual int32_t* mutable_num_attempts() = 0;
  virtual void set_num_attempts(const int32_t& num_attempts) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const bool& has_seed() const = 0;
  virtual bool* mutable_has_seed() = 0;
  virtual void set_has_seed(const bool& has_seed) = 0;

  virtual const std::vector<float>& random_area() const = 0;
  virtual std::vector<float>* mutable_random_area() = 0;
  virtual void set_random_area(const std::vector<float>& random_area) = 0;

  virtual const std::vector<float>& random_aspect_ratio() const = 0;
  virtual std::vector<float>* mutable_random_aspect_ratio() = 0;
  virtual void set_random_aspect_ratio(const std::vector<float>& random_aspect_ratio) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"name",     "color_space", "num_attempts",       "seed",
                                           "has_seed", "random_area", "random_aspect_ratio"};
    return attr_names;
  }
};
template<typename Provider>
class OfrecordImageDecoderRandomCropOpInterpCtxImpl
    : public OfrecordImageDecoderRandomCropOpInterpCtx {
 public:
  OfrecordImageDecoderRandomCropOpInterpCtxImpl() = default;
  OfrecordImageDecoderRandomCropOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& name() const override { return impl_.name(); }
  std::string* mutable_name() override { return impl_.mutable_name(); }
  void set_name(const std::string& name) override { impl_.set_name(name); }

  const std::string& color_space() const override { return impl_.color_space(); }
  std::string* mutable_color_space() override { return impl_.mutable_color_space(); }
  void set_color_space(const std::string& color_space) override {
    impl_.set_color_space(color_space);
  }

  const int32_t& num_attempts() const override { return impl_.num_attempts(); }
  int32_t* mutable_num_attempts() override { return impl_.mutable_num_attempts(); }
  void set_num_attempts(const int32_t& num_attempts) override {
    impl_.set_num_attempts(num_attempts);
  }

  const int64_t& seed() const override { return impl_.seed(); }
  int64_t* mutable_seed() override { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) override { impl_.set_seed(seed); }

  const bool& has_seed() const override { return impl_.has_seed(); }
  bool* mutable_has_seed() override { return impl_.mutable_has_seed(); }
  void set_has_seed(const bool& has_seed) override { impl_.set_has_seed(has_seed); }

  const std::vector<float>& random_area() const override { return impl_.random_area(); }
  std::vector<float>* mutable_random_area() override { return impl_.mutable_random_area(); }
  void set_random_area(const std::vector<float>& random_area) override {
    impl_.set_random_area(random_area);
  }

  const std::vector<float>& random_aspect_ratio() const override {
    return impl_.random_aspect_ratio();
  }
  std::vector<float>* mutable_random_aspect_ratio() override {
    return impl_.mutable_random_aspect_ratio();
  }
  void set_random_aspect_ratio(const std::vector<float>& random_aspect_ratio) override {
    impl_.set_random_aspect_ratio(random_aspect_ratio);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OfrecordImageDecoderRandomCropOp {
 public:
  OfrecordImageDecoderRandomCropOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "name") {
      return CastAttr(&internal_->name);
    } else if (attr_name == "color_space") {
      return CastAttr(&internal_->color_space);
    } else if (attr_name == "num_attempts") {
      return CastAttr(&internal_->num_attempts);
    } else if (attr_name == "seed") {
      return CastAttr(&internal_->seed);
    } else if (attr_name == "has_seed") {
      return CastAttr(&internal_->has_seed);
    } else if (attr_name == "random_area") {
      return CastAttr(&internal_->random_area);
    } else if (attr_name == "random_aspect_ratio") {
      return CastAttr(&internal_->random_aspect_ratio);
    } else {
      return Error::RuntimeError()
             << "OfrecordImageDecoderRandomCrop op has no attribute named " << attr_name;
    }
  }

  const std::string& name() const { return internal_->name; }
  std::string* mutable_name() { return &internal_->name; }
  void set_name(const std::string& name) { internal_->name = name; }

  const std::string& color_space() const { return internal_->color_space; }
  std::string* mutable_color_space() { return &internal_->color_space; }
  void set_color_space(const std::string& color_space) { internal_->color_space = color_space; }

  const int32_t& num_attempts() const { return internal_->num_attempts; }
  int32_t* mutable_num_attempts() { return &internal_->num_attempts; }
  void set_num_attempts(const int32_t& num_attempts) { internal_->num_attempts = num_attempts; }

  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }

  const bool& has_seed() const { return internal_->has_seed; }
  bool* mutable_has_seed() { return &internal_->has_seed; }
  void set_has_seed(const bool& has_seed) { internal_->has_seed = has_seed; }

  const std::vector<float>& random_area() const { return internal_->random_area; }
  std::vector<float>* mutable_random_area() { return &internal_->random_area; }
  void set_random_area(const std::vector<float>& random_area) {
    internal_->random_area = random_area;
  }

  const std::vector<float>& random_aspect_ratio() const { return internal_->random_aspect_ratio; }
  std::vector<float>* mutable_random_aspect_ratio() { return &internal_->random_aspect_ratio; }
  void set_random_aspect_ratio(const std::vector<float>& random_aspect_ratio) {
    internal_->random_aspect_ratio = random_aspect_ratio;
  }

 private:
  struct Internal {
    std::string name;
    std::string color_space;
    int32_t num_attempts;
    int64_t seed;
    bool has_seed;
    std::vector<float> random_area;
    std::vector<float> random_aspect_ratio;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.ofrecord_image_decoder_random_crop",
    OfrecordImageDecoderRandomCropOpInterpCtxImpl<schema::OfrecordImageDecoderRandomCropOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class OfrecordRawDecoderOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& name() const = 0;
  virtual std::string* mutable_name() = 0;
  virtual void set_name(const std::string& name) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  virtual const DataType& data_type() const = 0;
  virtual DataType* mutable_data_type() = 0;
  virtual void set_data_type(const DataType& data_type) = 0;

  virtual const bool& dim1_varying_length() const = 0;
  virtual bool* mutable_dim1_varying_length() = 0;
  virtual void set_dim1_varying_length(const bool& dim1_varying_length) = 0;

  virtual const bool& truncate() const = 0;
  virtual bool* mutable_truncate() = 0;
  virtual void set_truncate(const bool& truncate) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"name", "shape", "data_type", "dim1_varying_length",
                                           "truncate"};
    return attr_names;
  }
};
template<typename Provider>
class OfrecordRawDecoderOpInterpCtxImpl : public OfrecordRawDecoderOpInterpCtx {
 public:
  OfrecordRawDecoderOpInterpCtxImpl() = default;
  OfrecordRawDecoderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& name() const override { return impl_.name(); }
  std::string* mutable_name() override { return impl_.mutable_name(); }
  void set_name(const std::string& name) override { impl_.set_name(name); }

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  const DataType& data_type() const override { return impl_.data_type(); }
  DataType* mutable_data_type() override { return impl_.mutable_data_type(); }
  void set_data_type(const DataType& data_type) override { impl_.set_data_type(data_type); }

  const bool& dim1_varying_length() const override { return impl_.dim1_varying_length(); }
  bool* mutable_dim1_varying_length() override { return impl_.mutable_dim1_varying_length(); }
  void set_dim1_varying_length(const bool& dim1_varying_length) override {
    impl_.set_dim1_varying_length(dim1_varying_length);
  }

  const bool& truncate() const override { return impl_.truncate(); }
  bool* mutable_truncate() override { return impl_.mutable_truncate(); }
  void set_truncate(const bool& truncate) override { impl_.set_truncate(truncate); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OfrecordRawDecoderOp {
 public:
  OfrecordRawDecoderOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "name") {
      return CastAttr(&internal_->name);
    } else if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else if (attr_name == "data_type") {
      return CastAttr(&internal_->data_type);
    } else if (attr_name == "dim1_varying_length") {
      return CastAttr(&internal_->dim1_varying_length);
    } else if (attr_name == "truncate") {
      return CastAttr(&internal_->truncate);
    } else {
      return Error::RuntimeError() << "OfrecordRawDecoder op has no attribute named " << attr_name;
    }
  }

  const std::string& name() const { return internal_->name; }
  std::string* mutable_name() { return &internal_->name; }
  void set_name(const std::string& name) { internal_->name = name; }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

  const DataType& data_type() const { return internal_->data_type; }
  DataType* mutable_data_type() { return &internal_->data_type; }
  void set_data_type(const DataType& data_type) { internal_->data_type = data_type; }

  const bool& dim1_varying_length() const { return internal_->dim1_varying_length; }
  bool* mutable_dim1_varying_length() { return &internal_->dim1_varying_length; }
  void set_dim1_varying_length(const bool& dim1_varying_length) {
    internal_->dim1_varying_length = dim1_varying_length;
  }

  const bool& truncate() const { return internal_->truncate; }
  bool* mutable_truncate() { return &internal_->truncate; }
  void set_truncate(const bool& truncate) { internal_->truncate = truncate; }

 private:
  struct Internal {
    std::string name;
    Shape shape;
    DataType data_type;
    bool dim1_varying_length;
    bool truncate;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.ofrecord_raw_decoder",
                       OfrecordRawDecoderOpInterpCtxImpl<schema::OfrecordRawDecoderOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class OneHotOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  virtual const double& floating_on_value() const = 0;
  virtual double* mutable_floating_on_value() = 0;
  virtual void set_floating_on_value(const double& floating_on_value) = 0;

  virtual const int64_t& integer_on_value() const = 0;
  virtual int64_t* mutable_integer_on_value() = 0;
  virtual void set_integer_on_value(const int64_t& integer_on_value) = 0;

  virtual const double& floating_off_value() const = 0;
  virtual double* mutable_floating_off_value() = 0;
  virtual void set_floating_off_value(const double& floating_off_value) = 0;

  virtual const int64_t& integer_off_value() const = 0;
  virtual int64_t* mutable_integer_off_value() = 0;
  virtual void set_integer_off_value(const int64_t& integer_off_value) = 0;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{
        "depth", "floating_on_value", "integer_on_value", "floating_off_value", "integer_off_value",
        "dtype"};
    return attr_names;
  }
};
template<typename Provider>
class OneHotOpInterpCtxImpl : public OneHotOpInterpCtx {
 public:
  OneHotOpInterpCtxImpl() = default;
  OneHotOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& depth() const override { return impl_.depth(); }
  int64_t* mutable_depth() override { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) override { impl_.set_depth(depth); }

  const double& floating_on_value() const override { return impl_.floating_on_value(); }
  double* mutable_floating_on_value() override { return impl_.mutable_floating_on_value(); }
  void set_floating_on_value(const double& floating_on_value) override {
    impl_.set_floating_on_value(floating_on_value);
  }

  const int64_t& integer_on_value() const override { return impl_.integer_on_value(); }
  int64_t* mutable_integer_on_value() override { return impl_.mutable_integer_on_value(); }
  void set_integer_on_value(const int64_t& integer_on_value) override {
    impl_.set_integer_on_value(integer_on_value);
  }

  const double& floating_off_value() const override { return impl_.floating_off_value(); }
  double* mutable_floating_off_value() override { return impl_.mutable_floating_off_value(); }
  void set_floating_off_value(const double& floating_off_value) override {
    impl_.set_floating_off_value(floating_off_value);
  }

  const int64_t& integer_off_value() const override { return impl_.integer_off_value(); }
  int64_t* mutable_integer_off_value() override { return impl_.mutable_integer_off_value(); }
  void set_integer_off_value(const int64_t& integer_off_value) override {
    impl_.set_integer_off_value(integer_off_value);
  }

  const DataType& dtype() const override { return impl_.dtype(); }
  DataType* mutable_dtype() override { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) override { impl_.set_dtype(dtype); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OneHotOp {
 public:
  OneHotOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "depth") {
      return CastAttr(&internal_->depth);
    } else if (attr_name == "floating_on_value") {
      return CastAttr(&internal_->floating_on_value);
    } else if (attr_name == "integer_on_value") {
      return CastAttr(&internal_->integer_on_value);
    } else if (attr_name == "floating_off_value") {
      return CastAttr(&internal_->floating_off_value);
    } else if (attr_name == "integer_off_value") {
      return CastAttr(&internal_->integer_off_value);
    } else if (attr_name == "dtype") {
      return CastAttr(&internal_->dtype);
    } else {
      return Error::RuntimeError() << "OneHot op has no attribute named " << attr_name;
    }
  }

  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }

  const double& floating_on_value() const { return internal_->floating_on_value; }
  double* mutable_floating_on_value() { return &internal_->floating_on_value; }
  void set_floating_on_value(const double& floating_on_value) {
    internal_->floating_on_value = floating_on_value;
  }

  const int64_t& integer_on_value() const { return internal_->integer_on_value; }
  int64_t* mutable_integer_on_value() { return &internal_->integer_on_value; }
  void set_integer_on_value(const int64_t& integer_on_value) {
    internal_->integer_on_value = integer_on_value;
  }

  const double& floating_off_value() const { return internal_->floating_off_value; }
  double* mutable_floating_off_value() { return &internal_->floating_off_value; }
  void set_floating_off_value(const double& floating_off_value) {
    internal_->floating_off_value = floating_off_value;
  }

  const int64_t& integer_off_value() const { return internal_->integer_off_value; }
  int64_t* mutable_integer_off_value() { return &internal_->integer_off_value; }
  void set_integer_off_value(const int64_t& integer_off_value) {
    internal_->integer_off_value = integer_off_value;
  }

  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }

 private:
  struct Internal {
    int64_t depth;
    double floating_on_value;
    int64_t integer_on_value;
    double floating_off_value;
    int64_t integer_off_value;
    DataType dtype;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.one_hot", OneHotOpInterpCtxImpl<schema::OneHotOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class OnerecDecoderOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& key() const = 0;
  virtual std::string* mutable_key() = 0;
  virtual void set_key(const std::string& key) = 0;

  virtual const DataType& data_type() const = 0;
  virtual DataType* mutable_data_type() = 0;
  virtual void set_data_type(const DataType& data_type) = 0;

  virtual const Shape& static_shape() const = 0;
  virtual Shape* mutable_static_shape() = 0;
  virtual void set_static_shape(const Shape& static_shape) = 0;

  virtual const bool& is_dynamic() const = 0;
  virtual bool* mutable_is_dynamic() = 0;
  virtual void set_is_dynamic(const bool& is_dynamic) = 0;

  virtual const bool& has_reshape() const = 0;
  virtual bool* mutable_has_reshape() = 0;
  virtual void set_has_reshape(const bool& has_reshape) = 0;

  virtual const Shape& reshape() const = 0;
  virtual Shape* mutable_reshape() = 0;
  virtual void set_reshape(const Shape& reshape) = 0;

  virtual const bool& has_batch_padding() const = 0;
  virtual bool* mutable_has_batch_padding() = 0;
  virtual void set_has_batch_padding(const bool& has_batch_padding) = 0;

  virtual const Shape& batch_padding() const = 0;
  virtual Shape* mutable_batch_padding() = 0;
  virtual void set_batch_padding(const Shape& batch_padding) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{
        "key",         "data_type", "static_shape",      "is_dynamic",
        "has_reshape", "reshape",   "has_batch_padding", "batch_padding"};
    return attr_names;
  }
};
template<typename Provider>
class OnerecDecoderOpInterpCtxImpl : public OnerecDecoderOpInterpCtx {
 public:
  OnerecDecoderOpInterpCtxImpl() = default;
  OnerecDecoderOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& key() const override { return impl_.key(); }
  std::string* mutable_key() override { return impl_.mutable_key(); }
  void set_key(const std::string& key) override { impl_.set_key(key); }

  const DataType& data_type() const override { return impl_.data_type(); }
  DataType* mutable_data_type() override { return impl_.mutable_data_type(); }
  void set_data_type(const DataType& data_type) override { impl_.set_data_type(data_type); }

  const Shape& static_shape() const override { return impl_.static_shape(); }
  Shape* mutable_static_shape() override { return impl_.mutable_static_shape(); }
  void set_static_shape(const Shape& static_shape) override {
    impl_.set_static_shape(static_shape);
  }

  const bool& is_dynamic() const override { return impl_.is_dynamic(); }
  bool* mutable_is_dynamic() override { return impl_.mutable_is_dynamic(); }
  void set_is_dynamic(const bool& is_dynamic) override { impl_.set_is_dynamic(is_dynamic); }

  const bool& has_reshape() const override { return impl_.has_reshape(); }
  bool* mutable_has_reshape() override { return impl_.mutable_has_reshape(); }
  void set_has_reshape(const bool& has_reshape) override { impl_.set_has_reshape(has_reshape); }

  const Shape& reshape() const override { return impl_.reshape(); }
  Shape* mutable_reshape() override { return impl_.mutable_reshape(); }
  void set_reshape(const Shape& reshape) override { impl_.set_reshape(reshape); }

  const bool& has_batch_padding() const override { return impl_.has_batch_padding(); }
  bool* mutable_has_batch_padding() override { return impl_.mutable_has_batch_padding(); }
  void set_has_batch_padding(const bool& has_batch_padding) override {
    impl_.set_has_batch_padding(has_batch_padding);
  }

  const Shape& batch_padding() const override { return impl_.batch_padding(); }
  Shape* mutable_batch_padding() override { return impl_.mutable_batch_padding(); }
  void set_batch_padding(const Shape& batch_padding) override {
    impl_.set_batch_padding(batch_padding);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OnerecDecoderOp {
 public:
  OnerecDecoderOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "key") {
      return CastAttr(&internal_->key);
    } else if (attr_name == "data_type") {
      return CastAttr(&internal_->data_type);
    } else if (attr_name == "static_shape") {
      return CastAttr(&internal_->static_shape);
    } else if (attr_name == "is_dynamic") {
      return CastAttr(&internal_->is_dynamic);
    } else if (attr_name == "has_reshape") {
      return CastAttr(&internal_->has_reshape);
    } else if (attr_name == "reshape") {
      return CastAttr(&internal_->reshape);
    } else if (attr_name == "has_batch_padding") {
      return CastAttr(&internal_->has_batch_padding);
    } else if (attr_name == "batch_padding") {
      return CastAttr(&internal_->batch_padding);
    } else {
      return Error::RuntimeError() << "OnerecDecoder op has no attribute named " << attr_name;
    }
  }

  const std::string& key() const { return internal_->key; }
  std::string* mutable_key() { return &internal_->key; }
  void set_key(const std::string& key) { internal_->key = key; }

  const DataType& data_type() const { return internal_->data_type; }
  DataType* mutable_data_type() { return &internal_->data_type; }
  void set_data_type(const DataType& data_type) { internal_->data_type = data_type; }

  const Shape& static_shape() const { return internal_->static_shape; }
  Shape* mutable_static_shape() { return &internal_->static_shape; }
  void set_static_shape(const Shape& static_shape) { internal_->static_shape = static_shape; }

  const bool& is_dynamic() const { return internal_->is_dynamic; }
  bool* mutable_is_dynamic() { return &internal_->is_dynamic; }
  void set_is_dynamic(const bool& is_dynamic) { internal_->is_dynamic = is_dynamic; }

  const bool& has_reshape() const { return internal_->has_reshape; }
  bool* mutable_has_reshape() { return &internal_->has_reshape; }
  void set_has_reshape(const bool& has_reshape) { internal_->has_reshape = has_reshape; }

  const Shape& reshape() const { return internal_->reshape; }
  Shape* mutable_reshape() { return &internal_->reshape; }
  void set_reshape(const Shape& reshape) { internal_->reshape = reshape; }

  const bool& has_batch_padding() const { return internal_->has_batch_padding; }
  bool* mutable_has_batch_padding() { return &internal_->has_batch_padding; }
  void set_has_batch_padding(const bool& has_batch_padding) {
    internal_->has_batch_padding = has_batch_padding;
  }

  const Shape& batch_padding() const { return internal_->batch_padding; }
  Shape* mutable_batch_padding() { return &internal_->batch_padding; }
  void set_batch_padding(const Shape& batch_padding) { internal_->batch_padding = batch_padding; }

 private:
  struct Internal {
    std::string key;
    DataType data_type;
    Shape static_shape;
    bool is_dynamic;
    bool has_reshape;
    Shape reshape;
    bool has_batch_padding;
    Shape batch_padding;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.onerec_decoder",
                       OnerecDecoderOpInterpCtxImpl<schema::OnerecDecoderOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class OnesLikeOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class OnesLikeOpInterpCtxImpl : public OnesLikeOpInterpCtx {
 public:
  OnesLikeOpInterpCtxImpl() = default;
  OnesLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class OnesLikeOp {
 public:
  OnesLikeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "OnesLike op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.ones_like", OnesLikeOpInterpCtxImpl<schema::OnesLikeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class PackOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& pack_num() const = 0;
  virtual int32_t* mutable_pack_num() = 0;
  virtual void set_pack_num(const int32_t& pack_num) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"pack_num"};
    return attr_names;
  }
};
template<typename Provider>
class PackOpInterpCtxImpl : public PackOpInterpCtx {
 public:
  PackOpInterpCtxImpl() = default;
  PackOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& pack_num() const override { return impl_.pack_num(); }
  int32_t* mutable_pack_num() override { return impl_.mutable_pack_num(); }
  void set_pack_num(const int32_t& pack_num) override { impl_.set_pack_num(pack_num); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class PackOp {
 public:
  PackOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "pack_num") {
      return CastAttr(&internal_->pack_num);
    } else {
      return Error::RuntimeError() << "Pack op has no attribute named " << attr_name;
    }
  }

  const int32_t& pack_num() const { return internal_->pack_num; }
  int32_t* mutable_pack_num() { return &internal_->pack_num; }
  void set_pack_num(const int32_t& pack_num) { internal_->pack_num = pack_num; }

 private:
  struct Internal {
    int32_t pack_num;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.pack", PackOpInterpCtxImpl<schema::PackOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class PadOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& padding_before() const = 0;
  virtual std::vector<int64_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int64_t>& padding_before) = 0;

  virtual const std::vector<int64_t>& padding_after() const = 0;
  virtual std::vector<int64_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<int64_t>& padding_after) = 0;

  virtual const double& floating_constant_value() const = 0;
  virtual double* mutable_floating_constant_value() = 0;
  virtual void set_floating_constant_value(const double& floating_constant_value) = 0;

  virtual const int64_t& integral_constant_value() const = 0;
  virtual int64_t* mutable_integral_constant_value() = 0;
  virtual void set_integral_constant_value(const int64_t& integral_constant_value) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding_before", "padding_after",
                                           "floating_constant_value", "integral_constant_value"};
    return attr_names;
  }
};
template<typename Provider>
class PadOpInterpCtxImpl : public PadOpInterpCtx {
 public:
  PadOpInterpCtxImpl() = default;
  PadOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int64_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int64_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::vector<int64_t>& padding_after() const override { return impl_.padding_after(); }
  std::vector<int64_t>* mutable_padding_after() override { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<int64_t>& padding_after) override {
    impl_.set_padding_after(padding_after);
  }

  const double& floating_constant_value() const override { return impl_.floating_constant_value(); }
  double* mutable_floating_constant_value() override {
    return impl_.mutable_floating_constant_value();
  }
  void set_floating_constant_value(const double& floating_constant_value) override {
    impl_.set_floating_constant_value(floating_constant_value);
  }

  const int64_t& integral_constant_value() const override {
    return impl_.integral_constant_value();
  }
  int64_t* mutable_integral_constant_value() override {
    return impl_.mutable_integral_constant_value();
  }
  void set_integral_constant_value(const int64_t& integral_constant_value) override {
    impl_.set_integral_constant_value(integral_constant_value);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class PadOp {
 public:
  PadOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "padding_after") {
      return CastAttr(&internal_->padding_after);
    } else if (attr_name == "floating_constant_value") {
      return CastAttr(&internal_->floating_constant_value);
    } else if (attr_name == "integral_constant_value") {
      return CastAttr(&internal_->integral_constant_value);
    } else {
      return Error::RuntimeError() << "Pad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int64_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int64_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::vector<int64_t>& padding_after() const { return internal_->padding_after; }
  std::vector<int64_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<int64_t>& padding_after) {
    internal_->padding_after = padding_after;
  }

  const double& floating_constant_value() const { return internal_->floating_constant_value; }
  double* mutable_floating_constant_value() { return &internal_->floating_constant_value; }
  void set_floating_constant_value(const double& floating_constant_value) {
    internal_->floating_constant_value = floating_constant_value;
  }

  const int64_t& integral_constant_value() const { return internal_->integral_constant_value; }
  int64_t* mutable_integral_constant_value() { return &internal_->integral_constant_value; }
  void set_integral_constant_value(const int64_t& integral_constant_value) {
    internal_->integral_constant_value = integral_constant_value;
  }

 private:
  struct Internal {
    std::vector<int64_t> padding_before;
    std::vector<int64_t> padding_after;
    double floating_constant_value;
    int64_t integral_constant_value;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.pad", PadOpInterpCtxImpl<schema::PadOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class PadGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& padding_before() const = 0;
  virtual std::vector<int64_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int64_t>& padding_before) = 0;

  virtual const std::vector<int64_t>& padding_after() const = 0;
  virtual std::vector<int64_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<int64_t>& padding_after) = 0;

  virtual const double& floating_constant_value() const = 0;
  virtual double* mutable_floating_constant_value() = 0;
  virtual void set_floating_constant_value(const double& floating_constant_value) = 0;

  virtual const int64_t& integral_constant_value() const = 0;
  virtual int64_t* mutable_integral_constant_value() = 0;
  virtual void set_integral_constant_value(const int64_t& integral_constant_value) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding_before", "padding_after",
                                           "floating_constant_value", "integral_constant_value"};
    return attr_names;
  }
};
template<typename Provider>
class PadGradOpInterpCtxImpl : public PadGradOpInterpCtx {
 public:
  PadGradOpInterpCtxImpl() = default;
  PadGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int64_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int64_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::vector<int64_t>& padding_after() const override { return impl_.padding_after(); }
  std::vector<int64_t>* mutable_padding_after() override { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<int64_t>& padding_after) override {
    impl_.set_padding_after(padding_after);
  }

  const double& floating_constant_value() const override { return impl_.floating_constant_value(); }
  double* mutable_floating_constant_value() override {
    return impl_.mutable_floating_constant_value();
  }
  void set_floating_constant_value(const double& floating_constant_value) override {
    impl_.set_floating_constant_value(floating_constant_value);
  }

  const int64_t& integral_constant_value() const override {
    return impl_.integral_constant_value();
  }
  int64_t* mutable_integral_constant_value() override {
    return impl_.mutable_integral_constant_value();
  }
  void set_integral_constant_value(const int64_t& integral_constant_value) override {
    impl_.set_integral_constant_value(integral_constant_value);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class PadGradOp {
 public:
  PadGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "padding_after") {
      return CastAttr(&internal_->padding_after);
    } else if (attr_name == "floating_constant_value") {
      return CastAttr(&internal_->floating_constant_value);
    } else if (attr_name == "integral_constant_value") {
      return CastAttr(&internal_->integral_constant_value);
    } else {
      return Error::RuntimeError() << "PadGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int64_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int64_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::vector<int64_t>& padding_after() const { return internal_->padding_after; }
  std::vector<int64_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<int64_t>& padding_after) {
    internal_->padding_after = padding_after;
  }

  const double& floating_constant_value() const { return internal_->floating_constant_value; }
  double* mutable_floating_constant_value() { return &internal_->floating_constant_value; }
  void set_floating_constant_value(const double& floating_constant_value) {
    internal_->floating_constant_value = floating_constant_value;
  }

  const int64_t& integral_constant_value() const { return internal_->integral_constant_value; }
  int64_t* mutable_integral_constant_value() { return &internal_->integral_constant_value; }
  void set_integral_constant_value(const int64_t& integral_constant_value) {
    internal_->integral_constant_value = integral_constant_value;
  }

 private:
  struct Internal {
    std::vector<int64_t> padding_before;
    std::vector<int64_t> padding_after;
    double floating_constant_value;
    int64_t integral_constant_value;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.pad_grad", PadGradOpInterpCtxImpl<schema::PadGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ParallelCastOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& sbp_parallel() const = 0;
  virtual std::string* mutable_sbp_parallel() = 0;
  virtual void set_sbp_parallel(const std::string& sbp_parallel) = 0;

  virtual const std::string& grad_sbp_parallel() const = 0;
  virtual std::string* mutable_grad_sbp_parallel() = 0;
  virtual void set_grad_sbp_parallel(const std::string& grad_sbp_parallel) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"sbp_parallel", "grad_sbp_parallel"};
    return attr_names;
  }
};
template<typename Provider>
class ParallelCastOpInterpCtxImpl : public ParallelCastOpInterpCtx {
 public:
  ParallelCastOpInterpCtxImpl() = default;
  ParallelCastOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& sbp_parallel() const override { return impl_.sbp_parallel(); }
  std::string* mutable_sbp_parallel() override { return impl_.mutable_sbp_parallel(); }
  void set_sbp_parallel(const std::string& sbp_parallel) override {
    impl_.set_sbp_parallel(sbp_parallel);
  }

  const std::string& grad_sbp_parallel() const override { return impl_.grad_sbp_parallel(); }
  std::string* mutable_grad_sbp_parallel() override { return impl_.mutable_grad_sbp_parallel(); }
  void set_grad_sbp_parallel(const std::string& grad_sbp_parallel) override {
    impl_.set_grad_sbp_parallel(grad_sbp_parallel);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ParallelCastOp {
 public:
  ParallelCastOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "sbp_parallel") {
      return CastAttr(&internal_->sbp_parallel);
    } else if (attr_name == "grad_sbp_parallel") {
      return CastAttr(&internal_->grad_sbp_parallel);
    } else {
      return Error::RuntimeError() << "ParallelCast op has no attribute named " << attr_name;
    }
  }

  const std::string& sbp_parallel() const { return internal_->sbp_parallel; }
  std::string* mutable_sbp_parallel() { return &internal_->sbp_parallel; }
  void set_sbp_parallel(const std::string& sbp_parallel) { internal_->sbp_parallel = sbp_parallel; }

  const std::string& grad_sbp_parallel() const { return internal_->grad_sbp_parallel; }
  std::string* mutable_grad_sbp_parallel() { return &internal_->grad_sbp_parallel; }
  void set_grad_sbp_parallel(const std::string& grad_sbp_parallel) {
    internal_->grad_sbp_parallel = grad_sbp_parallel;
  }

 private:
  struct Internal {
    std::string sbp_parallel;
    std::string grad_sbp_parallel;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.parallel_cast", ParallelCastOpInterpCtxImpl<schema::ParallelCastOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class PowOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class PowOpInterpCtxImpl : public PowOpInterpCtx {
 public:
  PowOpInterpCtxImpl() = default;
  PowOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class PowOp {
 public:
  PowOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Pow op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.pow", PowOpInterpCtxImpl<schema::PowOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class PowXGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class PowXGradOpInterpCtxImpl : public PowXGradOpInterpCtx {
 public:
  PowXGradOpInterpCtxImpl() = default;
  PowXGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class PowXGradOp {
 public:
  PowXGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "PowXGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.pow_x_grad", PowXGradOpInterpCtxImpl<schema::PowXGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class PowYGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class PowYGradOpInterpCtxImpl : public PowYGradOpInterpCtx {
 public:
  PowYGradOpInterpCtxImpl() = default;
  PowYGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class PowYGradOp {
 public:
  PowYGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "PowYGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.pow_y_grad", PowYGradOpInterpCtxImpl<schema::PowYGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class PreluOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class PreluOpInterpCtxImpl : public PreluOpInterpCtx {
 public:
  PreluOpInterpCtxImpl() = default;
  PreluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class PreluOp {
 public:
  PreluOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Prelu op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.prelu", PreluOpInterpCtxImpl<schema::PreluOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class PreluGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class PreluGradOpInterpCtxImpl : public PreluGradOpInterpCtx {
 public:
  PreluGradOpInterpCtxImpl() = default;
  PreluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class PreluGradOp {
 public:
  PreluGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "PreluGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.prelu_grad", PreluGradOpInterpCtxImpl<schema::PreluGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class QuantizationOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& quantization_formula() const = 0;
  virtual std::string* mutable_quantization_formula() = 0;
  virtual void set_quantization_formula(const std::string& quantization_formula) = 0;

  virtual const int32_t& quantization_bit() const = 0;
  virtual int32_t* mutable_quantization_bit() = 0;
  virtual void set_quantization_bit(const int32_t& quantization_bit) = 0;

  virtual const std::string& quantization_scheme() const = 0;
  virtual std::string* mutable_quantization_scheme() = 0;
  virtual void set_quantization_scheme(const std::string& quantization_scheme) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"quantization_formula", "quantization_bit",
                                           "quantization_scheme"};
    return attr_names;
  }
};
template<typename Provider>
class QuantizationOpInterpCtxImpl : public QuantizationOpInterpCtx {
 public:
  QuantizationOpInterpCtxImpl() = default;
  QuantizationOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& quantization_formula() const override { return impl_.quantization_formula(); }
  std::string* mutable_quantization_formula() override {
    return impl_.mutable_quantization_formula();
  }
  void set_quantization_formula(const std::string& quantization_formula) override {
    impl_.set_quantization_formula(quantization_formula);
  }

  const int32_t& quantization_bit() const override { return impl_.quantization_bit(); }
  int32_t* mutable_quantization_bit() override { return impl_.mutable_quantization_bit(); }
  void set_quantization_bit(const int32_t& quantization_bit) override {
    impl_.set_quantization_bit(quantization_bit);
  }

  const std::string& quantization_scheme() const override { return impl_.quantization_scheme(); }
  std::string* mutable_quantization_scheme() override {
    return impl_.mutable_quantization_scheme();
  }
  void set_quantization_scheme(const std::string& quantization_scheme) override {
    impl_.set_quantization_scheme(quantization_scheme);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class QuantizationOp {
 public:
  QuantizationOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "quantization_formula") {
      return CastAttr(&internal_->quantization_formula);
    } else if (attr_name == "quantization_bit") {
      return CastAttr(&internal_->quantization_bit);
    } else if (attr_name == "quantization_scheme") {
      return CastAttr(&internal_->quantization_scheme);
    } else {
      return Error::RuntimeError() << "Quantization op has no attribute named " << attr_name;
    }
  }

  const std::string& quantization_formula() const { return internal_->quantization_formula; }
  std::string* mutable_quantization_formula() { return &internal_->quantization_formula; }
  void set_quantization_formula(const std::string& quantization_formula) {
    internal_->quantization_formula = quantization_formula;
  }

  const int32_t& quantization_bit() const { return internal_->quantization_bit; }
  int32_t* mutable_quantization_bit() { return &internal_->quantization_bit; }
  void set_quantization_bit(const int32_t& quantization_bit) {
    internal_->quantization_bit = quantization_bit;
  }

  const std::string& quantization_scheme() const { return internal_->quantization_scheme; }
  std::string* mutable_quantization_scheme() { return &internal_->quantization_scheme; }
  void set_quantization_scheme(const std::string& quantization_scheme) {
    internal_->quantization_scheme = quantization_scheme;
  }

 private:
  struct Internal {
    std::string quantization_formula;
    int32_t quantization_bit;
    std::string quantization_scheme;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.quantization", QuantizationOpInterpCtxImpl<schema::QuantizationOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class RandomMaskLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& rate() const = 0;
  virtual float* mutable_rate() = 0;
  virtual void set_rate(const float& rate) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"rate", "seed"};
    return attr_names;
  }
};
template<typename Provider>
class RandomMaskLikeOpInterpCtxImpl : public RandomMaskLikeOpInterpCtx {
 public:
  RandomMaskLikeOpInterpCtxImpl() = default;
  RandomMaskLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& rate() const override { return impl_.rate(); }
  float* mutable_rate() override { return impl_.mutable_rate(); }
  void set_rate(const float& rate) override { impl_.set_rate(rate); }

  const int64_t& seed() const override { return impl_.seed(); }
  int64_t* mutable_seed() override { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) override { impl_.set_seed(seed); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RandomMaskLikeOp {
 public:
  RandomMaskLikeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "rate") {
      return CastAttr(&internal_->rate);
    } else if (attr_name == "seed") {
      return CastAttr(&internal_->seed);
    } else {
      return Error::RuntimeError() << "RandomMaskLike op has no attribute named " << attr_name;
    }
  }

  const float& rate() const { return internal_->rate; }
  float* mutable_rate() { return &internal_->rate; }
  void set_rate(const float& rate) { internal_->rate = rate; }

  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }

 private:
  struct Internal {
    float rate;
    int64_t seed;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.random_mask_like",
                       RandomMaskLikeOpInterpCtxImpl<schema::RandomMaskLikeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class RandpermOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& n() const = 0;
  virtual int32_t* mutable_n() = 0;
  virtual void set_n(const int32_t& n) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const std::string& nd_sbp() const = 0;
  virtual std::string* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::string& nd_sbp) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"n", "seed", "nd_sbp"};
    return attr_names;
  }
};
template<typename Provider>
class RandpermOpInterpCtxImpl : public RandpermOpInterpCtx {
 public:
  RandpermOpInterpCtxImpl() = default;
  RandpermOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& n() const override { return impl_.n(); }
  int32_t* mutable_n() override { return impl_.mutable_n(); }
  void set_n(const int32_t& n) override { impl_.set_n(n); }

  const int64_t& seed() const override { return impl_.seed(); }
  int64_t* mutable_seed() override { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) override { impl_.set_seed(seed); }

  const std::string& nd_sbp() const override { return impl_.nd_sbp(); }
  std::string* mutable_nd_sbp() override { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::string& nd_sbp) override { impl_.set_nd_sbp(nd_sbp); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RandpermOp {
 public:
  RandpermOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "n") {
      return CastAttr(&internal_->n);
    } else if (attr_name == "seed") {
      return CastAttr(&internal_->seed);
    } else if (attr_name == "nd_sbp") {
      return CastAttr(&internal_->nd_sbp);
    } else {
      return Error::RuntimeError() << "Randperm op has no attribute named " << attr_name;
    }
  }

  const int32_t& n() const { return internal_->n; }
  int32_t* mutable_n() { return &internal_->n; }
  void set_n(const int32_t& n) { internal_->n = n; }

  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }

  const std::string& nd_sbp() const { return internal_->nd_sbp; }
  std::string* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::string& nd_sbp) { internal_->nd_sbp = nd_sbp; }

 private:
  struct Internal {
    int32_t n;
    int64_t seed;
    std::string nd_sbp;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.randperm", RandpermOpInterpCtxImpl<schema::RandpermOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReciprocalOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ReciprocalOpInterpCtxImpl : public ReciprocalOpInterpCtx {
 public:
  ReciprocalOpInterpCtxImpl() = default;
  ReciprocalOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReciprocalOp {
 public:
  ReciprocalOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Reciprocal op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reciprocal", ReciprocalOpInterpCtxImpl<schema::ReciprocalOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReciprocalGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ReciprocalGradOpInterpCtxImpl : public ReciprocalGradOpInterpCtx {
 public:
  ReciprocalGradOpInterpCtxImpl() = default;
  ReciprocalGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReciprocalGradOp {
 public:
  ReciprocalGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ReciprocalGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reciprocal_grad",
                       ReciprocalGradOpInterpCtxImpl<schema::ReciprocalGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReciprocalNoNanOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ReciprocalNoNanOpInterpCtxImpl : public ReciprocalNoNanOpInterpCtx {
 public:
  ReciprocalNoNanOpInterpCtxImpl() = default;
  ReciprocalNoNanOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReciprocalNoNanOp {
 public:
  ReciprocalNoNanOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ReciprocalNoNan op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reciprocal_no_nan",
                       ReciprocalNoNanOpInterpCtxImpl<schema::ReciprocalNoNanOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReciprocalNoNanGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ReciprocalNoNanGradOpInterpCtxImpl : public ReciprocalNoNanGradOpInterpCtx {
 public:
  ReciprocalNoNanGradOpInterpCtxImpl() = default;
  ReciprocalNoNanGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReciprocalNoNanGradOp {
 public:
  ReciprocalNoNanGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ReciprocalNoNanGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reciprocal_no_nan_grad",
                       ReciprocalNoNanGradOpInterpCtxImpl<schema::ReciprocalNoNanGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class RecvOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& src_process_id() const = 0;
  virtual int64_t* mutable_src_process_id() = 0;
  virtual void set_src_process_id(const int64_t& src_process_id) = 0;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  virtual const std::string& device_type() const = 0;
  virtual std::string* mutable_device_type() = 0;
  virtual void set_device_type(const std::string& device_type) = 0;

  virtual const int64_t& device_id() const = 0;
  virtual int64_t* mutable_device_id() = 0;
  virtual void set_device_id(const int64_t& device_id) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"src_process_id", "dtype", "shape", "device_type",
                                           "device_id"};
    return attr_names;
  }
};
template<typename Provider>
class RecvOpInterpCtxImpl : public RecvOpInterpCtx {
 public:
  RecvOpInterpCtxImpl() = default;
  RecvOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& src_process_id() const override { return impl_.src_process_id(); }
  int64_t* mutable_src_process_id() override { return impl_.mutable_src_process_id(); }
  void set_src_process_id(const int64_t& src_process_id) override {
    impl_.set_src_process_id(src_process_id);
  }

  const DataType& dtype() const override { return impl_.dtype(); }
  DataType* mutable_dtype() override { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) override { impl_.set_dtype(dtype); }

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  const std::string& device_type() const override { return impl_.device_type(); }
  std::string* mutable_device_type() override { return impl_.mutable_device_type(); }
  void set_device_type(const std::string& device_type) override {
    impl_.set_device_type(device_type);
  }

  const int64_t& device_id() const override { return impl_.device_id(); }
  int64_t* mutable_device_id() override { return impl_.mutable_device_id(); }
  void set_device_id(const int64_t& device_id) override { impl_.set_device_id(device_id); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RecvOp {
 public:
  RecvOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "src_process_id") {
      return CastAttr(&internal_->src_process_id);
    } else if (attr_name == "dtype") {
      return CastAttr(&internal_->dtype);
    } else if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else if (attr_name == "device_type") {
      return CastAttr(&internal_->device_type);
    } else if (attr_name == "device_id") {
      return CastAttr(&internal_->device_id);
    } else {
      return Error::RuntimeError() << "Recv op has no attribute named " << attr_name;
    }
  }

  const int64_t& src_process_id() const { return internal_->src_process_id; }
  int64_t* mutable_src_process_id() { return &internal_->src_process_id; }
  void set_src_process_id(const int64_t& src_process_id) {
    internal_->src_process_id = src_process_id;
  }

  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

  const std::string& device_type() const { return internal_->device_type; }
  std::string* mutable_device_type() { return &internal_->device_type; }
  void set_device_type(const std::string& device_type) { internal_->device_type = device_type; }

  const int64_t& device_id() const { return internal_->device_id; }
  int64_t* mutable_device_id() { return &internal_->device_id; }
  void set_device_id(const int64_t& device_id) { internal_->device_id = device_id; }

 private:
  struct Internal {
    int64_t src_process_id;
    DataType dtype;
    Shape shape;
    std::string device_type;
    int64_t device_id;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.recv", RecvOpInterpCtxImpl<schema::RecvOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReduceAllOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& axis() const = 0;
  virtual std::vector<int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "keepdims"};
    return attr_names;
  }
};
template<typename Provider>
class ReduceAllOpInterpCtxImpl : public ReduceAllOpInterpCtx {
 public:
  ReduceAllOpInterpCtxImpl() = default;
  ReduceAllOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& axis() const override { return impl_.axis(); }
  std::vector<int32_t>* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const std::vector<int32_t>& axis) override { impl_.set_axis(axis); }

  const bool& keepdims() const override { return impl_.keepdims(); }
  bool* mutable_keepdims() override { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) override { impl_.set_keepdims(keepdims); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceAllOp {
 public:
  ReduceAllOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "keepdims") {
      return CastAttr(&internal_->keepdims);
    } else {
      return Error::RuntimeError() << "ReduceAll op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& axis() const { return internal_->axis; }
  std::vector<int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<int32_t>& axis) { internal_->axis = axis; }

  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }

 private:
  struct Internal {
    std::vector<int32_t> axis;
    bool keepdims;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reduce_all", ReduceAllOpInterpCtxImpl<schema::ReduceAllOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReduceAnyOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& axis() const = 0;
  virtual std::vector<int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "keepdims"};
    return attr_names;
  }
};
template<typename Provider>
class ReduceAnyOpInterpCtxImpl : public ReduceAnyOpInterpCtx {
 public:
  ReduceAnyOpInterpCtxImpl() = default;
  ReduceAnyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& axis() const override { return impl_.axis(); }
  std::vector<int32_t>* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const std::vector<int32_t>& axis) override { impl_.set_axis(axis); }

  const bool& keepdims() const override { return impl_.keepdims(); }
  bool* mutable_keepdims() override { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) override { impl_.set_keepdims(keepdims); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceAnyOp {
 public:
  ReduceAnyOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "keepdims") {
      return CastAttr(&internal_->keepdims);
    } else {
      return Error::RuntimeError() << "ReduceAny op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& axis() const { return internal_->axis; }
  std::vector<int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<int32_t>& axis) { internal_->axis = axis; }

  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }

 private:
  struct Internal {
    std::vector<int32_t> axis;
    bool keepdims;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reduce_any", ReduceAnyOpInterpCtxImpl<schema::ReduceAnyOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReduceMaxOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& axis() const = 0;
  virtual std::vector<int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "keepdims"};
    return attr_names;
  }
};
template<typename Provider>
class ReduceMaxOpInterpCtxImpl : public ReduceMaxOpInterpCtx {
 public:
  ReduceMaxOpInterpCtxImpl() = default;
  ReduceMaxOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& axis() const override { return impl_.axis(); }
  std::vector<int32_t>* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const std::vector<int32_t>& axis) override { impl_.set_axis(axis); }

  const bool& keepdims() const override { return impl_.keepdims(); }
  bool* mutable_keepdims() override { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) override { impl_.set_keepdims(keepdims); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMaxOp {
 public:
  ReduceMaxOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "keepdims") {
      return CastAttr(&internal_->keepdims);
    } else {
      return Error::RuntimeError() << "ReduceMax op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& axis() const { return internal_->axis; }
  std::vector<int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<int32_t>& axis) { internal_->axis = axis; }

  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }

 private:
  struct Internal {
    std::vector<int32_t> axis;
    bool keepdims;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reduce_max", ReduceMaxOpInterpCtxImpl<schema::ReduceMaxOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReduceMaxDeviceStageOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& axis() const = 0;
  virtual std::vector<int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<int32_t>& axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis"};
    return attr_names;
  }
};
template<typename Provider>
class ReduceMaxDeviceStageOpInterpCtxImpl : public ReduceMaxDeviceStageOpInterpCtx {
 public:
  ReduceMaxDeviceStageOpInterpCtxImpl() = default;
  ReduceMaxDeviceStageOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& axis() const override { return impl_.axis(); }
  std::vector<int32_t>* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const std::vector<int32_t>& axis) override { impl_.set_axis(axis); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMaxDeviceStageOp {
 public:
  ReduceMaxDeviceStageOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else {
      return Error::RuntimeError()
             << "ReduceMaxDeviceStage op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& axis() const { return internal_->axis; }
  std::vector<int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<int32_t>& axis) { internal_->axis = axis; }

 private:
  struct Internal {
    std::vector<int32_t> axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reduce_max_device_stage",
                       ReduceMaxDeviceStageOpInterpCtxImpl<schema::ReduceMaxDeviceStageOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReduceMaxDeviceStageGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& axis() const = 0;
  virtual std::vector<int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<int32_t>& axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis"};
    return attr_names;
  }
};
template<typename Provider>
class ReduceMaxDeviceStageGradOpInterpCtxImpl : public ReduceMaxDeviceStageGradOpInterpCtx {
 public:
  ReduceMaxDeviceStageGradOpInterpCtxImpl() = default;
  ReduceMaxDeviceStageGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& axis() const override { return impl_.axis(); }
  std::vector<int32_t>* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const std::vector<int32_t>& axis) override { impl_.set_axis(axis); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMaxDeviceStageGradOp {
 public:
  ReduceMaxDeviceStageGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else {
      return Error::RuntimeError()
             << "ReduceMaxDeviceStageGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& axis() const { return internal_->axis; }
  std::vector<int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<int32_t>& axis) { internal_->axis = axis; }

 private:
  struct Internal {
    std::vector<int32_t> axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reduce_max_device_stage_grad",
                       ReduceMaxDeviceStageGradOpInterpCtxImpl<schema::ReduceMaxDeviceStageGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReduceMaxGlobalStageOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& axis() const = 0;
  virtual std::vector<int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "keepdims"};
    return attr_names;
  }
};
template<typename Provider>
class ReduceMaxGlobalStageOpInterpCtxImpl : public ReduceMaxGlobalStageOpInterpCtx {
 public:
  ReduceMaxGlobalStageOpInterpCtxImpl() = default;
  ReduceMaxGlobalStageOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& axis() const override { return impl_.axis(); }
  std::vector<int32_t>* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const std::vector<int32_t>& axis) override { impl_.set_axis(axis); }

  const bool& keepdims() const override { return impl_.keepdims(); }
  bool* mutable_keepdims() override { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) override { impl_.set_keepdims(keepdims); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMaxGlobalStageOp {
 public:
  ReduceMaxGlobalStageOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "keepdims") {
      return CastAttr(&internal_->keepdims);
    } else {
      return Error::RuntimeError()
             << "ReduceMaxGlobalStage op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& axis() const { return internal_->axis; }
  std::vector<int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<int32_t>& axis) { internal_->axis = axis; }

  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }

 private:
  struct Internal {
    std::vector<int32_t> axis;
    bool keepdims;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reduce_max_global_stage",
                       ReduceMaxGlobalStageOpInterpCtxImpl<schema::ReduceMaxGlobalStageOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReduceMaxGlobalStageGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& axis() const = 0;
  virtual std::vector<int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "keepdims"};
    return attr_names;
  }
};
template<typename Provider>
class ReduceMaxGlobalStageGradOpInterpCtxImpl : public ReduceMaxGlobalStageGradOpInterpCtx {
 public:
  ReduceMaxGlobalStageGradOpInterpCtxImpl() = default;
  ReduceMaxGlobalStageGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& axis() const override { return impl_.axis(); }
  std::vector<int32_t>* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const std::vector<int32_t>& axis) override { impl_.set_axis(axis); }

  const bool& keepdims() const override { return impl_.keepdims(); }
  bool* mutable_keepdims() override { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) override { impl_.set_keepdims(keepdims); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMaxGlobalStageGradOp {
 public:
  ReduceMaxGlobalStageGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "keepdims") {
      return CastAttr(&internal_->keepdims);
    } else {
      return Error::RuntimeError()
             << "ReduceMaxGlobalStageGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& axis() const { return internal_->axis; }
  std::vector<int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<int32_t>& axis) { internal_->axis = axis; }

  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }

 private:
  struct Internal {
    std::vector<int32_t> axis;
    bool keepdims;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reduce_max_global_stage_grad",
                       ReduceMaxGlobalStageGradOpInterpCtxImpl<schema::ReduceMaxGlobalStageGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReduceMinOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& axis() const = 0;
  virtual std::vector<int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "keepdims"};
    return attr_names;
  }
};
template<typename Provider>
class ReduceMinOpInterpCtxImpl : public ReduceMinOpInterpCtx {
 public:
  ReduceMinOpInterpCtxImpl() = default;
  ReduceMinOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& axis() const override { return impl_.axis(); }
  std::vector<int32_t>* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const std::vector<int32_t>& axis) override { impl_.set_axis(axis); }

  const bool& keepdims() const override { return impl_.keepdims(); }
  bool* mutable_keepdims() override { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) override { impl_.set_keepdims(keepdims); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMinOp {
 public:
  ReduceMinOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "keepdims") {
      return CastAttr(&internal_->keepdims);
    } else {
      return Error::RuntimeError() << "ReduceMin op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& axis() const { return internal_->axis; }
  std::vector<int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<int32_t>& axis) { internal_->axis = axis; }

  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }

 private:
  struct Internal {
    std::vector<int32_t> axis;
    bool keepdims;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reduce_min", ReduceMinOpInterpCtxImpl<schema::ReduceMinOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReduceMinDeviceStageOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& axis() const = 0;
  virtual std::vector<int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<int32_t>& axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis"};
    return attr_names;
  }
};
template<typename Provider>
class ReduceMinDeviceStageOpInterpCtxImpl : public ReduceMinDeviceStageOpInterpCtx {
 public:
  ReduceMinDeviceStageOpInterpCtxImpl() = default;
  ReduceMinDeviceStageOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& axis() const override { return impl_.axis(); }
  std::vector<int32_t>* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const std::vector<int32_t>& axis) override { impl_.set_axis(axis); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMinDeviceStageOp {
 public:
  ReduceMinDeviceStageOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else {
      return Error::RuntimeError()
             << "ReduceMinDeviceStage op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& axis() const { return internal_->axis; }
  std::vector<int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<int32_t>& axis) { internal_->axis = axis; }

 private:
  struct Internal {
    std::vector<int32_t> axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reduce_min_device_stage",
                       ReduceMinDeviceStageOpInterpCtxImpl<schema::ReduceMinDeviceStageOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReduceMinDeviceStageGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& axis() const = 0;
  virtual std::vector<int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<int32_t>& axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis"};
    return attr_names;
  }
};
template<typename Provider>
class ReduceMinDeviceStageGradOpInterpCtxImpl : public ReduceMinDeviceStageGradOpInterpCtx {
 public:
  ReduceMinDeviceStageGradOpInterpCtxImpl() = default;
  ReduceMinDeviceStageGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& axis() const override { return impl_.axis(); }
  std::vector<int32_t>* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const std::vector<int32_t>& axis) override { impl_.set_axis(axis); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMinDeviceStageGradOp {
 public:
  ReduceMinDeviceStageGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else {
      return Error::RuntimeError()
             << "ReduceMinDeviceStageGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& axis() const { return internal_->axis; }
  std::vector<int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<int32_t>& axis) { internal_->axis = axis; }

 private:
  struct Internal {
    std::vector<int32_t> axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reduce_min_device_stage_grad",
                       ReduceMinDeviceStageGradOpInterpCtxImpl<schema::ReduceMinDeviceStageGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReduceMinGlobalStageOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& axis() const = 0;
  virtual std::vector<int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "keepdims"};
    return attr_names;
  }
};
template<typename Provider>
class ReduceMinGlobalStageOpInterpCtxImpl : public ReduceMinGlobalStageOpInterpCtx {
 public:
  ReduceMinGlobalStageOpInterpCtxImpl() = default;
  ReduceMinGlobalStageOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& axis() const override { return impl_.axis(); }
  std::vector<int32_t>* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const std::vector<int32_t>& axis) override { impl_.set_axis(axis); }

  const bool& keepdims() const override { return impl_.keepdims(); }
  bool* mutable_keepdims() override { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) override { impl_.set_keepdims(keepdims); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMinGlobalStageOp {
 public:
  ReduceMinGlobalStageOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "keepdims") {
      return CastAttr(&internal_->keepdims);
    } else {
      return Error::RuntimeError()
             << "ReduceMinGlobalStage op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& axis() const { return internal_->axis; }
  std::vector<int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<int32_t>& axis) { internal_->axis = axis; }

  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }

 private:
  struct Internal {
    std::vector<int32_t> axis;
    bool keepdims;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reduce_min_global_stage",
                       ReduceMinGlobalStageOpInterpCtxImpl<schema::ReduceMinGlobalStageOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReduceMinGlobalStageGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& axis() const = 0;
  virtual std::vector<int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "keepdims"};
    return attr_names;
  }
};
template<typename Provider>
class ReduceMinGlobalStageGradOpInterpCtxImpl : public ReduceMinGlobalStageGradOpInterpCtx {
 public:
  ReduceMinGlobalStageGradOpInterpCtxImpl() = default;
  ReduceMinGlobalStageGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& axis() const override { return impl_.axis(); }
  std::vector<int32_t>* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const std::vector<int32_t>& axis) override { impl_.set_axis(axis); }

  const bool& keepdims() const override { return impl_.keepdims(); }
  bool* mutable_keepdims() override { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) override { impl_.set_keepdims(keepdims); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceMinGlobalStageGradOp {
 public:
  ReduceMinGlobalStageGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "keepdims") {
      return CastAttr(&internal_->keepdims);
    } else {
      return Error::RuntimeError()
             << "ReduceMinGlobalStageGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& axis() const { return internal_->axis; }
  std::vector<int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<int32_t>& axis) { internal_->axis = axis; }

  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }

 private:
  struct Internal {
    std::vector<int32_t> axis;
    bool keepdims;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reduce_min_global_stage_grad",
                       ReduceMinGlobalStageGradOpInterpCtxImpl<schema::ReduceMinGlobalStageGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReduceProdOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& axis() const = 0;
  virtual std::vector<int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "keepdims"};
    return attr_names;
  }
};
template<typename Provider>
class ReduceProdOpInterpCtxImpl : public ReduceProdOpInterpCtx {
 public:
  ReduceProdOpInterpCtxImpl() = default;
  ReduceProdOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& axis() const override { return impl_.axis(); }
  std::vector<int32_t>* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const std::vector<int32_t>& axis) override { impl_.set_axis(axis); }

  const bool& keepdims() const override { return impl_.keepdims(); }
  bool* mutable_keepdims() override { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) override { impl_.set_keepdims(keepdims); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceProdOp {
 public:
  ReduceProdOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "keepdims") {
      return CastAttr(&internal_->keepdims);
    } else {
      return Error::RuntimeError() << "ReduceProd op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& axis() const { return internal_->axis; }
  std::vector<int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<int32_t>& axis) { internal_->axis = axis; }

  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }

 private:
  struct Internal {
    std::vector<int32_t> axis;
    bool keepdims;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reduce_prod", ReduceProdOpInterpCtxImpl<schema::ReduceProdOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReduceSumOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& axis() const = 0;
  virtual std::vector<int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<int32_t>& axis) = 0;

  virtual const bool& keepdims() const = 0;
  virtual bool* mutable_keepdims() = 0;
  virtual void set_keepdims(const bool& keepdims) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "keepdims"};
    return attr_names;
  }
};
template<typename Provider>
class ReduceSumOpInterpCtxImpl : public ReduceSumOpInterpCtx {
 public:
  ReduceSumOpInterpCtxImpl() = default;
  ReduceSumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& axis() const override { return impl_.axis(); }
  std::vector<int32_t>* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const std::vector<int32_t>& axis) override { impl_.set_axis(axis); }

  const bool& keepdims() const override { return impl_.keepdims(); }
  bool* mutable_keepdims() override { return impl_.mutable_keepdims(); }
  void set_keepdims(const bool& keepdims) override { impl_.set_keepdims(keepdims); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceSumOp {
 public:
  ReduceSumOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "keepdims") {
      return CastAttr(&internal_->keepdims);
    } else {
      return Error::RuntimeError() << "ReduceSum op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& axis() const { return internal_->axis; }
  std::vector<int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<int32_t>& axis) { internal_->axis = axis; }

  const bool& keepdims() const { return internal_->keepdims; }
  bool* mutable_keepdims() { return &internal_->keepdims; }
  void set_keepdims(const bool& keepdims) { internal_->keepdims = keepdims; }

 private:
  struct Internal {
    std::vector<int32_t> axis;
    bool keepdims;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reduce_sum", ReduceSumOpInterpCtxImpl<schema::ReduceSumOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReduceSumLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& axis() const = 0;
  virtual std::vector<int32_t>* mutable_axis() = 0;
  virtual void set_axis(const std::vector<int32_t>& axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis"};
    return attr_names;
  }
};
template<typename Provider>
class ReduceSumLikeOpInterpCtxImpl : public ReduceSumLikeOpInterpCtx {
 public:
  ReduceSumLikeOpInterpCtxImpl() = default;
  ReduceSumLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& axis() const override { return impl_.axis(); }
  std::vector<int32_t>* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const std::vector<int32_t>& axis) override { impl_.set_axis(axis); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReduceSumLikeOp {
 public:
  ReduceSumLikeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else {
      return Error::RuntimeError() << "ReduceSumLike op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& axis() const { return internal_->axis; }
  std::vector<int32_t>* mutable_axis() { return &internal_->axis; }
  void set_axis(const std::vector<int32_t>& axis) { internal_->axis = axis; }

 private:
  struct Internal {
    std::vector<int32_t> axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reduce_sum_like",
                       ReduceSumLikeOpInterpCtxImpl<schema::ReduceSumLikeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReflectionPad2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& padding() const = 0;
  virtual std::vector<int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int64_t>& padding) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding"};
    return attr_names;
  }
};
template<typename Provider>
class ReflectionPad2DOpInterpCtxImpl : public ReflectionPad2DOpInterpCtx {
 public:
  ReflectionPad2DOpInterpCtxImpl() = default;
  ReflectionPad2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& padding() const override { return impl_.padding(); }
  std::vector<int64_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int64_t>& padding) override { impl_.set_padding(padding); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReflectionPad2DOp {
 public:
  ReflectionPad2DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else {
      return Error::RuntimeError() << "ReflectionPad2D op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& padding() const { return internal_->padding; }
  std::vector<int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int64_t>& padding) { internal_->padding = padding; }

 private:
  struct Internal {
    std::vector<int64_t> padding;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reflection_pad2d",
                       ReflectionPad2DOpInterpCtxImpl<schema::ReflectionPad2DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReflectionPad2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& padding() const = 0;
  virtual std::vector<int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int64_t>& padding) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding"};
    return attr_names;
  }
};
template<typename Provider>
class ReflectionPad2DGradOpInterpCtxImpl : public ReflectionPad2DGradOpInterpCtx {
 public:
  ReflectionPad2DGradOpInterpCtxImpl() = default;
  ReflectionPad2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& padding() const override { return impl_.padding(); }
  std::vector<int64_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int64_t>& padding) override { impl_.set_padding(padding); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReflectionPad2DGradOp {
 public:
  ReflectionPad2DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else {
      return Error::RuntimeError() << "ReflectionPad2DGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& padding() const { return internal_->padding; }
  std::vector<int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int64_t>& padding) { internal_->padding = padding; }

 private:
  struct Internal {
    std::vector<int64_t> padding;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reflection_pad2d_grad",
                       ReflectionPad2DGradOpInterpCtxImpl<schema::ReflectionPad2DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReluOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ReluOpInterpCtxImpl : public ReluOpInterpCtx {
 public:
  ReluOpInterpCtxImpl() = default;
  ReluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReluOp {
 public:
  ReluOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Relu op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.relu", ReluOpInterpCtxImpl<schema::ReluOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReluGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ReluGradOpInterpCtxImpl : public ReluGradOpInterpCtx {
 public:
  ReluGradOpInterpCtxImpl() = default;
  ReluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReluGradOp {
 public:
  ReluGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ReluGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.relu_grad", ReluGradOpInterpCtxImpl<schema::ReluGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class RepeatOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& repeat_num() const = 0;
  virtual int32_t* mutable_repeat_num() = 0;
  virtual void set_repeat_num(const int32_t& repeat_num) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"repeat_num"};
    return attr_names;
  }
};
template<typename Provider>
class RepeatOpInterpCtxImpl : public RepeatOpInterpCtx {
 public:
  RepeatOpInterpCtxImpl() = default;
  RepeatOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& repeat_num() const override { return impl_.repeat_num(); }
  int32_t* mutable_repeat_num() override { return impl_.mutable_repeat_num(); }
  void set_repeat_num(const int32_t& repeat_num) override { impl_.set_repeat_num(repeat_num); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RepeatOp {
 public:
  RepeatOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "repeat_num") {
      return CastAttr(&internal_->repeat_num);
    } else {
      return Error::RuntimeError() << "Repeat op has no attribute named " << attr_name;
    }
  }

  const int32_t& repeat_num() const { return internal_->repeat_num; }
  int32_t* mutable_repeat_num() { return &internal_->repeat_num; }
  void set_repeat_num(const int32_t& repeat_num) { internal_->repeat_num = repeat_num; }

 private:
  struct Internal {
    int32_t repeat_num;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.repeat", RepeatOpInterpCtxImpl<schema::RepeatOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReplicationPad2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& padding() const = 0;
  virtual std::vector<int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int64_t>& padding) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding"};
    return attr_names;
  }
};
template<typename Provider>
class ReplicationPad2DOpInterpCtxImpl : public ReplicationPad2DOpInterpCtx {
 public:
  ReplicationPad2DOpInterpCtxImpl() = default;
  ReplicationPad2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& padding() const override { return impl_.padding(); }
  std::vector<int64_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int64_t>& padding) override { impl_.set_padding(padding); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReplicationPad2DOp {
 public:
  ReplicationPad2DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else {
      return Error::RuntimeError() << "ReplicationPad2D op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& padding() const { return internal_->padding; }
  std::vector<int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int64_t>& padding) { internal_->padding = padding; }

 private:
  struct Internal {
    std::vector<int64_t> padding;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.replication_pad2d",
                       ReplicationPad2DOpInterpCtxImpl<schema::ReplicationPad2DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReplicationPad2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& padding() const = 0;
  virtual std::vector<int64_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int64_t>& padding) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding"};
    return attr_names;
  }
};
template<typename Provider>
class ReplicationPad2DGradOpInterpCtxImpl : public ReplicationPad2DGradOpInterpCtx {
 public:
  ReplicationPad2DGradOpInterpCtxImpl() = default;
  ReplicationPad2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& padding() const override { return impl_.padding(); }
  std::vector<int64_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int64_t>& padding) override { impl_.set_padding(padding); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReplicationPad2DGradOp {
 public:
  ReplicationPad2DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else {
      return Error::RuntimeError()
             << "ReplicationPad2DGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& padding() const { return internal_->padding; }
  std::vector<int64_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int64_t>& padding) { internal_->padding = padding; }

 private:
  struct Internal {
    std::vector<int64_t> padding;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.replication_pad2d_grad",
                       ReplicationPad2DGradOpInterpCtxImpl<schema::ReplicationPad2DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReshapeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"shape"};
    return attr_names;
  }
};
template<typename Provider>
class ReshapeOpInterpCtxImpl : public ReshapeOpInterpCtx {
 public:
  ReshapeOpInterpCtxImpl() = default;
  ReshapeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReshapeOp {
 public:
  ReshapeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else {
      return Error::RuntimeError() << "Reshape op has no attribute named " << attr_name;
    }
  }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

 private:
  struct Internal {
    Shape shape;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reshape", ReshapeOpInterpCtxImpl<schema::ReshapeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ReshapeLikeOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ReshapeLikeOpInterpCtxImpl : public ReshapeLikeOpInterpCtx {
 public:
  ReshapeLikeOpInterpCtxImpl() = default;
  ReshapeLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ReshapeLikeOp {
 public:
  ReshapeLikeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ReshapeLike op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.reshape_like", ReshapeLikeOpInterpCtxImpl<schema::ReshapeLikeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class RintOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class RintOpInterpCtxImpl : public RintOpInterpCtx {
 public:
  RintOpInterpCtxImpl() = default;
  RintOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RintOp {
 public:
  RintOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Rint op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.rint", RintOpInterpCtxImpl<schema::RintOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class RintGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class RintGradOpInterpCtxImpl : public RintGradOpInterpCtx {
 public:
  RintGradOpInterpCtxImpl() = default;
  RintGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RintGradOp {
 public:
  RintGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "RintGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.rint_grad", RintGradOpInterpCtxImpl<schema::RintGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class RmspropUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& learning_rate_val() const = 0;
  virtual float* mutable_learning_rate_val() = 0;
  virtual void set_learning_rate_val(const float& learning_rate_val) = 0;

  virtual const double& scale() const = 0;
  virtual double* mutable_scale() = 0;
  virtual void set_scale(const double& scale) = 0;

  virtual const float& l1() const = 0;
  virtual float* mutable_l1() = 0;
  virtual void set_l1(const float& l1) = 0;

  virtual const float& l2() const = 0;
  virtual float* mutable_l2() = 0;
  virtual void set_l2(const float& l2) = 0;

  virtual const bool& centered() const = 0;
  virtual bool* mutable_centered() = 0;
  virtual void set_centered(const bool& centered) = 0;

  virtual const float& epsilon() const = 0;
  virtual float* mutable_epsilon() = 0;
  virtual void set_epsilon(const float& epsilon) = 0;

  virtual const float& decay_rate() const = 0;
  virtual float* mutable_decay_rate() = 0;
  virtual void set_decay_rate(const float& decay_rate) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{
        "learning_rate_val", "scale",   "l1",         "l2",
        "centered",          "epsilon", "decay_rate", "weight_decay"};
    return attr_names;
  }
};
template<typename Provider>
class RmspropUpdateOpInterpCtxImpl : public RmspropUpdateOpInterpCtx {
 public:
  RmspropUpdateOpInterpCtxImpl() = default;
  RmspropUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& learning_rate_val() const override { return impl_.learning_rate_val(); }
  float* mutable_learning_rate_val() override { return impl_.mutable_learning_rate_val(); }
  void set_learning_rate_val(const float& learning_rate_val) override {
    impl_.set_learning_rate_val(learning_rate_val);
  }

  const double& scale() const override { return impl_.scale(); }
  double* mutable_scale() override { return impl_.mutable_scale(); }
  void set_scale(const double& scale) override { impl_.set_scale(scale); }

  const float& l1() const override { return impl_.l1(); }
  float* mutable_l1() override { return impl_.mutable_l1(); }
  void set_l1(const float& l1) override { impl_.set_l1(l1); }

  const float& l2() const override { return impl_.l2(); }
  float* mutable_l2() override { return impl_.mutable_l2(); }
  void set_l2(const float& l2) override { impl_.set_l2(l2); }

  const bool& centered() const override { return impl_.centered(); }
  bool* mutable_centered() override { return impl_.mutable_centered(); }
  void set_centered(const bool& centered) override { impl_.set_centered(centered); }

  const float& epsilon() const override { return impl_.epsilon(); }
  float* mutable_epsilon() override { return impl_.mutable_epsilon(); }
  void set_epsilon(const float& epsilon) override { impl_.set_epsilon(epsilon); }

  const float& decay_rate() const override { return impl_.decay_rate(); }
  float* mutable_decay_rate() override { return impl_.mutable_decay_rate(); }
  void set_decay_rate(const float& decay_rate) override { impl_.set_decay_rate(decay_rate); }

  const float& weight_decay() const override { return impl_.weight_decay(); }
  float* mutable_weight_decay() override { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) override {
    impl_.set_weight_decay(weight_decay);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RmspropUpdateOp {
 public:
  RmspropUpdateOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "learning_rate_val") {
      return CastAttr(&internal_->learning_rate_val);
    } else if (attr_name == "scale") {
      return CastAttr(&internal_->scale);
    } else if (attr_name == "l1") {
      return CastAttr(&internal_->l1);
    } else if (attr_name == "l2") {
      return CastAttr(&internal_->l2);
    } else if (attr_name == "centered") {
      return CastAttr(&internal_->centered);
    } else if (attr_name == "epsilon") {
      return CastAttr(&internal_->epsilon);
    } else if (attr_name == "decay_rate") {
      return CastAttr(&internal_->decay_rate);
    } else if (attr_name == "weight_decay") {
      return CastAttr(&internal_->weight_decay);
    } else {
      return Error::RuntimeError() << "RmspropUpdate op has no attribute named " << attr_name;
    }
  }

  const float& learning_rate_val() const { return internal_->learning_rate_val; }
  float* mutable_learning_rate_val() { return &internal_->learning_rate_val; }
  void set_learning_rate_val(const float& learning_rate_val) {
    internal_->learning_rate_val = learning_rate_val;
  }

  const double& scale() const { return internal_->scale; }
  double* mutable_scale() { return &internal_->scale; }
  void set_scale(const double& scale) { internal_->scale = scale; }

  const float& l1() const { return internal_->l1; }
  float* mutable_l1() { return &internal_->l1; }
  void set_l1(const float& l1) { internal_->l1 = l1; }

  const float& l2() const { return internal_->l2; }
  float* mutable_l2() { return &internal_->l2; }
  void set_l2(const float& l2) { internal_->l2 = l2; }

  const bool& centered() const { return internal_->centered; }
  bool* mutable_centered() { return &internal_->centered; }
  void set_centered(const bool& centered) { internal_->centered = centered; }

  const float& epsilon() const { return internal_->epsilon; }
  float* mutable_epsilon() { return &internal_->epsilon; }
  void set_epsilon(const float& epsilon) { internal_->epsilon = epsilon; }

  const float& decay_rate() const { return internal_->decay_rate; }
  float* mutable_decay_rate() { return &internal_->decay_rate; }
  void set_decay_rate(const float& decay_rate) { internal_->decay_rate = decay_rate; }

  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }

 private:
  struct Internal {
    float learning_rate_val;
    double scale;
    float l1;
    float l2;
    bool centered;
    float epsilon;
    float decay_rate;
    float weight_decay;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.rmsprop_update",
                       RmspropUpdateOpInterpCtxImpl<schema::RmspropUpdateOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class RoiAlignOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& pooled_h() const = 0;
  virtual int32_t* mutable_pooled_h() = 0;
  virtual void set_pooled_h(const int32_t& pooled_h) = 0;

  virtual const int32_t& pooled_w() const = 0;
  virtual int32_t* mutable_pooled_w() = 0;
  virtual void set_pooled_w(const int32_t& pooled_w) = 0;

  virtual const float& spatial_scale() const = 0;
  virtual float* mutable_spatial_scale() = 0;
  virtual void set_spatial_scale(const float& spatial_scale) = 0;

  virtual const int32_t& sampling_ratio() const = 0;
  virtual int32_t* mutable_sampling_ratio() = 0;
  virtual void set_sampling_ratio(const int32_t& sampling_ratio) = 0;

  virtual const bool& aligned() const = 0;
  virtual bool* mutable_aligned() = 0;
  virtual void set_aligned(const bool& aligned) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"pooled_h", "pooled_w", "spatial_scale",
                                           "sampling_ratio", "aligned"};
    return attr_names;
  }
};
template<typename Provider>
class RoiAlignOpInterpCtxImpl : public RoiAlignOpInterpCtx {
 public:
  RoiAlignOpInterpCtxImpl() = default;
  RoiAlignOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& pooled_h() const override { return impl_.pooled_h(); }
  int32_t* mutable_pooled_h() override { return impl_.mutable_pooled_h(); }
  void set_pooled_h(const int32_t& pooled_h) override { impl_.set_pooled_h(pooled_h); }

  const int32_t& pooled_w() const override { return impl_.pooled_w(); }
  int32_t* mutable_pooled_w() override { return impl_.mutable_pooled_w(); }
  void set_pooled_w(const int32_t& pooled_w) override { impl_.set_pooled_w(pooled_w); }

  const float& spatial_scale() const override { return impl_.spatial_scale(); }
  float* mutable_spatial_scale() override { return impl_.mutable_spatial_scale(); }
  void set_spatial_scale(const float& spatial_scale) override {
    impl_.set_spatial_scale(spatial_scale);
  }

  const int32_t& sampling_ratio() const override { return impl_.sampling_ratio(); }
  int32_t* mutable_sampling_ratio() override { return impl_.mutable_sampling_ratio(); }
  void set_sampling_ratio(const int32_t& sampling_ratio) override {
    impl_.set_sampling_ratio(sampling_ratio);
  }

  const bool& aligned() const override { return impl_.aligned(); }
  bool* mutable_aligned() override { return impl_.mutable_aligned(); }
  void set_aligned(const bool& aligned) override { impl_.set_aligned(aligned); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RoiAlignOp {
 public:
  RoiAlignOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "pooled_h") {
      return CastAttr(&internal_->pooled_h);
    } else if (attr_name == "pooled_w") {
      return CastAttr(&internal_->pooled_w);
    } else if (attr_name == "spatial_scale") {
      return CastAttr(&internal_->spatial_scale);
    } else if (attr_name == "sampling_ratio") {
      return CastAttr(&internal_->sampling_ratio);
    } else if (attr_name == "aligned") {
      return CastAttr(&internal_->aligned);
    } else {
      return Error::RuntimeError() << "RoiAlign op has no attribute named " << attr_name;
    }
  }

  const int32_t& pooled_h() const { return internal_->pooled_h; }
  int32_t* mutable_pooled_h() { return &internal_->pooled_h; }
  void set_pooled_h(const int32_t& pooled_h) { internal_->pooled_h = pooled_h; }

  const int32_t& pooled_w() const { return internal_->pooled_w; }
  int32_t* mutable_pooled_w() { return &internal_->pooled_w; }
  void set_pooled_w(const int32_t& pooled_w) { internal_->pooled_w = pooled_w; }

  const float& spatial_scale() const { return internal_->spatial_scale; }
  float* mutable_spatial_scale() { return &internal_->spatial_scale; }
  void set_spatial_scale(const float& spatial_scale) { internal_->spatial_scale = spatial_scale; }

  const int32_t& sampling_ratio() const { return internal_->sampling_ratio; }
  int32_t* mutable_sampling_ratio() { return &internal_->sampling_ratio; }
  void set_sampling_ratio(const int32_t& sampling_ratio) {
    internal_->sampling_ratio = sampling_ratio;
  }

  const bool& aligned() const { return internal_->aligned; }
  bool* mutable_aligned() { return &internal_->aligned; }
  void set_aligned(const bool& aligned) { internal_->aligned = aligned; }

 private:
  struct Internal {
    int32_t pooled_h;
    int32_t pooled_w;
    float spatial_scale;
    int32_t sampling_ratio;
    bool aligned;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.roi_align", RoiAlignOpInterpCtxImpl<schema::RoiAlignOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class RoiAlignGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& pooled_h() const = 0;
  virtual int32_t* mutable_pooled_h() = 0;
  virtual void set_pooled_h(const int32_t& pooled_h) = 0;

  virtual const int32_t& pooled_w() const = 0;
  virtual int32_t* mutable_pooled_w() = 0;
  virtual void set_pooled_w(const int32_t& pooled_w) = 0;

  virtual const float& spatial_scale() const = 0;
  virtual float* mutable_spatial_scale() = 0;
  virtual void set_spatial_scale(const float& spatial_scale) = 0;

  virtual const int32_t& sampling_ratio() const = 0;
  virtual int32_t* mutable_sampling_ratio() = 0;
  virtual void set_sampling_ratio(const int32_t& sampling_ratio) = 0;

  virtual const bool& aligned() const = 0;
  virtual bool* mutable_aligned() = 0;
  virtual void set_aligned(const bool& aligned) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"pooled_h", "pooled_w", "spatial_scale",
                                           "sampling_ratio", "aligned"};
    return attr_names;
  }
};
template<typename Provider>
class RoiAlignGradOpInterpCtxImpl : public RoiAlignGradOpInterpCtx {
 public:
  RoiAlignGradOpInterpCtxImpl() = default;
  RoiAlignGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& pooled_h() const override { return impl_.pooled_h(); }
  int32_t* mutable_pooled_h() override { return impl_.mutable_pooled_h(); }
  void set_pooled_h(const int32_t& pooled_h) override { impl_.set_pooled_h(pooled_h); }

  const int32_t& pooled_w() const override { return impl_.pooled_w(); }
  int32_t* mutable_pooled_w() override { return impl_.mutable_pooled_w(); }
  void set_pooled_w(const int32_t& pooled_w) override { impl_.set_pooled_w(pooled_w); }

  const float& spatial_scale() const override { return impl_.spatial_scale(); }
  float* mutable_spatial_scale() override { return impl_.mutable_spatial_scale(); }
  void set_spatial_scale(const float& spatial_scale) override {
    impl_.set_spatial_scale(spatial_scale);
  }

  const int32_t& sampling_ratio() const override { return impl_.sampling_ratio(); }
  int32_t* mutable_sampling_ratio() override { return impl_.mutable_sampling_ratio(); }
  void set_sampling_ratio(const int32_t& sampling_ratio) override {
    impl_.set_sampling_ratio(sampling_ratio);
  }

  const bool& aligned() const override { return impl_.aligned(); }
  bool* mutable_aligned() override { return impl_.mutable_aligned(); }
  void set_aligned(const bool& aligned) override { impl_.set_aligned(aligned); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RoiAlignGradOp {
 public:
  RoiAlignGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "pooled_h") {
      return CastAttr(&internal_->pooled_h);
    } else if (attr_name == "pooled_w") {
      return CastAttr(&internal_->pooled_w);
    } else if (attr_name == "spatial_scale") {
      return CastAttr(&internal_->spatial_scale);
    } else if (attr_name == "sampling_ratio") {
      return CastAttr(&internal_->sampling_ratio);
    } else if (attr_name == "aligned") {
      return CastAttr(&internal_->aligned);
    } else {
      return Error::RuntimeError() << "RoiAlignGrad op has no attribute named " << attr_name;
    }
  }

  const int32_t& pooled_h() const { return internal_->pooled_h; }
  int32_t* mutable_pooled_h() { return &internal_->pooled_h; }
  void set_pooled_h(const int32_t& pooled_h) { internal_->pooled_h = pooled_h; }

  const int32_t& pooled_w() const { return internal_->pooled_w; }
  int32_t* mutable_pooled_w() { return &internal_->pooled_w; }
  void set_pooled_w(const int32_t& pooled_w) { internal_->pooled_w = pooled_w; }

  const float& spatial_scale() const { return internal_->spatial_scale; }
  float* mutable_spatial_scale() { return &internal_->spatial_scale; }
  void set_spatial_scale(const float& spatial_scale) { internal_->spatial_scale = spatial_scale; }

  const int32_t& sampling_ratio() const { return internal_->sampling_ratio; }
  int32_t* mutable_sampling_ratio() { return &internal_->sampling_ratio; }
  void set_sampling_ratio(const int32_t& sampling_ratio) {
    internal_->sampling_ratio = sampling_ratio;
  }

  const bool& aligned() const { return internal_->aligned; }
  bool* mutable_aligned() { return &internal_->aligned; }
  void set_aligned(const bool& aligned) { internal_->aligned = aligned; }

 private:
  struct Internal {
    int32_t pooled_h;
    int32_t pooled_w;
    float spatial_scale;
    int32_t sampling_ratio;
    bool aligned;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.roi_align_grad", RoiAlignGradOpInterpCtxImpl<schema::RoiAlignGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class RollOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& shifts() const = 0;
  virtual std::vector<int32_t>* mutable_shifts() = 0;
  virtual void set_shifts(const std::vector<int32_t>& shifts) = 0;

  virtual const std::vector<int32_t>& dims() const = 0;
  virtual std::vector<int32_t>* mutable_dims() = 0;
  virtual void set_dims(const std::vector<int32_t>& dims) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"shifts", "dims"};
    return attr_names;
  }
};
template<typename Provider>
class RollOpInterpCtxImpl : public RollOpInterpCtx {
 public:
  RollOpInterpCtxImpl() = default;
  RollOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& shifts() const override { return impl_.shifts(); }
  std::vector<int32_t>* mutable_shifts() override { return impl_.mutable_shifts(); }
  void set_shifts(const std::vector<int32_t>& shifts) override { impl_.set_shifts(shifts); }

  const std::vector<int32_t>& dims() const override { return impl_.dims(); }
  std::vector<int32_t>* mutable_dims() override { return impl_.mutable_dims(); }
  void set_dims(const std::vector<int32_t>& dims) override { impl_.set_dims(dims); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RollOp {
 public:
  RollOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "shifts") {
      return CastAttr(&internal_->shifts);
    } else if (attr_name == "dims") {
      return CastAttr(&internal_->dims);
    } else {
      return Error::RuntimeError() << "Roll op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& shifts() const { return internal_->shifts; }
  std::vector<int32_t>* mutable_shifts() { return &internal_->shifts; }
  void set_shifts(const std::vector<int32_t>& shifts) { internal_->shifts = shifts; }

  const std::vector<int32_t>& dims() const { return internal_->dims; }
  std::vector<int32_t>* mutable_dims() { return &internal_->dims; }
  void set_dims(const std::vector<int32_t>& dims) { internal_->dims = dims; }

 private:
  struct Internal {
    std::vector<int32_t> shifts;
    std::vector<int32_t> dims;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.roll", RollOpInterpCtxImpl<schema::RollOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class RoundOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class RoundOpInterpCtxImpl : public RoundOpInterpCtx {
 public:
  RoundOpInterpCtxImpl() = default;
  RoundOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RoundOp {
 public:
  RoundOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Round op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.round", RoundOpInterpCtxImpl<schema::RoundOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class RoundGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class RoundGradOpInterpCtxImpl : public RoundGradOpInterpCtx {
 public:
  RoundGradOpInterpCtxImpl() = default;
  RoundGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RoundGradOp {
 public:
  RoundGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "RoundGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.round_grad", RoundGradOpInterpCtxImpl<schema::RoundGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class RsqrtOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class RsqrtOpInterpCtxImpl : public RsqrtOpInterpCtx {
 public:
  RsqrtOpInterpCtxImpl() = default;
  RsqrtOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RsqrtOp {
 public:
  RsqrtOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Rsqrt op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.rsqrt", RsqrtOpInterpCtxImpl<schema::RsqrtOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class RsqrtGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class RsqrtGradOpInterpCtxImpl : public RsqrtGradOpInterpCtx {
 public:
  RsqrtGradOpInterpCtxImpl() = default;
  RsqrtGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class RsqrtGradOp {
 public:
  RsqrtGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "RsqrtGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.rsqrt_grad", RsqrtGradOpInterpCtxImpl<schema::RsqrtGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SamePaddingOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const std::vector<int32_t>& dilation_rate() const = 0;
  virtual std::vector<int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<int32_t>& dilation_rate) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding", "data_format", "kernel_size", "strides",
                                           "dilation_rate"};
    return attr_names;
  }
};
template<typename Provider>
class SamePaddingOpInterpCtxImpl : public SamePaddingOpInterpCtx {
 public:
  SamePaddingOpInterpCtxImpl() = default;
  SamePaddingOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& padding() const override { return impl_.padding(); }
  std::string* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) override { impl_.set_padding(padding); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const std::vector<int32_t>& dilation_rate() const override { return impl_.dilation_rate(); }
  std::vector<int32_t>* mutable_dilation_rate() override { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) override {
    impl_.set_dilation_rate(dilation_rate);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SamePaddingOp {
 public:
  SamePaddingOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "dilation_rate") {
      return CastAttr(&internal_->dilation_rate);
    } else {
      return Error::RuntimeError() << "SamePadding op has no attribute named " << attr_name;
    }
  }

  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const std::vector<int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) {
    internal_->dilation_rate = dilation_rate;
  }

 private:
  struct Internal {
    std::string padding;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> strides;
    std::vector<int32_t> dilation_rate;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.same_padding", SamePaddingOpInterpCtxImpl<schema::SamePaddingOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SamePaddingGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const std::vector<int32_t>& dilation_rate() const = 0;
  virtual std::vector<int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<int32_t>& dilation_rate) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding", "data_format", "kernel_size", "strides",
                                           "dilation_rate"};
    return attr_names;
  }
};
template<typename Provider>
class SamePaddingGradOpInterpCtxImpl : public SamePaddingGradOpInterpCtx {
 public:
  SamePaddingGradOpInterpCtxImpl() = default;
  SamePaddingGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& padding() const override { return impl_.padding(); }
  std::string* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) override { impl_.set_padding(padding); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const std::vector<int32_t>& dilation_rate() const override { return impl_.dilation_rate(); }
  std::vector<int32_t>* mutable_dilation_rate() override { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) override {
    impl_.set_dilation_rate(dilation_rate);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SamePaddingGradOp {
 public:
  SamePaddingGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "dilation_rate") {
      return CastAttr(&internal_->dilation_rate);
    } else {
      return Error::RuntimeError() << "SamePaddingGrad op has no attribute named " << attr_name;
    }
  }

  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const std::vector<int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) {
    internal_->dilation_rate = dilation_rate;
  }

 private:
  struct Internal {
    std::string padding;
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> strides;
    std::vector<int32_t> dilation_rate;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.same_padding_grad",
                       SamePaddingGradOpInterpCtxImpl<schema::SamePaddingGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarAddOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class ScalarAddOpInterpCtxImpl : public ScalarAddOpInterpCtx {
 public:
  ScalarAddOpInterpCtxImpl() = default;
  ScalarAddOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarAddOp {
 public:
  ScalarAddOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError() << "ScalarAdd op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_add", ScalarAddOpInterpCtxImpl<schema::ScalarAddOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarAddByTensorOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ScalarAddByTensorOpInterpCtxImpl : public ScalarAddByTensorOpInterpCtx {
 public:
  ScalarAddByTensorOpInterpCtxImpl() = default;
  ScalarAddByTensorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarAddByTensorOp {
 public:
  ScalarAddByTensorOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ScalarAddByTensor op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_add_by_tensor",
                       ScalarAddByTensorOpInterpCtxImpl<schema::ScalarAddByTensorOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarDivByTensorOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ScalarDivByTensorOpInterpCtxImpl : public ScalarDivByTensorOpInterpCtx {
 public:
  ScalarDivByTensorOpInterpCtxImpl() = default;
  ScalarDivByTensorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarDivByTensorOp {
 public:
  ScalarDivByTensorOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ScalarDivByTensor op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_div_by_tensor",
                       ScalarDivByTensorOpInterpCtxImpl<schema::ScalarDivByTensorOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarFloordivOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class ScalarFloordivOpInterpCtxImpl : public ScalarFloordivOpInterpCtx {
 public:
  ScalarFloordivOpInterpCtxImpl() = default;
  ScalarFloordivOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarFloordivOp {
 public:
  ScalarFloordivOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError() << "ScalarFloordiv op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_floordiv",
                       ScalarFloordivOpInterpCtxImpl<schema::ScalarFloordivOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarFmodOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class ScalarFmodOpInterpCtxImpl : public ScalarFmodOpInterpCtx {
 public:
  ScalarFmodOpInterpCtxImpl() = default;
  ScalarFmodOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarFmodOp {
 public:
  ScalarFmodOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError() << "ScalarFmod op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_fmod", ScalarFmodOpInterpCtxImpl<schema::ScalarFmodOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarLogicalAndOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class ScalarLogicalAndOpInterpCtxImpl : public ScalarLogicalAndOpInterpCtx {
 public:
  ScalarLogicalAndOpInterpCtxImpl() = default;
  ScalarLogicalAndOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalAndOp {
 public:
  ScalarLogicalAndOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError() << "ScalarLogicalAnd op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_logical_and",
                       ScalarLogicalAndOpInterpCtxImpl<schema::ScalarLogicalAndOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarLogicalEqualOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class ScalarLogicalEqualOpInterpCtxImpl : public ScalarLogicalEqualOpInterpCtx {
 public:
  ScalarLogicalEqualOpInterpCtxImpl() = default;
  ScalarLogicalEqualOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalEqualOp {
 public:
  ScalarLogicalEqualOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError() << "ScalarLogicalEqual op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_logical_equal",
                       ScalarLogicalEqualOpInterpCtxImpl<schema::ScalarLogicalEqualOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarLogicalGreaterOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class ScalarLogicalGreaterOpInterpCtxImpl : public ScalarLogicalGreaterOpInterpCtx {
 public:
  ScalarLogicalGreaterOpInterpCtxImpl() = default;
  ScalarLogicalGreaterOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalGreaterOp {
 public:
  ScalarLogicalGreaterOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError()
             << "ScalarLogicalGreater op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_logical_greater",
                       ScalarLogicalGreaterOpInterpCtxImpl<schema::ScalarLogicalGreaterOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarLogicalGreaterEqualOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class ScalarLogicalGreaterEqualOpInterpCtxImpl : public ScalarLogicalGreaterEqualOpInterpCtx {
 public:
  ScalarLogicalGreaterEqualOpInterpCtxImpl() = default;
  ScalarLogicalGreaterEqualOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalGreaterEqualOp {
 public:
  ScalarLogicalGreaterEqualOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError()
             << "ScalarLogicalGreaterEqual op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.scalar_logical_greater_equal",
    ScalarLogicalGreaterEqualOpInterpCtxImpl<schema::ScalarLogicalGreaterEqualOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarLogicalLessOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class ScalarLogicalLessOpInterpCtxImpl : public ScalarLogicalLessOpInterpCtx {
 public:
  ScalarLogicalLessOpInterpCtxImpl() = default;
  ScalarLogicalLessOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalLessOp {
 public:
  ScalarLogicalLessOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError() << "ScalarLogicalLess op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_logical_less",
                       ScalarLogicalLessOpInterpCtxImpl<schema::ScalarLogicalLessOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarLogicalLessEqualOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class ScalarLogicalLessEqualOpInterpCtxImpl : public ScalarLogicalLessEqualOpInterpCtx {
 public:
  ScalarLogicalLessEqualOpInterpCtxImpl() = default;
  ScalarLogicalLessEqualOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalLessEqualOp {
 public:
  ScalarLogicalLessEqualOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError()
             << "ScalarLogicalLessEqual op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_logical_less_equal",
                       ScalarLogicalLessEqualOpInterpCtxImpl<schema::ScalarLogicalLessEqualOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarLogicalNotEqualOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class ScalarLogicalNotEqualOpInterpCtxImpl : public ScalarLogicalNotEqualOpInterpCtx {
 public:
  ScalarLogicalNotEqualOpInterpCtxImpl() = default;
  ScalarLogicalNotEqualOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalNotEqualOp {
 public:
  ScalarLogicalNotEqualOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError()
             << "ScalarLogicalNotEqual op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_logical_not_equal",
                       ScalarLogicalNotEqualOpInterpCtxImpl<schema::ScalarLogicalNotEqualOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarLogicalOrOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class ScalarLogicalOrOpInterpCtxImpl : public ScalarLogicalOrOpInterpCtx {
 public:
  ScalarLogicalOrOpInterpCtxImpl() = default;
  ScalarLogicalOrOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalOrOp {
 public:
  ScalarLogicalOrOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError() << "ScalarLogicalOr op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_logical_or",
                       ScalarLogicalOrOpInterpCtxImpl<schema::ScalarLogicalOrOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarLogicalXorOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class ScalarLogicalXorOpInterpCtxImpl : public ScalarLogicalXorOpInterpCtx {
 public:
  ScalarLogicalXorOpInterpCtxImpl() = default;
  ScalarLogicalXorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarLogicalXorOp {
 public:
  ScalarLogicalXorOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError() << "ScalarLogicalXor op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_logical_xor",
                       ScalarLogicalXorOpInterpCtxImpl<schema::ScalarLogicalXorOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarMulOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class ScalarMulOpInterpCtxImpl : public ScalarMulOpInterpCtx {
 public:
  ScalarMulOpInterpCtxImpl() = default;
  ScalarMulOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarMulOp {
 public:
  ScalarMulOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError() << "ScalarMul op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_mul", ScalarMulOpInterpCtxImpl<schema::ScalarMulOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarMulByTensorOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ScalarMulByTensorOpInterpCtxImpl : public ScalarMulByTensorOpInterpCtx {
 public:
  ScalarMulByTensorOpInterpCtxImpl() = default;
  ScalarMulByTensorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarMulByTensorOp {
 public:
  ScalarMulByTensorOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ScalarMulByTensor op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_mul_by_tensor",
                       ScalarMulByTensorOpInterpCtxImpl<schema::ScalarMulByTensorOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarPowOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class ScalarPowOpInterpCtxImpl : public ScalarPowOpInterpCtx {
 public:
  ScalarPowOpInterpCtxImpl() = default;
  ScalarPowOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarPowOp {
 public:
  ScalarPowOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError() << "ScalarPow op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_pow", ScalarPowOpInterpCtxImpl<schema::ScalarPowOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarPowGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class ScalarPowGradOpInterpCtxImpl : public ScalarPowGradOpInterpCtx {
 public:
  ScalarPowGradOpInterpCtxImpl() = default;
  ScalarPowGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarPowGradOp {
 public:
  ScalarPowGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError() << "ScalarPowGrad op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_pow_grad",
                       ScalarPowGradOpInterpCtxImpl<schema::ScalarPowGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScalarSubByTensorOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ScalarSubByTensorOpInterpCtxImpl : public ScalarSubByTensorOpInterpCtx {
 public:
  ScalarSubByTensorOpInterpCtxImpl() = default;
  ScalarSubByTensorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScalarSubByTensorOp {
 public:
  ScalarSubByTensorOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ScalarSubByTensor op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scalar_sub_by_tensor",
                       ScalarSubByTensorOpInterpCtxImpl<schema::ScalarSubByTensorOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScatterNdOpInterpCtx : public OpInterpCtx {
 public:
  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"shape"};
    return attr_names;
  }
};
template<typename Provider>
class ScatterNdOpInterpCtxImpl : public ScatterNdOpInterpCtx {
 public:
  ScatterNdOpInterpCtxImpl() = default;
  ScatterNdOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScatterNdOp {
 public:
  ScatterNdOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else {
      return Error::RuntimeError() << "ScatterNd op has no attribute named " << attr_name;
    }
  }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

 private:
  struct Internal {
    Shape shape;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scatter_nd", ScatterNdOpInterpCtxImpl<schema::ScatterNdOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ScatterNdLikeOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ScatterNdLikeOpInterpCtxImpl : public ScatterNdLikeOpInterpCtx {
 public:
  ScatterNdLikeOpInterpCtxImpl() = default;
  ScatterNdLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ScatterNdLikeOp {
 public:
  ScatterNdLikeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ScatterNdLike op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.scatter_nd_like",
                       ScatterNdLikeOpInterpCtxImpl<schema::ScatterNdLikeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SeluOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SeluOpInterpCtxImpl : public SeluOpInterpCtx {
 public:
  SeluOpInterpCtxImpl() = default;
  SeluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SeluOp {
 public:
  SeluOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Selu op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.selu", SeluOpInterpCtxImpl<schema::SeluOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SeluGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SeluGradOpInterpCtxImpl : public SeluGradOpInterpCtx {
 public:
  SeluGradOpInterpCtxImpl() = default;
  SeluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SeluGradOp {
 public:
  SeluGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SeluGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.selu_grad", SeluGradOpInterpCtxImpl<schema::SeluGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SendOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& dst_process_id() const = 0;
  virtual int64_t* mutable_dst_process_id() = 0;
  virtual void set_dst_process_id(const int64_t& dst_process_id) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"dst_process_id"};
    return attr_names;
  }
};
template<typename Provider>
class SendOpInterpCtxImpl : public SendOpInterpCtx {
 public:
  SendOpInterpCtxImpl() = default;
  SendOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& dst_process_id() const override { return impl_.dst_process_id(); }
  int64_t* mutable_dst_process_id() override { return impl_.mutable_dst_process_id(); }
  void set_dst_process_id(const int64_t& dst_process_id) override {
    impl_.set_dst_process_id(dst_process_id);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SendOp {
 public:
  SendOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "dst_process_id") {
      return CastAttr(&internal_->dst_process_id);
    } else {
      return Error::RuntimeError() << "Send op has no attribute named " << attr_name;
    }
  }

  const int64_t& dst_process_id() const { return internal_->dst_process_id; }
  int64_t* mutable_dst_process_id() { return &internal_->dst_process_id; }
  void set_dst_process_id(const int64_t& dst_process_id) {
    internal_->dst_process_id = dst_process_id;
  }

 private:
  struct Internal {
    int64_t dst_process_id;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.send", SendOpInterpCtxImpl<schema::SendOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SgdUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& learning_rate_val() const = 0;
  virtual float* mutable_learning_rate_val() = 0;
  virtual void set_learning_rate_val(const float& learning_rate_val) = 0;

  virtual const double& scale() const = 0;
  virtual double* mutable_scale() = 0;
  virtual void set_scale(const double& scale) = 0;

  virtual const float& l1() const = 0;
  virtual float* mutable_l1() = 0;
  virtual void set_l1(const float& l1) = 0;

  virtual const float& l2() const = 0;
  virtual float* mutable_l2() = 0;
  virtual void set_l2(const float& l2) = 0;

  virtual const float& weight_decay() const = 0;
  virtual float* mutable_weight_decay() = 0;
  virtual void set_weight_decay(const float& weight_decay) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"learning_rate_val", "scale", "l1", "l2",
                                           "weight_decay"};
    return attr_names;
  }
};
template<typename Provider>
class SgdUpdateOpInterpCtxImpl : public SgdUpdateOpInterpCtx {
 public:
  SgdUpdateOpInterpCtxImpl() = default;
  SgdUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& learning_rate_val() const override { return impl_.learning_rate_val(); }
  float* mutable_learning_rate_val() override { return impl_.mutable_learning_rate_val(); }
  void set_learning_rate_val(const float& learning_rate_val) override {
    impl_.set_learning_rate_val(learning_rate_val);
  }

  const double& scale() const override { return impl_.scale(); }
  double* mutable_scale() override { return impl_.mutable_scale(); }
  void set_scale(const double& scale) override { impl_.set_scale(scale); }

  const float& l1() const override { return impl_.l1(); }
  float* mutable_l1() override { return impl_.mutable_l1(); }
  void set_l1(const float& l1) override { impl_.set_l1(l1); }

  const float& l2() const override { return impl_.l2(); }
  float* mutable_l2() override { return impl_.mutable_l2(); }
  void set_l2(const float& l2) override { impl_.set_l2(l2); }

  const float& weight_decay() const override { return impl_.weight_decay(); }
  float* mutable_weight_decay() override { return impl_.mutable_weight_decay(); }
  void set_weight_decay(const float& weight_decay) override {
    impl_.set_weight_decay(weight_decay);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SgdUpdateOp {
 public:
  SgdUpdateOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "learning_rate_val") {
      return CastAttr(&internal_->learning_rate_val);
    } else if (attr_name == "scale") {
      return CastAttr(&internal_->scale);
    } else if (attr_name == "l1") {
      return CastAttr(&internal_->l1);
    } else if (attr_name == "l2") {
      return CastAttr(&internal_->l2);
    } else if (attr_name == "weight_decay") {
      return CastAttr(&internal_->weight_decay);
    } else {
      return Error::RuntimeError() << "SgdUpdate op has no attribute named " << attr_name;
    }
  }

  const float& learning_rate_val() const { return internal_->learning_rate_val; }
  float* mutable_learning_rate_val() { return &internal_->learning_rate_val; }
  void set_learning_rate_val(const float& learning_rate_val) {
    internal_->learning_rate_val = learning_rate_val;
  }

  const double& scale() const { return internal_->scale; }
  double* mutable_scale() { return &internal_->scale; }
  void set_scale(const double& scale) { internal_->scale = scale; }

  const float& l1() const { return internal_->l1; }
  float* mutable_l1() { return &internal_->l1; }
  void set_l1(const float& l1) { internal_->l1 = l1; }

  const float& l2() const { return internal_->l2; }
  float* mutable_l2() { return &internal_->l2; }
  void set_l2(const float& l2) { internal_->l2 = l2; }

  const float& weight_decay() const { return internal_->weight_decay; }
  float* mutable_weight_decay() { return &internal_->weight_decay; }
  void set_weight_decay(const float& weight_decay) { internal_->weight_decay = weight_decay; }

 private:
  struct Internal {
    float learning_rate_val;
    double scale;
    float l1;
    float l2;
    float weight_decay;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sgd_update", SgdUpdateOpInterpCtxImpl<schema::SgdUpdateOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SigmoidOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SigmoidOpInterpCtxImpl : public SigmoidOpInterpCtx {
 public:
  SigmoidOpInterpCtxImpl() = default;
  SigmoidOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SigmoidOp {
 public:
  SigmoidOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Sigmoid op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sigmoid", SigmoidOpInterpCtxImpl<schema::SigmoidOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SigmoidCrossEntropyOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SigmoidCrossEntropyOpInterpCtxImpl : public SigmoidCrossEntropyOpInterpCtx {
 public:
  SigmoidCrossEntropyOpInterpCtxImpl() = default;
  SigmoidCrossEntropyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SigmoidCrossEntropyOp {
 public:
  SigmoidCrossEntropyOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SigmoidCrossEntropy op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sigmoid_cross_entropy",
                       SigmoidCrossEntropyOpInterpCtxImpl<schema::SigmoidCrossEntropyOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SigmoidCrossEntropyGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SigmoidCrossEntropyGradOpInterpCtxImpl : public SigmoidCrossEntropyGradOpInterpCtx {
 public:
  SigmoidCrossEntropyGradOpInterpCtxImpl() = default;
  SigmoidCrossEntropyGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SigmoidCrossEntropyGradOp {
 public:
  SigmoidCrossEntropyGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SigmoidCrossEntropyGrad op has no attribute named "
                                 << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sigmoid_cross_entropy_grad",
                       SigmoidCrossEntropyGradOpInterpCtxImpl<schema::SigmoidCrossEntropyGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SigmoidGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SigmoidGradOpInterpCtxImpl : public SigmoidGradOpInterpCtx {
 public:
  SigmoidGradOpInterpCtxImpl() = default;
  SigmoidGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SigmoidGradOp {
 public:
  SigmoidGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SigmoidGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sigmoid_grad", SigmoidGradOpInterpCtxImpl<schema::SigmoidGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SigmoidV2OpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SigmoidV2OpInterpCtxImpl : public SigmoidV2OpInterpCtx {
 public:
  SigmoidV2OpInterpCtxImpl() = default;
  SigmoidV2OpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SigmoidV2Op {
 public:
  SigmoidV2Op() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SigmoidV2 op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sigmoid_v2", SigmoidV2OpInterpCtxImpl<schema::SigmoidV2Op>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SigmoidV2GradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SigmoidV2GradOpInterpCtxImpl : public SigmoidV2GradOpInterpCtx {
 public:
  SigmoidV2GradOpInterpCtxImpl() = default;
  SigmoidV2GradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SigmoidV2GradOp {
 public:
  SigmoidV2GradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SigmoidV2Grad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sigmoid_v2_grad",
                       SigmoidV2GradOpInterpCtxImpl<schema::SigmoidV2GradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SignOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SignOpInterpCtxImpl : public SignOpInterpCtx {
 public:
  SignOpInterpCtxImpl() = default;
  SignOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SignOp {
 public:
  SignOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Sign op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sign", SignOpInterpCtxImpl<schema::SignOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SignGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SignGradOpInterpCtxImpl : public SignGradOpInterpCtx {
 public:
  SignGradOpInterpCtxImpl() = default;
  SignGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SignGradOp {
 public:
  SignGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SignGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sign_grad", SignGradOpInterpCtxImpl<schema::SignGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SiluOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SiluOpInterpCtxImpl : public SiluOpInterpCtx {
 public:
  SiluOpInterpCtxImpl() = default;
  SiluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SiluOp {
 public:
  SiluOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Silu op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.silu", SiluOpInterpCtxImpl<schema::SiluOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SiluGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SiluGradOpInterpCtxImpl : public SiluGradOpInterpCtx {
 public:
  SiluGradOpInterpCtxImpl() = default;
  SiluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SiluGradOp {
 public:
  SiluGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SiluGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.silu_grad", SiluGradOpInterpCtxImpl<schema::SiluGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SinOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SinOpInterpCtxImpl : public SinOpInterpCtx {
 public:
  SinOpInterpCtxImpl() = default;
  SinOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SinOp {
 public:
  SinOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Sin op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sin", SinOpInterpCtxImpl<schema::SinOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SinGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SinGradOpInterpCtxImpl : public SinGradOpInterpCtx {
 public:
  SinGradOpInterpCtxImpl() = default;
  SinGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SinGradOp {
 public:
  SinGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SinGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sin_grad", SinGradOpInterpCtxImpl<schema::SinGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SinhOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SinhOpInterpCtxImpl : public SinhOpInterpCtx {
 public:
  SinhOpInterpCtxImpl() = default;
  SinhOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SinhOp {
 public:
  SinhOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Sinh op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sinh", SinhOpInterpCtxImpl<schema::SinhOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SinhGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SinhGradOpInterpCtxImpl : public SinhGradOpInterpCtx {
 public:
  SinhGradOpInterpCtxImpl() = default;
  SinhGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SinhGradOp {
 public:
  SinhGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SinhGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sinh_grad", SinhGradOpInterpCtxImpl<schema::SinhGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SliceOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& start() const = 0;
  virtual std::vector<int64_t>* mutable_start() = 0;
  virtual void set_start(const std::vector<int64_t>& start) = 0;

  virtual const std::vector<int64_t>& stop() const = 0;
  virtual std::vector<int64_t>* mutable_stop() = 0;
  virtual void set_stop(const std::vector<int64_t>& stop) = 0;

  virtual const std::vector<int64_t>& step() const = 0;
  virtual std::vector<int64_t>* mutable_step() = 0;
  virtual void set_step(const std::vector<int64_t>& step) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"start", "stop", "step"};
    return attr_names;
  }
};
template<typename Provider>
class SliceOpInterpCtxImpl : public SliceOpInterpCtx {
 public:
  SliceOpInterpCtxImpl() = default;
  SliceOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& start() const override { return impl_.start(); }
  std::vector<int64_t>* mutable_start() override { return impl_.mutable_start(); }
  void set_start(const std::vector<int64_t>& start) override { impl_.set_start(start); }

  const std::vector<int64_t>& stop() const override { return impl_.stop(); }
  std::vector<int64_t>* mutable_stop() override { return impl_.mutable_stop(); }
  void set_stop(const std::vector<int64_t>& stop) override { impl_.set_stop(stop); }

  const std::vector<int64_t>& step() const override { return impl_.step(); }
  std::vector<int64_t>* mutable_step() override { return impl_.mutable_step(); }
  void set_step(const std::vector<int64_t>& step) override { impl_.set_step(step); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SliceOp {
 public:
  SliceOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "start") {
      return CastAttr(&internal_->start);
    } else if (attr_name == "stop") {
      return CastAttr(&internal_->stop);
    } else if (attr_name == "step") {
      return CastAttr(&internal_->step);
    } else {
      return Error::RuntimeError() << "Slice op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& start() const { return internal_->start; }
  std::vector<int64_t>* mutable_start() { return &internal_->start; }
  void set_start(const std::vector<int64_t>& start) { internal_->start = start; }

  const std::vector<int64_t>& stop() const { return internal_->stop; }
  std::vector<int64_t>* mutable_stop() { return &internal_->stop; }
  void set_stop(const std::vector<int64_t>& stop) { internal_->stop = stop; }

  const std::vector<int64_t>& step() const { return internal_->step; }
  std::vector<int64_t>* mutable_step() { return &internal_->step; }
  void set_step(const std::vector<int64_t>& step) { internal_->step = step; }

 private:
  struct Internal {
    std::vector<int64_t> start;
    std::vector<int64_t> stop;
    std::vector<int64_t> step;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.slice", SliceOpInterpCtxImpl<schema::SliceOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SliceGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& start() const = 0;
  virtual std::vector<int64_t>* mutable_start() = 0;
  virtual void set_start(const std::vector<int64_t>& start) = 0;

  virtual const std::vector<int64_t>& stop() const = 0;
  virtual std::vector<int64_t>* mutable_stop() = 0;
  virtual void set_stop(const std::vector<int64_t>& stop) = 0;

  virtual const std::vector<int64_t>& step() const = 0;
  virtual std::vector<int64_t>* mutable_step() = 0;
  virtual void set_step(const std::vector<int64_t>& step) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"start", "stop", "step"};
    return attr_names;
  }
};
template<typename Provider>
class SliceGradOpInterpCtxImpl : public SliceGradOpInterpCtx {
 public:
  SliceGradOpInterpCtxImpl() = default;
  SliceGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& start() const override { return impl_.start(); }
  std::vector<int64_t>* mutable_start() override { return impl_.mutable_start(); }
  void set_start(const std::vector<int64_t>& start) override { impl_.set_start(start); }

  const std::vector<int64_t>& stop() const override { return impl_.stop(); }
  std::vector<int64_t>* mutable_stop() override { return impl_.mutable_stop(); }
  void set_stop(const std::vector<int64_t>& stop) override { impl_.set_stop(stop); }

  const std::vector<int64_t>& step() const override { return impl_.step(); }
  std::vector<int64_t>* mutable_step() override { return impl_.mutable_step(); }
  void set_step(const std::vector<int64_t>& step) override { impl_.set_step(step); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SliceGradOp {
 public:
  SliceGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "start") {
      return CastAttr(&internal_->start);
    } else if (attr_name == "stop") {
      return CastAttr(&internal_->stop);
    } else if (attr_name == "step") {
      return CastAttr(&internal_->step);
    } else {
      return Error::RuntimeError() << "SliceGrad op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& start() const { return internal_->start; }
  std::vector<int64_t>* mutable_start() { return &internal_->start; }
  void set_start(const std::vector<int64_t>& start) { internal_->start = start; }

  const std::vector<int64_t>& stop() const { return internal_->stop; }
  std::vector<int64_t>* mutable_stop() { return &internal_->stop; }
  void set_stop(const std::vector<int64_t>& stop) { internal_->stop = stop; }

  const std::vector<int64_t>& step() const { return internal_->step; }
  std::vector<int64_t>* mutable_step() { return &internal_->step; }
  void set_step(const std::vector<int64_t>& step) { internal_->step = step; }

 private:
  struct Internal {
    std::vector<int64_t> start;
    std::vector<int64_t> stop;
    std::vector<int64_t> step;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.slice_grad", SliceGradOpInterpCtxImpl<schema::SliceGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SliceUpdateOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int64_t>& start() const = 0;
  virtual std::vector<int64_t>* mutable_start() = 0;
  virtual void set_start(const std::vector<int64_t>& start) = 0;

  virtual const std::vector<int64_t>& stop() const = 0;
  virtual std::vector<int64_t>* mutable_stop() = 0;
  virtual void set_stop(const std::vector<int64_t>& stop) = 0;

  virtual const std::vector<int64_t>& step() const = 0;
  virtual std::vector<int64_t>* mutable_step() = 0;
  virtual void set_step(const std::vector<int64_t>& step) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"start", "stop", "step"};
    return attr_names;
  }
};
template<typename Provider>
class SliceUpdateOpInterpCtxImpl : public SliceUpdateOpInterpCtx {
 public:
  SliceUpdateOpInterpCtxImpl() = default;
  SliceUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int64_t>& start() const override { return impl_.start(); }
  std::vector<int64_t>* mutable_start() override { return impl_.mutable_start(); }
  void set_start(const std::vector<int64_t>& start) override { impl_.set_start(start); }

  const std::vector<int64_t>& stop() const override { return impl_.stop(); }
  std::vector<int64_t>* mutable_stop() override { return impl_.mutable_stop(); }
  void set_stop(const std::vector<int64_t>& stop) override { impl_.set_stop(stop); }

  const std::vector<int64_t>& step() const override { return impl_.step(); }
  std::vector<int64_t>* mutable_step() override { return impl_.mutable_step(); }
  void set_step(const std::vector<int64_t>& step) override { impl_.set_step(step); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SliceUpdateOp {
 public:
  SliceUpdateOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "start") {
      return CastAttr(&internal_->start);
    } else if (attr_name == "stop") {
      return CastAttr(&internal_->stop);
    } else if (attr_name == "step") {
      return CastAttr(&internal_->step);
    } else {
      return Error::RuntimeError() << "SliceUpdate op has no attribute named " << attr_name;
    }
  }

  const std::vector<int64_t>& start() const { return internal_->start; }
  std::vector<int64_t>* mutable_start() { return &internal_->start; }
  void set_start(const std::vector<int64_t>& start) { internal_->start = start; }

  const std::vector<int64_t>& stop() const { return internal_->stop; }
  std::vector<int64_t>* mutable_stop() { return &internal_->stop; }
  void set_stop(const std::vector<int64_t>& stop) { internal_->stop = stop; }

  const std::vector<int64_t>& step() const { return internal_->step; }
  std::vector<int64_t>* mutable_step() { return &internal_->step; }
  void set_step(const std::vector<int64_t>& step) { internal_->step = step; }

 private:
  struct Internal {
    std::vector<int64_t> start;
    std::vector<int64_t> stop;
    std::vector<int64_t> step;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.slice_update", SliceUpdateOpInterpCtxImpl<schema::SliceUpdateOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SmoothL1LossOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& beta() const = 0;
  virtual float* mutable_beta() = 0;
  virtual void set_beta(const float& beta) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"beta"};
    return attr_names;
  }
};
template<typename Provider>
class SmoothL1LossOpInterpCtxImpl : public SmoothL1LossOpInterpCtx {
 public:
  SmoothL1LossOpInterpCtxImpl() = default;
  SmoothL1LossOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& beta() const override { return impl_.beta(); }
  float* mutable_beta() override { return impl_.mutable_beta(); }
  void set_beta(const float& beta) override { impl_.set_beta(beta); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SmoothL1LossOp {
 public:
  SmoothL1LossOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "beta") {
      return CastAttr(&internal_->beta);
    } else {
      return Error::RuntimeError() << "SmoothL1Loss op has no attribute named " << attr_name;
    }
  }

  const float& beta() const { return internal_->beta; }
  float* mutable_beta() { return &internal_->beta; }
  void set_beta(const float& beta) { internal_->beta = beta; }

 private:
  struct Internal {
    float beta;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.smooth_l1_loss", SmoothL1LossOpInterpCtxImpl<schema::SmoothL1LossOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SmoothL1LossGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& beta() const = 0;
  virtual float* mutable_beta() = 0;
  virtual void set_beta(const float& beta) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"beta"};
    return attr_names;
  }
};
template<typename Provider>
class SmoothL1LossGradOpInterpCtxImpl : public SmoothL1LossGradOpInterpCtx {
 public:
  SmoothL1LossGradOpInterpCtxImpl() = default;
  SmoothL1LossGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& beta() const override { return impl_.beta(); }
  float* mutable_beta() override { return impl_.mutable_beta(); }
  void set_beta(const float& beta) override { impl_.set_beta(beta); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SmoothL1LossGradOp {
 public:
  SmoothL1LossGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "beta") {
      return CastAttr(&internal_->beta);
    } else {
      return Error::RuntimeError() << "SmoothL1LossGrad op has no attribute named " << attr_name;
    }
  }

  const float& beta() const { return internal_->beta; }
  float* mutable_beta() { return &internal_->beta; }
  void set_beta(const float& beta) { internal_->beta = beta; }

 private:
  struct Internal {
    float beta;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.smooth_l1_loss_grad",
                       SmoothL1LossGradOpInterpCtxImpl<schema::SmoothL1LossGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SoftmaxOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SoftmaxOpInterpCtxImpl : public SoftmaxOpInterpCtx {
 public:
  SoftmaxOpInterpCtxImpl() = default;
  SoftmaxOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SoftmaxOp {
 public:
  SoftmaxOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Softmax op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.softmax", SoftmaxOpInterpCtxImpl<schema::SoftmaxOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SoftmaxCrossEntropyOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SoftmaxCrossEntropyOpInterpCtxImpl : public SoftmaxCrossEntropyOpInterpCtx {
 public:
  SoftmaxCrossEntropyOpInterpCtxImpl() = default;
  SoftmaxCrossEntropyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SoftmaxCrossEntropyOp {
 public:
  SoftmaxCrossEntropyOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SoftmaxCrossEntropy op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.softmax_cross_entropy",
                       SoftmaxCrossEntropyOpInterpCtxImpl<schema::SoftmaxCrossEntropyOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SoftmaxCrossEntropyGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SoftmaxCrossEntropyGradOpInterpCtxImpl : public SoftmaxCrossEntropyGradOpInterpCtx {
 public:
  SoftmaxCrossEntropyGradOpInterpCtxImpl() = default;
  SoftmaxCrossEntropyGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SoftmaxCrossEntropyGradOp {
 public:
  SoftmaxCrossEntropyGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SoftmaxCrossEntropyGrad op has no attribute named "
                                 << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.softmax_cross_entropy_grad",
                       SoftmaxCrossEntropyGradOpInterpCtxImpl<schema::SoftmaxCrossEntropyGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SoftmaxGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SoftmaxGradOpInterpCtxImpl : public SoftmaxGradOpInterpCtx {
 public:
  SoftmaxGradOpInterpCtxImpl() = default;
  SoftmaxGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SoftmaxGradOp {
 public:
  SoftmaxGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SoftmaxGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.softmax_grad", SoftmaxGradOpInterpCtxImpl<schema::SoftmaxGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SoftplusOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SoftplusOpInterpCtxImpl : public SoftplusOpInterpCtx {
 public:
  SoftplusOpInterpCtxImpl() = default;
  SoftplusOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SoftplusOp {
 public:
  SoftplusOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Softplus op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.softplus", SoftplusOpInterpCtxImpl<schema::SoftplusOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SoftplusGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SoftplusGradOpInterpCtxImpl : public SoftplusGradOpInterpCtx {
 public:
  SoftplusGradOpInterpCtxImpl() = default;
  SoftplusGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SoftplusGradOp {
 public:
  SoftplusGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SoftplusGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.softplus_grad", SoftplusGradOpInterpCtxImpl<schema::SoftplusGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SoftsignOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SoftsignOpInterpCtxImpl : public SoftsignOpInterpCtx {
 public:
  SoftsignOpInterpCtxImpl() = default;
  SoftsignOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SoftsignOp {
 public:
  SoftsignOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Softsign op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.softsign", SoftsignOpInterpCtxImpl<schema::SoftsignOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SoftsignGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SoftsignGradOpInterpCtxImpl : public SoftsignGradOpInterpCtx {
 public:
  SoftsignGradOpInterpCtxImpl() = default;
  SoftsignGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SoftsignGradOp {
 public:
  SoftsignGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SoftsignGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.softsign_grad", SoftsignGradOpInterpCtxImpl<schema::SoftsignGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SortOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& direction() const = 0;
  virtual std::string* mutable_direction() = 0;
  virtual void set_direction(const std::string& direction) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"direction"};
    return attr_names;
  }
};
template<typename Provider>
class SortOpInterpCtxImpl : public SortOpInterpCtx {
 public:
  SortOpInterpCtxImpl() = default;
  SortOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& direction() const override { return impl_.direction(); }
  std::string* mutable_direction() override { return impl_.mutable_direction(); }
  void set_direction(const std::string& direction) override { impl_.set_direction(direction); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SortOp {
 public:
  SortOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "direction") {
      return CastAttr(&internal_->direction);
    } else {
      return Error::RuntimeError() << "Sort op has no attribute named " << attr_name;
    }
  }

  const std::string& direction() const { return internal_->direction; }
  std::string* mutable_direction() { return &internal_->direction; }
  void set_direction(const std::string& direction) { internal_->direction = direction; }

 private:
  struct Internal {
    std::string direction;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sort", SortOpInterpCtxImpl<schema::SortOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SparseCrossEntropyOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"depth"};
    return attr_names;
  }
};
template<typename Provider>
class SparseCrossEntropyOpInterpCtxImpl : public SparseCrossEntropyOpInterpCtx {
 public:
  SparseCrossEntropyOpInterpCtxImpl() = default;
  SparseCrossEntropyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& depth() const override { return impl_.depth(); }
  int64_t* mutable_depth() override { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) override { impl_.set_depth(depth); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SparseCrossEntropyOp {
 public:
  SparseCrossEntropyOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "depth") {
      return CastAttr(&internal_->depth);
    } else {
      return Error::RuntimeError() << "SparseCrossEntropy op has no attribute named " << attr_name;
    }
  }

  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }

 private:
  struct Internal {
    int64_t depth;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sparse_cross_entropy",
                       SparseCrossEntropyOpInterpCtxImpl<schema::SparseCrossEntropyOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SparseCrossEntropyGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"depth"};
    return attr_names;
  }
};
template<typename Provider>
class SparseCrossEntropyGradOpInterpCtxImpl : public SparseCrossEntropyGradOpInterpCtx {
 public:
  SparseCrossEntropyGradOpInterpCtxImpl() = default;
  SparseCrossEntropyGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& depth() const override { return impl_.depth(); }
  int64_t* mutable_depth() override { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) override { impl_.set_depth(depth); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SparseCrossEntropyGradOp {
 public:
  SparseCrossEntropyGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "depth") {
      return CastAttr(&internal_->depth);
    } else {
      return Error::RuntimeError()
             << "SparseCrossEntropyGrad op has no attribute named " << attr_name;
    }
  }

  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }

 private:
  struct Internal {
    int64_t depth;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sparse_cross_entropy_grad",
                       SparseCrossEntropyGradOpInterpCtxImpl<schema::SparseCrossEntropyGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SparseCrossEntropyMsOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"depth"};
    return attr_names;
  }
};
template<typename Provider>
class SparseCrossEntropyMsOpInterpCtxImpl : public SparseCrossEntropyMsOpInterpCtx {
 public:
  SparseCrossEntropyMsOpInterpCtxImpl() = default;
  SparseCrossEntropyMsOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& depth() const override { return impl_.depth(); }
  int64_t* mutable_depth() override { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) override { impl_.set_depth(depth); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SparseCrossEntropyMsOp {
 public:
  SparseCrossEntropyMsOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "depth") {
      return CastAttr(&internal_->depth);
    } else {
      return Error::RuntimeError()
             << "SparseCrossEntropyMs op has no attribute named " << attr_name;
    }
  }

  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }

 private:
  struct Internal {
    int64_t depth;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sparse_cross_entropy_ms",
                       SparseCrossEntropyMsOpInterpCtxImpl<schema::SparseCrossEntropyMsOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SparseCrossEntropyMsGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"depth"};
    return attr_names;
  }
};
template<typename Provider>
class SparseCrossEntropyMsGradOpInterpCtxImpl : public SparseCrossEntropyMsGradOpInterpCtx {
 public:
  SparseCrossEntropyMsGradOpInterpCtxImpl() = default;
  SparseCrossEntropyMsGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& depth() const override { return impl_.depth(); }
  int64_t* mutable_depth() override { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) override { impl_.set_depth(depth); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SparseCrossEntropyMsGradOp {
 public:
  SparseCrossEntropyMsGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "depth") {
      return CastAttr(&internal_->depth);
    } else {
      return Error::RuntimeError()
             << "SparseCrossEntropyMsGrad op has no attribute named " << attr_name;
    }
  }

  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }

 private:
  struct Internal {
    int64_t depth;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sparse_cross_entropy_ms_grad",
                       SparseCrossEntropyMsGradOpInterpCtxImpl<schema::SparseCrossEntropyMsGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SparseSoftmaxCrossEntropyOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"depth"};
    return attr_names;
  }
};
template<typename Provider>
class SparseSoftmaxCrossEntropyOpInterpCtxImpl : public SparseSoftmaxCrossEntropyOpInterpCtx {
 public:
  SparseSoftmaxCrossEntropyOpInterpCtxImpl() = default;
  SparseSoftmaxCrossEntropyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& depth() const override { return impl_.depth(); }
  int64_t* mutable_depth() override { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) override { impl_.set_depth(depth); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SparseSoftmaxCrossEntropyOp {
 public:
  SparseSoftmaxCrossEntropyOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "depth") {
      return CastAttr(&internal_->depth);
    } else {
      return Error::RuntimeError()
             << "SparseSoftmaxCrossEntropy op has no attribute named " << attr_name;
    }
  }

  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }

 private:
  struct Internal {
    int64_t depth;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.sparse_softmax_cross_entropy",
    SparseSoftmaxCrossEntropyOpInterpCtxImpl<schema::SparseSoftmaxCrossEntropyOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SparseSoftmaxCrossEntropyGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"depth"};
    return attr_names;
  }
};
template<typename Provider>
class SparseSoftmaxCrossEntropyGradOpInterpCtxImpl
    : public SparseSoftmaxCrossEntropyGradOpInterpCtx {
 public:
  SparseSoftmaxCrossEntropyGradOpInterpCtxImpl() = default;
  SparseSoftmaxCrossEntropyGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& depth() const override { return impl_.depth(); }
  int64_t* mutable_depth() override { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) override { impl_.set_depth(depth); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SparseSoftmaxCrossEntropyGradOp {
 public:
  SparseSoftmaxCrossEntropyGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "depth") {
      return CastAttr(&internal_->depth);
    } else {
      return Error::RuntimeError()
             << "SparseSoftmaxCrossEntropyGrad op has no attribute named " << attr_name;
    }
  }

  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }

 private:
  struct Internal {
    int64_t depth;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.sparse_softmax_cross_entropy_grad",
    SparseSoftmaxCrossEntropyGradOpInterpCtxImpl<schema::SparseSoftmaxCrossEntropyGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SparseSoftmaxCrossEntropyMsOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"depth"};
    return attr_names;
  }
};
template<typename Provider>
class SparseSoftmaxCrossEntropyMsOpInterpCtxImpl : public SparseSoftmaxCrossEntropyMsOpInterpCtx {
 public:
  SparseSoftmaxCrossEntropyMsOpInterpCtxImpl() = default;
  SparseSoftmaxCrossEntropyMsOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& depth() const override { return impl_.depth(); }
  int64_t* mutable_depth() override { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) override { impl_.set_depth(depth); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SparseSoftmaxCrossEntropyMsOp {
 public:
  SparseSoftmaxCrossEntropyMsOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "depth") {
      return CastAttr(&internal_->depth);
    } else {
      return Error::RuntimeError()
             << "SparseSoftmaxCrossEntropyMs op has no attribute named " << attr_name;
    }
  }

  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }

 private:
  struct Internal {
    int64_t depth;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.sparse_softmax_cross_entropy_ms",
    SparseSoftmaxCrossEntropyMsOpInterpCtxImpl<schema::SparseSoftmaxCrossEntropyMsOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SparseSoftmaxCrossEntropyMsGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& depth() const = 0;
  virtual int64_t* mutable_depth() = 0;
  virtual void set_depth(const int64_t& depth) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"depth"};
    return attr_names;
  }
};
template<typename Provider>
class SparseSoftmaxCrossEntropyMsGradOpInterpCtxImpl
    : public SparseSoftmaxCrossEntropyMsGradOpInterpCtx {
 public:
  SparseSoftmaxCrossEntropyMsGradOpInterpCtxImpl() = default;
  SparseSoftmaxCrossEntropyMsGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& depth() const override { return impl_.depth(); }
  int64_t* mutable_depth() override { return impl_.mutable_depth(); }
  void set_depth(const int64_t& depth) override { impl_.set_depth(depth); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SparseSoftmaxCrossEntropyMsGradOp {
 public:
  SparseSoftmaxCrossEntropyMsGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "depth") {
      return CastAttr(&internal_->depth);
    } else {
      return Error::RuntimeError()
             << "SparseSoftmaxCrossEntropyMsGrad op has no attribute named " << attr_name;
    }
  }

  const int64_t& depth() const { return internal_->depth; }
  int64_t* mutable_depth() { return &internal_->depth; }
  void set_depth(const int64_t& depth) { internal_->depth = depth; }

 private:
  struct Internal {
    int64_t depth;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.sparse_softmax_cross_entropy_ms_grad",
    SparseSoftmaxCrossEntropyMsGradOpInterpCtxImpl<schema::SparseSoftmaxCrossEntropyMsGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SplitLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& axis() const = 0;
  virtual int64_t* mutable_axis() = 0;
  virtual void set_axis(const int64_t& axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis"};
    return attr_names;
  }
};
template<typename Provider>
class SplitLikeOpInterpCtxImpl : public SplitLikeOpInterpCtx {
 public:
  SplitLikeOpInterpCtxImpl() = default;
  SplitLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& axis() const override { return impl_.axis(); }
  int64_t* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const int64_t& axis) override { impl_.set_axis(axis); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SplitLikeOp {
 public:
  SplitLikeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else {
      return Error::RuntimeError() << "SplitLike op has no attribute named " << attr_name;
    }
  }

  const int64_t& axis() const { return internal_->axis; }
  int64_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int64_t& axis) { internal_->axis = axis; }

 private:
  struct Internal {
    int64_t axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.split_like", SplitLikeOpInterpCtxImpl<schema::SplitLikeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SqrtOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SqrtOpInterpCtxImpl : public SqrtOpInterpCtx {
 public:
  SqrtOpInterpCtxImpl() = default;
  SqrtOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SqrtOp {
 public:
  SqrtOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Sqrt op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sqrt", SqrtOpInterpCtxImpl<schema::SqrtOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SqrtGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SqrtGradOpInterpCtxImpl : public SqrtGradOpInterpCtx {
 public:
  SqrtGradOpInterpCtxImpl() = default;
  SqrtGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SqrtGradOp {
 public:
  SqrtGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SqrtGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.sqrt_grad", SqrtGradOpInterpCtxImpl<schema::SqrtGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SquareOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SquareOpInterpCtxImpl : public SquareOpInterpCtx {
 public:
  SquareOpInterpCtxImpl() = default;
  SquareOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SquareOp {
 public:
  SquareOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Square op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.square", SquareOpInterpCtxImpl<schema::SquareOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SquareGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SquareGradOpInterpCtxImpl : public SquareGradOpInterpCtx {
 public:
  SquareGradOpInterpCtxImpl() = default;
  SquareGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SquareGradOp {
 public:
  SquareGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SquareGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.square_grad", SquareGradOpInterpCtxImpl<schema::SquareGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SquareSumOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SquareSumOpInterpCtxImpl : public SquareSumOpInterpCtx {
 public:
  SquareSumOpInterpCtxImpl() = default;
  SquareSumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SquareSumOp {
 public:
  SquareSumOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SquareSum op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.square_sum", SquareSumOpInterpCtxImpl<schema::SquareSumOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SqueezeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& axes() const = 0;
  virtual std::vector<int32_t>* mutable_axes() = 0;
  virtual void set_axes(const std::vector<int32_t>& axes) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axes"};
    return attr_names;
  }
};
template<typename Provider>
class SqueezeOpInterpCtxImpl : public SqueezeOpInterpCtx {
 public:
  SqueezeOpInterpCtxImpl() = default;
  SqueezeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& axes() const override { return impl_.axes(); }
  std::vector<int32_t>* mutable_axes() override { return impl_.mutable_axes(); }
  void set_axes(const std::vector<int32_t>& axes) override { impl_.set_axes(axes); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SqueezeOp {
 public:
  SqueezeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axes") {
      return CastAttr(&internal_->axes);
    } else {
      return Error::RuntimeError() << "Squeeze op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& axes() const { return internal_->axes; }
  std::vector<int32_t>* mutable_axes() { return &internal_->axes; }
  void set_axes(const std::vector<int32_t>& axes) { internal_->axes = axes; }

 private:
  struct Internal {
    std::vector<int32_t> axes;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.squeeze", SqueezeOpInterpCtxImpl<schema::SqueezeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SspVariableProxyOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& buffer_size() const = 0;
  virtual int64_t* mutable_buffer_size() = 0;
  virtual void set_buffer_size(const int64_t& buffer_size) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"buffer_size"};
    return attr_names;
  }
};
template<typename Provider>
class SspVariableProxyOpInterpCtxImpl : public SspVariableProxyOpInterpCtx {
 public:
  SspVariableProxyOpInterpCtxImpl() = default;
  SspVariableProxyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& buffer_size() const override { return impl_.buffer_size(); }
  int64_t* mutable_buffer_size() override { return impl_.mutable_buffer_size(); }
  void set_buffer_size(const int64_t& buffer_size) override { impl_.set_buffer_size(buffer_size); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SspVariableProxyOp {
 public:
  SspVariableProxyOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "buffer_size") {
      return CastAttr(&internal_->buffer_size);
    } else {
      return Error::RuntimeError() << "SspVariableProxy op has no attribute named " << attr_name;
    }
  }

  const int64_t& buffer_size() const { return internal_->buffer_size; }
  int64_t* mutable_buffer_size() { return &internal_->buffer_size; }
  void set_buffer_size(const int64_t& buffer_size) { internal_->buffer_size = buffer_size; }

 private:
  struct Internal {
    int64_t buffer_size;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.ssp_variable_proxy",
                       SspVariableProxyOpInterpCtxImpl<schema::SspVariableProxyOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SummaryWriteHistogramOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SummaryWriteHistogramOpInterpCtxImpl : public SummaryWriteHistogramOpInterpCtx {
 public:
  SummaryWriteHistogramOpInterpCtxImpl() = default;
  SummaryWriteHistogramOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SummaryWriteHistogramOp {
 public:
  SummaryWriteHistogramOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SummaryWriteHistogram op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.summary_write_histogram",
                       SummaryWriteHistogramOpInterpCtxImpl<schema::SummaryWriteHistogramOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SummaryWriteImageOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SummaryWriteImageOpInterpCtxImpl : public SummaryWriteImageOpInterpCtx {
 public:
  SummaryWriteImageOpInterpCtxImpl() = default;
  SummaryWriteImageOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SummaryWriteImageOp {
 public:
  SummaryWriteImageOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SummaryWriteImage op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.summary_write_image",
                       SummaryWriteImageOpInterpCtxImpl<schema::SummaryWriteImageOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SummaryWritePbOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SummaryWritePbOpInterpCtxImpl : public SummaryWritePbOpInterpCtx {
 public:
  SummaryWritePbOpInterpCtxImpl() = default;
  SummaryWritePbOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SummaryWritePbOp {
 public:
  SummaryWritePbOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SummaryWritePb op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.summary_write_pb",
                       SummaryWritePbOpInterpCtxImpl<schema::SummaryWritePbOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class SummaryWriteScalarOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class SummaryWriteScalarOpInterpCtxImpl : public SummaryWriteScalarOpInterpCtx {
 public:
  SummaryWriteScalarOpInterpCtxImpl() = default;
  SummaryWriteScalarOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class SummaryWriteScalarOp {
 public:
  SummaryWriteScalarOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "SummaryWriteScalar op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.summary_write_scalar",
                       SummaryWriteScalarOpInterpCtxImpl<schema::SummaryWriteScalarOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TanOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class TanOpInterpCtxImpl : public TanOpInterpCtx {
 public:
  TanOpInterpCtxImpl() = default;
  TanOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TanOp {
 public:
  TanOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Tan op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tan", TanOpInterpCtxImpl<schema::TanOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TanGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class TanGradOpInterpCtxImpl : public TanGradOpInterpCtx {
 public:
  TanGradOpInterpCtxImpl() = default;
  TanGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TanGradOp {
 public:
  TanGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "TanGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tan_grad", TanGradOpInterpCtxImpl<schema::TanGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TanhOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class TanhOpInterpCtxImpl : public TanhOpInterpCtx {
 public:
  TanhOpInterpCtxImpl() = default;
  TanhOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TanhOp {
 public:
  TanhOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Tanh op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tanh", TanhOpInterpCtxImpl<schema::TanhOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TanhGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class TanhGradOpInterpCtxImpl : public TanhGradOpInterpCtx {
 public:
  TanhGradOpInterpCtxImpl() = default;
  TanhGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TanhGradOp {
 public:
  TanhGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "TanhGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tanh_grad", TanhGradOpInterpCtxImpl<schema::TanhGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TensorBufferToListOfTensorsOpInterpCtx : public OpInterpCtx {
 public:
  virtual const Shape& out_shape() const = 0;
  virtual Shape* mutable_out_shape() = 0;
  virtual void set_out_shape(const Shape& out_shape) = 0;

  virtual const DataType& out_dtype() const = 0;
  virtual DataType* mutable_out_dtype() = 0;
  virtual void set_out_dtype(const DataType& out_dtype) = 0;

  virtual const bool& dynamic_out() const = 0;
  virtual bool* mutable_dynamic_out() = 0;
  virtual void set_dynamic_out(const bool& dynamic_out) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"out_shape", "out_dtype", "dynamic_out"};
    return attr_names;
  }
};
template<typename Provider>
class TensorBufferToListOfTensorsOpInterpCtxImpl : public TensorBufferToListOfTensorsOpInterpCtx {
 public:
  TensorBufferToListOfTensorsOpInterpCtxImpl() = default;
  TensorBufferToListOfTensorsOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const Shape& out_shape() const override { return impl_.out_shape(); }
  Shape* mutable_out_shape() override { return impl_.mutable_out_shape(); }
  void set_out_shape(const Shape& out_shape) override { impl_.set_out_shape(out_shape); }

  const DataType& out_dtype() const override { return impl_.out_dtype(); }
  DataType* mutable_out_dtype() override { return impl_.mutable_out_dtype(); }
  void set_out_dtype(const DataType& out_dtype) override { impl_.set_out_dtype(out_dtype); }

  const bool& dynamic_out() const override { return impl_.dynamic_out(); }
  bool* mutable_dynamic_out() override { return impl_.mutable_dynamic_out(); }
  void set_dynamic_out(const bool& dynamic_out) override { impl_.set_dynamic_out(dynamic_out); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TensorBufferToListOfTensorsOp {
 public:
  TensorBufferToListOfTensorsOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "out_shape") {
      return CastAttr(&internal_->out_shape);
    } else if (attr_name == "out_dtype") {
      return CastAttr(&internal_->out_dtype);
    } else if (attr_name == "dynamic_out") {
      return CastAttr(&internal_->dynamic_out);
    } else {
      return Error::RuntimeError()
             << "TensorBufferToListOfTensors op has no attribute named " << attr_name;
    }
  }

  const Shape& out_shape() const { return internal_->out_shape; }
  Shape* mutable_out_shape() { return &internal_->out_shape; }
  void set_out_shape(const Shape& out_shape) { internal_->out_shape = out_shape; }

  const DataType& out_dtype() const { return internal_->out_dtype; }
  DataType* mutable_out_dtype() { return &internal_->out_dtype; }
  void set_out_dtype(const DataType& out_dtype) { internal_->out_dtype = out_dtype; }

  const bool& dynamic_out() const { return internal_->dynamic_out; }
  bool* mutable_dynamic_out() { return &internal_->dynamic_out; }
  void set_dynamic_out(const bool& dynamic_out) { internal_->dynamic_out = dynamic_out; }

 private:
  struct Internal {
    Shape out_shape;
    DataType out_dtype;
    bool dynamic_out;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.tensor_buffer_to_list_of_tensors",
    TensorBufferToListOfTensorsOpInterpCtxImpl<schema::TensorBufferToListOfTensorsOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TensorBufferToListOfTensorsV2OpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<Shape>& out_shapes() const = 0;
  virtual std::vector<Shape>* mutable_out_shapes() = 0;
  virtual void set_out_shapes(const std::vector<Shape>& out_shapes) = 0;

  virtual const std::vector<DataType>& out_dtypes() const = 0;
  virtual std::vector<DataType>* mutable_out_dtypes() = 0;
  virtual void set_out_dtypes(const std::vector<DataType>& out_dtypes) = 0;

  virtual const bool& dynamic_out() const = 0;
  virtual bool* mutable_dynamic_out() = 0;
  virtual void set_dynamic_out(const bool& dynamic_out) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"out_shapes", "out_dtypes", "dynamic_out"};
    return attr_names;
  }
};
template<typename Provider>
class TensorBufferToListOfTensorsV2OpInterpCtxImpl
    : public TensorBufferToListOfTensorsV2OpInterpCtx {
 public:
  TensorBufferToListOfTensorsV2OpInterpCtxImpl() = default;
  TensorBufferToListOfTensorsV2OpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<Shape>& out_shapes() const override { return impl_.out_shapes(); }
  std::vector<Shape>* mutable_out_shapes() override { return impl_.mutable_out_shapes(); }
  void set_out_shapes(const std::vector<Shape>& out_shapes) override {
    impl_.set_out_shapes(out_shapes);
  }

  const std::vector<DataType>& out_dtypes() const override { return impl_.out_dtypes(); }
  std::vector<DataType>* mutable_out_dtypes() override { return impl_.mutable_out_dtypes(); }
  void set_out_dtypes(const std::vector<DataType>& out_dtypes) override {
    impl_.set_out_dtypes(out_dtypes);
  }

  const bool& dynamic_out() const override { return impl_.dynamic_out(); }
  bool* mutable_dynamic_out() override { return impl_.mutable_dynamic_out(); }
  void set_dynamic_out(const bool& dynamic_out) override { impl_.set_dynamic_out(dynamic_out); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TensorBufferToListOfTensorsV2Op {
 public:
  TensorBufferToListOfTensorsV2Op() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "out_shapes") {
      return CastAttr(&internal_->out_shapes);
    } else if (attr_name == "out_dtypes") {
      return CastAttr(&internal_->out_dtypes);
    } else if (attr_name == "dynamic_out") {
      return CastAttr(&internal_->dynamic_out);
    } else {
      return Error::RuntimeError()
             << "TensorBufferToListOfTensorsV2 op has no attribute named " << attr_name;
    }
  }

  const std::vector<Shape>& out_shapes() const { return internal_->out_shapes; }
  std::vector<Shape>* mutable_out_shapes() { return &internal_->out_shapes; }
  void set_out_shapes(const std::vector<Shape>& out_shapes) { internal_->out_shapes = out_shapes; }

  const std::vector<DataType>& out_dtypes() const { return internal_->out_dtypes; }
  std::vector<DataType>* mutable_out_dtypes() { return &internal_->out_dtypes; }
  void set_out_dtypes(const std::vector<DataType>& out_dtypes) {
    internal_->out_dtypes = out_dtypes;
  }

  const bool& dynamic_out() const { return internal_->dynamic_out; }
  bool* mutable_dynamic_out() { return &internal_->dynamic_out; }
  void set_dynamic_out(const bool& dynamic_out) { internal_->dynamic_out = dynamic_out; }

 private:
  struct Internal {
    std::vector<Shape> out_shapes;
    std::vector<DataType> out_dtypes;
    bool dynamic_out;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX(
    "user.tensor_buffer_to_list_of_tensors_v2",
    TensorBufferToListOfTensorsV2OpInterpCtxImpl<schema::TensorBufferToListOfTensorsV2Op>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TensorBufferToTensorOpInterpCtx : public OpInterpCtx {
 public:
  virtual const Shape& instance_shape() const = 0;
  virtual Shape* mutable_instance_shape() = 0;
  virtual void set_instance_shape(const Shape& instance_shape) = 0;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"instance_shape", "dtype"};
    return attr_names;
  }
};
template<typename Provider>
class TensorBufferToTensorOpInterpCtxImpl : public TensorBufferToTensorOpInterpCtx {
 public:
  TensorBufferToTensorOpInterpCtxImpl() = default;
  TensorBufferToTensorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const Shape& instance_shape() const override { return impl_.instance_shape(); }
  Shape* mutable_instance_shape() override { return impl_.mutable_instance_shape(); }
  void set_instance_shape(const Shape& instance_shape) override {
    impl_.set_instance_shape(instance_shape);
  }

  const DataType& dtype() const override { return impl_.dtype(); }
  DataType* mutable_dtype() override { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) override { impl_.set_dtype(dtype); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TensorBufferToTensorOp {
 public:
  TensorBufferToTensorOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "instance_shape") {
      return CastAttr(&internal_->instance_shape);
    } else if (attr_name == "dtype") {
      return CastAttr(&internal_->dtype);
    } else {
      return Error::RuntimeError()
             << "TensorBufferToTensor op has no attribute named " << attr_name;
    }
  }

  const Shape& instance_shape() const { return internal_->instance_shape; }
  Shape* mutable_instance_shape() { return &internal_->instance_shape; }
  void set_instance_shape(const Shape& instance_shape) {
    internal_->instance_shape = instance_shape;
  }

  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }

 private:
  struct Internal {
    Shape instance_shape;
    DataType dtype;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tensor_buffer_to_tensor",
                       TensorBufferToTensorOpInterpCtxImpl<schema::TensorBufferToTensorOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TensorScatterNdAddOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class TensorScatterNdAddOpInterpCtxImpl : public TensorScatterNdAddOpInterpCtx {
 public:
  TensorScatterNdAddOpInterpCtxImpl() = default;
  TensorScatterNdAddOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TensorScatterNdAddOp {
 public:
  TensorScatterNdAddOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "TensorScatterNdAdd op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tensor_scatter_nd_add",
                       TensorScatterNdAddOpInterpCtxImpl<schema::TensorScatterNdAddOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TensorScatterNdUpdateOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class TensorScatterNdUpdateOpInterpCtxImpl : public TensorScatterNdUpdateOpInterpCtx {
 public:
  TensorScatterNdUpdateOpInterpCtxImpl() = default;
  TensorScatterNdUpdateOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TensorScatterNdUpdateOp {
 public:
  TensorScatterNdUpdateOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "TensorScatterNdUpdate op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tensor_scatter_nd_update",
                       TensorScatterNdUpdateOpInterpCtxImpl<schema::TensorScatterNdUpdateOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TensorToTensorBufferOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& instance_dims() const = 0;
  virtual int32_t* mutable_instance_dims() = 0;
  virtual void set_instance_dims(const int32_t& instance_dims) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"instance_dims"};
    return attr_names;
  }
};
template<typename Provider>
class TensorToTensorBufferOpInterpCtxImpl : public TensorToTensorBufferOpInterpCtx {
 public:
  TensorToTensorBufferOpInterpCtxImpl() = default;
  TensorToTensorBufferOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& instance_dims() const override { return impl_.instance_dims(); }
  int32_t* mutable_instance_dims() override { return impl_.mutable_instance_dims(); }
  void set_instance_dims(const int32_t& instance_dims) override {
    impl_.set_instance_dims(instance_dims);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TensorToTensorBufferOp {
 public:
  TensorToTensorBufferOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "instance_dims") {
      return CastAttr(&internal_->instance_dims);
    } else {
      return Error::RuntimeError()
             << "TensorToTensorBuffer op has no attribute named " << attr_name;
    }
  }

  const int32_t& instance_dims() const { return internal_->instance_dims; }
  int32_t* mutable_instance_dims() { return &internal_->instance_dims; }
  void set_instance_dims(const int32_t& instance_dims) { internal_->instance_dims = instance_dims; }

 private:
  struct Internal {
    int32_t instance_dims;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tensor_to_tensor_buffer",
                       TensorToTensorBufferOpInterpCtxImpl<schema::TensorToTensorBufferOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TestUserOpAttrAutoTypeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& int1() const = 0;
  virtual int32_t* mutable_int1() = 0;
  virtual void set_int1(const int32_t& int1) = 0;

  virtual const int32_t& int2() const = 0;
  virtual int32_t* mutable_int2() = 0;
  virtual void set_int2(const int32_t& int2) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"int1", "int2"};
    return attr_names;
  }
};
template<typename Provider>
class TestUserOpAttrAutoTypeOpInterpCtxImpl : public TestUserOpAttrAutoTypeOpInterpCtx {
 public:
  TestUserOpAttrAutoTypeOpInterpCtxImpl() = default;
  TestUserOpAttrAutoTypeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& int1() const override { return impl_.int1(); }
  int32_t* mutable_int1() override { return impl_.mutable_int1(); }
  void set_int1(const int32_t& int1) override { impl_.set_int1(int1); }

  const int32_t& int2() const override { return impl_.int2(); }
  int32_t* mutable_int2() override { return impl_.mutable_int2(); }
  void set_int2(const int32_t& int2) override { impl_.set_int2(int2); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TestUserOpAttrAutoTypeOp {
 public:
  TestUserOpAttrAutoTypeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "int1") {
      return CastAttr(&internal_->int1);
    } else if (attr_name == "int2") {
      return CastAttr(&internal_->int2);
    } else {
      return Error::RuntimeError()
             << "TestUserOpAttrAutoType op has no attribute named " << attr_name;
    }
  }

  const int32_t& int1() const { return internal_->int1; }
  int32_t* mutable_int1() { return &internal_->int1; }
  void set_int1(const int32_t& int1) { internal_->int1 = int1; }

  const int32_t& int2() const { return internal_->int2; }
  int32_t* mutable_int2() { return &internal_->int2; }
  void set_int2(const int32_t& int2) { internal_->int2 = int2; }

 private:
  struct Internal {
    int32_t int1;
    int32_t int2;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.test_user_op_attr_auto_type",
                       TestUserOpAttrAutoTypeOpInterpCtxImpl<schema::TestUserOpAttrAutoTypeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TfAvgPool1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::vector<int32_t>& padding_after() const = 0;
  virtual std::vector<int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<int32_t>& padding_after) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& pool_size() const = 0;
  virtual std::vector<int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<int32_t>& pool_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",     "padding_before", "padding_after",
                                           "data_format", "pool_size",      "strides",
                                           "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class TfAvgPool1DOpInterpCtxImpl : public TfAvgPool1DOpInterpCtx {
 public:
  TfAvgPool1DOpInterpCtxImpl() = default;
  TfAvgPool1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& padding() const override { return impl_.padding(); }
  std::string* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) override { impl_.set_padding(padding); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::vector<int32_t>& padding_after() const override { return impl_.padding_after(); }
  std::vector<int32_t>* mutable_padding_after() override { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<int32_t>& padding_after) override {
    impl_.set_padding_after(padding_after);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& pool_size() const override { return impl_.pool_size(); }
  std::vector<int32_t>* mutable_pool_size() override { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<int32_t>& pool_size) override {
    impl_.set_pool_size(pool_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfAvgPool1DOp {
 public:
  TfAvgPool1DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "padding_after") {
      return CastAttr(&internal_->padding_after);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "pool_size") {
      return CastAttr(&internal_->pool_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "TfAvgPool1D op has no attribute named " << attr_name;
    }
  }

  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::vector<int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<int32_t>& padding_after) {
    internal_->padding_after = padding_after;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<int32_t>& pool_size) { internal_->pool_size = pool_size; }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::string padding;
    std::vector<int32_t> padding_before;
    std::vector<int32_t> padding_after;
    std::string data_format;
    std::vector<int32_t> pool_size;
    std::vector<int32_t> strides;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tf_avg_pool_1d", TfAvgPool1DOpInterpCtxImpl<schema::TfAvgPool1DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TfAvgPool1DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::vector<int32_t>& padding_after() const = 0;
  virtual std::vector<int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<int32_t>& padding_after) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& pool_size() const = 0;
  virtual std::vector<int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<int32_t>& pool_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",     "padding_before", "padding_after",
                                           "data_format", "pool_size",      "strides",
                                           "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class TfAvgPool1DGradOpInterpCtxImpl : public TfAvgPool1DGradOpInterpCtx {
 public:
  TfAvgPool1DGradOpInterpCtxImpl() = default;
  TfAvgPool1DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& padding() const override { return impl_.padding(); }
  std::string* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) override { impl_.set_padding(padding); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::vector<int32_t>& padding_after() const override { return impl_.padding_after(); }
  std::vector<int32_t>* mutable_padding_after() override { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<int32_t>& padding_after) override {
    impl_.set_padding_after(padding_after);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& pool_size() const override { return impl_.pool_size(); }
  std::vector<int32_t>* mutable_pool_size() override { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<int32_t>& pool_size) override {
    impl_.set_pool_size(pool_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfAvgPool1DGradOp {
 public:
  TfAvgPool1DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "padding_after") {
      return CastAttr(&internal_->padding_after);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "pool_size") {
      return CastAttr(&internal_->pool_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "TfAvgPool1DGrad op has no attribute named " << attr_name;
    }
  }

  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::vector<int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<int32_t>& padding_after) {
    internal_->padding_after = padding_after;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<int32_t>& pool_size) { internal_->pool_size = pool_size; }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::string padding;
    std::vector<int32_t> padding_before;
    std::vector<int32_t> padding_after;
    std::string data_format;
    std::vector<int32_t> pool_size;
    std::vector<int32_t> strides;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tf_avg_pool_1d_grad",
                       TfAvgPool1DGradOpInterpCtxImpl<schema::TfAvgPool1DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TfAvgPool2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::vector<int32_t>& padding_after() const = 0;
  virtual std::vector<int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<int32_t>& padding_after) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& pool_size() const = 0;
  virtual std::vector<int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<int32_t>& pool_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",     "padding_before", "padding_after",
                                           "data_format", "pool_size",      "strides",
                                           "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class TfAvgPool2DOpInterpCtxImpl : public TfAvgPool2DOpInterpCtx {
 public:
  TfAvgPool2DOpInterpCtxImpl() = default;
  TfAvgPool2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& padding() const override { return impl_.padding(); }
  std::string* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) override { impl_.set_padding(padding); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::vector<int32_t>& padding_after() const override { return impl_.padding_after(); }
  std::vector<int32_t>* mutable_padding_after() override { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<int32_t>& padding_after) override {
    impl_.set_padding_after(padding_after);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& pool_size() const override { return impl_.pool_size(); }
  std::vector<int32_t>* mutable_pool_size() override { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<int32_t>& pool_size) override {
    impl_.set_pool_size(pool_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfAvgPool2DOp {
 public:
  TfAvgPool2DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "padding_after") {
      return CastAttr(&internal_->padding_after);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "pool_size") {
      return CastAttr(&internal_->pool_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "TfAvgPool2D op has no attribute named " << attr_name;
    }
  }

  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::vector<int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<int32_t>& padding_after) {
    internal_->padding_after = padding_after;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<int32_t>& pool_size) { internal_->pool_size = pool_size; }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::string padding;
    std::vector<int32_t> padding_before;
    std::vector<int32_t> padding_after;
    std::string data_format;
    std::vector<int32_t> pool_size;
    std::vector<int32_t> strides;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tf_avg_pool_2d", TfAvgPool2DOpInterpCtxImpl<schema::TfAvgPool2DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TfAvgPool2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::vector<int32_t>& padding_after() const = 0;
  virtual std::vector<int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<int32_t>& padding_after) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& pool_size() const = 0;
  virtual std::vector<int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<int32_t>& pool_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",     "padding_before", "padding_after",
                                           "data_format", "pool_size",      "strides",
                                           "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class TfAvgPool2DGradOpInterpCtxImpl : public TfAvgPool2DGradOpInterpCtx {
 public:
  TfAvgPool2DGradOpInterpCtxImpl() = default;
  TfAvgPool2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& padding() const override { return impl_.padding(); }
  std::string* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) override { impl_.set_padding(padding); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::vector<int32_t>& padding_after() const override { return impl_.padding_after(); }
  std::vector<int32_t>* mutable_padding_after() override { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<int32_t>& padding_after) override {
    impl_.set_padding_after(padding_after);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& pool_size() const override { return impl_.pool_size(); }
  std::vector<int32_t>* mutable_pool_size() override { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<int32_t>& pool_size) override {
    impl_.set_pool_size(pool_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfAvgPool2DGradOp {
 public:
  TfAvgPool2DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "padding_after") {
      return CastAttr(&internal_->padding_after);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "pool_size") {
      return CastAttr(&internal_->pool_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "TfAvgPool2DGrad op has no attribute named " << attr_name;
    }
  }

  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::vector<int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<int32_t>& padding_after) {
    internal_->padding_after = padding_after;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<int32_t>& pool_size) { internal_->pool_size = pool_size; }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::string padding;
    std::vector<int32_t> padding_before;
    std::vector<int32_t> padding_after;
    std::string data_format;
    std::vector<int32_t> pool_size;
    std::vector<int32_t> strides;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tf_avg_pool_2d_grad",
                       TfAvgPool2DGradOpInterpCtxImpl<schema::TfAvgPool2DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TfAvgPool3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::vector<int32_t>& padding_after() const = 0;
  virtual std::vector<int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<int32_t>& padding_after) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& pool_size() const = 0;
  virtual std::vector<int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<int32_t>& pool_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",     "padding_before", "padding_after",
                                           "data_format", "pool_size",      "strides",
                                           "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class TfAvgPool3DOpInterpCtxImpl : public TfAvgPool3DOpInterpCtx {
 public:
  TfAvgPool3DOpInterpCtxImpl() = default;
  TfAvgPool3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& padding() const override { return impl_.padding(); }
  std::string* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) override { impl_.set_padding(padding); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::vector<int32_t>& padding_after() const override { return impl_.padding_after(); }
  std::vector<int32_t>* mutable_padding_after() override { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<int32_t>& padding_after) override {
    impl_.set_padding_after(padding_after);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& pool_size() const override { return impl_.pool_size(); }
  std::vector<int32_t>* mutable_pool_size() override { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<int32_t>& pool_size) override {
    impl_.set_pool_size(pool_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfAvgPool3DOp {
 public:
  TfAvgPool3DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "padding_after") {
      return CastAttr(&internal_->padding_after);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "pool_size") {
      return CastAttr(&internal_->pool_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "TfAvgPool3D op has no attribute named " << attr_name;
    }
  }

  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::vector<int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<int32_t>& padding_after) {
    internal_->padding_after = padding_after;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<int32_t>& pool_size) { internal_->pool_size = pool_size; }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::string padding;
    std::vector<int32_t> padding_before;
    std::vector<int32_t> padding_after;
    std::string data_format;
    std::vector<int32_t> pool_size;
    std::vector<int32_t> strides;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tf_avg_pool_3d", TfAvgPool3DOpInterpCtxImpl<schema::TfAvgPool3DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TfAvgPool3DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::vector<int32_t>& padding_after() const = 0;
  virtual std::vector<int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<int32_t>& padding_after) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& pool_size() const = 0;
  virtual std::vector<int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<int32_t>& pool_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",     "padding_before", "padding_after",
                                           "data_format", "pool_size",      "strides",
                                           "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class TfAvgPool3DGradOpInterpCtxImpl : public TfAvgPool3DGradOpInterpCtx {
 public:
  TfAvgPool3DGradOpInterpCtxImpl() = default;
  TfAvgPool3DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& padding() const override { return impl_.padding(); }
  std::string* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) override { impl_.set_padding(padding); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::vector<int32_t>& padding_after() const override { return impl_.padding_after(); }
  std::vector<int32_t>* mutable_padding_after() override { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<int32_t>& padding_after) override {
    impl_.set_padding_after(padding_after);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& pool_size() const override { return impl_.pool_size(); }
  std::vector<int32_t>* mutable_pool_size() override { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<int32_t>& pool_size) override {
    impl_.set_pool_size(pool_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfAvgPool3DGradOp {
 public:
  TfAvgPool3DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "padding_after") {
      return CastAttr(&internal_->padding_after);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "pool_size") {
      return CastAttr(&internal_->pool_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "TfAvgPool3DGrad op has no attribute named " << attr_name;
    }
  }

  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::vector<int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<int32_t>& padding_after) {
    internal_->padding_after = padding_after;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<int32_t>& pool_size) { internal_->pool_size = pool_size; }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::string padding;
    std::vector<int32_t> padding_before;
    std::vector<int32_t> padding_after;
    std::string data_format;
    std::vector<int32_t> pool_size;
    std::vector<int32_t> strides;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tf_avg_pool_3d_grad",
                       TfAvgPool3DGradOpInterpCtxImpl<schema::TfAvgPool3DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TfMaxPool1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::vector<int32_t>& padding_after() const = 0;
  virtual std::vector<int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<int32_t>& padding_after) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& pool_size() const = 0;
  virtual std::vector<int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<int32_t>& pool_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",     "padding_before", "padding_after",
                                           "data_format", "pool_size",      "strides",
                                           "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class TfMaxPool1DOpInterpCtxImpl : public TfMaxPool1DOpInterpCtx {
 public:
  TfMaxPool1DOpInterpCtxImpl() = default;
  TfMaxPool1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& padding() const override { return impl_.padding(); }
  std::string* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) override { impl_.set_padding(padding); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::vector<int32_t>& padding_after() const override { return impl_.padding_after(); }
  std::vector<int32_t>* mutable_padding_after() override { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<int32_t>& padding_after) override {
    impl_.set_padding_after(padding_after);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& pool_size() const override { return impl_.pool_size(); }
  std::vector<int32_t>* mutable_pool_size() override { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<int32_t>& pool_size) override {
    impl_.set_pool_size(pool_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfMaxPool1DOp {
 public:
  TfMaxPool1DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "padding_after") {
      return CastAttr(&internal_->padding_after);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "pool_size") {
      return CastAttr(&internal_->pool_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "TfMaxPool1D op has no attribute named " << attr_name;
    }
  }

  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::vector<int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<int32_t>& padding_after) {
    internal_->padding_after = padding_after;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<int32_t>& pool_size) { internal_->pool_size = pool_size; }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::string padding;
    std::vector<int32_t> padding_before;
    std::vector<int32_t> padding_after;
    std::string data_format;
    std::vector<int32_t> pool_size;
    std::vector<int32_t> strides;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tf_max_pool_1d", TfMaxPool1DOpInterpCtxImpl<schema::TfMaxPool1DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TfMaxPool1DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::vector<int32_t>& padding_after() const = 0;
  virtual std::vector<int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<int32_t>& padding_after) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& pool_size() const = 0;
  virtual std::vector<int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<int32_t>& pool_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",     "padding_before", "padding_after",
                                           "data_format", "pool_size",      "strides",
                                           "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class TfMaxPool1DGradOpInterpCtxImpl : public TfMaxPool1DGradOpInterpCtx {
 public:
  TfMaxPool1DGradOpInterpCtxImpl() = default;
  TfMaxPool1DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& padding() const override { return impl_.padding(); }
  std::string* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) override { impl_.set_padding(padding); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::vector<int32_t>& padding_after() const override { return impl_.padding_after(); }
  std::vector<int32_t>* mutable_padding_after() override { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<int32_t>& padding_after) override {
    impl_.set_padding_after(padding_after);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& pool_size() const override { return impl_.pool_size(); }
  std::vector<int32_t>* mutable_pool_size() override { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<int32_t>& pool_size) override {
    impl_.set_pool_size(pool_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfMaxPool1DGradOp {
 public:
  TfMaxPool1DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "padding_after") {
      return CastAttr(&internal_->padding_after);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "pool_size") {
      return CastAttr(&internal_->pool_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "TfMaxPool1DGrad op has no attribute named " << attr_name;
    }
  }

  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::vector<int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<int32_t>& padding_after) {
    internal_->padding_after = padding_after;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<int32_t>& pool_size) { internal_->pool_size = pool_size; }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::string padding;
    std::vector<int32_t> padding_before;
    std::vector<int32_t> padding_after;
    std::string data_format;
    std::vector<int32_t> pool_size;
    std::vector<int32_t> strides;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tf_max_pool_1d_grad",
                       TfMaxPool1DGradOpInterpCtxImpl<schema::TfMaxPool1DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TfMaxPool2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::vector<int32_t>& padding_after() const = 0;
  virtual std::vector<int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<int32_t>& padding_after) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& pool_size() const = 0;
  virtual std::vector<int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<int32_t>& pool_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",     "padding_before", "padding_after",
                                           "data_format", "pool_size",      "strides",
                                           "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class TfMaxPool2DOpInterpCtxImpl : public TfMaxPool2DOpInterpCtx {
 public:
  TfMaxPool2DOpInterpCtxImpl() = default;
  TfMaxPool2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& padding() const override { return impl_.padding(); }
  std::string* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) override { impl_.set_padding(padding); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::vector<int32_t>& padding_after() const override { return impl_.padding_after(); }
  std::vector<int32_t>* mutable_padding_after() override { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<int32_t>& padding_after) override {
    impl_.set_padding_after(padding_after);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& pool_size() const override { return impl_.pool_size(); }
  std::vector<int32_t>* mutable_pool_size() override { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<int32_t>& pool_size) override {
    impl_.set_pool_size(pool_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfMaxPool2DOp {
 public:
  TfMaxPool2DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "padding_after") {
      return CastAttr(&internal_->padding_after);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "pool_size") {
      return CastAttr(&internal_->pool_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "TfMaxPool2D op has no attribute named " << attr_name;
    }
  }

  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::vector<int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<int32_t>& padding_after) {
    internal_->padding_after = padding_after;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<int32_t>& pool_size) { internal_->pool_size = pool_size; }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::string padding;
    std::vector<int32_t> padding_before;
    std::vector<int32_t> padding_after;
    std::string data_format;
    std::vector<int32_t> pool_size;
    std::vector<int32_t> strides;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tf_max_pool_2d", TfMaxPool2DOpInterpCtxImpl<schema::TfMaxPool2DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TfMaxPool2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::vector<int32_t>& padding_after() const = 0;
  virtual std::vector<int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<int32_t>& padding_after) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& pool_size() const = 0;
  virtual std::vector<int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<int32_t>& pool_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",     "padding_before", "padding_after",
                                           "data_format", "pool_size",      "strides",
                                           "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class TfMaxPool2DGradOpInterpCtxImpl : public TfMaxPool2DGradOpInterpCtx {
 public:
  TfMaxPool2DGradOpInterpCtxImpl() = default;
  TfMaxPool2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& padding() const override { return impl_.padding(); }
  std::string* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) override { impl_.set_padding(padding); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::vector<int32_t>& padding_after() const override { return impl_.padding_after(); }
  std::vector<int32_t>* mutable_padding_after() override { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<int32_t>& padding_after) override {
    impl_.set_padding_after(padding_after);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& pool_size() const override { return impl_.pool_size(); }
  std::vector<int32_t>* mutable_pool_size() override { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<int32_t>& pool_size) override {
    impl_.set_pool_size(pool_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfMaxPool2DGradOp {
 public:
  TfMaxPool2DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "padding_after") {
      return CastAttr(&internal_->padding_after);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "pool_size") {
      return CastAttr(&internal_->pool_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "TfMaxPool2DGrad op has no attribute named " << attr_name;
    }
  }

  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::vector<int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<int32_t>& padding_after) {
    internal_->padding_after = padding_after;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<int32_t>& pool_size) { internal_->pool_size = pool_size; }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::string padding;
    std::vector<int32_t> padding_before;
    std::vector<int32_t> padding_after;
    std::string data_format;
    std::vector<int32_t> pool_size;
    std::vector<int32_t> strides;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tf_max_pool_2d_grad",
                       TfMaxPool2DGradOpInterpCtxImpl<schema::TfMaxPool2DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TfMaxPool3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::vector<int32_t>& padding_after() const = 0;
  virtual std::vector<int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<int32_t>& padding_after) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& pool_size() const = 0;
  virtual std::vector<int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<int32_t>& pool_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",     "padding_before", "padding_after",
                                           "data_format", "pool_size",      "strides",
                                           "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class TfMaxPool3DOpInterpCtxImpl : public TfMaxPool3DOpInterpCtx {
 public:
  TfMaxPool3DOpInterpCtxImpl() = default;
  TfMaxPool3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& padding() const override { return impl_.padding(); }
  std::string* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) override { impl_.set_padding(padding); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::vector<int32_t>& padding_after() const override { return impl_.padding_after(); }
  std::vector<int32_t>* mutable_padding_after() override { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<int32_t>& padding_after) override {
    impl_.set_padding_after(padding_after);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& pool_size() const override { return impl_.pool_size(); }
  std::vector<int32_t>* mutable_pool_size() override { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<int32_t>& pool_size) override {
    impl_.set_pool_size(pool_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfMaxPool3DOp {
 public:
  TfMaxPool3DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "padding_after") {
      return CastAttr(&internal_->padding_after);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "pool_size") {
      return CastAttr(&internal_->pool_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "TfMaxPool3D op has no attribute named " << attr_name;
    }
  }

  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::vector<int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<int32_t>& padding_after) {
    internal_->padding_after = padding_after;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<int32_t>& pool_size) { internal_->pool_size = pool_size; }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::string padding;
    std::vector<int32_t> padding_before;
    std::vector<int32_t> padding_after;
    std::string data_format;
    std::vector<int32_t> pool_size;
    std::vector<int32_t> strides;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tf_max_pool_3d", TfMaxPool3DOpInterpCtxImpl<schema::TfMaxPool3DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TfMaxPool3DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& padding() const = 0;
  virtual std::string* mutable_padding() = 0;
  virtual void set_padding(const std::string& padding) = 0;

  virtual const std::vector<int32_t>& padding_before() const = 0;
  virtual std::vector<int32_t>* mutable_padding_before() = 0;
  virtual void set_padding_before(const std::vector<int32_t>& padding_before) = 0;

  virtual const std::vector<int32_t>& padding_after() const = 0;
  virtual std::vector<int32_t>* mutable_padding_after() = 0;
  virtual void set_padding_after(const std::vector<int32_t>& padding_after) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& pool_size() const = 0;
  virtual std::vector<int32_t>* mutable_pool_size() = 0;
  virtual void set_pool_size(const std::vector<int32_t>& pool_size) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const bool& ceil_mode() const = 0;
  virtual bool* mutable_ceil_mode() = 0;
  virtual void set_ceil_mode(const bool& ceil_mode) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"padding",     "padding_before", "padding_after",
                                           "data_format", "pool_size",      "strides",
                                           "ceil_mode"};
    return attr_names;
  }
};
template<typename Provider>
class TfMaxPool3DGradOpInterpCtxImpl : public TfMaxPool3DGradOpInterpCtx {
 public:
  TfMaxPool3DGradOpInterpCtxImpl() = default;
  TfMaxPool3DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& padding() const override { return impl_.padding(); }
  std::string* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::string& padding) override { impl_.set_padding(padding); }

  const std::vector<int32_t>& padding_before() const override { return impl_.padding_before(); }
  std::vector<int32_t>* mutable_padding_before() override { return impl_.mutable_padding_before(); }
  void set_padding_before(const std::vector<int32_t>& padding_before) override {
    impl_.set_padding_before(padding_before);
  }

  const std::vector<int32_t>& padding_after() const override { return impl_.padding_after(); }
  std::vector<int32_t>* mutable_padding_after() override { return impl_.mutable_padding_after(); }
  void set_padding_after(const std::vector<int32_t>& padding_after) override {
    impl_.set_padding_after(padding_after);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& pool_size() const override { return impl_.pool_size(); }
  std::vector<int32_t>* mutable_pool_size() override { return impl_.mutable_pool_size(); }
  void set_pool_size(const std::vector<int32_t>& pool_size) override {
    impl_.set_pool_size(pool_size);
  }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const bool& ceil_mode() const override { return impl_.ceil_mode(); }
  bool* mutable_ceil_mode() override { return impl_.mutable_ceil_mode(); }
  void set_ceil_mode(const bool& ceil_mode) override { impl_.set_ceil_mode(ceil_mode); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfMaxPool3DGradOp {
 public:
  TfMaxPool3DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "padding_before") {
      return CastAttr(&internal_->padding_before);
    } else if (attr_name == "padding_after") {
      return CastAttr(&internal_->padding_after);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "pool_size") {
      return CastAttr(&internal_->pool_size);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "ceil_mode") {
      return CastAttr(&internal_->ceil_mode);
    } else {
      return Error::RuntimeError() << "TfMaxPool3DGrad op has no attribute named " << attr_name;
    }
  }

  const std::string& padding() const { return internal_->padding; }
  std::string* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::string& padding) { internal_->padding = padding; }

  const std::vector<int32_t>& padding_before() const { return internal_->padding_before; }
  std::vector<int32_t>* mutable_padding_before() { return &internal_->padding_before; }
  void set_padding_before(const std::vector<int32_t>& padding_before) {
    internal_->padding_before = padding_before;
  }

  const std::vector<int32_t>& padding_after() const { return internal_->padding_after; }
  std::vector<int32_t>* mutable_padding_after() { return &internal_->padding_after; }
  void set_padding_after(const std::vector<int32_t>& padding_after) {
    internal_->padding_after = padding_after;
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& pool_size() const { return internal_->pool_size; }
  std::vector<int32_t>* mutable_pool_size() { return &internal_->pool_size; }
  void set_pool_size(const std::vector<int32_t>& pool_size) { internal_->pool_size = pool_size; }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const bool& ceil_mode() const { return internal_->ceil_mode; }
  bool* mutable_ceil_mode() { return &internal_->ceil_mode; }
  void set_ceil_mode(const bool& ceil_mode) { internal_->ceil_mode = ceil_mode; }

 private:
  struct Internal {
    std::string padding;
    std::vector<int32_t> padding_before;
    std::vector<int32_t> padding_after;
    std::string data_format;
    std::vector<int32_t> pool_size;
    std::vector<int32_t> strides;
    bool ceil_mode;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tf_max_pool_3d_grad",
                       TfMaxPool3DGradOpInterpCtxImpl<schema::TfMaxPool3DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TfPreluOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class TfPreluOpInterpCtxImpl : public TfPreluOpInterpCtx {
 public:
  TfPreluOpInterpCtxImpl() = default;
  TfPreluOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfPreluOp {
 public:
  TfPreluOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "TfPrelu op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tf_prelu", TfPreluOpInterpCtxImpl<schema::TfPreluOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TfPreluGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class TfPreluGradOpInterpCtxImpl : public TfPreluGradOpInterpCtx {
 public:
  TfPreluGradOpInterpCtxImpl() = default;
  TfPreluGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TfPreluGradOp {
 public:
  TfPreluGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "TfPreluGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tf_prelu_grad", TfPreluGradOpInterpCtxImpl<schema::TfPreluGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TopKOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& k() const = 0;
  virtual int32_t* mutable_k() = 0;
  virtual void set_k(const int32_t& k) = 0;

  virtual const bool& sorted() const = 0;
  virtual bool* mutable_sorted() = 0;
  virtual void set_sorted(const bool& sorted) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"k", "sorted"};
    return attr_names;
  }
};
template<typename Provider>
class TopKOpInterpCtxImpl : public TopKOpInterpCtx {
 public:
  TopKOpInterpCtxImpl() = default;
  TopKOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& k() const override { return impl_.k(); }
  int32_t* mutable_k() override { return impl_.mutable_k(); }
  void set_k(const int32_t& k) override { impl_.set_k(k); }

  const bool& sorted() const override { return impl_.sorted(); }
  bool* mutable_sorted() override { return impl_.mutable_sorted(); }
  void set_sorted(const bool& sorted) override { impl_.set_sorted(sorted); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TopKOp {
 public:
  TopKOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "k") {
      return CastAttr(&internal_->k);
    } else if (attr_name == "sorted") {
      return CastAttr(&internal_->sorted);
    } else {
      return Error::RuntimeError() << "TopK op has no attribute named " << attr_name;
    }
  }

  const int32_t& k() const { return internal_->k; }
  int32_t* mutable_k() { return &internal_->k; }
  void set_k(const int32_t& k) { internal_->k = k; }

  const bool& sorted() const { return internal_->sorted; }
  bool* mutable_sorted() { return &internal_->sorted; }
  void set_sorted(const bool& sorted) { internal_->sorted = sorted; }

 private:
  struct Internal {
    int32_t k;
    bool sorted;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.top_k", TopKOpInterpCtxImpl<schema::TopKOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TransposeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::vector<int32_t>& perm() const = 0;
  virtual std::vector<int32_t>* mutable_perm() = 0;
  virtual void set_perm(const std::vector<int32_t>& perm) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"perm"};
    return attr_names;
  }
};
template<typename Provider>
class TransposeOpInterpCtxImpl : public TransposeOpInterpCtx {
 public:
  TransposeOpInterpCtxImpl() = default;
  TransposeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::vector<int32_t>& perm() const override { return impl_.perm(); }
  std::vector<int32_t>* mutable_perm() override { return impl_.mutable_perm(); }
  void set_perm(const std::vector<int32_t>& perm) override { impl_.set_perm(perm); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TransposeOp {
 public:
  TransposeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "perm") {
      return CastAttr(&internal_->perm);
    } else {
      return Error::RuntimeError() << "Transpose op has no attribute named " << attr_name;
    }
  }

  const std::vector<int32_t>& perm() const { return internal_->perm; }
  std::vector<int32_t>* mutable_perm() { return &internal_->perm; }
  void set_perm(const std::vector<int32_t>& perm) { internal_->perm = perm; }

 private:
  struct Internal {
    std::vector<int32_t> perm;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.transpose", TransposeOpInterpCtxImpl<schema::TransposeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TrilOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& diagonal() const = 0;
  virtual int64_t* mutable_diagonal() = 0;
  virtual void set_diagonal(const int64_t& diagonal) = 0;

  virtual const double& floating_fill_value() const = 0;
  virtual double* mutable_floating_fill_value() = 0;
  virtual void set_floating_fill_value(const double& floating_fill_value) = 0;

  virtual const int64_t& integer_fill_value() const = 0;
  virtual int64_t* mutable_integer_fill_value() = 0;
  virtual void set_integer_fill_value(const int64_t& integer_fill_value) = 0;

  virtual const bool& is_floating_fill_value() const = 0;
  virtual bool* mutable_is_floating_fill_value() = 0;
  virtual void set_is_floating_fill_value(const bool& is_floating_fill_value) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"diagonal", "floating_fill_value", "integer_fill_value",
                                           "is_floating_fill_value"};
    return attr_names;
  }
};
template<typename Provider>
class TrilOpInterpCtxImpl : public TrilOpInterpCtx {
 public:
  TrilOpInterpCtxImpl() = default;
  TrilOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& diagonal() const override { return impl_.diagonal(); }
  int64_t* mutable_diagonal() override { return impl_.mutable_diagonal(); }
  void set_diagonal(const int64_t& diagonal) override { impl_.set_diagonal(diagonal); }

  const double& floating_fill_value() const override { return impl_.floating_fill_value(); }
  double* mutable_floating_fill_value() override { return impl_.mutable_floating_fill_value(); }
  void set_floating_fill_value(const double& floating_fill_value) override {
    impl_.set_floating_fill_value(floating_fill_value);
  }

  const int64_t& integer_fill_value() const override { return impl_.integer_fill_value(); }
  int64_t* mutable_integer_fill_value() override { return impl_.mutable_integer_fill_value(); }
  void set_integer_fill_value(const int64_t& integer_fill_value) override {
    impl_.set_integer_fill_value(integer_fill_value);
  }

  const bool& is_floating_fill_value() const override { return impl_.is_floating_fill_value(); }
  bool* mutable_is_floating_fill_value() override { return impl_.mutable_is_floating_fill_value(); }
  void set_is_floating_fill_value(const bool& is_floating_fill_value) override {
    impl_.set_is_floating_fill_value(is_floating_fill_value);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TrilOp {
 public:
  TrilOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "diagonal") {
      return CastAttr(&internal_->diagonal);
    } else if (attr_name == "floating_fill_value") {
      return CastAttr(&internal_->floating_fill_value);
    } else if (attr_name == "integer_fill_value") {
      return CastAttr(&internal_->integer_fill_value);
    } else if (attr_name == "is_floating_fill_value") {
      return CastAttr(&internal_->is_floating_fill_value);
    } else {
      return Error::RuntimeError() << "Tril op has no attribute named " << attr_name;
    }
  }

  const int64_t& diagonal() const { return internal_->diagonal; }
  int64_t* mutable_diagonal() { return &internal_->diagonal; }
  void set_diagonal(const int64_t& diagonal) { internal_->diagonal = diagonal; }

  const double& floating_fill_value() const { return internal_->floating_fill_value; }
  double* mutable_floating_fill_value() { return &internal_->floating_fill_value; }
  void set_floating_fill_value(const double& floating_fill_value) {
    internal_->floating_fill_value = floating_fill_value;
  }

  const int64_t& integer_fill_value() const { return internal_->integer_fill_value; }
  int64_t* mutable_integer_fill_value() { return &internal_->integer_fill_value; }
  void set_integer_fill_value(const int64_t& integer_fill_value) {
    internal_->integer_fill_value = integer_fill_value;
  }

  const bool& is_floating_fill_value() const { return internal_->is_floating_fill_value; }
  bool* mutable_is_floating_fill_value() { return &internal_->is_floating_fill_value; }
  void set_is_floating_fill_value(const bool& is_floating_fill_value) {
    internal_->is_floating_fill_value = is_floating_fill_value;
  }

 private:
  struct Internal {
    int64_t diagonal;
    double floating_fill_value;
    int64_t integer_fill_value;
    bool is_floating_fill_value;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tril", TrilOpInterpCtxImpl<schema::TrilOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TriuOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& diagonal() const = 0;
  virtual int64_t* mutable_diagonal() = 0;
  virtual void set_diagonal(const int64_t& diagonal) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"diagonal"};
    return attr_names;
  }
};
template<typename Provider>
class TriuOpInterpCtxImpl : public TriuOpInterpCtx {
 public:
  TriuOpInterpCtxImpl() = default;
  TriuOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& diagonal() const override { return impl_.diagonal(); }
  int64_t* mutable_diagonal() override { return impl_.mutable_diagonal(); }
  void set_diagonal(const int64_t& diagonal) override { impl_.set_diagonal(diagonal); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TriuOp {
 public:
  TriuOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "diagonal") {
      return CastAttr(&internal_->diagonal);
    } else {
      return Error::RuntimeError() << "Triu op has no attribute named " << attr_name;
    }
  }

  const int64_t& diagonal() const { return internal_->diagonal; }
  int64_t* mutable_diagonal() { return &internal_->diagonal; }
  void set_diagonal(const int64_t& diagonal) { internal_->diagonal = diagonal; }

 private:
  struct Internal {
    int64_t diagonal;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.triu", TriuOpInterpCtxImpl<schema::TriuOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class TupleIdentityOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class TupleIdentityOpInterpCtxImpl : public TupleIdentityOpInterpCtx {
 public:
  TupleIdentityOpInterpCtxImpl() = default;
  TupleIdentityOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class TupleIdentityOp {
 public:
  TupleIdentityOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "TupleIdentity op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.tuple_identity",
                       TupleIdentityOpInterpCtxImpl<schema::TupleIdentityOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UnfoldOpInterpCtx : public OpInterpCtx {
 public:
  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::vector<int32_t>& kernel_size() const = 0;
  virtual std::vector<int32_t>* mutable_kernel_size() = 0;
  virtual void set_kernel_size(const std::vector<int32_t>& kernel_size) = 0;

  virtual const std::vector<int32_t>& padding() const = 0;
  virtual std::vector<int32_t>* mutable_padding() = 0;
  virtual void set_padding(const std::vector<int32_t>& padding) = 0;

  virtual const std::vector<int32_t>& strides() const = 0;
  virtual std::vector<int32_t>* mutable_strides() = 0;
  virtual void set_strides(const std::vector<int32_t>& strides) = 0;

  virtual const std::vector<int32_t>& dilation_rate() const = 0;
  virtual std::vector<int32_t>* mutable_dilation_rate() = 0;
  virtual void set_dilation_rate(const std::vector<int32_t>& dilation_rate) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"data_format", "kernel_size", "padding", "strides",
                                           "dilation_rate"};
    return attr_names;
  }
};
template<typename Provider>
class UnfoldOpInterpCtxImpl : public UnfoldOpInterpCtx {
 public:
  UnfoldOpInterpCtxImpl() = default;
  UnfoldOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::vector<int32_t>& kernel_size() const override { return impl_.kernel_size(); }
  std::vector<int32_t>* mutable_kernel_size() override { return impl_.mutable_kernel_size(); }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) override {
    impl_.set_kernel_size(kernel_size);
  }

  const std::vector<int32_t>& padding() const override { return impl_.padding(); }
  std::vector<int32_t>* mutable_padding() override { return impl_.mutable_padding(); }
  void set_padding(const std::vector<int32_t>& padding) override { impl_.set_padding(padding); }

  const std::vector<int32_t>& strides() const override { return impl_.strides(); }
  std::vector<int32_t>* mutable_strides() override { return impl_.mutable_strides(); }
  void set_strides(const std::vector<int32_t>& strides) override { impl_.set_strides(strides); }

  const std::vector<int32_t>& dilation_rate() const override { return impl_.dilation_rate(); }
  std::vector<int32_t>* mutable_dilation_rate() override { return impl_.mutable_dilation_rate(); }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) override {
    impl_.set_dilation_rate(dilation_rate);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UnfoldOp {
 public:
  UnfoldOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "kernel_size") {
      return CastAttr(&internal_->kernel_size);
    } else if (attr_name == "padding") {
      return CastAttr(&internal_->padding);
    } else if (attr_name == "strides") {
      return CastAttr(&internal_->strides);
    } else if (attr_name == "dilation_rate") {
      return CastAttr(&internal_->dilation_rate);
    } else {
      return Error::RuntimeError() << "Unfold op has no attribute named " << attr_name;
    }
  }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::vector<int32_t>& kernel_size() const { return internal_->kernel_size; }
  std::vector<int32_t>* mutable_kernel_size() { return &internal_->kernel_size; }
  void set_kernel_size(const std::vector<int32_t>& kernel_size) {
    internal_->kernel_size = kernel_size;
  }

  const std::vector<int32_t>& padding() const { return internal_->padding; }
  std::vector<int32_t>* mutable_padding() { return &internal_->padding; }
  void set_padding(const std::vector<int32_t>& padding) { internal_->padding = padding; }

  const std::vector<int32_t>& strides() const { return internal_->strides; }
  std::vector<int32_t>* mutable_strides() { return &internal_->strides; }
  void set_strides(const std::vector<int32_t>& strides) { internal_->strides = strides; }

  const std::vector<int32_t>& dilation_rate() const { return internal_->dilation_rate; }
  std::vector<int32_t>* mutable_dilation_rate() { return &internal_->dilation_rate; }
  void set_dilation_rate(const std::vector<int32_t>& dilation_rate) {
    internal_->dilation_rate = dilation_rate;
  }

 private:
  struct Internal {
    std::string data_format;
    std::vector<int32_t> kernel_size;
    std::vector<int32_t> padding;
    std::vector<int32_t> strides;
    std::vector<int32_t> dilation_rate;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.unfold", UnfoldOpInterpCtxImpl<schema::UnfoldOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UnfoldTensorOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& dimension() const = 0;
  virtual int32_t* mutable_dimension() = 0;
  virtual void set_dimension(const int32_t& dimension) = 0;

  virtual const int32_t& size() const = 0;
  virtual int32_t* mutable_size() = 0;
  virtual void set_size(const int32_t& size) = 0;

  virtual const int32_t& step() const = 0;
  virtual int32_t* mutable_step() = 0;
  virtual void set_step(const int32_t& step) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"dimension", "size", "step"};
    return attr_names;
  }
};
template<typename Provider>
class UnfoldTensorOpInterpCtxImpl : public UnfoldTensorOpInterpCtx {
 public:
  UnfoldTensorOpInterpCtxImpl() = default;
  UnfoldTensorOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& dimension() const override { return impl_.dimension(); }
  int32_t* mutable_dimension() override { return impl_.mutable_dimension(); }
  void set_dimension(const int32_t& dimension) override { impl_.set_dimension(dimension); }

  const int32_t& size() const override { return impl_.size(); }
  int32_t* mutable_size() override { return impl_.mutable_size(); }
  void set_size(const int32_t& size) override { impl_.set_size(size); }

  const int32_t& step() const override { return impl_.step(); }
  int32_t* mutable_step() override { return impl_.mutable_step(); }
  void set_step(const int32_t& step) override { impl_.set_step(step); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UnfoldTensorOp {
 public:
  UnfoldTensorOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "dimension") {
      return CastAttr(&internal_->dimension);
    } else if (attr_name == "size") {
      return CastAttr(&internal_->size);
    } else if (attr_name == "step") {
      return CastAttr(&internal_->step);
    } else {
      return Error::RuntimeError() << "UnfoldTensor op has no attribute named " << attr_name;
    }
  }

  const int32_t& dimension() const { return internal_->dimension; }
  int32_t* mutable_dimension() { return &internal_->dimension; }
  void set_dimension(const int32_t& dimension) { internal_->dimension = dimension; }

  const int32_t& size() const { return internal_->size; }
  int32_t* mutable_size() { return &internal_->size; }
  void set_size(const int32_t& size) { internal_->size = size; }

  const int32_t& step() const { return internal_->step; }
  int32_t* mutable_step() { return &internal_->step; }
  void set_step(const int32_t& step) { internal_->step = step; }

 private:
  struct Internal {
    int32_t dimension;
    int32_t size;
    int32_t step;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.unfold_tensor", UnfoldTensorOpInterpCtxImpl<schema::UnfoldTensorOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UnfoldTensorGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& dimension() const = 0;
  virtual int32_t* mutable_dimension() = 0;
  virtual void set_dimension(const int32_t& dimension) = 0;

  virtual const int32_t& size() const = 0;
  virtual int32_t* mutable_size() = 0;
  virtual void set_size(const int32_t& size) = 0;

  virtual const int32_t& step() const = 0;
  virtual int32_t* mutable_step() = 0;
  virtual void set_step(const int32_t& step) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"dimension", "size", "step"};
    return attr_names;
  }
};
template<typename Provider>
class UnfoldTensorGradOpInterpCtxImpl : public UnfoldTensorGradOpInterpCtx {
 public:
  UnfoldTensorGradOpInterpCtxImpl() = default;
  UnfoldTensorGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& dimension() const override { return impl_.dimension(); }
  int32_t* mutable_dimension() override { return impl_.mutable_dimension(); }
  void set_dimension(const int32_t& dimension) override { impl_.set_dimension(dimension); }

  const int32_t& size() const override { return impl_.size(); }
  int32_t* mutable_size() override { return impl_.mutable_size(); }
  void set_size(const int32_t& size) override { impl_.set_size(size); }

  const int32_t& step() const override { return impl_.step(); }
  int32_t* mutable_step() override { return impl_.mutable_step(); }
  void set_step(const int32_t& step) override { impl_.set_step(step); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UnfoldTensorGradOp {
 public:
  UnfoldTensorGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "dimension") {
      return CastAttr(&internal_->dimension);
    } else if (attr_name == "size") {
      return CastAttr(&internal_->size);
    } else if (attr_name == "step") {
      return CastAttr(&internal_->step);
    } else {
      return Error::RuntimeError() << "UnfoldTensorGrad op has no attribute named " << attr_name;
    }
  }

  const int32_t& dimension() const { return internal_->dimension; }
  int32_t* mutable_dimension() { return &internal_->dimension; }
  void set_dimension(const int32_t& dimension) { internal_->dimension = dimension; }

  const int32_t& size() const { return internal_->size; }
  int32_t* mutable_size() { return &internal_->size; }
  void set_size(const int32_t& size) { internal_->size = size; }

  const int32_t& step() const { return internal_->step; }
  int32_t* mutable_step() { return &internal_->step; }
  void set_step(const int32_t& step) { internal_->step = step; }

 private:
  struct Internal {
    int32_t dimension;
    int32_t size;
    int32_t step;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.unfold_tensor_grad",
                       UnfoldTensorGradOpInterpCtxImpl<schema::UnfoldTensorGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UniformOpInterpCtx : public OpInterpCtx {
 public:
  virtual const double& from() const = 0;
  virtual double* mutable_from() = 0;
  virtual void set_from(const double& from) = 0;

  virtual const double& to() const = 0;
  virtual double* mutable_to() = 0;
  virtual void set_to(const double& to) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  virtual const std::string& nd_sbp() const = 0;
  virtual std::string* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::string& nd_sbp) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"from", "to", "seed", "dtype", "shape", "nd_sbp"};
    return attr_names;
  }
};
template<typename Provider>
class UniformOpInterpCtxImpl : public UniformOpInterpCtx {
 public:
  UniformOpInterpCtxImpl() = default;
  UniformOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const double& from() const override { return impl_.from(); }
  double* mutable_from() override { return impl_.mutable_from(); }
  void set_from(const double& from) override { impl_.set_from(from); }

  const double& to() const override { return impl_.to(); }
  double* mutable_to() override { return impl_.mutable_to(); }
  void set_to(const double& to) override { impl_.set_to(to); }

  const int64_t& seed() const override { return impl_.seed(); }
  int64_t* mutable_seed() override { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) override { impl_.set_seed(seed); }

  const DataType& dtype() const override { return impl_.dtype(); }
  DataType* mutable_dtype() override { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) override { impl_.set_dtype(dtype); }

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  const std::string& nd_sbp() const override { return impl_.nd_sbp(); }
  std::string* mutable_nd_sbp() override { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::string& nd_sbp) override { impl_.set_nd_sbp(nd_sbp); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UniformOp {
 public:
  UniformOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "from") {
      return CastAttr(&internal_->from);
    } else if (attr_name == "to") {
      return CastAttr(&internal_->to);
    } else if (attr_name == "seed") {
      return CastAttr(&internal_->seed);
    } else if (attr_name == "dtype") {
      return CastAttr(&internal_->dtype);
    } else if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else if (attr_name == "nd_sbp") {
      return CastAttr(&internal_->nd_sbp);
    } else {
      return Error::RuntimeError() << "Uniform op has no attribute named " << attr_name;
    }
  }

  const double& from() const { return internal_->from; }
  double* mutable_from() { return &internal_->from; }
  void set_from(const double& from) { internal_->from = from; }

  const double& to() const { return internal_->to; }
  double* mutable_to() { return &internal_->to; }
  void set_to(const double& to) { internal_->to = to; }

  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }

  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

  const std::string& nd_sbp() const { return internal_->nd_sbp; }
  std::string* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::string& nd_sbp) { internal_->nd_sbp = nd_sbp; }

 private:
  struct Internal {
    double from;
    double to;
    int64_t seed;
    DataType dtype;
    Shape shape;
    std::string nd_sbp;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.uniform", UniformOpInterpCtxImpl<schema::UniformOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UniformIntOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& from() const = 0;
  virtual int64_t* mutable_from() = 0;
  virtual void set_from(const int64_t& from) = 0;

  virtual const int64_t& to() const = 0;
  virtual int64_t* mutable_to() = 0;
  virtual void set_to(const int64_t& to) = 0;

  virtual const int64_t& seed() const = 0;
  virtual int64_t* mutable_seed() = 0;
  virtual void set_seed(const int64_t& seed) = 0;

  virtual const DataType& dtype() const = 0;
  virtual DataType* mutable_dtype() = 0;
  virtual void set_dtype(const DataType& dtype) = 0;

  virtual const Shape& shape() const = 0;
  virtual Shape* mutable_shape() = 0;
  virtual void set_shape(const Shape& shape) = 0;

  virtual const std::string& nd_sbp() const = 0;
  virtual std::string* mutable_nd_sbp() = 0;
  virtual void set_nd_sbp(const std::string& nd_sbp) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"from", "to", "seed", "dtype", "shape", "nd_sbp"};
    return attr_names;
  }
};
template<typename Provider>
class UniformIntOpInterpCtxImpl : public UniformIntOpInterpCtx {
 public:
  UniformIntOpInterpCtxImpl() = default;
  UniformIntOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& from() const override { return impl_.from(); }
  int64_t* mutable_from() override { return impl_.mutable_from(); }
  void set_from(const int64_t& from) override { impl_.set_from(from); }

  const int64_t& to() const override { return impl_.to(); }
  int64_t* mutable_to() override { return impl_.mutable_to(); }
  void set_to(const int64_t& to) override { impl_.set_to(to); }

  const int64_t& seed() const override { return impl_.seed(); }
  int64_t* mutable_seed() override { return impl_.mutable_seed(); }
  void set_seed(const int64_t& seed) override { impl_.set_seed(seed); }

  const DataType& dtype() const override { return impl_.dtype(); }
  DataType* mutable_dtype() override { return impl_.mutable_dtype(); }
  void set_dtype(const DataType& dtype) override { impl_.set_dtype(dtype); }

  const Shape& shape() const override { return impl_.shape(); }
  Shape* mutable_shape() override { return impl_.mutable_shape(); }
  void set_shape(const Shape& shape) override { impl_.set_shape(shape); }

  const std::string& nd_sbp() const override { return impl_.nd_sbp(); }
  std::string* mutable_nd_sbp() override { return impl_.mutable_nd_sbp(); }
  void set_nd_sbp(const std::string& nd_sbp) override { impl_.set_nd_sbp(nd_sbp); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UniformIntOp {
 public:
  UniformIntOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "from") {
      return CastAttr(&internal_->from);
    } else if (attr_name == "to") {
      return CastAttr(&internal_->to);
    } else if (attr_name == "seed") {
      return CastAttr(&internal_->seed);
    } else if (attr_name == "dtype") {
      return CastAttr(&internal_->dtype);
    } else if (attr_name == "shape") {
      return CastAttr(&internal_->shape);
    } else if (attr_name == "nd_sbp") {
      return CastAttr(&internal_->nd_sbp);
    } else {
      return Error::RuntimeError() << "UniformInt op has no attribute named " << attr_name;
    }
  }

  const int64_t& from() const { return internal_->from; }
  int64_t* mutable_from() { return &internal_->from; }
  void set_from(const int64_t& from) { internal_->from = from; }

  const int64_t& to() const { return internal_->to; }
  int64_t* mutable_to() { return &internal_->to; }
  void set_to(const int64_t& to) { internal_->to = to; }

  const int64_t& seed() const { return internal_->seed; }
  int64_t* mutable_seed() { return &internal_->seed; }
  void set_seed(const int64_t& seed) { internal_->seed = seed; }

  const DataType& dtype() const { return internal_->dtype; }
  DataType* mutable_dtype() { return &internal_->dtype; }
  void set_dtype(const DataType& dtype) { internal_->dtype = dtype; }

  const Shape& shape() const { return internal_->shape; }
  Shape* mutable_shape() { return &internal_->shape; }
  void set_shape(const Shape& shape) { internal_->shape = shape; }

  const std::string& nd_sbp() const { return internal_->nd_sbp; }
  std::string* mutable_nd_sbp() { return &internal_->nd_sbp; }
  void set_nd_sbp(const std::string& nd_sbp) { internal_->nd_sbp = nd_sbp; }

 private:
  struct Internal {
    int64_t from;
    int64_t to;
    int64_t seed;
    DataType dtype;
    Shape shape;
    std::string nd_sbp;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.uniform_int", UniformIntOpInterpCtxImpl<schema::UniformIntOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UniqueWithCountsOpInterpCtx : public OpInterpCtx {
 public:
  virtual const DataType& out_idx() const = 0;
  virtual DataType* mutable_out_idx() = 0;
  virtual void set_out_idx(const DataType& out_idx) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"out_idx"};
    return attr_names;
  }
};
template<typename Provider>
class UniqueWithCountsOpInterpCtxImpl : public UniqueWithCountsOpInterpCtx {
 public:
  UniqueWithCountsOpInterpCtxImpl() = default;
  UniqueWithCountsOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const DataType& out_idx() const override { return impl_.out_idx(); }
  DataType* mutable_out_idx() override { return impl_.mutable_out_idx(); }
  void set_out_idx(const DataType& out_idx) override { impl_.set_out_idx(out_idx); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UniqueWithCountsOp {
 public:
  UniqueWithCountsOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "out_idx") {
      return CastAttr(&internal_->out_idx);
    } else {
      return Error::RuntimeError() << "UniqueWithCounts op has no attribute named " << attr_name;
    }
  }

  const DataType& out_idx() const { return internal_->out_idx; }
  DataType* mutable_out_idx() { return &internal_->out_idx; }
  void set_out_idx(const DataType& out_idx) { internal_->out_idx = out_idx; }

 private:
  struct Internal {
    DataType out_idx;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.unique_with_counts",
                       UniqueWithCountsOpInterpCtxImpl<schema::UniqueWithCountsOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UnpackOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int32_t& unpack_num() const = 0;
  virtual int32_t* mutable_unpack_num() = 0;
  virtual void set_unpack_num(const int32_t& unpack_num) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"unpack_num"};
    return attr_names;
  }
};
template<typename Provider>
class UnpackOpInterpCtxImpl : public UnpackOpInterpCtx {
 public:
  UnpackOpInterpCtxImpl() = default;
  UnpackOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int32_t& unpack_num() const override { return impl_.unpack_num(); }
  int32_t* mutable_unpack_num() override { return impl_.mutable_unpack_num(); }
  void set_unpack_num(const int32_t& unpack_num) override { impl_.set_unpack_num(unpack_num); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UnpackOp {
 public:
  UnpackOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "unpack_num") {
      return CastAttr(&internal_->unpack_num);
    } else {
      return Error::RuntimeError() << "Unpack op has no attribute named " << attr_name;
    }
  }

  const int32_t& unpack_num() const { return internal_->unpack_num; }
  int32_t* mutable_unpack_num() { return &internal_->unpack_num; }
  void set_unpack_num(const int32_t& unpack_num) { internal_->unpack_num = unpack_num; }

 private:
  struct Internal {
    int32_t unpack_num;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.unpack", UnpackOpInterpCtxImpl<schema::UnpackOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UnsortedBatchSegmentSumOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& num_segments() const = 0;
  virtual int64_t* mutable_num_segments() = 0;
  virtual void set_num_segments(const int64_t& num_segments) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"num_segments"};
    return attr_names;
  }
};
template<typename Provider>
class UnsortedBatchSegmentSumOpInterpCtxImpl : public UnsortedBatchSegmentSumOpInterpCtx {
 public:
  UnsortedBatchSegmentSumOpInterpCtxImpl() = default;
  UnsortedBatchSegmentSumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& num_segments() const override { return impl_.num_segments(); }
  int64_t* mutable_num_segments() override { return impl_.mutable_num_segments(); }
  void set_num_segments(const int64_t& num_segments) override {
    impl_.set_num_segments(num_segments);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UnsortedBatchSegmentSumOp {
 public:
  UnsortedBatchSegmentSumOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "num_segments") {
      return CastAttr(&internal_->num_segments);
    } else {
      return Error::RuntimeError()
             << "UnsortedBatchSegmentSum op has no attribute named " << attr_name;
    }
  }

  const int64_t& num_segments() const { return internal_->num_segments; }
  int64_t* mutable_num_segments() { return &internal_->num_segments; }
  void set_num_segments(const int64_t& num_segments) { internal_->num_segments = num_segments; }

 private:
  struct Internal {
    int64_t num_segments;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.unsorted_batch_segment_sum",
                       UnsortedBatchSegmentSumOpInterpCtxImpl<schema::UnsortedBatchSegmentSumOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UnsortedSegmentSumOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& axis() const = 0;
  virtual int64_t* mutable_axis() = 0;
  virtual void set_axis(const int64_t& axis) = 0;

  virtual const int64_t& num_segments() const = 0;
  virtual int64_t* mutable_num_segments() = 0;
  virtual void set_num_segments(const int64_t& num_segments) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis", "num_segments"};
    return attr_names;
  }
};
template<typename Provider>
class UnsortedSegmentSumOpInterpCtxImpl : public UnsortedSegmentSumOpInterpCtx {
 public:
  UnsortedSegmentSumOpInterpCtxImpl() = default;
  UnsortedSegmentSumOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& axis() const override { return impl_.axis(); }
  int64_t* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const int64_t& axis) override { impl_.set_axis(axis); }

  const int64_t& num_segments() const override { return impl_.num_segments(); }
  int64_t* mutable_num_segments() override { return impl_.mutable_num_segments(); }
  void set_num_segments(const int64_t& num_segments) override {
    impl_.set_num_segments(num_segments);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UnsortedSegmentSumOp {
 public:
  UnsortedSegmentSumOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else if (attr_name == "num_segments") {
      return CastAttr(&internal_->num_segments);
    } else {
      return Error::RuntimeError() << "UnsortedSegmentSum op has no attribute named " << attr_name;
    }
  }

  const int64_t& axis() const { return internal_->axis; }
  int64_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int64_t& axis) { internal_->axis = axis; }

  const int64_t& num_segments() const { return internal_->num_segments; }
  int64_t* mutable_num_segments() { return &internal_->num_segments; }
  void set_num_segments(const int64_t& num_segments) { internal_->num_segments = num_segments; }

 private:
  struct Internal {
    int64_t axis;
    int64_t num_segments;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.unsorted_segment_sum",
                       UnsortedSegmentSumOpInterpCtxImpl<schema::UnsortedSegmentSumOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UnsortedSegmentSumLikeOpInterpCtx : public OpInterpCtx {
 public:
  virtual const int64_t& axis() const = 0;
  virtual int64_t* mutable_axis() = 0;
  virtual void set_axis(const int64_t& axis) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"axis"};
    return attr_names;
  }
};
template<typename Provider>
class UnsortedSegmentSumLikeOpInterpCtxImpl : public UnsortedSegmentSumLikeOpInterpCtx {
 public:
  UnsortedSegmentSumLikeOpInterpCtxImpl() = default;
  UnsortedSegmentSumLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const int64_t& axis() const override { return impl_.axis(); }
  int64_t* mutable_axis() override { return impl_.mutable_axis(); }
  void set_axis(const int64_t& axis) override { impl_.set_axis(axis); }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UnsortedSegmentSumLikeOp {
 public:
  UnsortedSegmentSumLikeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "axis") {
      return CastAttr(&internal_->axis);
    } else {
      return Error::RuntimeError()
             << "UnsortedSegmentSumLike op has no attribute named " << attr_name;
    }
  }

  const int64_t& axis() const { return internal_->axis; }
  int64_t* mutable_axis() { return &internal_->axis; }
  void set_axis(const int64_t& axis) { internal_->axis = axis; }

 private:
  struct Internal {
    int64_t axis;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.unsorted_segment_sum_like",
                       UnsortedSegmentSumLikeOpInterpCtxImpl<schema::UnsortedSegmentSumLikeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UpsampleOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::string& interpolation() const = 0;
  virtual std::string* mutable_interpolation() = 0;
  virtual void set_interpolation(const std::string& interpolation) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"height_scale", "width_scale", "align_corners",
                                           "data_format", "interpolation"};
    return attr_names;
  }
};
template<typename Provider>
class UpsampleOpInterpCtxImpl : public UpsampleOpInterpCtx {
 public:
  UpsampleOpInterpCtxImpl() = default;
  UpsampleOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& height_scale() const override { return impl_.height_scale(); }
  float* mutable_height_scale() override { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) override {
    impl_.set_height_scale(height_scale);
  }

  const float& width_scale() const override { return impl_.width_scale(); }
  float* mutable_width_scale() override { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) override { impl_.set_width_scale(width_scale); }

  const bool& align_corners() const override { return impl_.align_corners(); }
  bool* mutable_align_corners() override { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) override {
    impl_.set_align_corners(align_corners);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::string& interpolation() const override { return impl_.interpolation(); }
  std::string* mutable_interpolation() override { return impl_.mutable_interpolation(); }
  void set_interpolation(const std::string& interpolation) override {
    impl_.set_interpolation(interpolation);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleOp {
 public:
  UpsampleOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "height_scale") {
      return CastAttr(&internal_->height_scale);
    } else if (attr_name == "width_scale") {
      return CastAttr(&internal_->width_scale);
    } else if (attr_name == "align_corners") {
      return CastAttr(&internal_->align_corners);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "interpolation") {
      return CastAttr(&internal_->interpolation);
    } else {
      return Error::RuntimeError() << "Upsample op has no attribute named " << attr_name;
    }
  }

  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }

  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }

  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::string& interpolation() const { return internal_->interpolation; }
  std::string* mutable_interpolation() { return &internal_->interpolation; }
  void set_interpolation(const std::string& interpolation) {
    internal_->interpolation = interpolation;
  }

 private:
  struct Internal {
    float height_scale;
    float width_scale;
    bool align_corners;
    std::string data_format;
    std::string interpolation;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.upsample", UpsampleOpInterpCtxImpl<schema::UpsampleOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UpsampleBicubic2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"height_scale", "width_scale", "align_corners",
                                           "data_format"};
    return attr_names;
  }
};
template<typename Provider>
class UpsampleBicubic2DOpInterpCtxImpl : public UpsampleBicubic2DOpInterpCtx {
 public:
  UpsampleBicubic2DOpInterpCtxImpl() = default;
  UpsampleBicubic2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& height_scale() const override { return impl_.height_scale(); }
  float* mutable_height_scale() override { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) override {
    impl_.set_height_scale(height_scale);
  }

  const float& width_scale() const override { return impl_.width_scale(); }
  float* mutable_width_scale() override { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) override { impl_.set_width_scale(width_scale); }

  const bool& align_corners() const override { return impl_.align_corners(); }
  bool* mutable_align_corners() override { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) override {
    impl_.set_align_corners(align_corners);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleBicubic2DOp {
 public:
  UpsampleBicubic2DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "height_scale") {
      return CastAttr(&internal_->height_scale);
    } else if (attr_name == "width_scale") {
      return CastAttr(&internal_->width_scale);
    } else if (attr_name == "align_corners") {
      return CastAttr(&internal_->align_corners);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else {
      return Error::RuntimeError() << "UpsampleBicubic2D op has no attribute named " << attr_name;
    }
  }

  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }

  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }

  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

 private:
  struct Internal {
    float height_scale;
    float width_scale;
    bool align_corners;
    std::string data_format;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.upsample_bicubic_2d",
                       UpsampleBicubic2DOpInterpCtxImpl<schema::UpsampleBicubic2DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UpsampleBicubic2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"height_scale", "width_scale", "align_corners",
                                           "data_format"};
    return attr_names;
  }
};
template<typename Provider>
class UpsampleBicubic2DGradOpInterpCtxImpl : public UpsampleBicubic2DGradOpInterpCtx {
 public:
  UpsampleBicubic2DGradOpInterpCtxImpl() = default;
  UpsampleBicubic2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& height_scale() const override { return impl_.height_scale(); }
  float* mutable_height_scale() override { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) override {
    impl_.set_height_scale(height_scale);
  }

  const float& width_scale() const override { return impl_.width_scale(); }
  float* mutable_width_scale() override { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) override { impl_.set_width_scale(width_scale); }

  const bool& align_corners() const override { return impl_.align_corners(); }
  bool* mutable_align_corners() override { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) override {
    impl_.set_align_corners(align_corners);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleBicubic2DGradOp {
 public:
  UpsampleBicubic2DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "height_scale") {
      return CastAttr(&internal_->height_scale);
    } else if (attr_name == "width_scale") {
      return CastAttr(&internal_->width_scale);
    } else if (attr_name == "align_corners") {
      return CastAttr(&internal_->align_corners);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else {
      return Error::RuntimeError()
             << "UpsampleBicubic2DGrad op has no attribute named " << attr_name;
    }
  }

  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }

  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }

  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

 private:
  struct Internal {
    float height_scale;
    float width_scale;
    bool align_corners;
    std::string data_format;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.upsample_bicubic_2d_grad",
                       UpsampleBicubic2DGradOpInterpCtxImpl<schema::UpsampleBicubic2DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UpsampleBilinear2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"height_scale", "width_scale", "align_corners",
                                           "data_format"};
    return attr_names;
  }
};
template<typename Provider>
class UpsampleBilinear2DOpInterpCtxImpl : public UpsampleBilinear2DOpInterpCtx {
 public:
  UpsampleBilinear2DOpInterpCtxImpl() = default;
  UpsampleBilinear2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& height_scale() const override { return impl_.height_scale(); }
  float* mutable_height_scale() override { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) override {
    impl_.set_height_scale(height_scale);
  }

  const float& width_scale() const override { return impl_.width_scale(); }
  float* mutable_width_scale() override { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) override { impl_.set_width_scale(width_scale); }

  const bool& align_corners() const override { return impl_.align_corners(); }
  bool* mutable_align_corners() override { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) override {
    impl_.set_align_corners(align_corners);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleBilinear2DOp {
 public:
  UpsampleBilinear2DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "height_scale") {
      return CastAttr(&internal_->height_scale);
    } else if (attr_name == "width_scale") {
      return CastAttr(&internal_->width_scale);
    } else if (attr_name == "align_corners") {
      return CastAttr(&internal_->align_corners);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else {
      return Error::RuntimeError() << "UpsampleBilinear2D op has no attribute named " << attr_name;
    }
  }

  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }

  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }

  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

 private:
  struct Internal {
    float height_scale;
    float width_scale;
    bool align_corners;
    std::string data_format;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.upsample_bilinear_2d",
                       UpsampleBilinear2DOpInterpCtxImpl<schema::UpsampleBilinear2DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UpsampleBilinear2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"height_scale", "width_scale", "align_corners",
                                           "data_format"};
    return attr_names;
  }
};
template<typename Provider>
class UpsampleBilinear2DGradOpInterpCtxImpl : public UpsampleBilinear2DGradOpInterpCtx {
 public:
  UpsampleBilinear2DGradOpInterpCtxImpl() = default;
  UpsampleBilinear2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& height_scale() const override { return impl_.height_scale(); }
  float* mutable_height_scale() override { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) override {
    impl_.set_height_scale(height_scale);
  }

  const float& width_scale() const override { return impl_.width_scale(); }
  float* mutable_width_scale() override { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) override { impl_.set_width_scale(width_scale); }

  const bool& align_corners() const override { return impl_.align_corners(); }
  bool* mutable_align_corners() override { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) override {
    impl_.set_align_corners(align_corners);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleBilinear2DGradOp {
 public:
  UpsampleBilinear2DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "height_scale") {
      return CastAttr(&internal_->height_scale);
    } else if (attr_name == "width_scale") {
      return CastAttr(&internal_->width_scale);
    } else if (attr_name == "align_corners") {
      return CastAttr(&internal_->align_corners);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else {
      return Error::RuntimeError()
             << "UpsampleBilinear2DGrad op has no attribute named " << attr_name;
    }
  }

  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }

  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }

  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

 private:
  struct Internal {
    float height_scale;
    float width_scale;
    bool align_corners;
    std::string data_format;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.upsample_bilinear_2d_grad",
                       UpsampleBilinear2DGradOpInterpCtxImpl<schema::UpsampleBilinear2DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UpsampleGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  virtual const std::string& interpolation() const = 0;
  virtual std::string* mutable_interpolation() = 0;
  virtual void set_interpolation(const std::string& interpolation) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"height_scale", "width_scale", "align_corners",
                                           "data_format", "interpolation"};
    return attr_names;
  }
};
template<typename Provider>
class UpsampleGradOpInterpCtxImpl : public UpsampleGradOpInterpCtx {
 public:
  UpsampleGradOpInterpCtxImpl() = default;
  UpsampleGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& height_scale() const override { return impl_.height_scale(); }
  float* mutable_height_scale() override { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) override {
    impl_.set_height_scale(height_scale);
  }

  const float& width_scale() const override { return impl_.width_scale(); }
  float* mutable_width_scale() override { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) override { impl_.set_width_scale(width_scale); }

  const bool& align_corners() const override { return impl_.align_corners(); }
  bool* mutable_align_corners() override { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) override {
    impl_.set_align_corners(align_corners);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  const std::string& interpolation() const override { return impl_.interpolation(); }
  std::string* mutable_interpolation() override { return impl_.mutable_interpolation(); }
  void set_interpolation(const std::string& interpolation) override {
    impl_.set_interpolation(interpolation);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleGradOp {
 public:
  UpsampleGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "height_scale") {
      return CastAttr(&internal_->height_scale);
    } else if (attr_name == "width_scale") {
      return CastAttr(&internal_->width_scale);
    } else if (attr_name == "align_corners") {
      return CastAttr(&internal_->align_corners);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else if (attr_name == "interpolation") {
      return CastAttr(&internal_->interpolation);
    } else {
      return Error::RuntimeError() << "UpsampleGrad op has no attribute named " << attr_name;
    }
  }

  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }

  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }

  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

  const std::string& interpolation() const { return internal_->interpolation; }
  std::string* mutable_interpolation() { return &internal_->interpolation; }
  void set_interpolation(const std::string& interpolation) {
    internal_->interpolation = interpolation;
  }

 private:
  struct Internal {
    float height_scale;
    float width_scale;
    bool align_corners;
    std::string data_format;
    std::string interpolation;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.upsample_grad", UpsampleGradOpInterpCtxImpl<schema::UpsampleGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UpsampleLinear1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& scale_factor() const = 0;
  virtual float* mutable_scale_factor() = 0;
  virtual void set_scale_factor(const float& scale_factor) = 0;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"scale_factor", "align_corners", "data_format"};
    return attr_names;
  }
};
template<typename Provider>
class UpsampleLinear1DOpInterpCtxImpl : public UpsampleLinear1DOpInterpCtx {
 public:
  UpsampleLinear1DOpInterpCtxImpl() = default;
  UpsampleLinear1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& scale_factor() const override { return impl_.scale_factor(); }
  float* mutable_scale_factor() override { return impl_.mutable_scale_factor(); }
  void set_scale_factor(const float& scale_factor) override {
    impl_.set_scale_factor(scale_factor);
  }

  const bool& align_corners() const override { return impl_.align_corners(); }
  bool* mutable_align_corners() override { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) override {
    impl_.set_align_corners(align_corners);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleLinear1DOp {
 public:
  UpsampleLinear1DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "scale_factor") {
      return CastAttr(&internal_->scale_factor);
    } else if (attr_name == "align_corners") {
      return CastAttr(&internal_->align_corners);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else {
      return Error::RuntimeError() << "UpsampleLinear1D op has no attribute named " << attr_name;
    }
  }

  const float& scale_factor() const { return internal_->scale_factor; }
  float* mutable_scale_factor() { return &internal_->scale_factor; }
  void set_scale_factor(const float& scale_factor) { internal_->scale_factor = scale_factor; }

  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

 private:
  struct Internal {
    float scale_factor;
    bool align_corners;
    std::string data_format;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.upsample_linear_1d",
                       UpsampleLinear1DOpInterpCtxImpl<schema::UpsampleLinear1DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UpsampleLinear1DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& scale_factor() const = 0;
  virtual float* mutable_scale_factor() = 0;
  virtual void set_scale_factor(const float& scale_factor) = 0;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"scale_factor", "align_corners", "data_format"};
    return attr_names;
  }
};
template<typename Provider>
class UpsampleLinear1DGradOpInterpCtxImpl : public UpsampleLinear1DGradOpInterpCtx {
 public:
  UpsampleLinear1DGradOpInterpCtxImpl() = default;
  UpsampleLinear1DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& scale_factor() const override { return impl_.scale_factor(); }
  float* mutable_scale_factor() override { return impl_.mutable_scale_factor(); }
  void set_scale_factor(const float& scale_factor) override {
    impl_.set_scale_factor(scale_factor);
  }

  const bool& align_corners() const override { return impl_.align_corners(); }
  bool* mutable_align_corners() override { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) override {
    impl_.set_align_corners(align_corners);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleLinear1DGradOp {
 public:
  UpsampleLinear1DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "scale_factor") {
      return CastAttr(&internal_->scale_factor);
    } else if (attr_name == "align_corners") {
      return CastAttr(&internal_->align_corners);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else {
      return Error::RuntimeError()
             << "UpsampleLinear1DGrad op has no attribute named " << attr_name;
    }
  }

  const float& scale_factor() const { return internal_->scale_factor; }
  float* mutable_scale_factor() { return &internal_->scale_factor; }
  void set_scale_factor(const float& scale_factor) { internal_->scale_factor = scale_factor; }

  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

 private:
  struct Internal {
    float scale_factor;
    bool align_corners;
    std::string data_format;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.upsample_linear_1d_grad",
                       UpsampleLinear1DGradOpInterpCtxImpl<schema::UpsampleLinear1DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UpsampleNearest1DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& scale_factor() const = 0;
  virtual float* mutable_scale_factor() = 0;
  virtual void set_scale_factor(const float& scale_factor) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"scale_factor", "data_format"};
    return attr_names;
  }
};
template<typename Provider>
class UpsampleNearest1DOpInterpCtxImpl : public UpsampleNearest1DOpInterpCtx {
 public:
  UpsampleNearest1DOpInterpCtxImpl() = default;
  UpsampleNearest1DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& scale_factor() const override { return impl_.scale_factor(); }
  float* mutable_scale_factor() override { return impl_.mutable_scale_factor(); }
  void set_scale_factor(const float& scale_factor) override {
    impl_.set_scale_factor(scale_factor);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleNearest1DOp {
 public:
  UpsampleNearest1DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "scale_factor") {
      return CastAttr(&internal_->scale_factor);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else {
      return Error::RuntimeError() << "UpsampleNearest1D op has no attribute named " << attr_name;
    }
  }

  const float& scale_factor() const { return internal_->scale_factor; }
  float* mutable_scale_factor() { return &internal_->scale_factor; }
  void set_scale_factor(const float& scale_factor) { internal_->scale_factor = scale_factor; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

 private:
  struct Internal {
    float scale_factor;
    std::string data_format;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.upsample_nearest_1d",
                       UpsampleNearest1DOpInterpCtxImpl<schema::UpsampleNearest1DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UpsampleNearest1DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& scale_factor() const = 0;
  virtual float* mutable_scale_factor() = 0;
  virtual void set_scale_factor(const float& scale_factor) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"scale_factor", "data_format"};
    return attr_names;
  }
};
template<typename Provider>
class UpsampleNearest1DGradOpInterpCtxImpl : public UpsampleNearest1DGradOpInterpCtx {
 public:
  UpsampleNearest1DGradOpInterpCtxImpl() = default;
  UpsampleNearest1DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& scale_factor() const override { return impl_.scale_factor(); }
  float* mutable_scale_factor() override { return impl_.mutable_scale_factor(); }
  void set_scale_factor(const float& scale_factor) override {
    impl_.set_scale_factor(scale_factor);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleNearest1DGradOp {
 public:
  UpsampleNearest1DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "scale_factor") {
      return CastAttr(&internal_->scale_factor);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else {
      return Error::RuntimeError()
             << "UpsampleNearest1DGrad op has no attribute named " << attr_name;
    }
  }

  const float& scale_factor() const { return internal_->scale_factor; }
  float* mutable_scale_factor() { return &internal_->scale_factor; }
  void set_scale_factor(const float& scale_factor) { internal_->scale_factor = scale_factor; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

 private:
  struct Internal {
    float scale_factor;
    std::string data_format;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.upsample_nearest_1d_grad",
                       UpsampleNearest1DGradOpInterpCtxImpl<schema::UpsampleNearest1DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UpsampleNearest2DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"height_scale", "width_scale", "data_format"};
    return attr_names;
  }
};
template<typename Provider>
class UpsampleNearest2DOpInterpCtxImpl : public UpsampleNearest2DOpInterpCtx {
 public:
  UpsampleNearest2DOpInterpCtxImpl() = default;
  UpsampleNearest2DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& height_scale() const override { return impl_.height_scale(); }
  float* mutable_height_scale() override { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) override {
    impl_.set_height_scale(height_scale);
  }

  const float& width_scale() const override { return impl_.width_scale(); }
  float* mutable_width_scale() override { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) override { impl_.set_width_scale(width_scale); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleNearest2DOp {
 public:
  UpsampleNearest2DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "height_scale") {
      return CastAttr(&internal_->height_scale);
    } else if (attr_name == "width_scale") {
      return CastAttr(&internal_->width_scale);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else {
      return Error::RuntimeError() << "UpsampleNearest2D op has no attribute named " << attr_name;
    }
  }

  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }

  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

 private:
  struct Internal {
    float height_scale;
    float width_scale;
    std::string data_format;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.upsample_nearest_2d",
                       UpsampleNearest2DOpInterpCtxImpl<schema::UpsampleNearest2DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UpsampleNearest2DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"height_scale", "width_scale", "data_format"};
    return attr_names;
  }
};
template<typename Provider>
class UpsampleNearest2DGradOpInterpCtxImpl : public UpsampleNearest2DGradOpInterpCtx {
 public:
  UpsampleNearest2DGradOpInterpCtxImpl() = default;
  UpsampleNearest2DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& height_scale() const override { return impl_.height_scale(); }
  float* mutable_height_scale() override { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) override {
    impl_.set_height_scale(height_scale);
  }

  const float& width_scale() const override { return impl_.width_scale(); }
  float* mutable_width_scale() override { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) override { impl_.set_width_scale(width_scale); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleNearest2DGradOp {
 public:
  UpsampleNearest2DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "height_scale") {
      return CastAttr(&internal_->height_scale);
    } else if (attr_name == "width_scale") {
      return CastAttr(&internal_->width_scale);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else {
      return Error::RuntimeError()
             << "UpsampleNearest2DGrad op has no attribute named " << attr_name;
    }
  }

  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }

  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

 private:
  struct Internal {
    float height_scale;
    float width_scale;
    std::string data_format;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.upsample_nearest_2d_grad",
                       UpsampleNearest2DGradOpInterpCtxImpl<schema::UpsampleNearest2DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UpsampleNearest3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& depth_scale() const = 0;
  virtual float* mutable_depth_scale() = 0;
  virtual void set_depth_scale(const float& depth_scale) = 0;

  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"depth_scale", "height_scale", "width_scale",
                                           "data_format"};
    return attr_names;
  }
};
template<typename Provider>
class UpsampleNearest3DOpInterpCtxImpl : public UpsampleNearest3DOpInterpCtx {
 public:
  UpsampleNearest3DOpInterpCtxImpl() = default;
  UpsampleNearest3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& depth_scale() const override { return impl_.depth_scale(); }
  float* mutable_depth_scale() override { return impl_.mutable_depth_scale(); }
  void set_depth_scale(const float& depth_scale) override { impl_.set_depth_scale(depth_scale); }

  const float& height_scale() const override { return impl_.height_scale(); }
  float* mutable_height_scale() override { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) override {
    impl_.set_height_scale(height_scale);
  }

  const float& width_scale() const override { return impl_.width_scale(); }
  float* mutable_width_scale() override { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) override { impl_.set_width_scale(width_scale); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleNearest3DOp {
 public:
  UpsampleNearest3DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "depth_scale") {
      return CastAttr(&internal_->depth_scale);
    } else if (attr_name == "height_scale") {
      return CastAttr(&internal_->height_scale);
    } else if (attr_name == "width_scale") {
      return CastAttr(&internal_->width_scale);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else {
      return Error::RuntimeError() << "UpsampleNearest3D op has no attribute named " << attr_name;
    }
  }

  const float& depth_scale() const { return internal_->depth_scale; }
  float* mutable_depth_scale() { return &internal_->depth_scale; }
  void set_depth_scale(const float& depth_scale) { internal_->depth_scale = depth_scale; }

  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }

  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

 private:
  struct Internal {
    float depth_scale;
    float height_scale;
    float width_scale;
    std::string data_format;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.upsample_nearest_3d",
                       UpsampleNearest3DOpInterpCtxImpl<schema::UpsampleNearest3DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UpsampleNearest3DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& depth_scale() const = 0;
  virtual float* mutable_depth_scale() = 0;
  virtual void set_depth_scale(const float& depth_scale) = 0;

  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"depth_scale", "height_scale", "width_scale",
                                           "data_format"};
    return attr_names;
  }
};
template<typename Provider>
class UpsampleNearest3DGradOpInterpCtxImpl : public UpsampleNearest3DGradOpInterpCtx {
 public:
  UpsampleNearest3DGradOpInterpCtxImpl() = default;
  UpsampleNearest3DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& depth_scale() const override { return impl_.depth_scale(); }
  float* mutable_depth_scale() override { return impl_.mutable_depth_scale(); }
  void set_depth_scale(const float& depth_scale) override { impl_.set_depth_scale(depth_scale); }

  const float& height_scale() const override { return impl_.height_scale(); }
  float* mutable_height_scale() override { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) override {
    impl_.set_height_scale(height_scale);
  }

  const float& width_scale() const override { return impl_.width_scale(); }
  float* mutable_width_scale() override { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) override { impl_.set_width_scale(width_scale); }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleNearest3DGradOp {
 public:
  UpsampleNearest3DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "depth_scale") {
      return CastAttr(&internal_->depth_scale);
    } else if (attr_name == "height_scale") {
      return CastAttr(&internal_->height_scale);
    } else if (attr_name == "width_scale") {
      return CastAttr(&internal_->width_scale);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else {
      return Error::RuntimeError()
             << "UpsampleNearest3DGrad op has no attribute named " << attr_name;
    }
  }

  const float& depth_scale() const { return internal_->depth_scale; }
  float* mutable_depth_scale() { return &internal_->depth_scale; }
  void set_depth_scale(const float& depth_scale) { internal_->depth_scale = depth_scale; }

  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }

  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

 private:
  struct Internal {
    float depth_scale;
    float height_scale;
    float width_scale;
    std::string data_format;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.upsample_nearest_3d_grad",
                       UpsampleNearest3DGradOpInterpCtxImpl<schema::UpsampleNearest3DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UpsampleTrilinear3DOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& depth_scale() const = 0;
  virtual float* mutable_depth_scale() = 0;
  virtual void set_depth_scale(const float& depth_scale) = 0;

  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"depth_scale", "height_scale", "width_scale",
                                           "align_corners", "data_format"};
    return attr_names;
  }
};
template<typename Provider>
class UpsampleTrilinear3DOpInterpCtxImpl : public UpsampleTrilinear3DOpInterpCtx {
 public:
  UpsampleTrilinear3DOpInterpCtxImpl() = default;
  UpsampleTrilinear3DOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& depth_scale() const override { return impl_.depth_scale(); }
  float* mutable_depth_scale() override { return impl_.mutable_depth_scale(); }
  void set_depth_scale(const float& depth_scale) override { impl_.set_depth_scale(depth_scale); }

  const float& height_scale() const override { return impl_.height_scale(); }
  float* mutable_height_scale() override { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) override {
    impl_.set_height_scale(height_scale);
  }

  const float& width_scale() const override { return impl_.width_scale(); }
  float* mutable_width_scale() override { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) override { impl_.set_width_scale(width_scale); }

  const bool& align_corners() const override { return impl_.align_corners(); }
  bool* mutable_align_corners() override { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) override {
    impl_.set_align_corners(align_corners);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleTrilinear3DOp {
 public:
  UpsampleTrilinear3DOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "depth_scale") {
      return CastAttr(&internal_->depth_scale);
    } else if (attr_name == "height_scale") {
      return CastAttr(&internal_->height_scale);
    } else if (attr_name == "width_scale") {
      return CastAttr(&internal_->width_scale);
    } else if (attr_name == "align_corners") {
      return CastAttr(&internal_->align_corners);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else {
      return Error::RuntimeError() << "UpsampleTrilinear3D op has no attribute named " << attr_name;
    }
  }

  const float& depth_scale() const { return internal_->depth_scale; }
  float* mutable_depth_scale() { return &internal_->depth_scale; }
  void set_depth_scale(const float& depth_scale) { internal_->depth_scale = depth_scale; }

  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }

  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }

  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

 private:
  struct Internal {
    float depth_scale;
    float height_scale;
    float width_scale;
    bool align_corners;
    std::string data_format;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.upsample_trilinear_3d",
                       UpsampleTrilinear3DOpInterpCtxImpl<schema::UpsampleTrilinear3DOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class UpsampleTrilinear3DGradOpInterpCtx : public OpInterpCtx {
 public:
  virtual const float& depth_scale() const = 0;
  virtual float* mutable_depth_scale() = 0;
  virtual void set_depth_scale(const float& depth_scale) = 0;

  virtual const float& height_scale() const = 0;
  virtual float* mutable_height_scale() = 0;
  virtual void set_height_scale(const float& height_scale) = 0;

  virtual const float& width_scale() const = 0;
  virtual float* mutable_width_scale() = 0;
  virtual void set_width_scale(const float& width_scale) = 0;

  virtual const bool& align_corners() const = 0;
  virtual bool* mutable_align_corners() = 0;
  virtual void set_align_corners(const bool& align_corners) = 0;

  virtual const std::string& data_format() const = 0;
  virtual std::string* mutable_data_format() = 0;
  virtual void set_data_format(const std::string& data_format) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"depth_scale", "height_scale", "width_scale",
                                           "align_corners", "data_format"};
    return attr_names;
  }
};
template<typename Provider>
class UpsampleTrilinear3DGradOpInterpCtxImpl : public UpsampleTrilinear3DGradOpInterpCtx {
 public:
  UpsampleTrilinear3DGradOpInterpCtxImpl() = default;
  UpsampleTrilinear3DGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const float& depth_scale() const override { return impl_.depth_scale(); }
  float* mutable_depth_scale() override { return impl_.mutable_depth_scale(); }
  void set_depth_scale(const float& depth_scale) override { impl_.set_depth_scale(depth_scale); }

  const float& height_scale() const override { return impl_.height_scale(); }
  float* mutable_height_scale() override { return impl_.mutable_height_scale(); }
  void set_height_scale(const float& height_scale) override {
    impl_.set_height_scale(height_scale);
  }

  const float& width_scale() const override { return impl_.width_scale(); }
  float* mutable_width_scale() override { return impl_.mutable_width_scale(); }
  void set_width_scale(const float& width_scale) override { impl_.set_width_scale(width_scale); }

  const bool& align_corners() const override { return impl_.align_corners(); }
  bool* mutable_align_corners() override { return impl_.mutable_align_corners(); }
  void set_align_corners(const bool& align_corners) override {
    impl_.set_align_corners(align_corners);
  }

  const std::string& data_format() const override { return impl_.data_format(); }
  std::string* mutable_data_format() override { return impl_.mutable_data_format(); }
  void set_data_format(const std::string& data_format) override {
    impl_.set_data_format(data_format);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class UpsampleTrilinear3DGradOp {
 public:
  UpsampleTrilinear3DGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "depth_scale") {
      return CastAttr(&internal_->depth_scale);
    } else if (attr_name == "height_scale") {
      return CastAttr(&internal_->height_scale);
    } else if (attr_name == "width_scale") {
      return CastAttr(&internal_->width_scale);
    } else if (attr_name == "align_corners") {
      return CastAttr(&internal_->align_corners);
    } else if (attr_name == "data_format") {
      return CastAttr(&internal_->data_format);
    } else {
      return Error::RuntimeError()
             << "UpsampleTrilinear3DGrad op has no attribute named " << attr_name;
    }
  }

  const float& depth_scale() const { return internal_->depth_scale; }
  float* mutable_depth_scale() { return &internal_->depth_scale; }
  void set_depth_scale(const float& depth_scale) { internal_->depth_scale = depth_scale; }

  const float& height_scale() const { return internal_->height_scale; }
  float* mutable_height_scale() { return &internal_->height_scale; }
  void set_height_scale(const float& height_scale) { internal_->height_scale = height_scale; }

  const float& width_scale() const { return internal_->width_scale; }
  float* mutable_width_scale() { return &internal_->width_scale; }
  void set_width_scale(const float& width_scale) { internal_->width_scale = width_scale; }

  const bool& align_corners() const { return internal_->align_corners; }
  bool* mutable_align_corners() { return &internal_->align_corners; }
  void set_align_corners(const bool& align_corners) { internal_->align_corners = align_corners; }

  const std::string& data_format() const { return internal_->data_format; }
  std::string* mutable_data_format() { return &internal_->data_format; }
  void set_data_format(const std::string& data_format) { internal_->data_format = data_format; }

 private:
  struct Internal {
    float depth_scale;
    float height_scale;
    float width_scale;
    bool align_corners;
    std::string data_format;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.upsample_trilinear_3d_grad",
                       UpsampleTrilinear3DGradOpInterpCtxImpl<schema::UpsampleTrilinear3DGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class WhereOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class WhereOpInterpCtxImpl : public WhereOpInterpCtx {
 public:
  WhereOpInterpCtxImpl() = default;
  WhereOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class WhereOp {
 public:
  WhereOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Where op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.where", WhereOpInterpCtxImpl<schema::WhereOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class WhereScalarXOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class WhereScalarXOpInterpCtxImpl : public WhereScalarXOpInterpCtx {
 public:
  WhereScalarXOpInterpCtxImpl() = default;
  WhereScalarXOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class WhereScalarXOp {
 public:
  WhereScalarXOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError() << "WhereScalarX op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.where_scalar_x", WhereScalarXOpInterpCtxImpl<schema::WhereScalarXOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class WhereScalarXyOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_x_int_operand() const = 0;
  virtual bool* mutable_has_x_int_operand() = 0;
  virtual void set_has_x_int_operand(const bool& has_x_int_operand) = 0;

  virtual const bool& has_x_float_operand() const = 0;
  virtual bool* mutable_has_x_float_operand() = 0;
  virtual void set_has_x_float_operand(const bool& has_x_float_operand) = 0;

  virtual const bool& has_y_int_operand() const = 0;
  virtual bool* mutable_has_y_int_operand() = 0;
  virtual void set_has_y_int_operand(const bool& has_y_int_operand) = 0;

  virtual const bool& has_y_float_operand() const = 0;
  virtual bool* mutable_has_y_float_operand() = 0;
  virtual void set_has_y_float_operand(const bool& has_y_float_operand) = 0;

  virtual const int64_t& x_int_operand() const = 0;
  virtual int64_t* mutable_x_int_operand() = 0;
  virtual void set_x_int_operand(const int64_t& x_int_operand) = 0;

  virtual const double& x_float_operand() const = 0;
  virtual double* mutable_x_float_operand() = 0;
  virtual void set_x_float_operand(const double& x_float_operand) = 0;

  virtual const int64_t& y_int_operand() const = 0;
  virtual int64_t* mutable_y_int_operand() = 0;
  virtual void set_y_int_operand(const int64_t& y_int_operand) = 0;

  virtual const double& y_float_operand() const = 0;
  virtual double* mutable_y_float_operand() = 0;
  virtual void set_y_float_operand(const double& y_float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{
        "has_x_int_operand", "has_x_float_operand", "has_y_int_operand", "has_y_float_operand",
        "x_int_operand",     "x_float_operand",     "y_int_operand",     "y_float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class WhereScalarXyOpInterpCtxImpl : public WhereScalarXyOpInterpCtx {
 public:
  WhereScalarXyOpInterpCtxImpl() = default;
  WhereScalarXyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_x_int_operand() const override { return impl_.has_x_int_operand(); }
  bool* mutable_has_x_int_operand() override { return impl_.mutable_has_x_int_operand(); }
  void set_has_x_int_operand(const bool& has_x_int_operand) override {
    impl_.set_has_x_int_operand(has_x_int_operand);
  }

  const bool& has_x_float_operand() const override { return impl_.has_x_float_operand(); }
  bool* mutable_has_x_float_operand() override { return impl_.mutable_has_x_float_operand(); }
  void set_has_x_float_operand(const bool& has_x_float_operand) override {
    impl_.set_has_x_float_operand(has_x_float_operand);
  }

  const bool& has_y_int_operand() const override { return impl_.has_y_int_operand(); }
  bool* mutable_has_y_int_operand() override { return impl_.mutable_has_y_int_operand(); }
  void set_has_y_int_operand(const bool& has_y_int_operand) override {
    impl_.set_has_y_int_operand(has_y_int_operand);
  }

  const bool& has_y_float_operand() const override { return impl_.has_y_float_operand(); }
  bool* mutable_has_y_float_operand() override { return impl_.mutable_has_y_float_operand(); }
  void set_has_y_float_operand(const bool& has_y_float_operand) override {
    impl_.set_has_y_float_operand(has_y_float_operand);
  }

  const int64_t& x_int_operand() const override { return impl_.x_int_operand(); }
  int64_t* mutable_x_int_operand() override { return impl_.mutable_x_int_operand(); }
  void set_x_int_operand(const int64_t& x_int_operand) override {
    impl_.set_x_int_operand(x_int_operand);
  }

  const double& x_float_operand() const override { return impl_.x_float_operand(); }
  double* mutable_x_float_operand() override { return impl_.mutable_x_float_operand(); }
  void set_x_float_operand(const double& x_float_operand) override {
    impl_.set_x_float_operand(x_float_operand);
  }

  const int64_t& y_int_operand() const override { return impl_.y_int_operand(); }
  int64_t* mutable_y_int_operand() override { return impl_.mutable_y_int_operand(); }
  void set_y_int_operand(const int64_t& y_int_operand) override {
    impl_.set_y_int_operand(y_int_operand);
  }

  const double& y_float_operand() const override { return impl_.y_float_operand(); }
  double* mutable_y_float_operand() override { return impl_.mutable_y_float_operand(); }
  void set_y_float_operand(const double& y_float_operand) override {
    impl_.set_y_float_operand(y_float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class WhereScalarXyOp {
 public:
  WhereScalarXyOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_x_int_operand") {
      return CastAttr(&internal_->has_x_int_operand);
    } else if (attr_name == "has_x_float_operand") {
      return CastAttr(&internal_->has_x_float_operand);
    } else if (attr_name == "has_y_int_operand") {
      return CastAttr(&internal_->has_y_int_operand);
    } else if (attr_name == "has_y_float_operand") {
      return CastAttr(&internal_->has_y_float_operand);
    } else if (attr_name == "x_int_operand") {
      return CastAttr(&internal_->x_int_operand);
    } else if (attr_name == "x_float_operand") {
      return CastAttr(&internal_->x_float_operand);
    } else if (attr_name == "y_int_operand") {
      return CastAttr(&internal_->y_int_operand);
    } else if (attr_name == "y_float_operand") {
      return CastAttr(&internal_->y_float_operand);
    } else {
      return Error::RuntimeError() << "WhereScalarXy op has no attribute named " << attr_name;
    }
  }

  const bool& has_x_int_operand() const { return internal_->has_x_int_operand; }
  bool* mutable_has_x_int_operand() { return &internal_->has_x_int_operand; }
  void set_has_x_int_operand(const bool& has_x_int_operand) {
    internal_->has_x_int_operand = has_x_int_operand;
  }

  const bool& has_x_float_operand() const { return internal_->has_x_float_operand; }
  bool* mutable_has_x_float_operand() { return &internal_->has_x_float_operand; }
  void set_has_x_float_operand(const bool& has_x_float_operand) {
    internal_->has_x_float_operand = has_x_float_operand;
  }

  const bool& has_y_int_operand() const { return internal_->has_y_int_operand; }
  bool* mutable_has_y_int_operand() { return &internal_->has_y_int_operand; }
  void set_has_y_int_operand(const bool& has_y_int_operand) {
    internal_->has_y_int_operand = has_y_int_operand;
  }

  const bool& has_y_float_operand() const { return internal_->has_y_float_operand; }
  bool* mutable_has_y_float_operand() { return &internal_->has_y_float_operand; }
  void set_has_y_float_operand(const bool& has_y_float_operand) {
    internal_->has_y_float_operand = has_y_float_operand;
  }

  const int64_t& x_int_operand() const { return internal_->x_int_operand; }
  int64_t* mutable_x_int_operand() { return &internal_->x_int_operand; }
  void set_x_int_operand(const int64_t& x_int_operand) { internal_->x_int_operand = x_int_operand; }

  const double& x_float_operand() const { return internal_->x_float_operand; }
  double* mutable_x_float_operand() { return &internal_->x_float_operand; }
  void set_x_float_operand(const double& x_float_operand) {
    internal_->x_float_operand = x_float_operand;
  }

  const int64_t& y_int_operand() const { return internal_->y_int_operand; }
  int64_t* mutable_y_int_operand() { return &internal_->y_int_operand; }
  void set_y_int_operand(const int64_t& y_int_operand) { internal_->y_int_operand = y_int_operand; }

  const double& y_float_operand() const { return internal_->y_float_operand; }
  double* mutable_y_float_operand() { return &internal_->y_float_operand; }
  void set_y_float_operand(const double& y_float_operand) {
    internal_->y_float_operand = y_float_operand;
  }

 private:
  struct Internal {
    bool has_x_int_operand;
    bool has_x_float_operand;
    bool has_y_int_operand;
    bool has_y_float_operand;
    int64_t x_int_operand;
    double x_float_operand;
    int64_t y_int_operand;
    double y_float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.where_scalar_xy",
                       WhereScalarXyOpInterpCtxImpl<schema::WhereScalarXyOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class WhereScalarYOpInterpCtx : public OpInterpCtx {
 public:
  virtual const bool& has_int_operand() const = 0;
  virtual bool* mutable_has_int_operand() = 0;
  virtual void set_has_int_operand(const bool& has_int_operand) = 0;

  virtual const bool& has_float_operand() const = 0;
  virtual bool* mutable_has_float_operand() = 0;
  virtual void set_has_float_operand(const bool& has_float_operand) = 0;

  virtual const int64_t& int_operand() const = 0;
  virtual int64_t* mutable_int_operand() = 0;
  virtual void set_int_operand(const int64_t& int_operand) = 0;

  virtual const double& float_operand() const = 0;
  virtual double* mutable_float_operand() = 0;
  virtual void set_float_operand(const double& float_operand) = 0;

  const HashSet<std::string>& AttrNames() const override {
    static HashSet<std::string> attr_names{"has_int_operand", "has_float_operand", "int_operand",
                                           "float_operand"};
    return attr_names;
  }
};
template<typename Provider>
class WhereScalarYOpInterpCtxImpl : public WhereScalarYOpInterpCtx {
 public:
  WhereScalarYOpInterpCtxImpl() = default;
  WhereScalarYOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  const bool& has_int_operand() const override { return impl_.has_int_operand(); }
  bool* mutable_has_int_operand() override { return impl_.mutable_has_int_operand(); }
  void set_has_int_operand(const bool& has_int_operand) override {
    impl_.set_has_int_operand(has_int_operand);
  }

  const bool& has_float_operand() const override { return impl_.has_float_operand(); }
  bool* mutable_has_float_operand() override { return impl_.mutable_has_float_operand(); }
  void set_has_float_operand(const bool& has_float_operand) override {
    impl_.set_has_float_operand(has_float_operand);
  }

  const int64_t& int_operand() const override { return impl_.int_operand(); }
  int64_t* mutable_int_operand() override { return impl_.mutable_int_operand(); }
  void set_int_operand(const int64_t& int_operand) override { impl_.set_int_operand(int_operand); }

  const double& float_operand() const override { return impl_.float_operand(); }
  double* mutable_float_operand() override { return impl_.mutable_float_operand(); }
  void set_float_operand(const double& float_operand) override {
    impl_.set_float_operand(float_operand);
  }

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class WhereScalarYOp {
 public:
  WhereScalarYOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    if (attr_name == "has_int_operand") {
      return CastAttr(&internal_->has_int_operand);
    } else if (attr_name == "has_float_operand") {
      return CastAttr(&internal_->has_float_operand);
    } else if (attr_name == "int_operand") {
      return CastAttr(&internal_->int_operand);
    } else if (attr_name == "float_operand") {
      return CastAttr(&internal_->float_operand);
    } else {
      return Error::RuntimeError() << "WhereScalarY op has no attribute named " << attr_name;
    }
  }

  const bool& has_int_operand() const { return internal_->has_int_operand; }
  bool* mutable_has_int_operand() { return &internal_->has_int_operand; }
  void set_has_int_operand(const bool& has_int_operand) {
    internal_->has_int_operand = has_int_operand;
  }

  const bool& has_float_operand() const { return internal_->has_float_operand; }
  bool* mutable_has_float_operand() { return &internal_->has_float_operand; }
  void set_has_float_operand(const bool& has_float_operand) {
    internal_->has_float_operand = has_float_operand;
  }

  const int64_t& int_operand() const { return internal_->int_operand; }
  int64_t* mutable_int_operand() { return &internal_->int_operand; }
  void set_int_operand(const int64_t& int_operand) { internal_->int_operand = int_operand; }

  const double& float_operand() const { return internal_->float_operand; }
  double* mutable_float_operand() { return &internal_->float_operand; }
  void set_float_operand(const double& float_operand) { internal_->float_operand = float_operand; }

 private:
  struct Internal {
    bool has_int_operand;
    bool has_float_operand;
    int64_t int_operand;
    double float_operand;
  };

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.where_scalar_y", WhereScalarYOpInterpCtxImpl<schema::WhereScalarYOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class XdivyOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class XdivyOpInterpCtxImpl : public XdivyOpInterpCtx {
 public:
  XdivyOpInterpCtxImpl() = default;
  XdivyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class XdivyOp {
 public:
  XdivyOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Xdivy op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.xdivy", XdivyOpInterpCtxImpl<schema::XdivyOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class XdivyXGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class XdivyXGradOpInterpCtxImpl : public XdivyXGradOpInterpCtx {
 public:
  XdivyXGradOpInterpCtxImpl() = default;
  XdivyXGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class XdivyXGradOp {
 public:
  XdivyXGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "XdivyXGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.xdivy_x_grad", XdivyXGradOpInterpCtxImpl<schema::XdivyXGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class XdivyYGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class XdivyYGradOpInterpCtxImpl : public XdivyYGradOpInterpCtx {
 public:
  XdivyYGradOpInterpCtxImpl() = default;
  XdivyYGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class XdivyYGradOp {
 public:
  XdivyYGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "XdivyYGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.xdivy_y_grad", XdivyYGradOpInterpCtxImpl<schema::XdivyYGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class XlogyOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class XlogyOpInterpCtxImpl : public XlogyOpInterpCtx {
 public:
  XlogyOpInterpCtxImpl() = default;
  XlogyOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class XlogyOp {
 public:
  XlogyOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "Xlogy op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.xlogy", XlogyOpInterpCtxImpl<schema::XlogyOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class XlogyXGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class XlogyXGradOpInterpCtxImpl : public XlogyXGradOpInterpCtx {
 public:
  XlogyXGradOpInterpCtxImpl() = default;
  XlogyXGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class XlogyXGradOp {
 public:
  XlogyXGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "XlogyXGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.xlogy_x_grad", XlogyXGradOpInterpCtxImpl<schema::XlogyXGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class XlogyYGradOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class XlogyYGradOpInterpCtxImpl : public XlogyYGradOpInterpCtx {
 public:
  XlogyYGradOpInterpCtxImpl() = default;
  XlogyYGradOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class XlogyYGradOp {
 public:
  XlogyYGradOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "XlogyYGrad op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.xlogy_y_grad", XlogyYGradOpInterpCtxImpl<schema::XlogyYGradOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

class ZeroLikeOpInterpCtx : public OpInterpCtx {};
template<typename Provider>
class ZeroLikeOpInterpCtxImpl : public ZeroLikeOpInterpCtx {
 public:
  ZeroLikeOpInterpCtxImpl() = default;
  ZeroLikeOpInterpCtxImpl(const Provider& impl) : impl_(impl) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const override {
    return impl_.GetAttr(attr_name);
  }

 private:
  Provider impl_;
};

namespace schema {
class ZeroLikeOp {
 public:
  ZeroLikeOp() : internal_(std::make_shared<Internal>()) {}

  Maybe<AttrVal> GetAttr(const std::string& attr_name) const {
    return Error::RuntimeError() << "ZeroLike op has no attribute named " << attr_name;
  }

 private:
  struct Internal {};

 private:
  std::shared_ptr<Internal> internal_;
};
}  // namespace schema

#ifdef NEED_REGISTER_OP_INTERP_CTX
REGISTER_OP_INTERP_CTX("user.zero_like", ZeroLikeOpInterpCtxImpl<schema::ZeroLikeOp>);
#endif  // NEED_REGISTER_OP_INTERP_CTX

}  // namespace oneflow
#endif  // ONEFLOW_CORE_FRAMEWORK_OP_INTERP_CTX_GENERATED_H_
